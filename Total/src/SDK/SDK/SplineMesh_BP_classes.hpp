#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SplineMesh_BP

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SplineMeshData_structs.hpp"
#include "MeshIndex_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass SplineMesh_BP.SplineMesh_BP_C
// 0x00B8 (0x02E8 - 0x0230)
class ASplineMesh_BP_C : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	TArray<struct FSplineMeshData>                Meshes;                                            // 0x0240(0x0010)(Edit, BlueprintVisible)
	TArray<struct FMeshIndex>                     OverwriteMeshes;                                   // 0x0250(0x0010)(Edit, BlueprintVisible)
	bool                                          UseDetailsMesh;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DetailsStaticMiddleMesh;                           // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseCollision;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetailsMeshesDistance;                             // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ESplineMeshAxis                               FowardAxis;                                        // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             MaterialOvewrite;                                  // 0x0280(0x0010)(Edit, BlueprintVisible)
	bool                                          CloseLoop;                                         // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastLocation;                                      // 0x0294(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                LastTangent;                                       // 0x02A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         EndDistance;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SkipMesh;                                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CurrentStaticMesh;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseGrid;                                           // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridSize;                                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ESplineCoordinateSpace                        GridSizeSpace;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseFirstMesh;                                      // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkipMeshAtPoint;                                   // 0x02D0(0x0010)(Edit, BlueprintVisible)
	bool                                          SkipLastMesh;                                      // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	ELightmapType                                 Default_Lightmap_Type;                             // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Static_Shadow;                                     // 0x02E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)

public:
	void SnapPointOnGrid(class USplineComponent* Spline_0);
	void FindClosetMeshes(int32 A, class USplineComponent* Target, TArray<struct FSplineMeshData>& Meshes_0, int32* Index_0);
	void AddStaticMesh(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, class UStaticMesh* NewMesh);
	void AddMiddleMeshe(float Distance, const struct FVector& Location, const struct FRotator& Relative_Transform_Rotation);
	void UserConstructionScript();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"SplineMesh_BP_C">();
	}
	static class ASplineMesh_BP_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineMesh_BP_C>();
	}
};
static_assert(alignof(ASplineMesh_BP_C) == 0x000008, "Wrong alignment on ASplineMesh_BP_C");
static_assert(sizeof(ASplineMesh_BP_C) == 0x0002E8, "Wrong size on ASplineMesh_BP_C");
static_assert(offsetof(ASplineMesh_BP_C, Spline) == 0x000230, "Member 'ASplineMesh_BP_C::Spline' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, DefaultSceneRoot) == 0x000238, "Member 'ASplineMesh_BP_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, Meshes) == 0x000240, "Member 'ASplineMesh_BP_C::Meshes' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, OverwriteMeshes) == 0x000250, "Member 'ASplineMesh_BP_C::OverwriteMeshes' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, UseDetailsMesh) == 0x000260, "Member 'ASplineMesh_BP_C::UseDetailsMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, DetailsStaticMiddleMesh) == 0x000268, "Member 'ASplineMesh_BP_C::DetailsStaticMiddleMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, UseCollision) == 0x000270, "Member 'ASplineMesh_BP_C::UseCollision' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, DetailsMeshesDistance) == 0x000274, "Member 'ASplineMesh_BP_C::DetailsMeshesDistance' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, FowardAxis) == 0x000278, "Member 'ASplineMesh_BP_C::FowardAxis' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, MaterialOvewrite) == 0x000280, "Member 'ASplineMesh_BP_C::MaterialOvewrite' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, CloseLoop) == 0x000290, "Member 'ASplineMesh_BP_C::CloseLoop' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, LastLocation) == 0x000294, "Member 'ASplineMesh_BP_C::LastLocation' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, LastTangent) == 0x0002A0, "Member 'ASplineMesh_BP_C::LastTangent' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, EndDistance) == 0x0002AC, "Member 'ASplineMesh_BP_C::EndDistance' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, SkipMesh) == 0x0002B0, "Member 'ASplineMesh_BP_C::SkipMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, CurrentStaticMesh) == 0x0002B8, "Member 'ASplineMesh_BP_C::CurrentStaticMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, UseGrid) == 0x0002C0, "Member 'ASplineMesh_BP_C::UseGrid' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, GridSize) == 0x0002C4, "Member 'ASplineMesh_BP_C::GridSize' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, GridSizeSpace) == 0x0002C8, "Member 'ASplineMesh_BP_C::GridSizeSpace' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, UseFirstMesh) == 0x0002C9, "Member 'ASplineMesh_BP_C::UseFirstMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, SkipMeshAtPoint) == 0x0002D0, "Member 'ASplineMesh_BP_C::SkipMeshAtPoint' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, SkipLastMesh) == 0x0002E0, "Member 'ASplineMesh_BP_C::SkipLastMesh' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, Default_Lightmap_Type) == 0x0002E1, "Member 'ASplineMesh_BP_C::Default_Lightmap_Type' has a wrong offset!");
static_assert(offsetof(ASplineMesh_BP_C, Static_Shadow) == 0x0002E2, "Member 'ASplineMesh_BP_C::Static_Shadow' has a wrong offset!");

}

