#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OPP

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum OPP.EAIEvent
// NumValues: 0x005E
enum class EAIEvent : uint8
{
	Undefined                                = 0,
	ReactToSoundDisturbanceAware             = 1,
	ReactToSoundDisturbanceUnaware           = 2,
	ReactToVisualDisturbanceAware            = 3,
	ReactToVisualDisturbanceUnaware          = 4,
	ReactToMajorDisturbance                  = 5,
	ReactToSensingDisturbance                = 6,
	InvestigateDisturbanceAware              = 7,
	InvestigateDisturbanceUnaware            = 8,
	InvestigatePoint                         = 9,
	ReachedInvestigationPoint                = 10,
	FinishedInvestigatingPoint               = 11,
	InvestigationGiveUp                      = 12,
	AlertedGiveUp                            = 13,
	SuspiciousGiveUp                         = 14,
	SawPlayerEnterHidingSpot                 = 15,
	FoundHiddenPlayer                        = 16,
	SearchForOtherPlayersAfterKnockDown      = 17,
	PullOutFromHidespot                      = 18,
	ReactToPlayerBeforeChase                 = 19,
	ReactToMultiplePlayersBeforeChase        = 20,
	StartChaseAfterReaction                  = 21,
	StartChaseNoReaction                     = 22,
	StartMoveToIncapacitatedPlayer           = 23,
	ChaseReachedLeashLimit                   = 24,
	ChaseStartGiveUp                         = 25,
	ChaseGiveUp                              = 26,
	ChaseStartYielding                       = 27,
	ChaseYield                               = 28,
	ChaseChangedTarget                       = 29,
	ChaseTaunt                               = 30,
	LostSightOfPlayer                        = 31,
	StartMoveToLostSight                     = 32,
	ReachedLastKnownPosition                 = 33,
	UnawarePlayerProximity                   = 34,
	ChasePlayerProximity                     = 35,
	ReachedPatrolWaypoint                    = 36,
	PassUnderDynamicObstacle                 = 37,
	EnterDarknessZone                        = 38,
	EnterLightZone                           = 39,
	AttackPlayer                             = 40,
	GuardingAttack                           = 41,
	PushPlayer                               = 42,
	ImposterCharge                           = 43,
	PusherAttack                             = 44,
	PairedAttackConnecting                   = 45,
	KnockedDownPlayer                        = 46,
	StartFinishingIncapacitatedPlayer        = 47,
	FinishIncapacitatedPlayer                = 48,
	DealtDamage                              = 49,
	KilledPlayer                             = 50,
	AttackOtherNPC                           = 51,
	AttackedByOtherNPC                       = 52,
	ThrowProjectile                          = 53,
	ThrownProjectileHit                      = 54,
	ThrownProjectileMiss                     = 55,
	TakeDamage                               = 56,
	HitByProjectile                          = 57,
	PairedAttackInterrupted                  = 58,
	HitReaction_Low                          = 59,
	HitReaction_Med                          = 60,
	HitReaction_High                         = 61,
	DelayedHitReaction                       = 62,
	ShovedByPlayerAware                      = 63,
	ShovedByPlayerUnaware                    = 64,
	ShovePunish                              = 65,
	KnockedOut                               = 66,
	GetUpFromKnockOut                        = 67,
	Killed                                   = 68,
	ProvocationWarning                       = 69,
	ProvokedByPlayer                         = 70,
	ReactToImperativeDisturbance             = 71,
	TurnOffImperativeDisturbance             = 72,
	SignalTackle                             = 73,
	FailedTackle                             = 74,
	SuccessfulTackle                         = 75,
	FinishedGroundAndPound                   = 76,
	PlayerAvoidanceStart                     = 77,
	PlayerAvoidanceRepath                    = 78,
	AcknowledgePlayer                        = 79,
	AcknowledgeOtherNPC                      = 80,
	ZoneDefenseBecomeAlert                   = 81,
	ZoneDefenseBlown                         = 82,
	ReactToCloseGrenade                      = 83,
	AffectedByStunGrenade                    = 84,
	RecoverFromStunGrenade                   = 85,
	AffectedByBlindPaint                     = 86,
	AffectedByHealSlowdown                   = 87,
	SleeperDisturbed                         = 88,
	SleeperScream                            = 89,
	StartRetirement                          = 90,
	RaisingWeapon                            = 91,
	GoryDeathStart                           = 92,
	MAX                                      = 93,
};

// Enum OPP.EScheduledPropertyValueChangedType
// NumValues: 0x0005
enum class EScheduledPropertyValueChangedType : uint8
{
	LocallySet                               = 0,
	DesiredTimeReached                       = 1,
	FailsafeTimeReached                      = 2,
	OnRepExpired                             = 3,
	EScheduledPropertyValueChangedType_MAX   = 4,
};

// Enum OPP.ENPCWeapon
// NumValues: 0x000A
enum class ENPCWeapon : uint8
{
	None                                     = 0,
	Knife                                    = 1,
	Machete                                  = 2,
	Axe                                      = 3,
	Bottle                                   = 4,
	Shotgun                                  = 5,
	MolotovCocktail                          = 6,
	CattleProd                               = 7,
	DoubleClaw                               = 8,
	ENPCWeapon_MAX                           = 9,
};

// Enum OPP.EDamageSoundMaterial
// NumValues: 0x0015
enum class EDamageSoundMaterial : uint8
{
	None                                     = 0,
	Unarmed                                  = 1,
	Berzerker                                = 2,
	Blade_Large                              = 3,
	Blade_Small                              = 4,
	Blunt_DenseMetal                         = 5,
	Blunt_HollowMetal                        = 6,
	Blunt_Wood                               = 7,
	Blunt_Electric                           = 8,
	Electric                                 = 9,
	Fire                                     = 10,
	Brick                                    = 11,
	PsychosisEntity                          = 12,
	Grinder                                  = 13,
	Glass                                    = 14,
	Acid                                     = 15,
	Cold                                     = 16,
	Chemical                                 = 17,
	Bleeding                                 = 18,
	Shotgun                                  = 19,
	EDamageSoundMaterial_MAX                 = 20,
};

// Enum OPP.EHurtVOType
// NumValues: 0x000E
enum class EHurtVOType : uint8
{
	None                                     = 0,
	GenericLow                               = 1,
	GenericMedium                            = 2,
	GenericHigh                              = 3,
	LandLow                                  = 4,
	LandHigh                                 = 5,
	Fire                                     = 6,
	Electricity                              = 7,
	Shock                                    = 8,
	HurtContinuousMedium                     = 9,
	Acid                                     = 10,
	Gas                                      = 11,
	Bleeding                                 = 12,
	EHurtVOType_MAX                          = 13,
};

// Enum OPP.EDamageType
// NumValues: 0x0026
enum class EDamageType : uint8
{
	NoDamage                                 = 0,
	Generic                                  = 1,
	GenericNonFatal                          = 2,
	Temporary                                = 3,
	UnarmedRightHandStrike                   = 4,
	UnarmedLeftHandStrike                    = 5,
	UnarmedHeadStrike                        = 6,
	UnarmedLeftFootStrike                    = 7,
	UnarmedRightFootStrike                   = 8,
	UnarmedOtherStrike                       = 9,
	WeaponStrike                             = 10,
	Throwable                                = 11,
	Animated                                 = 12,
	AnimatedDangerous                        = 13,
	ForceKill                                = 14,
	Electric                                 = 15,
	Fire                                     = 16,
	MolotovFire                              = 17,
	Falling                                  = 18,
	Trap                                     = 19,
	SpectreProximity                         = 20,
	Gas                                      = 21,
	EndOfStage                               = 22,
	HackPanelFail                            = 23,
	CoopTrap                                 = 24,
	PlayerDamageLeash                        = 25,
	RunningProhibitedDamage                  = 26,
	Grinder                                  = 27,
	AcidBottleSpill                          = 28,
	StepOnGlass                              = 29,
	FailedPuzzleRoom                         = 30,
	Cold                                     = 31,
	Bleeding                                 = 32,
	Explosion                                = 33,
	Chemical                                 = 34,
	Shotgun                                  = 35,
	Custom                                   = 36,
	MAX                                      = 37,
};

// Enum OPP.EHallucinationType
// NumValues: 0x0008
enum class EHallucinationType : uint8
{
	None                                     = 0,
	AlteredControls                          = 1,
	JumpScare                                = 2,
	RandomSound                              = 3,
	LSDEffect                                = 4,
	Psychosis                                = 5,
	HallucinationTraps                       = 6,
	EHallucinationType_MAX                   = 7,
};

// Enum OPP.EObjectiveCoordinatorState
// NumValues: 0x0008
enum class EObjectiveCoordinatorState : uint8
{
	Invalid                                  = 0,
	Disabled                                 = 1,
	WaitingForStart                          = 2,
	Started                                  = 3,
	Stopped                                  = 4,
	Failed                                   = 5,
	Completed                                = 6,
	EObjectiveCoordinatorState_MAX           = 7,
};

// Enum OPP.EDoorActionType
// NumValues: 0x0008
enum class EDoorActionType : uint8
{
	Open                                     = 0,
	QuickOpen                                = 1,
	Close                                    = 2,
	Lock                                     = 3,
	Unlock                                   = 4,
	AttachDoorRotation                       = 5,
	ReleaseDoor                              = 6,
	EDoorActionType_MAX                      = 7,
};

// Enum OPP.EArmWreslingPanelInputFailType
// NumValues: 0x0004
enum class EArmWreslingPanelInputFailType : uint8
{
	Failed                                   = 0,
	Success                                  = 1,
	NoInput                                  = 2,
	EArmWreslingPanelInputFailType_MAX       = 3,
};

// Enum OPP.EPlayerLeaveTarget
// NumValues: 0x0009
enum class EPlayerLeaveTarget : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	Lobby                                    = 2,
	Party                                    = 3,
	Experiment                               = 4,
	Desktop                                  = 5,
	Tutorial                                 = 6,
	PartyGameSession                         = 7,
	EPlayerLeaveTarget_MAX                   = 8,
};

// Enum OPP.EAdversarialRole
// NumValues: 0x0005
enum class EAdversarialRole : uint8
{
	Reagents                                 = 0,
	Imposters                                = 1,
	Count                                    = 2,
	None                                     = 3,
	EAdversarialRole_MAX                     = 4,
};

// Enum OPP.ECurrencyType
// NumValues: 0x000C
enum class ECurrencyType : uint8
{
	None                                     = 0,
	MurkoffPoint                             = 1,
	MurkoffDollar                            = 2,
	ReleaseToken                             = 3,
	EventToken                               = 4,
	EventTokenChristmas                      = 5,
	EventTokenToxic                          = 6,
	EventTokenPrime                          = 7,
	BattlePassToken                          = 8,
	BattlePassPremiumToken                   = 9,
	Count                                    = 10,
	ECurrencyType_MAX                        = 11,
};

// Enum OPP.EPlayerCustomizationSlot
// NumValues: 0x000B
enum class EPlayerCustomizationSlot : uint8
{
	NightVisionGoggles                       = 0,
	Hair                                     = 1,
	Head                                     = 2,
	Watch                                    = 3,
	UpperBody                                = 4,
	Toaster                                  = 5,
	LowerBody                                = 6,
	Glove                                    = 7,
	ESOPStraps                               = 8,
	None                                     = 9,
	EPlayerCustomizationSlot_MAX             = 10,
};

// Enum OPP.EProfilePlatform
// NumValues: 0x0007
enum class EProfilePlatform : uint8
{
	Unknown                                  = 0,
	Test                                     = 1,
	Steam                                    = 2,
	EOS                                      = 3,
	Xbox                                     = 4,
	Psn                                      = 5,
	EProfilePlatform_MAX                     = 6,
};

// Enum OPP.EActiveSkillType
// NumValues: 0x000A
enum class EActiveSkillType : uint8
{
	None                                     = 0,
	Amp                                      = 1,
	Chem                                     = 2,
	Pharma                                   = 3,
	Spec                                     = 4,
	DoorBlocker                              = 5,
	Hacking                                  = 6,
	Max                                      = 7,
	Knife                                    = 8,
	Disguise                                 = 9,
};

// Enum OPP.ESkinColorType
// NumValues: 0x0003
enum class ESkinColorType : uint8
{
	Light                                    = 0,
	Dark                                     = 1,
	ESkinColorType_MAX                       = 2,
};

// Enum OPP.EPerkCategory
// NumValues: 0x0006
enum class EPerkCategory : uint8
{
	Slot1                                    = 0,
	Slot2                                    = 1,
	Slot3                                    = 2,
	Count                                    = 3,
	None                                     = 4,
	EPerkCategory_MAX                        = 5,
};

// Enum OPP.ETrialChainingUpgradeType
// NumValues: 0x000C
enum class ETrialChainingUpgradeType : uint8
{
	None                                     = 0,
	ActiveSkill                              = 1,
	ActiveSkillUpgrade                       = 2,
	Meds1                                    = 3,
	Meds2                                    = 4,
	Meds3                                    = 5,
	Perks1                                   = 6,
	Perks2                                   = 7,
	Perks3                                   = 8,
	Item                                     = 9,
	ItemPack                                 = 10,
	ETrialChainingUpgradeType_MAX            = 11,
};

// Enum OPP.ETrialChainingUpgradeChoiceType
// NumValues: 0x0005
enum class ETrialChainingUpgradeChoiceType : uint8
{
	Default                                  = 0,
	Round1                                   = 1,
	SubObjective                             = 2,
	Count                                    = 3,
	ETrialChainingUpgradeChoiceType_MAX      = 4,
};

// Enum OPP.EProgramDifficulty
// NumValues: 0x0006
enum class EProgramDifficulty : uint8
{
	Undefined                                = 0,
	Easy                                     = 1,
	Normal                                   = 2,
	Hard                                     = 3,
	Insane                                   = 4,
	EProgramDifficulty_MAX                   = 5,
};

// Enum OPP.EPlayerEvent
// NumValues: 0x007C
enum class EPlayerEvent : uint8
{
	None                                     = 0,
	CoopMove                                 = 1,
	HelpedUpByTeammate                       = 2,
	HelpedUpTeammate                         = 3,
	PlayerTookDamage                         = 4,
	PlayerKnockedDown                        = 5,
	PlayerDied                               = 6,
	PlayerLostChance                         = 7,
	SanityLost                               = 8,
	RevivedDeadPlayer                        = 9,
	SuccessfullyUsedDynamicObstacle          = 10,
	BodyHitEnemy                             = 11,
	HeadShotHitEnemy                         = 12,
	DistractEnemyWithBrick                   = 13,
	DistractEnemyWithBottle                  = 14,
	ShovedEnemy                              = 15,
	SavedYourselfFromGroundAndPound          = 16,
	SavedPlayerFromGroundAndPound            = 17,
	SavedPlayerFromExecution                 = 18,
	SavedPlayerFromElectricTrap              = 19,
	SavedYourselfFromElectricTrap            = 20,
	SavedByPlayerFromElectricTrap            = 21,
	TriggeredSoundTrap                       = 22,
	CaughtByDoorTrap                         = 23,
	DamagedByExplosiveTrap                   = 24,
	DamagedByExplosiveWireTrap               = 25,
	DamagedByElectricFloorTrap               = 26,
	UsedActiveSkill                          = 27,
	Skill_Spec_Activated                     = 28,
	Skill_Spec_Deactivated                   = 29,
	Skill_Spec_SpottedEnemy                  = 30,
	Skill_Pharma_Activated                   = 31,
	Skill_Pharma_AffectedPlayer              = 32,
	Skill_Pharma_CuredPsychosis              = 33,
	Skill_Pharma_SlowdownEnemy               = 34,
	Skill_Amp_AffectedEnemy                  = 35,
	Skill_Amp_HeadshotEnemy                  = 36,
	Skill_Amp_BrokeTrap                      = 37,
	Skill_Amp_RestoredBattery                = 38,
	Skill_Chem_Deployed                      = 39,
	Skill_Chem_AffectedEnemy                 = 40,
	Skill_Chem_GainedAdrenaline              = 41,
	Skill_DoorBlocker_Deployed               = 42,
	Skill_HackingRig_HackObject              = 43,
	Unlocked_Door_Lockpick                   = 44,
	Unlocked_Container_Lockpick              = 45,
	Unlocked_Door_LockBreakerPerk            = 46,
	Unlocked_Container_LockBreakerPerk       = 47,
	Unlocked_Door_MasterKey                  = 48,
	Unlocked_Container_MasterKey             = 49,
	SurvivedPsychosis                        = 50,
	CuredFullPsychosis                       = 51,
	PickedUp_CollectibleDocument             = 52,
	PickedUp_EquippableItem                  = 53,
	UsedItem_Health                          = 54,
	UsedItem_ReviveSyringe                   = 55,
	UsedItem_Stamina                         = 56,
	UsedItem_Battery                         = 57,
	UsedItem_SkillCharge                     = 58,
	UsedItem_Antidote                        = 59,
	UsedItem_Throwable                       = 60,
	UsedItem_RespawnPill                     = 61,
	UsedItem_Bandage                         = 62,
	UsedItem_TimeExtender                    = 63,
	UsedItem_HealthSickness                  = 64,
	UsedItem_StaminaSickness                 = 65,
	UsedItem_MotionDetection                 = 66,
	GroupUsedItem_TimeExtender               = 67,
	DisarmedWireTriggerTrap                  = 68,
	DoorTrapsAvoided                         = 69,
	BashOpenLockedDoor                       = 70,
	BashOpenLockedDoor_Kick                  = 71,
	BashOpenLockedDoor_Shoulder              = 72,
	EnteredHidingSpot                        = 73,
	ExitHidingSpot                           = 74,
	JumpOverObstacle                         = 75,
	StartedRunning                           = 76,
	StoppedRunning                           = 77,
	OpenedContainer                          = 78,
	PropagandaPosterCollected                = 79,
	ChristmasGiftCollected                   = 80,
	ToxicRatCollected                        = 81,
	PropagandaTVBroken                       = 82,
	OrganSampleCollected                     = 83,
	StageTimeElapsed                         = 84,
	CompletedStage                           = 85,
	CompletedStageAlive                      = 86,
	CompletedStageDead                       = 87,
	LeftTeammateBehind                       = 88,
	StageEndPercentageHealthLost             = 89,
	CompletedMainObjective                   = 90,
	CompletedSecondaryObjective              = 91,
	CompletedSecondaryObjective_Posters      = 92,
	CompletedSecondaryObjective_Rats         = 93,
	CompletedSecondaryObjective_Gifts        = 94,
	CompletedSecondaryObjective_Televisions  = 95,
	CompletedSecondaryObjective_Radio        = 96,
	CompletedSecondaryObjective_Organs       = 97,
	CompletedMainObjectiveStep               = 98,
	CompletedSecondaryObjectiveStep          = 99,
	CompletedMainObjectiveStepPlayerSpecific = 100,
	CompletedSecondaryObjectiveStepPlayerSpecific = 101,
	CompletedExperiment                      = 102,
	ScriptedPoints                           = 103,
	Variator_BombExploded                    = 104,
	Exhausted                                = 105,
	DiscoveredRewardRoom                     = 106,
	GroupDiscoveredRewardRoom                = 107,
	DodgedImposterAttack                     = 108,
	BrokeWindow                              = 109,
	PrimeAssetTrapDisarmed                   = 110,
	BrokeSecondaryObjectiveRadio             = 111,
	DisarmPsychosisMine                      = 112,
	Skill_HackingRig_AffectedNPCWithTrap     = 113,
	Skill_HackingRig_HackTraps               = 114,
	Skill_HackingRig_ReviveOtherPlayer       = 115,
	Skill_HackingRig_SelfRevive              = 116,
	Skill_HackingRig_HackNPC                 = 117,
	Skill_HackingRig_HackLockedContainer     = 118,
	Skill_HackingRig_HackLockedDoor          = 119,
	AffectedByMine                           = 120,
	MadeNPCAffectedByMine                    = 121,
	DamagedByWrongOrderPanel                 = 122,
	Max                                      = 123,
};

// Enum OPP.EPlayerIndicatorType
// NumValues: 0x0016
enum class EPlayerIndicatorType : uint8
{
	Default                                  = 0,
	Knockdown                                = 1,
	Objective_Default                        = 2,
	Objective_Cart                           = 3,
	Objective_Exit                           = 4,
	Objective_HotPotato                      = 5,
	Objective_QuestInventoryItem             = 6,
	Objective_Stalker                        = 7,
	Objective_ZoneDefense                    = 8,
	Objective_LargePickup                    = 9,
	KnockdownBeingTargetted                  = 10,
	AboutToDie                               = 11,
	CoopTrap                                 = 12,
	CoopMove                                 = 13,
	HelpUp                                   = 14,
	Revive                                   = 15,
	Dead                                     = 16,
	CanBeRevived                             = 17,
	WantsToTrade                             = 18,
	PlayerInvestigating                      = 19,
	ItemHoldingAction                        = 20,
	EPlayerIndicatorType_MAX                 = 21,
};

// Enum OPP.EItemType
// NumValues: 0x0028
enum class EItemType : uint8
{
	Nothing                                  = 0,
	Fists                                    = 1,
	HealthGain                               = 2,
	HealthBoost                              = 3,
	TempHealthGain                           = 4,
	ReviveSyringe                            = 5,
	RespawnConsumable                        = 6,
	StaminaRegen                             = 7,
	MaxStaminaBoost                          = 8,
	SmallBattery                             = 9,
	Battery                                  = 10,
	SuperBattery                             = 11,
	LockPick                                 = 12,
	MasterKey                                = 13,
	SkillCharge                              = 14,
	Bottle                                   = 15,
	PsychosisAntidote                        = 16,
	Bandage                                  = 17,
	Brick                                    = 18,
	CollectibleDocument                      = 19,
	TimeExtender                             = 20,
	HealthSicknessPill                       = 21,
	StaminaSicknessPill                      = 22,
	Quest                                    = 23,
	ActiveSkillController                    = 24,
	ActiveSkillThrowable                     = 25,
	ActiveSkillDeployable                    = 26,
	ActiveSkillUsable                        = 27,
	ObjectiveThrowable                       = 28,
	GoreThrowable                            = 29,
	Decoder                                  = 30,
	ProximityDetector                        = 31,
	ObjectiveEquipable                       = 32,
	ObjectiveCollectable                     = 33,
	ChainingUpgradePoint                     = 34,
	AdvWeapon                                = 35,
	MotionDetection                          = 36,
	AIAttractorItem                          = 37,
	ImposterStunThrowable                    = 38,
	Max                                      = 39,
};

// Enum OPP.EGameplayAttributeModifierType
// NumValues: 0x0004
enum class EGameplayAttributeModifierType : uint8
{
	Addition                                 = 0,
	Multiplication                           = 1,
	AddBaseValueRatio                        = 2,
	EGameplayAttributeModifierType_MAX       = 3,
};

// Enum OPP.EGameplayAttributeType
// NumValues: 0x0057
enum class EGameplayAttributeType : uint8
{
	Invalid                                  = 0,
	MaxHealth                                = 1,
	MaxNVBatteries                           = 2,
	MaxStamina                               = 3,
	HealthRegenDelay                         = 4,
	HealthOnHelpedUp                         = 5,
	HealthOnRevived                          = 6,
	HealthAfterRespawn                       = 7,
	PsychosisDecaySpeed                      = 8,
	PsychosisContinuousGainDelay             = 9,
	PsychosisGainMultiplier                  = 10,
	PsychosisDurationMultiplier              = 11,
	ExtraPsychosisGain                       = 12,
	NVBatteryConsumption                     = 13,
	NVBatteryRechargeRate                    = 14,
	StaminaMovementCostMultiplier            = 15,
	StaminaExhaustionDuration                = 16,
	StaminaRecoveryRateMultiplier            = 17,
	StaminaShoveCostMultiplier               = 18,
	StaminaCoopCostMultiplier                = 19,
	StaminaBashCostMultiplier                = 20,
	StaminaTraversalCostMultiplier           = 21,
	HidingSpotMaxStaminaModifier             = 22,
	ActiveSkillCooldown                      = 23,
	ActiveSkillEffect                        = 24,
	ActiveSkillActivationRadius              = 25,
	ActiveSkillEffectRadius                  = 26,
	ActiveSkillEffectDuration                = 27,
	ActiveSkillEffect2Duration               = 28,
	ActiveSkillPharmaEffectMultiplier        = 29,
	ActiveSkillSpecTagDuration               = 30,
	ActiveSkillDoorBlockerCountLimit         = 31,
	ActiveSkillDoorBlockerBashCount          = 32,
	StartItemsBrick                          = 33,
	StartItemsLockpick                       = 34,
	StartItemsHealthGain                     = 35,
	BatteryItemUseMultiplier                 = 36,
	HealthItemUseMultiplier                  = 37,
	TempHealthItemUseMultiplier              = 38,
	TempHealthDecayRate                      = 39,
	TempHealthConversionRate                 = 40,
	StaminaItemUseMultiplier                 = 41,
	AntidoteItemUseMultiplier                = 42,
	MoneyPickupMultiplier                    = 43,
	SkillChargeItemPickupMultiplier          = 44,
	ChanceOfKeepingSyringeAfterUse           = 45,
	ChanceOfKeepingLockpickAfterUse          = 46,
	ChanceOfKeepingMasterKeyAfterUse         = 47,
	MeleeDamageReceivedMultiplier            = 48,
	ProjectileDamageReceivedMultiplier       = 49,
	SpectreDamageReceivedMultiplier          = 50,
	TrapDamageReceivedMultiplier             = 51,
	FallDamageMultiplier                     = 52,
	ChanceOfPlayerBreakingIn1Hit             = 53,
	PlayerBashDamage                         = 54,
	PlayerShovePushDistance                  = 55,
	PerkSlotCount_Slot1                      = 56,
	PerkSlotCount_Slot2                      = 57,
	PerkSlotCount_Slot3                      = 58,
	InventorySlotCount                       = 59,
	NoiseTrapNoiseMultiplier                 = 60,
	ThrowableNoiseMultiplier                 = 61,
	ThrowableStunDurationMultiplier          = 62,
	NoiseWhenCrouching                       = 63,
	NoiseWhenRunning                         = 64,
	NoiseWhenWalking                         = 65,
	NoiseWhenOpeningDoorsMultiplier          = 66,
	PerceivedVisibilityMultiplier            = 67,
	MinigameSpeedMultiplier                  = 68,
	MinigameZoneSizeModifier                 = 69,
	HoldDurationMultiplier                   = 70,
	GarageDoorProgressMultiplier             = 71,
	RemoveTrapMultiplier                     = 72,
	GroundAndPoundMashMultiplier             = 73,
	PushCartMultiplier                       = 74,
	DisarmTrapMultiplier                     = 75,
	HelpUpMultiplier                         = 76,
	HelpUpDamageSlowDownMultiplier           = 77,
	ReviveVictimMultiplier                   = 78,
	ReviveHelperMultiplier                   = 79,
	ReviveDamageSlowDownMultiplier           = 80,
	CrouchSpeedMultiplier                    = 81,
	WalkingSpeedMultiplier                   = 82,
	RunningSpeedMultiplier                   = 83,
	LargeObjectCarrySpeedMultiplier          = 84,
	AimAssistRadiusMultiplier                = 85,
	EGameplayAttributeType_MAX               = 86,
};

// Enum OPP.ETaskCategory
// NumValues: 0x0006
enum class ETaskCategory : uint8
{
	Daily                                    = 0,
	DailyPermanent                           = 1,
	Weekly                                   = 2,
	WeeklyPermanent                          = 3,
	Normal                                   = 4,
	MAX                                      = 5,
};

// Enum OPP.ETeam
// NumValues: 0x0004
enum class ETeam : uint8
{
	Team1                                    = 0,
	Team2                                    = 1,
	Count                                    = 2,
	ETeam_MAX                                = 3,
};

// Enum OPP.ECustomizationMenuCategory
// NumValues: 0x0021
enum class ECustomizationMenuCategory : uint8
{
	DNA                                      = 0,
	Voice                                    = 1,
	Outfits                                  = 2,
	NightVision                              = 3,
	UpperBody                                = 4,
	LowerBody                                = 5,
	Watch                                    = 6,
	Haircut                                  = 7,
	Glove                                    = 8,
	Rigs                                     = 9,
	Toaster                                  = 10,
	Trinkets                                 = 11,
	PlayerIcon                               = 12,
	PlayerIconBorder                         = 13,
	PodiumEmote                              = 14,
	TerminalEmote                            = 15,
	Cell_Bundle                              = 16,
	Cell_MediumProp1                         = 17,
	Cell_MediumProp2                         = 18,
	Cell_SmallProp1                          = 19,
	Cell_SmallProp2                          = 20,
	Cell_Poster1                             = 21,
	Cell_Poster2                             = 22,
	Cell_Poster3                             = 23,
	Cell_Poster4                             = 24,
	Cell_WallPaper                           = 25,
	Cell_Carpet                              = 26,
	Cell_Bed                                 = 27,
	Cell_Sink                                = 28,
	Cell_Ceramic                             = 29,
	Cell_Trim                                = 30,
	None                                     = 31,
	ECustomizationMenuCategory_MAX           = 32,
};

// Enum OPP.EPlayerCustomizationRarity
// NumValues: 0x0008
enum class EPlayerCustomizationRarity : uint8
{
	Invalid                                  = 0,
	Common                                   = 1,
	Standard                                 = 2,
	Rare                                     = 3,
	Epic                                     = 4,
	Legendary                                = 5,
	Deluxe                                   = 6,
	EPlayerCustomizationRarity_MAX           = 7,
};

// Enum OPP.ERewardType
// NumValues: 0x0007
enum class ERewardType : uint8
{
	None                                     = 0,
	PlayerXp                                 = 1,
	Customization                            = 2,
	PerkSlot                                 = 3,
	Currency                                 = 4,
	RandomCustomization                      = 5,
	ERewardType_MAX                          = 6,
};

// Enum OPP.EXPGainType
// NumValues: 0x000A
enum class EXPGainType : uint8
{
	None                                     = 0,
	TrialRepeatable                          = 1,
	TrialPlayerRating                        = 2,
	TrialScore                               = 3,
	SecondaryObjective                       = 4,
	TrialChain                               = 5,
	Task                                     = 6,
	Badge                                    = 7,
	Catalog                                  = 8,
	EXPGainType_MAX                          = 9,
};

// Enum OPP.EChessGameState
// NumValues: 0x0006
enum class EChessGameState : uint8
{
	None                                     = 0,
	WaitingForPlayers                        = 1,
	Intro                                    = 2,
	GameInProgress                           = 3,
	Outtro                                   = 4,
	EChessGameState_MAX                      = 5,
};

// Enum OPP.EChessTeam
// NumValues: 0x0004
enum class EChessTeam : uint8
{
	None                                     = 0,
	White                                    = 1,
	Black                                    = 2,
	EChessTeam_MAX                           = 3,
};

// Enum OPP.EChessGameEndReason
// NumValues: 0x0009
enum class EChessGameEndReason : uint8
{
	None                                     = 0,
	Mate                                     = 1,
	Timeout                                  = 2,
	Resign                                   = 3,
	DrawStalemate                            = 4,
	DrawThreefold                            = 5,
	DrawFiftyRule                            = 6,
	DrawMaterial                             = 7,
	EChessGameEndReason_MAX                  = 8,
};

// Enum OPP.EChessGameTurnType
// NumValues: 0x0005
enum class EChessGameTurnType : uint8
{
	None                                     = 0,
	Play                                     = 1,
	Promoting                                = 2,
	Checked                                  = 3,
	EChessGameTurnType_MAX                   = 4,
};

// Enum OPP.EChessPieceType
// NumValues: 0x0008
enum class EChessPieceType : uint8
{
	None                                     = 0,
	Pawn                                     = 1,
	Rook                                     = 2,
	Knight                                   = 3,
	Bishop                                   = 4,
	Queen                                    = 5,
	King                                     = 6,
	EChessPieceType_MAX                      = 7,
};

// Enum OPP.EPlayerStat
// NumValues: 0x00DA
enum class EPlayerStat : uint8
{
	None                                     = 0,
	ItemsPickedUp                            = 1,
	ItemsPickedUp_SmallMedicine              = 2,
	ItemsPickedUp_LargeMedicine              = 3,
	ItemsPickedUp_HealthBooster              = 4,
	ItemsPickedUp_ReviveSyringe              = 5,
	ItemsPickedUp_Adrenaline                 = 6,
	ItemsPickedUp_StaminaBooster             = 7,
	ItemsPickedUp_SmallBattery               = 8,
	ItemsPickedUp_LargeBattery               = 9,
	ItemsPickedUp_BatteryBooster             = 10,
	ItemsPickedUp_LockPick                   = 11,
	ItemsPickedUp_MasterKey                  = 12,
	ItemsPickedUp_RigRecharger               = 13,
	ItemsPickedUp_Bottle                     = 14,
	ItemsPickedUp_Antidote                   = 15,
	ItemsPickedUp_Brick                      = 16,
	ItemsPickedUp_CollectibleDocument        = 17,
	ItemsPickedUp_RespawnConsumable          = 18,
	ItemsPickedUp_Bandage                    = 19,
	ItemsPickedUp_ObjectiveCollectable       = 20,
	ItemsUsed                                = 21,
	ItemsUsed_Health                         = 22,
	ItemsUsed_Throwable                      = 23,
	ItemsUsed_SmallMedicine                  = 24,
	ItemsUsed_LargeMedicine                  = 25,
	ItemsUsed_HealthBooster                  = 26,
	ItemsUsed_ReviveSyringe                  = 27,
	ItemsUsed_Adrenaline                     = 28,
	ItemsUsed_StaminaBooster                 = 29,
	ItemsUsed_SmallBattery                   = 30,
	ItemsUsed_LargeBattery                   = 31,
	ItemsUsed_BatteryBooster                 = 32,
	ItemsUsed_LockPick                       = 33,
	ItemsUsed_MasterKey                      = 34,
	ItemsUsed_RigRecharger                   = 35,
	ItemsUsed_Bottle                         = 36,
	ItemsUsed_Antidote                       = 37,
	ItemsUsed_Brick                          = 38,
	ItemsUsed_RespawnConsumable              = 39,
	ItemsDropped                             = 40,
	ItemsDropped_SmallMedicine               = 41,
	ItemsDropped_LargeMedicine               = 42,
	ItemsDropped_HealthBooster               = 43,
	ItemsDropped_ReviveSyringe               = 44,
	ItemsDropped_Adrenaline                  = 45,
	ItemsDropped_StaminaBooster              = 46,
	ItemsDropped_SmallBattery                = 47,
	ItemsDropped_LargeBattery                = 48,
	ItemsDropped_BatteryBooster              = 49,
	ItemsDropped_LockPick                    = 50,
	ItemsDropped_MasterKey                   = 51,
	ItemsDropped_RigRecharger                = 52,
	ItemsDropped_Bottle                      = 53,
	ItemsDropped_Antidote                    = 54,
	ItemsDropped_Brick                       = 55,
	UnlockedContainers                       = 56,
	ItemsTraded                              = 57,
	ItemsTraded_SmallMedicine                = 58,
	ItemsTraded_LargeMedicine                = 59,
	ItemsTraded_HealthBooster                = 60,
	ItemsTraded_ReviveSyringe                = 61,
	ItemsTraded_Adrenaline                   = 62,
	ItemsTraded_StaminaBooster               = 63,
	ItemsTraded_SmallBattery                 = 64,
	ItemsTraded_LargeBattery                 = 65,
	ItemsTraded_BatteryBooster               = 66,
	ItemsTraded_LockPick                     = 67,
	ItemsTraded_MasterKey                    = 68,
	ItemsTraded_RigRecharger                 = 69,
	ItemsTraded_Bottle                       = 70,
	ItemsTraded_Antidote                     = 71,
	ItemsTraded_Brick                        = 72,
	TimesCurrencyPickedUp                    = 73,
	CurrencyPickedUp_MurkoffPoint            = 74,
	CurrencyPickedUp_MurkoffDollar           = 75,
	TimesUsedActiveSkill                     = 76,
	TotalDamageTaken                         = 77,
	TimesIncapacitated                       = 78,
	SecondsSpentIncapacitated                = 79,
	TimesKilled                              = 80,
	ChancesLost                              = 81,
	SecondsSpentDead                         = 82,
	TimesRevived                             = 83,
	TimesRespawned                           = 84,
	TimesHelpedUpTeammate                    = 85,
	TimesRevivedDeadPlayer                   = 86,
	TimesUsedHidingSpot                      = 87,
	SecondsSpentInHidingSpot                 = 88,
	TimesUsedNightVision                     = 89,
	SecondsSpentInNightVision                = 90,
	SecondsSpentInXRay                       = 91,
	TimesUsedDynamicObstable                 = 92,
	TimesHitNpcWithDynamicObstable           = 93,
	TimesTriggeredExplosiveTrap              = 94,
	TimesDamagedByExplosiveTrap              = 95,
	TotalDamageByExplosiveTraps              = 96,
	TimesTriggeredExplosiveWireTrap          = 97,
	TimesDamagedByExplosiveWireTrap          = 98,
	TotalDamageByExplosiveWireTraps          = 99,
	DoorTrapsDisarmed                        = 100,
	DoorTrapsTriggered                       = 101,
	DoorTrapsAvoided                         = 102,
	DoorTrapsCaught                          = 103,
	BashOpenLockedDoor                       = 104,
	PrimeAssetTrapDisarmed                   = 105,
	LockedContainersDisarmAttempts           = 106,
	LockedContainersDisarmSuccess            = 107,
	LockedContainersDisarmFailure            = 108,
	TimesDamagedByElectricFloorTrap          = 109,
	TotalDamageByElectricFloorTraps          = 110,
	JumpScaresTriggered                      = 111,
	Shove                                    = 112,
	BodyHitEnemy                             = 113,
	HeadShotHitEnemy                         = 114,
	DistractEnemyWithThrowable               = 115,
	Spotted                                  = 116,
	SecondsSpentCrouched                     = 117,
	SecondsSpentRunning                      = 118,
	SecondsSpentSliding                      = 119,
	Chases                                   = 120,
	ChasesEscaped                            = 121,
	ChasesDamaged                            = 122,
	ChasesIncapacitated                      = 123,
	ChasesEscapedWithHidingSpot              = 124,
	SecondsSpentChased                       = 125,
	TimesInPsychosis                         = 126,
	SecondsSpentInPsychosis                  = 127,
	PuzzleRoomsCompleted                     = 128,
	RewardRoomsUnlocked                      = 129,
	DistanceTraveled                         = 130,
	DistanceTraveledWalking                  = 131,
	DistanceTraveledCrouching                = 132,
	DistanceTraveledRunning                  = 133,
	DistanceTraveledSliding                  = 134,
	HealthRecovered                          = 135,
	BatteryRecovered                         = 136,
	StaminaRecovered                         = 137,
	SanityRecovered                          = 138,
	CoopMovesPerformed                       = 139,
	Badge_BigSaver                           = 140,
	Badge_SleighOfHand                       = 141,
	Badge_Mechanophiliac                     = 142,
	Badge_TogetherWeAreStong                 = 143,
	Badge_CrowdControl                       = 144,
	Badge_Hypochondriac                      = 145,
	Badge_NotYourTimeYet                     = 146,
	Badge_GottaGoFast                        = 147,
	Badge_BreatheIn                          = 148,
	Badge_PowerSurge                         = 149,
	Badge_Bulleye                            = 150,
	Badge_MajorLeaguePlayer                  = 151,
	Badge_Distraction                        = 152,
	Badge_Coward                             = 153,
	Badge_TriggerHappy                       = 154,
	Badge_AngerIssues                        = 155,
	Badge_TappingOut                         = 156,
	Badge_BoostMeUp                          = 157,
	Badge_ClearVision                        = 158,
	Badge_HighAsAKite                        = 159,
	Badge_StepOnMeDaddy                      = 160,
	Badge_Hemophiliac                        = 161,
	Badge_Hoarder                            = 162,
	Badge_DriftKing                          = 163,
	Badge_Marathonian                        = 164,
	Badge_Hunchback                          = 165,
	Badge_CantTouchThis                      = 166,
	Badge_AverageJoe                         = 167,
	Badge_CompletedProgram1                  = 168,
	Badge_CompletedProgram2                  = 169,
	Badge_CompletedProgram3                  = 170,
	Badge_CompletedProgram4                  = 171,
	Badge_CompletedProgram5                  = 172,
	Badge_CompletedProgramX                  = 173,
	CharactersReleased_Volundary             = 174,
	BestTrialCompletionTimeSeconds           = 175,
	BestTrialGroupTQ                         = 176,
	BestTrialPersonalTQ                      = 177,
	MaxCharacterLevelReached                 = 178,
	TotalTrialTimePlayedSeconds              = 179,
	TrialsCompleted                          = 180,
	TrialsCompletedCoop                      = 181,
	TrialsCompletedNoDamage                  = 182,
	TrialsFailed                             = 183,
	TrialsCompletedDRating                   = 184,
	TrialsCompletedDPlusRating               = 185,
	TrialsCompletedCMinusRating              = 186,
	TrialsCompletedCRating                   = 187,
	TrialsCompletedCPlusRating               = 188,
	TrialsCompletedBMinusRating              = 189,
	TrialsCompletedBRating                   = 190,
	TrialsCompletedBPlusRating               = 191,
	TrialsCompletedAMinusRating              = 192,
	TrialsCompletedARating                   = 193,
	TrialsCompletedAPlusRating               = 194,
	ArmWrestlingMatchesWon                   = 195,
	ArmWrestlingMatchesLost                  = 196,
	ChessMatchesWon                          = 197,
	ChessMatchesLost                         = 198,
	StroopMatchesWon                         = 199,
	StroopMatchesLost                        = 200,
	TennisMatchesWon                         = 201,
	TennisMatchesLost                        = 202,
	TalkWheel                                = 203,
	TalkWheel_Help                           = 204,
	TalkWheel_Acknowledge                    = 205,
	TalkWheel_Regroup                        = 206,
	TalkWheel_Wait                           = 207,
	TalkWheel_Danger                         = 208,
	TalkWheel_Thanks                         = 209,
	TalkWheel_OnMyWay                        = 210,
	TalkWheel_Hello                          = 211,
	TalkWheel_Ping                           = 212,
	TrialChaining_RunsCompleted              = 213,
	TrialChaining_TrialsCompleted            = 214,
	TrialChaining_HighestTrialReached        = 215,
	TrialChaining_TotalTimePlayedSeconds     = 216,
	Max                                      = 217,
};

// Enum OPP.EGamepadType
// NumValues: 0x0007
enum class EGamepadType : uint8
{
	XboxOne                                  = 0,
	Xbox360                                  = 1,
	DualSense                                = 2,
	Dualshock4                               = 3,
	Dualshock3                               = 4,
	None                                     = 5,
	EGamepadType_MAX                         = 6,
};

// Enum OPP.EExitStageObjectiveState
// NumValues: 0x0006
enum class EExitStageObjectiveState : uint8
{
	Invalid                                  = 0,
	WaitingForButton                         = 1,
	WaitingForDoors                          = 2,
	CanAccessSAS                             = 3,
	WaitingForPlayersExitingSAS              = 4,
	EExitStageObjectiveState_MAX             = 5,
};

// Enum OPP.ETimingInputResultType
// NumValues: 0x0005
enum class ETimingInputResultType : uint8
{
	Failure                                  = 0,
	PartialSuccess                           = 1,
	BarelySuccess                            = 2,
	Success                                  = 3,
	ETimingInputResultType_MAX               = 4,
};

// Enum OPP.ELoadoutElementType
// NumValues: 0x0006
enum class ELoadoutElementType : uint8
{
	None                                     = 0,
	ActiveSkill                              = 1,
	ActiveSkillUpgrade                       = 2,
	Perk                                     = 3,
	ProfileUpgrade                           = 4,
	ELoadoutElementType_MAX                  = 5,
};

// Enum OPP.EMainMenuState
// NumValues: 0x000D
enum class EMainMenuState : uint8
{
	None                                     = 0,
	WaitingForPlayerController               = 1,
	WaitingForInput                          = 2,
	Disclaimer                               = 3,
	Connecting                               = 4,
	ProcessingBootInvite                     = 5,
	Connected                                = 6,
	OptionsMenu                              = 7,
	MainMenu                                 = 8,
	EnteringLobby                            = 9,
	TransitionToTutorialMap                  = 10,
	EnteringTutorialMap                      = 11,
	EMainMenuState_MAX                       = 12,
};

// Enum OPP.EGamePhase
// NumValues: 0x0013
enum class EGamePhase : uint8
{
	None                                     = 0,
	WaitingForPlayers                        = 1,
	WaitingForPlayersSitting                 = 2,
	LoadingStage                             = 3,
	Populating                               = 4,
	WaitingForClientsPopulate                = 5,
	StageReady                               = 6,
	StageStarted                             = 7,
	StageEnding                              = 8,
	StageFailed                              = 9,
	WaitingForRetry                          = 10,
	TrialChainingTransition                  = 11,
	StageReset                               = 12,
	StageSuccess                             = 13,
	RoundCompleting                          = 14,
	ReturnToLobby                            = 15,
	TransitioningToNextServer                = 16,
	PostGameExitTimeout                      = 17,
	EGamePhase_MAX                           = 18,
};

// Enum OPP.ENPCType
// NumValues: 0x0015
enum class ENPCType : uint8
{
	Grunt                                    = 0,
	Ambient                                  = 1,
	BigGrunt                                 = 2,
	SleeperScreamer                          = 3,
	Pouncer                                  = 4,
	Pusher                                   = 5,
	GroundPitcher                            = 6,
	Berserker                                = 7,
	Imposter                                 = 8,
	NightHunter                              = 9,
	Spectre                                  = 10,
	ThrowableTarget                          = 11,
	StalkerTarget                            = 12,
	Gooseberry                               = 13,
	Coyle                                    = 14,
	Franco                                   = 15,
	Scientist                                = 16,
	Guard                                    = 17,
	StageDefaultPrimeAsset                   = 18,
	StageNonDefaultPrimeAsset                = 19,
	MAX                                      = 20,
};

// Enum OPP.ESASVariatorType
// NumValues: 0x0004
enum class ESASVariatorType : uint8
{
	None                                     = 0,
	SplitEntrance                            = 1,
	SplitExit                                = 2,
	Max                                      = 3,
};

// Enum OPP.EObstacleVariatorType
// NumValues: 0x0007
enum class EObstacleVariatorType : uint8
{
	None                                     = 0,
	SoundTraps                               = 1,
	ExplosiveTraps                           = 2,
	ElectricFloors                           = 3,
	PsychosisMine                            = 4,
	ExplosiveWireTraps                       = 5,
	Max                                      = 6,
};

// Enum OPP.EGameSessionType
// NumValues: 0x0004
enum class EGameSessionType : uint8
{
	Unknown                                  = 0,
	Placement                                = 1,
	Matchmaking                              = 2,
	EGameSessionType_MAX                     = 3,
};

// Enum OPP.ESASState
// NumValues: 0x0009
enum class ESASState : uint8
{
	Invalid                                  = 0,
	NextExitUnlocked                         = 1,
	InTransit                                = 2,
	EndingLevel                              = 3,
	RestartingLevel                          = 4,
	NextExitLocked                           = 5,
	Begin                                    = 6,
	ReturnToLobby                            = 7,
	ESASState_MAX                            = 8,
};

// Enum OPP.EHotPotatoState
// NumValues: 0x0007
enum class EHotPotatoState : uint8
{
	Disabled                                 = 0,
	Idle                                     = 1,
	Dropped                                  = 2,
	Carried                                  = 3,
	Completed                                = 4,
	Expired                                  = 5,
	EHotPotatoState_MAX                      = 6,
};

// Enum OPP.EWorldIconType
// NumValues: 0x000D
enum class EWorldIconType : uint8
{
	Unspecified                              = 0,
	PlayerIndicator                          = 1,
	CoopNotification                         = 2,
	ObjectiveDefault                         = 3,
	ObjectivePsychosis                       = 4,
	PlayerPing                               = 5,
	NPCDebugIcon                             = 6,
	FriendlyDevice                           = 7,
	DeadBodySolo                             = 8,
	TutorialZone                             = 9,
	AIAttractorNPCIcon                       = 10,
	MotionDetectorIcon                       = 11,
	Max                                      = 12,
};

// Enum OPP.EActionProgressContext
// NumValues: 0x0004
enum class EActionProgressContext : uint8
{
	General                                  = 0,
	Investigation                            = 1,
	Count                                    = 2,
	EActionProgressContext_MAX               = 3,
};

// Enum OPP.EGameMessageCategory
// NumValues: 0x0005
enum class EGameMessageCategory : uint8
{
	Normal                                   = 0,
	Error                                    = 1,
	ObjectiveStarted                         = 2,
	ObjectiveCompleted                       = 3,
	EGameMessageCategory_MAX                 = 4,
};

// Enum OPP.InventoryWheelMode
// NumValues: 0x0004
enum class EInventoryWheelMode : uint8
{
	Hold                                     = 0,
	Scroll                                   = 1,
	None                                     = 2,
	InventoryWheelMode_MAX                   = 3,
};

// Enum OPP.PlayerActionStatus
// NumValues: 0x0008
enum class EPlayerActionStatus : uint8
{
	None                                     = 0,
	HelpUp                                   = 1,
	Revive                                   = 2,
	InTrap                                   = 3,
	GettingPounced                           = 4,
	Investigating                            = 5,
	ItemHoldingAction                        = 6,
	PlayerActionStatus_MAX                   = 7,
};

// Enum OPP.ERBSocialMenuEntryAction
// NumValues: 0x001A
enum class ERBSocialMenuEntryAction : uint8
{
	ShowPlatformProfileUi                    = 0,
	ChangeActiveSkill                        = 1,
	OpenSocialMenu                           = 2,
	SendFriendInvite                         = 3,
	CancelFriendInvite                       = 4,
	AcceptFriendInvite                       = 5,
	RefuseFriendInvite                       = 6,
	RemoveFriend                             = 7,
	ShowAddFriendUi                          = 8,
	SendPlatformFriendInvite                 = 9,
	AcceptPlatformFriendInvite               = 10,
	RefusePlatformFriendInvite               = 11,
	JoinParty                                = 12,
	LeaveParty                               = 13,
	InviteToParty                            = 14,
	RemoveFromParty                          = 15,
	RefusePartyInvite                        = 16,
	PromotePartyMember                       = 17,
	TogglePartyInviteWidget                  = 18,
	Block                                    = 19,
	UnBlock                                  = 20,
	PlatformBlock                            = 21,
	Report                                   = 22,
	InvitePlayer                             = 23,
	UpdatePartySettings                      = 24,
	ERBSocialMenuEntryAction_MAX             = 25,
};

// Enum OPP.ERBSocialMenuEntryFilter
// NumValues: 0x0003
enum class ERBSocialMenuEntryFilter : uint8
{
	None                                     = 0,
	SamePlatform                             = 1,
	ERBSocialMenuEntryFilter_MAX             = 2,
};

// Enum OPP.ELobbyGameState
// NumValues: 0x0006
enum class ELobbyGameState : uint8
{
	None                                     = 0,
	WaitingForPlayers                        = 1,
	Intro                                    = 2,
	GameInProgress                           = 3,
	Outro                                    = 4,
	ELobbyGameState_MAX                      = 5,
};

// Enum OPP.EFindPartyTicketState
// NumValues: 0x0005
enum class EFindPartyTicketState : uint8
{
	Searching                                = 0,
	PendingAcceptance                        = 1,
	AcceptanceProvided                       = 2,
	Completed                                = 3,
	EFindPartyTicketState_MAX                = 4,
};

// Enum OPP.EInventoryUpdateEventType
// NumValues: 0x0006
enum class EInventoryUpdateEventType : uint8
{
	EquippedItemChanged                      = 0,
	InventoryChanged                         = 1,
	ItemPickup                               = 2,
	ActiveSkillChargeChanged                 = 3,
	ForceTemporaryFadeIn                     = 4,
	EInventoryUpdateEventType_MAX            = 5,
};

// Enum OPP.ELocomotionMode
// NumValues: 0x0021
enum class ELocomotionMode : uint8
{
	Normal                                   = 0,
	SpecialMove                              = 1,
	Cinematic                                = 2,
	KnockedDown                              = 3,
	KnockedDownSliding                       = 4,
	Dead                                     = 5,
	Falling                                  = 6,
	Ghost                                    = 7,
	Operating                                = 8,
	SoftOperating                            = 9,
	DoorLiftHold                             = 10,
	Pushing                                  = 11,
	Hidden                                   = 12,
	FreeSlide                                = 13,
	SlideOver                                = 14,
	SlideUnder                               = 15,
	SlideDown                                = 16,
	GroundAndPound                           = 17,
	ScriptedIdle                             = 18,
	NPCAnimating                             = 19,
	Knockout                                 = 20,
	MovingLargePickup                        = 21,
	WakeUp                                   = 22,
	OperatingDoor                            = 23,
	CoopTrapped_Victim                       = 24,
	CoopTrapped_Helper                       = 25,
	Coop_WaitingForBash                      = 26,
	Coop_HelpUp                              = 27,
	Coop_Revive                              = 28,
	Coop_WaitingForTraversal                 = 29,
	Tutorial                                 = 30,
	ActivatingDoorBlock                      = 31,
	MAX                                      = 32,
};

// Enum OPP.ESpecialMove
// NumValues: 0x00B4
enum class ESpecialMove : uint8
{
	None                                     = 0,
	EnterCinematicModeSmooth                 = 1,
	EnterCinematicModeTeleport               = 2,
	ScriptedAnimation                        = 3,
	CustomInteractable                       = 4,
	AdjustPosition                           = 5,
	Jumping                                  = 6,
	Landing                                  = 7,
	NPC_Landing                              = 8,
	JumpOver                                 = 9,
	SlideOver                                = 10,
	JumpThroughWindow                        = 11,
	ClimbOnto                                = 12,
	ClimbDown                                = 13,
	Interaction                              = 14,
	InteractionPhysWalking                   = 15,
	UsingLargeObject                         = 16,
	StartOperating                           = 17,
	FinishOperating                          = 18,
	InterruptOperating                       = 19,
	StartSoftOperating                       = 20,
	FinishSoftOperating                      = 21,
	InterruptSoftOperating                   = 22,
	PickUp                                   = 23,
	ContainerPickUp                          = 24,
	GiveItem                                 = 25,
	ContainerOpen                            = 26,
	DropItem                                 = 27,
	PlayerShove                              = 28,
	PushOtherPawn                            = 29,
	HitReaction                              = 30,
	StunnedByScreamer                        = 31,
	CoopLongJumpJumper                       = 32,
	CoopLongJumpTossed                       = 33,
	CoopLongJumpTossedToCatcher              = 34,
	CoopLongJumpTosser                       = 35,
	CoopLongJumpCatcher                      = 36,
	CoopHighJumpJumper                       = 37,
	CoopHighJumpTossed                       = 38,
	CoopHighJumpTossedToCatcher              = 39,
	CoopHighJumpTosser                       = 40,
	CoopHighJumpCatcher                      = 41,
	CoopClimbOverTossed                      = 42,
	CoopStabAttacker                         = 43,
	CoopStabVictim                           = 44,
	ThrowSmallWeapon                         = 45,
	EnterReadyCoopBash                       = 46,
	BashDoor                                 = 47,
	BashBreakableObject                      = 48,
	LiftGarageDoor                           = 49,
	LetGoOfGarageDoor                        = 50,
	StartPushing                             = 51,
	StopPushing                              = 52,
	StartKnockdownSliding                    = 53,
	StopKnockdownSliding                     = 54,
	SelfRevive                               = 55,
	EnterCoopTrapped_Victim                  = 56,
	ExitCoopTrapped_Victim                   = 57,
	FailCoopTrapped_VictimKnockdown          = 58,
	FailCoopTrapped_VictimDead               = 59,
	EnterCoopTrapped_Helper                  = 60,
	ExitCoopTrapped_Helper                   = 61,
	Enter_CoopWaitingForTraversal            = 62,
	Exit_CoopWaitingForTraversal             = 63,
	StartDoorBlocking                        = 64,
	FinishDoorBlocking                       = 65,
	PairedPulloutFromHidingSpotLeader        = 66,
	PairedPulloutFromHidingSpotFollower      = 67,
	LandOntoLedge                            = 68,
	ConsumeItem                              = 69,
	PushFromLedge                            = 70,
	HelpUpEntryLeader                        = 71,
	HelpUpEntryFollower                      = 72,
	HelpUpLeaveLeader                        = 73,
	HelpUpSuccessLeader                      = 74,
	HelpUpSuccessFollower                    = 75,
	HelpUpFailFollower                       = 76,
	ReviveEntryLeader                        = 77,
	ReviveEntryFollower                      = 78,
	ReviveLeaveLeader                        = 79,
	ReviveSuccessLeader                      = 80,
	ReviveSuccessFollower                    = 81,
	Wait                                     = 82,
	TraversalSlide                           = 83,
	PickupLargeObject                        = 84,
	PutDownLargeObject                       = 85,
	EnterWakeUpSequence                      = 86,
	ExitWakeUpSequence                       = 87,
	DoorInteraction                          = 88,
	ActivateDynamicObstacle                  = 89,
	StartOperatingDoor                       = 90,
	StopOperatingDoor                        = 91,
	InterruptedOperatingDoor                 = 92,
	NearDeathToKnockdown                     = 93,
	KnockDownSelfHelpSAS                     = 94,
	KnockDownStandUp                         = 95,
	PlayUpperBodyAnimation                   = 96,
	EnterHidespot                            = 97,
	ExitHidespot                             = 98,
	KnockdownInHidespot                      = 99,
	Align                                    = 100,
	SignalTackle                             = 101,
	TackleFail                               = 102,
	EnterGroundAndPoundAttacker              = 103,
	EnterGroundAndPoundVictim                = 104,
	GroundAndPoundFinishAttacker             = 105,
	GroundAndPoundFinishVictim               = 106,
	GroundAndPoundGiveUpAttacker             = 107,
	GroundAndPoundGiveUpVictim               = 108,
	GroundAndPoundEscapePlayer               = 109,
	GroundAndPoundEscapePouncer              = 110,
	GroundAndPoundInterruptPouncer           = 111,
	GroundAndPoundInterruptPinnedPlayer      = 112,
	PusherAttackAttacker                     = 113,
	PusherAttackVictim                       = 114,
	PairedAttackAttacker                     = 115,
	PairedAttackVictim                       = 116,
	StandardFatalityAttacker                 = 117,
	StandardFatalityVictim                   = 118,
	KnockdownToDeath                         = 119,
	GrabAndThrowAttacker                     = 120,
	GrabAndThrowVictim                       = 121,
	NPC_AnimatedStart                        = 122,
	NPC_AnimatedStop                         = 123,
	NPC_SingleShotAnim                       = 124,
	NPC_FixedPoseAnim                        = 125,
	NPC_Startled                             = 126,
	NPC_Attack                               = 127,
	NPC_GroupAttack                          = 128,
	NPC_QuickAttack                          = 129,
	NPC_Investigate                          = 130,
	NPC_GiveUpInvestigation                  = 131,
	NPC_GiveUpAlerted                        = 132,
	NPC_GiveUpSuspicious                     = 133,
	NPC_IdleBreaker                          = 134,
	NPC_PlayerTaunt                          = 135,
	NPC_InvestigateHidespot                  = 136,
	NPC_DoorInvestigation                    = 137,
	NPC_BashDynamicObstacle                  = 138,
	NPC_EnterAmbientIdle                     = 139,
	NPC_LeaveAmbientIdle                     = 140,
	NPC_PeekFromHidespot                     = 141,
	NPC_Sabotage                             = 142,
	NPC_BerserkerIdleBreaker                 = 143,
	NPC_Spectre_Intro                        = 144,
	NPC_Spectre_Outro                        = 145,
	NPC_JumpOver                             = 146,
	NPC_ClimbOnto                            = 147,
	NPC_ClimbDownLedge                       = 148,
	NPC_CrouchUnder                          = 149,
	NPC_GhostThroughObstacle                 = 150,
	NPC_DoorPassthrough                      = 151,
	NPC_TrapReaction                         = 152,
	NPC_TurnOnSpot                           = 153,
	NPC_HitReaction                          = 154,
	NPC_DelayedFlinchReaction                = 155,
	NPC_CheckSurroundings                    = 156,
	NPC_Knockout                             = 157,
	NPC_GetUpFromKnockout                    = 158,
	NPC_GoryDeath                            = 159,
	NPC_WaypointAnim                         = 160,
	NPC_DrawWeapon                           = 161,
	NPC_HolsterWeapon                        = 162,
	NPC_ShootWeapon                          = 163,
	NPC_ReloadWeapon                         = 164,
	NPC_ThrowWeapon                          = 165,
	NPC_ShakePushable                        = 166,
	NPC_HaarpReaction                        = 167,
	NPC_BreakDistrator                       = 168,
	NPC_ReactToGrenade                       = 169,
	NPC_ReactToGrenadeStun                   = 170,
	NPC_GrenadeStun                          = 171,
	NPC_RecoverFromGrenadeStun               = 172,
	NPC_ReactToBlindPaint                    = 173,
	NPC_ReactToHealSlowdown                  = 174,
	NPC_ReactToIllness                       = 175,
	NPC_SleeperDisturbed                     = 176,
	NPC_SleeperWakeUp                        = 177,
	NPC_StalkerTargetBulbExplodeReaction     = 178,
	MAX                                      = 179,
};

// Enum OPP.ESpecialMoveNotifyType
// NumValues: 0x0008
enum class ESpecialMoveNotifyType : uint8
{
	DoAction                                 = 0,
	DoSecondaryAction                        = 1,
	SpecialMoveCompleted                     = 2,
	DisablePawnCollisions                    = 3,
	AllowMovement                            = 4,
	EnableGravity                            = 5,
	EnabledWorldCollision                    = 6,
	ESpecialMoveNotifyType_MAX               = 7,
};

// Enum OPP.EFootStepModifierType
// NumValues: 0x0005
enum class EFootStepModifierType : uint8
{
	None                                     = 0,
	Rubbish                                  = 1,
	Bloody                                   = 2,
	Wet                                      = 3,
	EFootStepModifierType_MAX                = 4,
};

// Enum OPP.EProceduralAnimInterpType
// NumValues: 0x0008
enum class EProceduralAnimInterpType : uint8
{
	Smooth                                   = 0,
	Linear                                   = 1,
	Decel                                    = 2,
	Accel                                    = 3,
	ExpDecel                                 = 4,
	ExpAccel                                 = 5,
	EaseOut                                  = 6,
	EProceduralAnimInterpType_MAX            = 7,
};

// Enum OPP.EGhostFinishReason
// NumValues: 0x0005
enum class EGhostFinishReason : uint8
{
	NoneGiven                                = 0,
	Leaving                                  = 1,
	Interrupted                              = 2,
	Custom                                   = 3,
	MAX                                      = 4,
};

// Enum OPP.EBashDoorType
// NumValues: 0x0006
enum class EBashDoorType : uint8
{
	KickTry                                  = 0,
	KickOpen                                 = 1,
	ShoulderTry                              = 2,
	ShoulderOpen                             = 3,
	CoopBash                                 = 4,
	EBashDoorType_MAX                        = 5,
};

// Enum OPP.EDoorInteractionType
// NumValues: 0x0011
enum class EDoorInteractionType : uint8
{
	None                                     = 0,
	Open                                     = 1,
	OpenFail                                 = 2,
	CloseInsideLeft                          = 3,
	CloseInsideRight                         = 4,
	CloseOutsideLeft                         = 5,
	CloseOutsideRight                        = 6,
	CloseInsideLeftQuick                     = 7,
	CloseInsideRightQuick                    = 8,
	CloseOutsideLeftQuick                    = 9,
	CloseOutsideRightQuick                   = 10,
	CloseInsideLeftRunning                   = 11,
	CloseInsideRightRunning                  = 12,
	CloseOutsideLeftRunning                  = 13,
	CloseOutsideRightRunning                 = 14,
	SlowOpenStart                            = 15,
	EDoorInteractionType_MAX                 = 16,
};

// Enum OPP.EBasicDirection
// NumValues: 0x0006
enum class EBasicDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Left                                     = 3,
	Right                                    = 4,
	MAX                                      = 5,
};

// Enum OPP.EHackState
// NumValues: 0x0007
enum class EHackState : uint8
{
	Undefined                                = 0,
	Disabled                                 = 1,
	Hackable                                 = 2,
	ActivelyBeingHacked                      = 3,
	HackedDisabled                           = 4,
	HackedActive                             = 5,
	EHackState_MAX                           = 6,
};

// Enum OPP.EPawnRepulsionType
// NumValues: 0x0006
enum class EPawnRepulsionType : uint8
{
	None                                     = 0,
	AllDirection                             = 1,
	AllDirectionExceptBack                   = 2,
	ForwardOnly                              = 3,
	SideOnly                                 = 4,
	EPawnRepulsionType_MAX                   = 5,
};

// Enum OPP.EItemCategory
// NumValues: 0x0009
enum class EItemCategory : uint8
{
	Fist                                     = 0,
	Throwable                                = 1,
	Health                                   = 2,
	Utility                                  = 3,
	ActiveSkill                              = 4,
	Collectible                              = 5,
	QuestItem                                = 6,
	None                                     = 7,
	EItemCategory_MAX                        = 8,
};

// Enum OPP.EDamageVolumeType
// NumValues: 0x0007
enum class EDamageVolumeType : uint8
{
	RightHand                                = 0,
	LeftHand                                 = 1,
	Head                                     = 2,
	LeftFoot                                 = 3,
	RightFoot                                = 4,
	Other                                    = 5,
	EDamageVolumeType_MAX                    = 6,
};

// Enum OPP.EKnockbackValue
// NumValues: 0x0007
enum class EKnockbackValue : uint8
{
	None                                     = 0,
	VeryLow                                  = 1,
	Low                                      = 2,
	Medium                                   = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	EKnockbackValue_MAX                      = 6,
};

// Enum OPP.EDamageValue
// NumValues: 0x0007
enum class EDamageValue : uint8
{
	None                                     = 0,
	VeryLow                                  = 1,
	Low                                      = 2,
	Medium                                   = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	EDamageValue_MAX                         = 6,
};

// Enum OPP.EConfigValueType
// NumValues: 0x0008
enum class EConfigValueType : uint8
{
	None                                     = 0,
	Int                                      = 1,
	Float                                    = 2,
	Bool                                     = 3,
	IntByDifficulty                          = 4,
	FloatByDifficulty                        = 5,
	BoolByDifficulty                         = 6,
	EConfigValueType_MAX                     = 7,
};

// Enum OPP.EForceFeedbackDataType
// NumValues: 0x000B
enum class EForceFeedbackDataType : uint8
{
	None                                     = 0,
	GenericVeryLow                           = 1,
	GenericLow                               = 2,
	GenericMedium                            = 3,
	GenericHigh                              = 4,
	LoopingLow                               = 5,
	LoopingMedium                            = 6,
	LoopingHigh                              = 7,
	Death                                    = 8,
	Revive                                   = 9,
	EForceFeedbackDataType_MAX               = 10,
};

// Enum OPP.EPlayerHitReactionType
// NumValues: 0x0008
enum class EPlayerHitReactionType : uint8
{
	None                                     = 0,
	Flinch                                   = 1,
	Light                                    = 2,
	Medium                                   = 3,
	Heavy                                    = 4,
	KnockedDown                              = 5,
	Dead                                     = 6,
	EPlayerHitReactionType_MAX               = 7,
};

// Enum OPP.EMessagePriority
// NumValues: 0x000C
enum class EMessagePriority : uint8
{
	NoPriority                               = 0,
	Generic_SuperLowPriority                 = 1,
	Gameplay_VeryLowPriority                 = 2,
	Gameplay_LowPriority                     = 3,
	Tutorial_LowPriority                     = 4,
	Gameplay_MediumPriority                  = 5,
	Tutorial_MediumPriority                  = 6,
	Gameplay_HighPriority                    = 7,
	Tutorial_HighPriority                    = 8,
	Gameplay_VeryHighPriority                = 9,
	Generic_SuperHighPriority                = 10,
	EMessagePriority_MAX                     = 11,
};

// Enum OPP.ENightVisionAnimNotifyType
// NumValues: 0x000A
enum class ENightVisionAnimNotifyType : uint8
{
	ShowMesh                                 = 0,
	HUD                                      = 1,
	EnterFX                                  = 2,
	ExitFX                                   = 3,
	TurnOn                                   = 4,
	TurnOff                                  = 5,
	RestrictNVOn                             = 6,
	RestrictNVOff                            = 7,
	RemoveAllRestrictions                    = 8,
	ENightVisionAnimNotifyType_MAX           = 9,
};

// Enum OPP.EStimulusType
// NumValues: 0x000A
enum class EStimulusType : uint8
{
	None                                     = 0,
	PartialPlayerVisibility                  = 1,
	FullPlayerVisibility                     = 2,
	LostChasedPlayer                         = 3,
	MinorAudio                               = 4,
	NormalAudio                              = 5,
	ObviousAudio                             = 6,
	HighPriorityEvent                        = 7,
	SurfaceMovement                          = 8,
	EStimulusType_MAX                        = 9,
};

// Enum OPP.EDamageResultType
// NumValues: 0x0005
enum class EDamageResultType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	KnockedDown                              = 2,
	Dead                                     = 3,
	EDamageResultType_MAX                    = 4,
};

// Enum OPP.ELargeObjectPickupSubtype
// NumValues: 0x0004
enum class ELargeObjectPickupSubtype : uint8
{
	AsIs                                     = 0,
	ForcedCrouched                           = 1,
	ForcedStanding                           = 2,
	ELargeObjectPickupSubtype_MAX            = 3,
};

// Enum OPP.EUpperBodyAnimationType
// NumValues: 0x000C
enum class EUpperBodyAnimationType : uint8
{
	Unspecified                              = 0,
	Emote_Hello                              = 1,
	Emote_Pointing                           = 2,
	Emote_OnMyWay                            = 3,
	Emote_Thanks                             = 4,
	Emote_Danger                             = 5,
	Emote_Wait                               = 6,
	Emote_Regroup                            = 7,
	Emote_Acknowledge                        = 8,
	Emote_Help                               = 9,
	Cough                                    = 10,
	EUpperBodyAnimationType_MAX              = 11,
};

// Enum OPP.EPlayerPingType
// NumValues: 0x0004
enum class EPlayerPingType : uint8
{
	None                                     = 0,
	NPC                                      = 1,
	PointOfInterest                          = 2,
	EPlayerPingType_MAX                      = 3,
};

// Enum OPP.ECoopMoveOfferState
// NumValues: 0x0005
enum class ECoopMoveOfferState : uint8
{
	None                                     = 0,
	HailingGeneric                           = 1,
	HailingSpecific                          = 2,
	Nearby                                   = 3,
	ECoopMoveOfferState_MAX                  = 4,
};

// Enum OPP.ECoopMoveType
// NumValues: 0x0006
enum class ECoopMoveType : uint8
{
	None                                     = 0,
	HighJumpCatch                            = 1,
	HighJumpToss                             = 2,
	LongJump                                 = 3,
	CoopClimbOverToss                        = 4,
	ECoopMoveType_MAX                        = 5,
};

// Enum OPP.EClimbOntoAnimType
// NumValues: 0x0004
enum class EClimbOntoAnimType : uint8
{
	None                                     = 0,
	Running                                  = 1,
	Walking                                  = 2,
	EClimbOntoAnimType_MAX                   = 3,
};

// Enum OPP.EJumpOverAnimType
// NumValues: 0x0009
enum class EJumpOverAnimType : uint8
{
	None                                     = 0,
	Running                                  = 1,
	Walking                                  = 2,
	NarrowNoContact                          = 3,
	NoContact                                = 4,
	ClimbOver                                = 5,
	ClimberJumpOver                          = 6,
	BigGruntJumpOverLowCeiling               = 7,
	EJumpOverAnimType_MAX                    = 8,
};

// Enum OPP.EScriptedAnimationType
// NumValues: 0x0003
enum class EScriptedAnimationType : uint8
{
	Unspecified                              = 0,
	EquipBomb                                = 1,
	EScriptedAnimationType_MAX               = 2,
};

// Enum OPP.HallucinationFadeOutType
// NumValues: 0x0004
enum class EHallucinationFadeOutType : uint8
{
	Immediate                                = 0,
	Normal                                   = 1,
	Fast                                     = 2,
	HallucinationFadeOutType_MAX             = 3,
};

// Enum OPP.ETalkWheelAction
// NumValues: 0x000B
enum class ETalkWheelAction : uint8
{
	None                                     = 0,
	Help                                     = 1,
	Acknowledge                              = 2,
	Regroup                                  = 3,
	Wait                                     = 4,
	Danger                                   = 5,
	Thanks                                   = 6,
	OnMyWay                                  = 7,
	Hello                                    = 8,
	Ping                                     = 9,
	ETalkWheelAction_MAX                     = 10,
};

// Enum OPP.EUINoiseMeterStrength
// NumValues: 0x0005
enum class EUINoiseMeterStrength : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	EUINoiseMeterStrength_MAX                = 4,
};

// Enum OPP.EPlayerInterruptActionType
// NumValues: 0x0004
enum class EPlayerInterruptActionType : uint8
{
	None                                     = 0,
	Throwable                                = 1,
	Shove                                    = 2,
	EPlayerInterruptActionType_MAX           = 3,
};

// Enum OPP.EPawnCustomizationRequestType
// NumValues: 0x0004
enum class EPawnCustomizationRequestType : uint8
{
	None                                     = 0,
	PlayerCusto                              = 1,
	NPCCusto                                 = 2,
	EPawnCustomizationRequestType_MAX        = 3,
};

// Enum OPP.EPlayerComponentDetectionState
// NumValues: 0x0004
enum class EPlayerComponentDetectionState : uint8
{
	Idle                                     = 0,
	Suspicious                               = 1,
	Alerted                                  = 2,
	EPlayerComponentDetectionState_MAX       = 3,
};

// Enum OPP.EPlayerSoundDetectionState
// NumValues: 0x0006
enum class EPlayerSoundDetectionState : uint8
{
	Idle                                     = 0,
	Suspicious                               = 1,
	Alerted                                  = 2,
	Resetting                                = 3,
	Disabled                                 = 4,
	EPlayerSoundDetectionState_MAX           = 5,
};

// Enum OPP.ERegroupObjectiveState
// NumValues: 0x0007
enum class ERegroupObjectiveState : uint8
{
	Invalid                                  = 0,
	WaitingForPsychosis                      = 1,
	WaitingForPlayers                        = 2,
	WaitingForNPCs                           = 3,
	WaitingForBP                             = 4,
	Ready                                    = 5,
	ERegroupObjectiveState_MAX               = 6,
};

// Enum OPP.ESimonTortureGameOption
// NumValues: 0x0005
enum class ESimonTortureGameOption : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	Option3                                  = 2,
	Option4                                  = 3,
	ESimonTortureGameOption_MAX              = 4,
};

// Enum OPP.ESimonTortureGameState
// NumValues: 0x0009
enum class ESimonTortureGameState : uint8
{
	Unavailable                              = 0,
	WaitingForActivation                     = 1,
	Intro                                    = 2,
	PlaySolution                             = 3,
	WaitForAnswer                            = 4,
	ResolveRound                             = 5,
	Outro                                    = 6,
	GameOver                                 = 7,
	ESimonTortureGameState_MAX               = 8,
};

// Enum OPP.ESimonTortureMannequinsState
// NumValues: 0x0003
enum class ESimonTortureMannequinsState : uint8
{
	Idle                                     = 0,
	Playing                                  = 1,
	ESimonTortureMannequinsState_MAX         = 2,
};

// Enum OPP.ELobbyGameTeam
// NumValues: 0x0006
enum class ELobbyGameTeam : uint8
{
	None                                     = 0,
	Team1                                    = 1,
	Team2                                    = 2,
	Team3                                    = 3,
	Team4                                    = 4,
	ELobbyGameTeam_MAX                       = 5,
};

// Enum OPP.EStroopGameTurn
// NumValues: 0x0004
enum class EStroopGameTurn : uint8
{
	WaitForQuestion                          = 0,
	WaitForAnswer                            = 1,
	LevelChange                              = 2,
	EStroopGameTurn_MAX                      = 3,
};

// Enum OPP.ETennisGameState
// NumValues: 0x0006
enum class ETennisGameState : uint8
{
	Reset                                    = 0,
	Waiting                                  = 1,
	Service                                  = 2,
	Playing                                  = 3,
	ResolveRound                             = 4,
	ETennisGameState_MAX                     = 5,
};

// Enum OPP.EUnionTortureGameState
// NumValues: 0x000A
enum class EUnionTortureGameState : uint8
{
	Unavailable                              = 0,
	WaitingForActivation                     = 1,
	Intro                                    = 2,
	SymbolPresentation                       = 3,
	PlayingRound                             = 4,
	ReshuffleTargets                         = 5,
	ResolveRound                             = 6,
	Outro                                    = 7,
	GameOver                                 = 8,
	EUnionTortureGameState_MAX               = 9,
};

// Enum OPP.EUnionTortureSymbol
// NumValues: 0x0008
enum class EUnionTortureSymbol : uint8
{
	None                                     = 0,
	Symbol1                                  = 1,
	Symbol2                                  = 2,
	Symbol3                                  = 3,
	Symbol4                                  = 4,
	Symbol5                                  = 5,
	Symbol6                                  = 6,
	EUnionTortureSymbol_MAX                  = 7,
};

// Enum OPP.EUnionTortureTarget
// NumValues: 0x0008
enum class EUnionTortureTarget : uint8
{
	None                                     = 0,
	Target1                                  = 1,
	Target2                                  = 2,
	Target3                                  = 3,
	Target4                                  = 4,
	Target5                                  = 5,
	Target6                                  = 6,
	EUnionTortureTarget_MAX                  = 7,
};

// Enum OPP.EIKFootRootLocalAxis
// NumValues: 0x0005
enum class EIKFootRootLocalAxis : uint8
{
	NONE                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	EIKFootRootLocalAxis_MAX                 = 4,
};

// Enum OPP.EAuthErrorCodes
// NumValues: 0x0015
enum class EAuthErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	InvalidSessionResponseFormat             = 1,
	InvalidProfileListResponseFormat         = 2,
	InvalidProfileResponseFormat             = 3,
	UnsupportedPlatform                      = 4,
	MissingCredentials                       = 5,
	AuthTokenRequestFailed                   = 6,
	AuthTokenRequestTimeout                  = 7,
	FailedToRequestSteamAuthTicket           = 8,
	InvalidAuthCode                          = 9,
	MissingRole                              = 10,
	ProfileNotFound                          = 11,
	ProfileIdMismatch                        = 12,
	ProfileVersionCheckFailed                = 13,
	AuthenticationFailed                     = 14,
	InvalidRefreshToken                      = 15,
	InvalidClientApiKey                      = 16,
	InvalidServerApiKey                      = 17,
	SessionGroupNotFound                     = 18,
	PolicyDocumentNotFound                   = 19,
	EAuthErrorCodes_MAX                      = 20,
};

// Enum OPP.EProfilePrivilegeRevocationReason
// NumValues: 0x0003
enum class EProfilePrivilegeRevocationReason : uint8
{
	Unknown                                  = 0,
	TermsOfServiceViolation                  = 1,
	EProfilePrivilegeRevocationReason_MAX    = 2,
};

// Enum OPP.EProfilePrivilege
// NumValues: 0x0004
enum class EProfilePrivilege : uint8
{
	Invalid                                  = 0,
	Play                                     = 1,
	VoiceChat                                = 2,
	EProfilePrivilege_MAX                    = 3,
};

// Enum OPP.ECoreAnalyticsErrorCodes
// NumValues: 0x0002
enum class ECoreAnalyticsErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	ECoreAnalyticsErrorCodes_MAX             = 1,
};

// Enum OPP.EConfigurationErrorCodes
// NumValues: 0x0007
enum class EConfigurationErrorCodes : uint8
{
	InvalidConfigurationResponseFormat       = 0,
	MissingCredentials                       = 1,
	InvalidScope                             = 2,
	InvalidEnvironment                       = 3,
	ConfigurationNotFound                    = 4,
	InvalidApplication                       = 5,
	EConfigurationErrorCodes_MAX             = 6,
};

// Enum OPP.ECoreMatchmakingErrorCodes
// NumValues: 0x000B
enum class ECoreMatchmakingErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	InvalidTicketFormat                      = 1,
	MatchmakingConfigurationNotFound         = 2,
	TicketNotFound                           = 3,
	TicketCannotBeCanceled                   = 4,
	GameSessionNotFound                      = 5,
	GameSessionFull                          = 6,
	InvalidGameSessionStatus                 = 7,
	GameSessionPlacementCannotBeCanceled     = 8,
	FailedCannotPlayOnlinePrivilegeCheck     = 50,
	ECoreMatchmakingErrorCodes_MAX           = 51,
};

// Enum OPP.ECorePartyErrorCodes
// NumValues: 0x0010
enum class ECorePartyErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	UnexpectedResponseFormat                 = 1,
	TooManyParties                           = 2,
	PartyNotFound                            = 3,
	UnauthorizedPartyOperation               = 4,
	InvalidPartyOperation                    = 5,
	CannotPromoteNonMember                   = 6,
	CannotPromoteSelf                        = 7,
	InviteRequired                           = 8,
	InviteNotValid                           = 9,
	NotInParty                               = 10,
	PartyFull                                = 11,
	InvalidPartyData                         = 12,
	PartyNotJoinable                         = 13,
	INVALID                                  = 14,
	ECorePartyErrorCodes_MAX                 = 15,
};

// Enum OPP.EPartyPrivacy
// NumValues: 0x0006
enum class EPartyPrivacy : uint8
{
	Public                                   = 0,
	Friends                                  = 1,
	Private                                  = 2,
	AllowList                                = 3,
	Unknown                                  = 4,
	EPartyPrivacy_MAX                        = 5,
};

// Enum OPP.ECorePresenceErrorCodes
// NumValues: 0x0002
enum class ECorePresenceErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	ECorePresenceErrorCodes_MAX              = 1,
};

// Enum OPP.ECoreStatsErrorCodes
// NumValues: 0x0007
enum class ECoreStatsErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	StatConfigNotFound                       = 1,
	StatContextNotFound                      = 2,
	StatConfigVersionCheckFailed             = 3,
	StatContextVersionCheckFailed            = 4,
	StatsUpdateTooLarge                      = 5,
	ECoreStatsErrorCodes_MAX                 = 6,
};

// Enum OPP.EEntityErrorCodes
// NumValues: 0x000F
enum class EEntityErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	InvalidEntityResponseFormat              = 1,
	InvalidEntityListResponseFormat          = 2,
	EntityCategoryNotFound                   = 3,
	EntityNotFound                           = 4,
	EntityNotVisible                         = 5,
	InvalidApplication                       = 6,
	InvalidEntityData                        = 7,
	InvalidEntityId                          = 8,
	UnauthorizedAdminOperation               = 9,
	UnauthorizedApplication                  = 10,
	UnauthorizedEntityUpdate                 = 11,
	EntityCategoryVersionCheckFailed         = 12,
	EntityVersionCheckFailed                 = 13,
	EEntityErrorCodes_MAX                    = 14,
};

// Enum OPP.EGameServerErrorCodes
// NumValues: 0x0002
enum class EGameServerErrorCodes : uint8
{
	Disabled                                 = 0,
	EGameServerErrorCodes_MAX                = 1,
};

// Enum OPP.EInventoryErrorCodes
// NumValues: 0x000F
enum class EInventoryErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	InventoryConditionFailed                 = 1,
	OfferNotFound                            = 2,
	ItemNotFound                             = 3,
	DefaultInventoryNotFound                 = 4,
	ItemVersionCheckFailed                   = 5,
	OfferVersionCheckFailed                  = 6,
	DefaultInventoryVersionCheckFailed       = 7,
	ProductNotFound                          = 8,
	ProductSkuNotFound                       = 9,
	ProductLocalizationDataNotFound          = 10,
	ProfilePlatformNotSupported              = 11,
	OrderNotFound                            = 12,
	InvalidOrderStatus                       = 13,
	EInventoryErrorCodes_MAX                 = 14,
};

// Enum OPP.EMatchmakingErrorCodes
// NumValues: 0x000F
enum class EMatchmakingErrorCodes : uint8
{
	FailedToPingDataCenters                  = 0,
	NoMatchmakingConfigurationAvailable      = 1,
	NoGameSessionQueueAvailable              = 2,
	FindMatchCanceled                        = 3,
	FindMatchFailed                          = 4,
	FindMatchTimedOut                        = 5,
	WaitForTicketTimedOut                    = 6,
	GameSessionPlacementFailed               = 7,
	UnexpectedPlayerSessionState             = 8,
	WaitForPlacementTimedOut                 = 9,
	NoAvailableRegion                        = 10,
	NoValidRegion                            = 11,
	NoSharedValidRegion                      = 12,
	MatchRefused                             = 13,
	EMatchmakingErrorCodes_MAX               = 14,
};

// Enum OPP.ENewsItemCTAMenuType
// NumValues: 0x0003
enum class ENewsItemCTAMenuType : uint8
{
	None                                     = 0,
	CurrencyPacks                            = 1,
	ENewsItemCTAMenuType_MAX                 = 2,
};

// Enum OPP.ENewsItemCTAType
// NumValues: 0x0005
enum class ENewsItemCTAType : uint8
{
	None                                     = 0,
	External                                 = 1,
	Menu                                     = 2,
	Product                                  = 3,
	ENewsItemCTAType_MAX                     = 4,
};

// Enum OPP.ENewsItemLocation
// NumValues: 0x0004
enum class ENewsItemLocation : uint8
{
	Unknown                                  = 0,
	MainMenu                                 = 1,
	Lobby                                    = 2,
	ENewsItemLocation_MAX                    = 3,
};

// Enum OPP.EOnlineCoreErrorCode
// NumValues: 0x001A
enum class EOnlineCoreErrorCode : uint8
{
	Canceled                                 = 0,
	Unexpected                               = 1,
	OnlineSubsystemError                     = 2,
	DependenciesNotSatisfied                 = 3,
	NotConnected                             = 4,
	HttpRequestFailed                        = 5,
	HttpRequestUnexpectedStatusCode          = 6,
	HttpRequestInvalidResponseBody           = 7,
	HttpRequestUnexpectedError               = 8,
	HttpRequestUnmappedErrorCode             = 9,
	HttpRequestForbidden                     = 10,
	Shutdown                                 = 11,
	FeatureDisabled                          = 12,
	Throttled                                = 13,
	InvalidAuthenticationToken               = 14,
	AuthenticationTokenExpired               = 15,
	UnauthorizedSource                       = 16,
	UnauthorizedApplication                  = 17,
	UnauthorizedProfile                      = 18,
	NotAuthorized                            = 19,
	MissingPrivilege                         = 20,
	ParameterMissing                         = 21,
	InvalidParameterValue                    = 22,
	InvalidParameterType                     = 23,
	UnexpectedParameterValidationError       = 24,
	EOnlineCoreErrorCode_MAX                 = 25,
};

// Enum OPP.EOnlineCoreErrorFacility
// NumValues: 0x0011
enum class EOnlineCoreErrorFacility : uint8
{
	Core                                     = 0,
	Platform                                 = 1,
	Configuration                            = 2,
	Auth                                     = 3,
	Entity                                   = 4,
	Messaging                                = 5,
	Matchmaking                              = 6,
	GameServer                               = 7,
	Analytics                                = 8,
	Inventory                                = 9,
	RTA                                      = 10,
	Relationship                             = 11,
	Party                                    = 12,
	Presence                                 = 13,
	CommunitySift                            = 14,
	Stats                                    = 15,
	EOnlineCoreErrorFacility_MAX             = 16,
};

// Enum OPP.EOnlineErrorFacility
// NumValues: 0x000B
enum class EOnlineErrorFacility : uint8
{
	Configuration                            = 100,
	Matchmaking                              = 101,
	PlayerProfile                            = 102,
	PlayerProgression                        = 103,
	Stats                                    = 104,
	Store                                    = 105,
	Party                                    = 106,
	PlayerStats                              = 107,
	Achievements                             = 108,
	Ratings                                  = 109,
	EOnlineErrorFacility_MAX                 = 110,
};

// Enum OPP.EPartyErrorCodes
// NumValues: 0x0013
enum class EPartyErrorCodes : uint8
{
	FailedToJoinParty_TimedOutWaitingForInvite = 0,
	FailedToJoinParty_CrossplayRequired      = 1,
	FailedToJoinParty_CrossplayNotAllowed    = 2,
	FailedToJoinParty_PartyNotFound          = 3,
	FailedToJoinParty_InviteRequired         = 4,
	FailedToJoinParty_InviteNotValid         = 5,
	FailedToJoinParty_InvalidGameState       = 6,
	FailedToJoinParty_PartyFull              = 7,
	FailedToJoinParty_PartyNotJoinable       = 8,
	FailedToJoinParty_FirstPartySessionNotFound = 9,
	FailedToJoinParty_VersionMismatch        = 10,
	FailedToJoinParty_Unknown                = 11,
	FailedToCreateFirstPartySession          = 12,
	FailedToUpdateFirstPartySession          = 13,
	FailedToDestroyFirstPartySession         = 14,
	FailedToJoinFirstPartySession            = 15,
	FailedToSendFirstPartySessionInvite      = 16,
	FailedToProcessSessionJoinInvite_PrivilegeFailure = 17,
	EPartyErrorCodes_MAX                     = 18,
};

// Enum OPP.EPartyGameSessionState
// NumValues: 0x0005
enum class EPartyGameSessionState : uint8
{
	FindingLobby                             = 0,
	InLobby                                  = 1,
	InMatch                                  = 2,
	Unknown                                  = 3,
	EPartyGameSessionState_MAX               = 4,
};

// Enum OPP.EPartyInviteRequestRefusalReason
// NumValues: 0x0007
enum class EPartyInviteRequestRefusalReason : uint8
{
	InvalidGameState                         = 0,
	PartyFull                                = 1,
	PlayerBlocked                            = 2,
	PrivacyRelated                           = 3,
	CrossplayDisabled                        = 4,
	None                                     = 5,
	EPartyInviteRequestRefusalReason_MAX     = 6,
};

// Enum OPP.EPlatformErrorCodes
// NumValues: 0x0009
enum class EPlatformErrorCodes : uint8
{
	NoUniqueNetId                            = 0,
	PlatformLoginFailed                      = 1,
	PlatformLoginUiFailed                    = 2,
	PlatformPrivilegeCheckFailed             = 3,
	UserSignedOut                            = 4,
	UserLogout                               = 5,
	LoginDisabled                            = 6,
	Unknown                                  = 7,
	EPlatformErrorCodes_MAX                  = 8,
};

// Enum OPP.EPlayerProgressionErrorCodes
// NumValues: 0x0003
enum class EPlayerProgressionErrorCodes : uint8
{
	NoOfferFoundForPurchase                  = 0,
	NoOfferFoundForLevelUp                   = 1,
	EPlayerProgressionErrorCodes_MAX         = 2,
};

// Enum OPP.EPlayerReportReason
// NumValues: 0x0007
enum class EPlayerReportReason : uint8
{
	AbusiveVoiceChat                         = 0,
	Griefing                                 = 1,
	NonParticipation                         = 2,
	Cheating                                 = 3,
	Spam                                     = 4,
	Other                                    = 5,
	MAX                                      = 6,
};

// Enum OPP.EPresenceState
// NumValues: 0x000A
enum class EPresenceState : uint8
{
	InMainMenu                               = 0,
	InTutorial                               = 1,
	InLobby                                  = 2,
	PreparingTrial                           = 3,
	InTrial                                  = 4,
	InTrialChain                             = 5,
	ReturningToLobby                         = 6,
	FindingParty                             = 7,
	Unknown                                  = 8,
	EPresenceState_MAX                       = 9,
};

// Enum OPP.EIntelType
// NumValues: 0x0004
enum class EIntelType : uint8
{
	None                                     = 0,
	Objective                                = 1,
	Ressource                                = 2,
	EIntelType_MAX                           = 3,
};

// Enum OPP.ERoundWinCondition
// NumValues: 0x0004
enum class ERoundWinCondition : uint8
{
	ReagentsEliminated                       = 0,
	ObjectiveCompleted                       = 1,
	MaxTimeReached                           = 2,
	ERoundWinCondition_MAX                   = 3,
};

// Enum OPP.EAmbientAwarenessPhase
// NumValues: 0x0005
enum class EAmbientAwarenessPhase : uint8
{
	InStation                                = 0,
	WaitingForStartle                        = 1,
	WaitingForIdle                           = 2,
	WaitingForStation                        = 3,
	EAmbientAwarenessPhase_MAX               = 4,
};

// Enum OPP.EAIBoolCommandResult
// NumValues: 0x0003
enum class EAIBoolCommandResult : uint8
{
	Passed                                   = 0,
	Failed                                   = 1,
	EAIBoolCommandResult_MAX                 = 2,
};

// Enum OPP.EAICommandResult
// NumValues: 0x0005
enum class EAICommandResult : uint8
{
	Started                                  = 0,
	Success                                  = 1,
	Failed                                   = 2,
	Interrupted                              = 3,
	EAICommandResult_MAX                     = 4,
};

// Enum OPP.EBotCollisionType
// NumValues: 0x0006
enum class EBotCollisionType : uint8
{
	None                                     = 0,
	HeadToHead                               = 1,
	SideCollision                            = 2,
	TakeOver                                 = 3,
	Merge                                    = 4,
	EBotCollisionType_MAX                    = 5,
};

// Enum OPP.EAssistType
// NumValues: 0x0006
enum class EAssistType : uint8
{
	LocationAndVelocityPrediction            = 0,
	OnlyLocation                             = 1,
	OnlyVelocityPrediction                   = 2,
	AverageLocationAndVelocityPrediction     = 3,
	LocationToVelocityPredictionRange        = 4,
	EAssistType_MAX                          = 5,
};

// Enum OPP.EPlayerVisibilityState
// NumValues: 0x0004
enum class EPlayerVisibilityState : uint8
{
	None                                     = 0,
	Partial                                  = 1,
	Full                                     = 2,
	EPlayerVisibilityState_MAX               = 3,
};

// Enum OPP.EPlayerAwarenessState
// NumValues: 0x0005
enum class EPlayerAwarenessState : uint8
{
	Unaware                                  = 0,
	ForcedUnaware                            = 1,
	Aware                                    = 2,
	ForcedAware                              = 3,
	EPlayerAwarenessState_MAX                = 4,
};

// Enum OPP.EPlayerVisibilityType
// NumValues: 0x0006
enum class EPlayerVisibilityType : uint8
{
	NotVisible                               = 0,
	CloseFull                                = 1,
	ClosePartial                             = 2,
	FullVisionCone                           = 3,
	PartialVisionCone                        = 4,
	EPlayerVisibilityType_MAX                = 5,
};

// Enum OPP.ERBAISpawnerVersion
// NumValues: 0x0006
enum class ERBAISpawnerVersion : uint8
{
	Initial                                  = 0,
	WithSpawnType                            = 1,
	SoftMonsterCloset                        = 2,
	SoftLeashPtr                             = 3,
	Current                                  = 3,
	ERBAISpawnerVersion_MAX                  = 4,
};

// Enum OPP.EAISpawnControlType
// NumValues: 0x0006
enum class EAISpawnControlType : uint8
{
	AIDirector                               = 0,
	Always                                   = 1,
	RandomManager                            = 2,
	Manual                                   = 3,
	Objective                                = 4,
	EAISpawnControlType_MAX                  = 5,
};

// Enum OPP.EAISpawnerState
// NumValues: 0x0005
enum class EAISpawnerState : uint8
{
	Inactive                                 = 0,
	Spawned                                  = 1,
	Retired                                  = 2,
	Limbo                                    = 3,
	EAISpawnerState_MAX                      = 4,
};

// Enum OPP.EBackgroundCharacterLocomotionState
// NumValues: 0x0005
enum class EBackgroundCharacterLocomotionState : uint8
{
	Idle                                     = 0,
	Starting                                 = 1,
	Moving                                   = 2,
	Stopping                                 = 3,
	EBackgroundCharacterLocomotionState_MAX  = 4,
};

// Enum OPP.EAnimLogCategory
// NumValues: 0x000A
enum class EAnimLogCategory : uint8
{
	AnimatedStart                            = 0,
	AnimatedStop                             = 1,
	Startled                                 = 2,
	StartledReaction                         = 3,
	Attack                                   = 4,
	ActiveSkills                             = 5,
	Investigate                              = 6,
	SpecialMove                              = 7,
	Other                                    = 8,
	MAX                                      = 9,
};

// Enum OPP.EInterruptibilityState
// NumValues: 0x0004
enum class EInterruptibilityState : uint8
{
	EnableInterruption                       = 0,
	DisableInterruption                      = 1,
	Custom                                   = 2,
	EInterruptibilityState_MAX               = 3,
};

// Enum OPP.EPlayerCameraTargetBehavior
// NumValues: 0x0006
enum class EPlayerCameraTargetBehavior : uint8
{
	Animation                                = 0,
	Manual                                   = 1,
	Gameplay                                 = 2,
	LookAt                                   = 3,
	None                                     = 4,
	EPlayerCameraTargetBehavior_MAX          = 5,
};

// Enum OPP.EPlayItemCondition
// NumValues: 0x0003
enum class EPlayItemCondition : uint8
{
	None                                     = 0,
	ActiveHoldAction                         = 1,
	EPlayItemCondition_MAX                   = 2,
};

// Enum OPP.EPlayerDamageSetting
// NumValues: 0x0005
enum class EPlayerDamageSetting : uint8
{
	None                                     = 0,
	PulledOutOfHidingSpot                    = 1,
	ThrownPlayer                             = 2,
	InitialCoopTrap                          = 3,
	EPlayerDamageSetting_MAX                 = 4,
};

// Enum OPP.ESpecialMoveNotifyTriggerType
// NumValues: 0x0004
enum class ESpecialMoveNotifyTriggerType : uint8
{
	All                                      = 0,
	PlayerOnly                               = 1,
	NPCOnly                                  = 2,
	ESpecialMoveNotifyTriggerType_MAX        = 3,
};

// Enum OPP.ENPCHidespotPeekDistance
// NumValues: 0x0004
enum class ENPCHidespotPeekDistance : uint8
{
	Close                                    = 0,
	Medium                                   = 1,
	Far                                      = 2,
	ENPCHidespotPeekDistance_MAX             = 3,
};

// Enum OPP.EItemConsumeAnimType
// NumValues: 0x0004
enum class EItemConsumeAnimType : uint8
{
	Standing                                 = 0,
	Crouched                                 = 1,
	Hidespot                                 = 2,
	EItemConsumeAnimType_MAX                 = 3,
};

// Enum OPP.EArmWreslingTableState
// NumValues: 0x0005
enum class EArmWreslingTableState : uint8
{
	WaitingForPlayers                        = 0,
	MatchIntro                               = 1,
	MatchInProgress                          = 2,
	MatchOutro                               = 3,
	EArmWreslingTableState_MAX               = 4,
};

// Enum OPP.EMusicEventType
// NumValues: 0x0005
enum class EMusicEventType : uint8
{
	MusicCommand                             = 0,
	PostPlayEvent                            = 1,
	PostStopEvent                            = 2,
	SingleShotTrackEnded                     = 3,
	EMusicEventType_MAX                      = 4,
};

// Enum OPP.EAudioEventSource
// NumValues: 0x0006
enum class EAudioEventSource : uint8
{
	None                                     = 0,
	Generic                                  = 1,
	OldBlueprintNotify                       = 2,
	AnimNotify                               = 3,
	VONotify                                 = 4,
	EAudioEventSource_MAX                    = 5,
};

// Enum OPP.EEmitterUpdateDetail
// NumValues: 0x0006
enum class EEmitterUpdateDetail : uint8
{
	Irrelevant                               = 0,
	VeryLow                                  = 1,
	Low                                      = 2,
	Normal                                   = 3,
	High                                     = 4,
	EEmitterUpdateDetail_MAX                 = 5,
};

// Enum OPP.EGameModeTestAction
// NumValues: 0x0009
enum class EGameModeTestAction : uint8
{
	None                                     = 0,
	SitInChair                               = 1,
	StageReady                               = 2,
	TeleportToSASExit                        = 3,
	CheatCompleteStage                       = 4,
	TeleportToStageExit                      = 5,
	CompleteStage                            = 6,
	ReturnToLobby                            = 7,
	EGameModeTestAction_MAX                  = 8,
};

// Enum OPP.EBackgroundDoorState
// NumValues: 0x0003
enum class EBackgroundDoorState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	EBackgroundDoorState_MAX                 = 2,
};

// Enum OPP.ECoordinatorExecutionType
// NumValues: 0x0007
enum class ECoordinatorExecutionType : uint8
{
	Unspecified                              = 0,
	OnStageStarted                           = 1,
	GroupConcurrent                          = 2,
	GroupSpecific                            = 4,
	GroupNext                                = 8,
	MainObjective                            = 16,
	ECoordinatorExecutionType_MAX            = 17,
};

// Enum OPP.EObjectiveConfinesType
// NumValues: 0x0004
enum class EObjectiveConfinesType : uint8
{
	Unspecified                              = 0,
	NotConfining                             = 1,
	Confining                                = 2,
	EObjectiveConfinesType_MAX               = 3,
};

// Enum OPP.EMinorObjectiveEffetOnMajor
// NumValues: 0x0005
enum class EMinorObjectiveEffetOnMajor : uint8
{
	None                                     = 0,
	CloseMajorPrimaryActorRoom               = 1,
	DelayMajorReadyFeedbackOnMinorCompleted  = 2,
	DelayMajorEndingOnMinorCompleted         = 3,
	EMinorObjectiveEffetOnMajor_MAX          = 4,
};

// Enum OPP.EObjectiveCoordinatorPopulatePriority
// NumValues: 0x000A
enum class EObjectiveCoordinatorPopulatePriority : uint8
{
	Rails                                    = 0,
	PreDoorRandomization                     = 1,
	Highest                                  = 2,
	VeryHigh                                 = 3,
	High                                     = 4,
	Normal                                   = 5,
	Low                                      = 6,
	VeryLow                                  = 7,
	Lowest                                   = 8,
	EObjectiveCoordinatorPopulatePriority_MAX = 9,
};

// Enum OPP.EBattlePassItemAvailability
// NumValues: 0x0007
enum class EBattlePassItemAvailability : uint8
{
	Locked                                   = 0,
	Locked_RequiresPreviousPages             = 1,
	Locked_RequiresCurrentPageItems          = 2,
	Acquired                                 = 3,
	Available                                = 4,
	CannotAfford                             = 5,
	EBattlePassItemAvailability_MAX          = 6,
};

// Enum OPP.EBattlePassAvailability
// NumValues: 0x0005
enum class EBattlePassAvailability : uint8
{
	Locked                                   = 0,
	Acquired                                 = 1,
	Available                                = 2,
	CannotAfford                             = 3,
	EBattlePassAvailability_MAX              = 4,
};

// Enum OPP.EBlockableState
// NumValues: 0x0005
enum class EBlockableState : uint8
{
	Unknown                                  = 0,
	Opened                                   = 1,
	PermanentlyBlocked                       = 2,
	TemporaryBlocked                         = 3,
	EBlockableState_MAX                      = 4,
};

// Enum OPP.EBlockableLinkType
// NumValues: 0x0004
enum class EBlockableLinkType : uint8
{
	MaximumBlockedCount                      = 0,
	MinimunUnblockedCount                    = 1,
	AlsoBlock                                = 2,
	EBlockableLinkType_MAX                   = 3,
};

// Enum OPP.EPlayerCollisionType
// NumValues: 0x0003
enum class EPlayerCollisionType : uint8
{
	Normal                                   = 0,
	FallingOnly                              = 1,
	EPlayerCollisionType_MAX                 = 2,
};

// Enum OPP.EBoolCommandResult
// NumValues: 0x0003
enum class EBoolCommandResult : uint8
{
	Passed                                   = 0,
	Failed                                   = 1,
	EBoolCommandResult_MAX                   = 2,
};

// Enum OPP.ERandomSwitch10
// NumValues: 0x000B
enum class ERandomSwitch10 : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	Option3                                  = 2,
	Option4                                  = 3,
	Option5                                  = 4,
	Option6                                  = 5,
	Option7                                  = 6,
	Option8                                  = 7,
	Option9                                  = 8,
	Option10                                 = 9,
	ERandomSwitch10_MAX                      = 10,
};

// Enum OPP.ERandomSwitch5
// NumValues: 0x0006
enum class ERandomSwitch5 : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	Option3                                  = 2,
	Option4                                  = 3,
	Option5                                  = 4,
	ERandomSwitch5_MAX                       = 5,
};

// Enum OPP.ERandomSwitch4
// NumValues: 0x0005
enum class ERandomSwitch4 : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	Option3                                  = 2,
	Option4                                  = 3,
	ERandomSwitch4_MAX                       = 4,
};

// Enum OPP.ERandomSwitch3
// NumValues: 0x0004
enum class ERandomSwitch3 : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	Option3                                  = 2,
	ERandomSwitch3_MAX                       = 3,
};

// Enum OPP.ERandomSwitch2
// NumValues: 0x0003
enum class ERandomSwitch2 : uint8
{
	Option1                                  = 0,
	Option2                                  = 1,
	ERandomSwitch2_MAX                       = 2,
};

// Enum OPP.EAISpawnSource
// NumValues: 0x0008
enum class EAISpawnSource : uint8
{
	InitialDirectorSpawn                     = 0,
	SpawnWave                                = 1,
	SummonedByAIDirector                     = 2,
	AlwaysSpawn                              = 3,
	RandomManager                            = 4,
	External                                 = 5,
	FromLimbo                                = 6,
	EAISpawnSource_MAX                       = 7,
};

// Enum OPP.EAIDebugErrorFlags
// NumValues: 0x0005
enum class EAIDebugErrorFlags : uint16
{
	TargetPlayerUnreacheable                 = 1,
	DestUnreacheable                         = 2,
	DestNotOnNavmesh                         = 4,
	NotOnNavmesh                             = 8,
	EAIDebugErrorFlags_MAX                   = 9,
};

// Enum OPP.EAIDebugConfigFlags
// NumValues: 0x000A
enum class EAIDebugConfigFlags : uint16
{
	IgnoringPlayers                          = 1,
	Neutral                                  = 2,
	AlwaysChase                              = 16,
	CanChase                                 = 32,
	CanSeePlayers                            = 64,
	CanHearPlayers                           = 128,
	CanInvestigate                           = 256,
	CanBeDisturbed                           = 512,
	CanAttack                                = 1024,
	EAIDebugConfigFlags_MAX                  = 1025,
};

// Enum OPP.ERotationMode
// NumValues: 0x0004
enum class ERotationMode : uint8
{
	FaceVelocity                             = 0,
	FaceTarget                               = 1,
	Explicit                                 = 2,
	ERotationMode_MAX                        = 3,
};

// Enum OPP.EMoveFailedReason
// NumValues: 0x0006
enum class EMoveFailedReason : uint8
{
	Unknown                                  = 0,
	AINotOnNavMesh                           = 1,
	TargetNotOnNavMesh                       = 2,
	NoPathToTarget                           = 3,
	Aborted                                  = 4,
	EMoveFailedReason_MAX                    = 5,
};

// Enum OPP.EMoveType
// NumValues: 0x0004
enum class EMoveType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	Actor                                    = 2,
	EMoveType_MAX                            = 3,
};

// Enum OPP.EMoveResult
// NumValues: 0x0005
enum class EMoveResult : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Failed                                   = 2,
	Interrupted                              = 3,
	EMoveResult_MAX                          = 4,
};

// Enum OPP.EMoveStatus
// NumValues: 0x0005
enum class EMoveStatus : uint8
{
	Idle                                     = 0,
	Waiting                                  = 1,
	Paused                                   = 2,
	Moving                                   = 3,
	EMoveStatus_MAX                          = 4,
};

// Enum OPP.EAIScriptedState
// NumValues: 0x0008
enum class EAIScriptedState : uint8
{
	None                                     = 0,
	MovingToAnchor                           = 1,
	LoopingIdle                              = 2,
	SingleShotAnim                           = 3,
	ScriptedAnimStation                      = 4,
	ScriptedAttack                           = 5,
	ScriptedStartled                         = 6,
	EAIScriptedState_MAX                     = 7,
};

// Enum OPP.ENPCMonsterClosetInteractionState
// NumValues: 0x0007
enum class ENPCMonsterClosetInteractionState : uint8
{
	None                                     = 0,
	SpawnWarning                             = 1,
	DoorOpeningRequested                     = 2,
	NPCInMovement                            = 3,
	UnspawnWaitingForNav                     = 4,
	UnspawnWaitingForDestroy                 = 5,
	ENPCMonsterClosetInteractionState_MAX    = 6,
};

// Enum OPP.ESneakState
// NumValues: 0x0003
enum class ESneakState : uint8
{
	GotoLocation                             = 0,
	LookAround                               = 1,
	ESneakState_MAX                          = 2,
};

// Enum OPP.EPlayerAvoidanceState
// NumValues: 0x0004
enum class EPlayerAvoidanceState : uint8
{
	Avoidance                                = 0,
	LastSegment                              = 1,
	CheckSurroundings                        = 2,
	EPlayerAvoidanceState_MAX                = 3,
};

// Enum OPP.EPlayerAvoidanceType
// NumValues: 0x0003
enum class EPlayerAvoidanceType : uint8
{
	RoomPathing                              = 0,
	NavDestination                           = 1,
	EPlayerAvoidanceType_MAX                 = 2,
};

// Enum OPP.EImperativeActionType
// NumValues: 0x0004
enum class EImperativeActionType : uint8
{
	None                                     = 0,
	Radio                                    = 1,
	Generator                                = 2,
	EImperativeActionType_MAX                = 3,
};

// Enum OPP.EWaypointValidityStatus
// NumValues: 0x0007
enum class EWaypointValidityStatus : uint8
{
	Valid                                    = 0,
	Disabled                                 = 1,
	CurrentPoint                             = 2,
	Unavailable                              = 3,
	FilteredOut                              = 4,
	Unreacheable                             = 5,
	EWaypointValidityStatus_MAX              = 6,
};

// Enum OPP.EPatrolType
// NumValues: 0x0006
enum class EPatrolType : uint8
{
	None                                     = 0,
	Route                                    = 1,
	Point                                    = 2,
	SingleWaypoint                           = 3,
	AmbientActivity                          = 4,
	EPatrolType_MAX                          = 5,
};

// Enum OPP.EBreakableObstacleAnimStyle
// NumValues: 0x0003
enum class EBreakableObstacleAnimStyle : uint8
{
	WoodPlanks                               = 0,
	Window                                   = 1,
	EBreakableObstacleAnimStyle_MAX          = 2,
};

// Enum OPP.EBreakableLedgeMarkerBehavior
// NumValues: 0x0004
enum class EBreakableLedgeMarkerBehavior : uint8
{
	None                                     = 0,
	EnableOnBreak                            = 1,
	DisableOnBreak                           = 2,
	EBreakableLedgeMarkerBehavior_MAX        = 3,
};

// Enum OPP.EWindowJumpOverType
// NumValues: 0x0005
enum class EWindowJumpOverType : uint8
{
	None                                     = 0,
	WalkToLand                               = 1,
	RunToLand                                = 2,
	RunToFall                                = 3,
	EWindowJumpOverType_MAX                  = 4,
};

// Enum OPP.EVariatorAvailabilityType
// NumValues: 0x0004
enum class EVariatorAvailabilityType : uint8
{
	Available                                = 0,
	Unavailable_Trial                        = 1,
	Unavailable_Variator                     = 2,
	EVariatorAvailabilityType_MAX            = 3,
};

// Enum OPP.ESortingType
// NumValues: 0x0003
enum class ESortingType : uint8
{
	RarityDescending                         = 0,
	RarityAscending                          = 1,
	ESortingType_MAX                         = 2,
};

// Enum OPP.ECustomizationInteractionType
// NumValues: 0x000A
enum class ECustomizationInteractionType : uint8
{
	ShopNone                                 = 0,
	ShopBuy                                  = 1,
	ShopNoneCantAfford                       = 2,
	LockerEquip                              = 3,
	LockerNoneForSale                        = 4,
	LockerNoneCantAfford                     = 5,
	NoneLocked                               = 6,
	LockerNone                               = 7,
	ViewDLCContentPack                       = 8,
	ECustomizationInteractionType_MAX        = 9,
};

// Enum OPP.EDebugWorldOctreeObjectType
// NumValues: 0x0004
enum class EDebugWorldOctreeObjectType : uint8
{
	LedgeMarker                              = 0,
	InteractionZoneComponent                 = 1,
	Triggerable                              = 2,
	EDebugWorldOctreeObjectType_MAX          = 3,
};

// Enum OPP.EPerformActionDebugType
// NumValues: 0x0007
enum class EPerformActionDebugType : uint8
{
	HolsterWeapon                            = 0,
	ShootWeapon                              = 1,
	ThrowWeapon                              = 2,
	GroupAttack                              = 3,
	InduceIllness                            = 4,
	ReactToIllness                           = 5,
	EPerformActionDebugType_MAX              = 6,
};

// Enum OPP.EDisplayDebugModifier
// NumValues: 0x0006
enum class EDisplayDebugModifier : uint8
{
	None                                     = 0,
	AnimInstance                             = 1,
	AIConfig                                 = 2,
	AIPointSelection                         = 3,
	VO                                       = 4,
	EDisplayDebugModifier_MAX                = 5,
};

// Enum OPP.EFullScreenDebugInfoType
// NumValues: 0x002E
enum class EFullScreenDebugInfoType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	AI                                       = 2,
	PlayerAndAI                              = 3,
	Physics                                  = 4,
	TQ                                       = 5,
	ActorInView                              = 6,
	VO                                       = 7,
	SoundEnvironment                         = 8,
	AudioEvents                              = 9,
	Music                                    = 10,
	RTPC                                     = 11,
	Streaming                                = 12,
	Online                                   = 13,
	Overseer                                 = 14,
	WhoWasWhere                              = 15,
	Objectives                               = 16,
	GameplayAttributes                       = 17,
	PlayerCustomization                      = 18,
	ItemSpawning                             = 19,
	Variators                                = 20,
	AnimUsage                                = 21,
	NPCRandomization                         = 22,
	MovementNetwork                          = 23,
	BackgroundCharacters                     = 24,
	Rooms                                    = 25,
	DoorRandomization                        = 26,
	BlockableRandomization                   = 27,
	HidespotRandomization                    = 28,
	SpecialRooms                             = 29,
	DarknessDetection                        = 30,
	VoiceChat                                = 31,
	PlayerStats                              = 32,
	GameplayRandomization                    = 33,
	SwitchMatchRandomization                 = 34,
	QuickGraphs                              = 35,
	ChunkInstall                             = 36,
	ModifiedOptions                          = 37,
	UI                                       = 38,
	SafeZone                                 = 39,
	LobbyGameChess                           = 40,
	Inputs                                   = 41,
	LobbyGame                                = 42,
	Decoder                                  = 43,
	InWorldIcons                             = 44,
	EFullScreenDebugInfoType_MAX             = 45,
};

// Enum OPP.ECollisionDebugViewType
// NumValues: 0x0005
enum class ECollisionDebugViewType : uint8
{
	None                                     = 0,
	SimpleLineDraw                           = 1,
	SimpleMeshDraw                           = 2,
	ComplexMeshDraw                          = 3,
	ECollisionDebugViewType_MAX              = 4,
};

// Enum OPP.EChessGamePlayerAnimState
// NumValues: 0x0008
enum class EChessGamePlayerAnimState : uint8
{
	WaitForOpponent                          = 0,
	WaitForTurn                              = 1,
	PlayTurn                                 = 2,
	RevertMove                               = 3,
	MovePiece                                = 4,
	TapChessClock                            = 5,
	EndRoundReaction                         = 6,
	EChessGamePlayerAnimState_MAX            = 7,
};

// Enum OPP.EChessActionType
// NumValues: 0x0007
enum class EChessActionType : uint8
{
	Invalid                                  = 0,
	Move                                     = 1,
	Take                                     = 2,
	EnPassant                                = 3,
	SmallCastle                              = 4,
	LongCastle                               = 5,
	EChessActionType_MAX                     = 6,
};

// Enum OPP.ERBChunkRuleMode
// NumValues: 0x0003
enum class ERBChunkRuleMode : uint8
{
	Include                                  = 0,
	Exclude                                  = 1,
	ERBChunkRuleMode_MAX                     = 2,
};

// Enum OPP.ECollectibleType
// NumValues: 0x0003
enum class ECollectibleType : uint8
{
	Document                                 = 0,
	Photo                                    = 1,
	ECollectibleType_MAX                     = 2,
};

// Enum OPP.EContainerPopulatedState
// NumValues: 0x0004
enum class EContainerPopulatedState : uint8
{
	Unpopulated                              = 0,
	Used                                     = 1,
	Empty                                    = 2,
	EContainerPopulatedState_MAX             = 3,
};

// Enum OPP.EContainerSpawningType
// NumValues: 0x0006
enum class EContainerSpawningType : uint8
{
	StageOnly                                = 0,
	RewardOnly                               = 1,
	StageAndReward                           = 2,
	PuzzleRoom                               = 3,
	ReviveStation                            = 4,
	EContainerSpawningType_MAX               = 5,
};

// Enum OPP.EContainerSpawnLocationPriority
// NumValues: 0x0004
enum class EContainerSpawnLocationPriority : uint8
{
	Low                                      = 0,
	Normal                                   = 1,
	High                                     = 2,
	EContainerSpawnLocationPriority_MAX      = 3,
};

// Enum OPP.EPlayerBreathType
// NumValues: 0x0005
enum class EPlayerBreathType : uint8
{
	Run                                      = 0,
	Exhausted                                = 1,
	Pain                                     = 2,
	Crawl                                    = 3,
	EPlayerBreathType_MAX                    = 4,
};

// Enum OPP.ESpectatorMode
// NumValues: 0x0006
enum class ESpectatorMode : uint8
{
	RequestedByPlayer                        = 0,
	PlayingUnavailable                       = 1,
	PlayerDead                               = 2,
	Cheat                                    = 3,
	Replay                                   = 4,
	ESpectatorMode_MAX                       = 5,
};

// Enum OPP.EDeadRepulsionType
// NumValues: 0x0003
enum class EDeadRepulsionType : uint8
{
	Box                                      = 0,
	Spline                                   = 1,
	EDeadRepulsionType_MAX                   = 2,
};

// Enum OPP.EDecoderProximityType
// NumValues: 0x0008
enum class EDecoderProximityType : uint8
{
	Far                                      = 0,
	Proximity_Level1                         = 1,
	Proximity_Level2                         = 2,
	OnTarget                                 = 3,
	Decoded_Level1                           = 4,
	Decoded_Level2                           = 5,
	Decoded_Level3                           = 6,
	EDecoderProximityType_MAX                = 7,
};

// Enum OPP.EDestructibleActionType
// NumValues: 0x0003
enum class EDestructibleActionType : uint8
{
	AddDisplacement                          = 0,
	BreakInSphere                            = 1,
	EDestructibleActionType_MAX              = 2,
};

// Enum OPP.EDisplayMessageViewMode
// NumValues: 0x0004
enum class EDisplayMessageViewMode : uint8
{
	WithOrWithoutNV                          = 0,
	OnlyNV                                   = 1,
	OnlyWithoutNV                            = 2,
	EDisplayMessageViewMode_MAX              = 3,
};

// Enum OPP.EDisplayMessagePriority
// NumValues: 0x0007
enum class EDisplayMessagePriority : uint8
{
	None                                     = 0,
	Low                                      = 1,
	BelowNormal                              = 2,
	Normal                                   = 3,
	AboveNormal                              = 4,
	High                                     = 5,
	EDisplayMessagePriority_MAX              = 6,
};

// Enum OPP.EDoorVersion
// NumValues: 0x0003
enum class EDoorVersion : uint8
{
	Uninitialized                            = 0,
	NewPadLockableFlag                       = 1,
	MAX                                      = 2,
};

// Enum OPP.EDoorCollisionType
// NumValues: 0x0004
enum class EDoorCollisionType : uint8
{
	Full                                     = 0,
	Window                                   = 1,
	SeeThrough                               = 2,
	EDoorCollisionType_MAX                   = 3,
};

// Enum OPP.EAudioDoorType
// NumValues: 0x0008
enum class EAudioDoorType : uint8
{
	SW_Door_Wood                             = 0,
	SW_Door_Wood_Window                      = 1,
	SW_Door_MetalSolid                       = 2,
	SW_Door_MetalGate                        = 3,
	SW_Door_MetalFence                       = 4,
	SW_Door_MetalBarricade                   = 5,
	SW_Door_Type_Planks                      = 6,
	SW_Door_MAX                              = 7,
};

// Enum OPP.EDoorRandomization
// NumValues: 0x000B
enum class EDoorRandomization : uint8
{
	Blockable                                = 0,
	ReplaceableFront                         = 1,
	ReplaceableBack                          = 2,
	TrappableFront                           = 3,
	TrappableBack                            = 4,
	Lockable                                 = 5,
	OpenCloseFront                           = 6,
	OpenCloseBack                            = 7,
	RewardRoomDoor                           = 8,
	PadLockable                              = 9,
	EDoorRandomization_MAX                   = 10,
};

// Enum OPP.EDoorLockerRandomAction
// NumValues: 0x0006
enum class EDoorLockerRandomAction : uint8
{
	UnlockDoor                               = 0,
	LockDoor                                 = 1,
	UnblockDoor                              = 2,
	BlockDoor                                = 3,
	RemoveLock                               = 4,
	EDoorLockerRandomAction_MAX              = 5,
};

// Enum OPP.EMapCheckType
// NumValues: 0x0006
enum class EMapCheckType : uint8
{
	EditorRoaming                            = 0,
	EditorSelected                           = 1,
	EditorErrored                            = 2,
	EditorErroredSelected                    = 3,
	BuildMapCheck                            = 4,
	EMapCheckType_MAX                        = 5,
};

// Enum OPP.EElectricFloorTrapState
// NumValues: 0x0009
enum class EElectricFloorTrapState : uint8
{
	Hidden                                   = 0,
	ActiveInitialization                     = 1,
	ActiveOff                                = 2,
	ActiveWarning                            = 3,
	ActiveOn                                 = 4,
	ActiveTriggered                          = 5,
	Inactive                                 = 6,
	Broken                                   = 7,
	EElectricFloorTrapState_MAX              = 8,
};

// Enum OPP.EElectrocutionSwitchState
// NumValues: 0x0007
enum class EElectrocutionSwitchState : uint8
{
	Idle                                     = 0,
	Intro                                    = 1,
	Starting                                 = 2,
	Active                                   = 3,
	ActiveOverloading                        = 4,
	Overloaded                               = 5,
	EElectrocutionSwitchState_MAX            = 6,
};

// Enum OPP.EExplosiveWireTrapState
// NumValues: 0x0006
enum class EExplosiveWireTrapState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	DisabledTemporary                        = 2,
	Broken                                   = 3,
	Triggered                                = 4,
	EExplosiveWireTrapState_MAX              = 5,
};

// Enum OPP.ENPCSpecificGesture
// NumValues: 0x000E
enum class ENPCSpecificGesture : uint8
{
	Default                                  = 0,
	Attack                                   = 1,
	Grab                                     = 2,
	Taunt                                    = 3,
	Murder                                   = 4,
	Struggle                                 = 5,
	HitReact_Light                           = 6,
	HitReact_Medium                          = 7,
	HitReact_Heavy                           = 8,
	RigReact_BlindPaint                      = 9,
	RigReact_Stun                            = 10,
	Startle                                  = 11,
	Puking                                   = 12,
	ENPCSpecificGesture_MAX                  = 13,
};

// Enum OPP.ENPCBaseEmotion
// NumValues: 0x0005
enum class ENPCBaseEmotion : uint8
{
	Relaxed                                  = 0,
	Suspicious                               = 1,
	Alerted                                  = 2,
	Chase                                    = 3,
	ENPCBaseEmotion_MAX                      = 4,
};

// Enum OPP.EPlayerInjuryLevel
// NumValues: 0x0005
enum class EPlayerInjuryLevel : uint8
{
	NotInjured                               = 0,
	SlightlyInjured                          = 1,
	ModeratelyInjured                        = 2,
	HighlyInjured                            = 3,
	EPlayerInjuryLevel_MAX                   = 4,
};

// Enum OPP.EPlayerSpecificGesture
// NumValues: 0x0010
enum class EPlayerSpecificGesture : uint8
{
	Default                                  = 0,
	Attack                                   = 1,
	Grab                                     = 2,
	Taunt                                    = 3,
	Murder                                   = 4,
	SAS                                      = 5,
	Struggle                                 = 6,
	Downed                                   = 7,
	HitReact_Light                           = 8,
	HitReact_Medium                          = 9,
	HitReact_Heavy                           = 10,
	RigReact_BlindPaint                      = 11,
	RigReact_Stun                            = 12,
	ArmWrestling_Struggle                    = 13,
	Startle                                  = 14,
	EPlayerSpecificGesture_MAX               = 15,
};

// Enum OPP.EGridType
// NumValues: 0x0003
enum class EGridType : uint8
{
	Relative                                 = 0,
	World                                    = 1,
	EGridType_MAX                            = 2,
};

// Enum OPP.EGlobalAIEvaluationType
// NumValues: 0x0003
enum class EGlobalAIEvaluationType : uint8
{
	SingleBot                                = 0,
	AnyBot                                   = 1,
	EGlobalAIEvaluationType_MAX              = 2,
};

// Enum OPP.EMainMenuButton
// NumValues: 0x0006
enum class EMainMenuButton : uint8
{
	EnterLobby                               = 0,
	ReplayTutorial                           = 1,
	Options                                  = 2,
	Credits                                  = 3,
	Quit                                     = 4,
	EMainMenuButton_MAX                      = 5,
};

// Enum OPP.EGameplayTriggerType
// NumValues: 0x0003
enum class EGameplayTriggerType : uint8
{
	Pushable                                 = 0,
	NPC                                      = 1,
	EGameplayTriggerType_MAX                 = 2,
};

// Enum OPP.ETriggerType
// NumValues: 0x0003
enum class ETriggerType : uint8
{
	Trigger                                  = 0,
	Untrigger                                = 1,
	ETriggerType_MAX                         = 2,
};

// Enum OPP.ECustomizationCategory
// NumValues: 0x0006
enum class ECustomizationCategory : uint8
{
	Appearance                               = 0,
	Identification                           = 1,
	Behaviour                                = 2,
	Count                                    = 3,
	None                                     = 4,
	ECustomizationCategory_MAX               = 5,
};

// Enum OPP.EOptionsErrorCode
// NumValues: 0x0006
enum class EOptionsErrorCode : uint8
{
	Default                                  = 0,
	NvidiaCard                               = 1,
	RaytracingReboot                         = 2,
	MainMenuOnly                             = 3,
	None                                     = 4,
	EOptionsErrorCode_MAX                    = 5,
};

// Enum OPP.EOptionsMenuOption
// NumValues: 0x0058
enum class EOptionsMenuOption : uint8
{
	None                                     = 0,
	WindowMode                               = 1,
	Resolution                               = 2,
	ResolutionScale                          = 3,
	VSync                                    = 4,
	RefreshRate                              = 5,
	DisplayDevice                            = 6,
	FrameLimit                               = 7,
	CalibrationScreen                        = 8,
	Brightness                               = 9,
	HDREnabled                               = 10,
	HDRPeakBrightness                        = 11,
	HDRPaperwhite                            = 12,
	HDRUserInterfaceBrightness               = 13,
	QualityPreset                            = 14,
	ViewDistance                             = 15,
	Shadows                                  = 16,
	AntiAliasing                             = 17,
	Texture                                  = 18,
	Effects                                  = 19,
	Reflections                              = 20,
	Volumetrics                              = 21,
	AutoDetectQuality                        = 22,
	Direct3DVersion                          = 23,
	MotionBlur                               = 24,
	DLSS                                     = 25,
	FSR2                                     = 26,
	EnableRT                                 = 27,
	RTShadows                                = 28,
	RTReflections                            = 29,
	ConsolePerfMode                          = 30,
	MasterVolume                             = 31,
	MusicVolume                              = 32,
	EffectsVolume                            = 33,
	EnableVoiceChat                          = 34,
	VoiceChatPartyOnly                       = 35,
	VoiceChatInputDevice                     = 36,
	VoiceChatVolume                          = 37,
	MicrophoneVolume                         = 38,
	PushToTalk                               = 39,
	EnableRadio                              = 40,
	VoiceActivityDetectorAuto                = 41,
	VoiceActivityDetectorHangover            = 42,
	VoiceActivityDetectorSensitivity         = 43,
	VoiceActivityDetectorNoiseFloor          = 44,
	MicTest                                  = 45,
	LookSensitivityMouse                     = 46,
	LookSensitivityControllerYaw             = 47,
	LookSensitivityControllerPitch           = 48,
	ToggleRun                                = 49,
	AutoHideItemInHand                       = 50,
	InputBindings                            = 51,
	InvertXAxis                              = 52,
	InvertYAxis                              = 53,
	GamepadControlScheme                     = 54,
	ToggleInteractGamepad                    = 55,
	ToggleInteractKBM                        = 56,
	ForceFeedbackEnabled                     = 57,
	ResetMenuTutorials                       = 58,
	ResetNonMenuTutorials                    = 59,
	Crossplay                                = 60,
	Region                                   = 61,
	InterfacePreset                          = 62,
	HealthDisplay                            = 63,
	StaminaDisplay                           = 64,
	SanityDisplay                            = 65,
	NoiseDisplay                             = 66,
	DarknessDisplay                          = 67,
	InventoryDisplay                         = 68,
	ObjectiveDisplay                         = 69,
	SecondaryObjectiveDisplay                = 70,
	CrosshairDisplay                         = 71,
	TeammateStatusHUDDisplay                 = 72,
	TeammateStatusInWorldDisplay             = 73,
	TeammateStatusOutsideViewDisplay         = 74,
	VoiceChatOverlayDisplay                  = 75,
	FriendsOnlineStatusNotifications         = 76,
	AllowFriendRequestNotifications          = 77,
	AllowPartyInviteNotifications            = 78,
	AudioLanguage                            = 79,
	TextLanguage                             = 80,
	SubtitlesEnabled                         = 81,
	SubtitlesLanguage                        = 82,
	SubtitlesFontSize                        = 83,
	SubtitlesBackground                      = 84,
	HeadBobbingEnabled                       = 85,
	TinnitusFilter                           = 86,
	Max                                      = 87,
};

// Enum OPP.ECustomGhostFinishState
// NumValues: 0x0003
enum class ECustomGhostFinishState : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
	ECustomGhostFinishState_MAX              = 2,
};

// Enum OPP.EHackQuadrantState
// NumValues: 0x0004
enum class EHackQuadrantState : uint8
{
	Failure                                  = 0,
	Neutral                                  = 1,
	Success                                  = 2,
	EHackQuadrantState_MAX                   = 3,
};

// Enum OPP.EHidespotVerticalDirection
// NumValues: 0x0009
enum class EHidespotVerticalDirection : uint8
{
	Forward                                  = 0,
	ForwardRight                             = 1,
	Right                                    = 2,
	BackwardRight                            = 3,
	Backward                                 = 4,
	BackwardLeft                             = 5,
	Left                                     = 6,
	ForwardLeft                              = 7,
	EHidespotVerticalDirection_MAX           = 8,
};

// Enum OPP.EImpactTriggerableShape
// NumValues: 0x0003
enum class EImpactTriggerableShape : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	EImpactTriggerableShape_MAX              = 2,
};

// Enum OPP.EAdjustmentType
// NumValues: 0x0007
enum class EAdjustmentType : uint8
{
	None                                     = 0,
	LocationAndRotation                      = 1,
	LocationOnly                             = 2,
	RotationOnly                             = 3,
	LookAtWithDistance                       = 4,
	LookAtOnPlace                            = 5,
	EAdjustmentType_MAX                      = 6,
};

// Enum OPP.EInteractionPriority
// NumValues: 0x0007
enum class EInteractionPriority : uint8
{
	None                                     = 0,
	Low                                      = 1,
	BelowNormal                              = 2,
	Normal                                   = 3,
	AboveNormal                              = 4,
	High                                     = 5,
	EInteractionPriority_MAX                 = 6,
};

// Enum OPP.EInvestigationRotationAlignBehavior
// NumValues: 0x0007
enum class EInvestigationRotationAlignBehavior : uint8
{
	None                                     = 0,
	LookAtThisPoint                          = 1,
	LookAtTarget                             = 2,
	LookInDirection                          = 3,
	LookInAxisEitherDirection                = 4,
	LookInPlayerDirection                    = 5,
	EInvestigationRotationAlignBehavior_MAX  = 6,
};

// Enum OPP.EItemProgressionCategory
// NumValues: 0x000A
enum class EItemProgressionCategory : uint8
{
	None                                     = 0,
	ActiveSkill                              = 1,
	ActiveSkillUpgrade                       = 2,
	Perk                                     = 3,
	CharacterUpgrade                         = 4,
	CustomizationOption                      = 5,
	CellItem                                 = 6,
	CurrencyPack                             = 7,
	Count                                    = 8,
	EItemProgressionCategory_MAX             = 9,
};

// Enum OPP.EItemSpawningManagerState
// NumValues: 0x0019
enum class EItemSpawningManagerState : uint8
{
	Unpopulated                              = 0,
	RemoveContainersOutsideTrial             = 1,
	GatherItemRemovingActors                 = 2,
	SetupReviveContainers                    = 3,
	PopulatingReviveContainers               = 4,
	RemoveContainersCloseToObjectives        = 5,
	RemoveContainersCloseToRandomHelpers     = 6,
	RemoveContainersBlockedByHidespot        = 7,
	SortActors                               = 8,
	SetupRewardRooms                         = 9,
	PopulatingRewardRooms                    = 10,
	SetupStageContainers                     = 11,
	SetupContainerLocks                      = 12,
	PopulatingMandatoryLockedPrimaryItems    = 13,
	PopulatingLockedPrimaryItems             = 14,
	PopulatingLockedSecondaryItems           = 15,
	PopulatingStageContainers                = 16,
	SetupContainerTraps                      = 17,
	PopulatingContainerTraps                 = 18,
	SetupCollectableContainers               = 19,
	PopulatingCollectableContainers          = 20,
	SetupReplacedContainers                  = 21,
	PopulatingReplacedContainers             = 22,
	Populated                                = 23,
	EItemSpawningManagerState_MAX            = 24,
};

// Enum OPP.EItemLockType
// NumValues: 0x0006
enum class EItemLockType : uint8
{
	AllowedSecondaryItem                     = 0,
	CannotBeLocked                           = 1,
	PrimaryAndSecondaryItem                  = 2,
	PrimaryItemOnly                          = 3,
	MandatoryPrimaryItem                     = 4,
	EItemLockType_MAX                        = 5,
};

// Enum OPP.EJumpScareFlags
// NumValues: 0x0009
enum class EJumpScareFlags : uint8
{
	InvalidIfRunning                         = 0,
	InvalidIfWalking                         = 1,
	InvalidIfCrouched                        = 2,
	InvalidIfChased                          = 3,
	InvalidIfKnockedDown                     = 4,
	InvalidIfInDifferentRoom                 = 5,
	TriggerOnLineOfSight                     = 6,
	UseRoomVolume                            = 7,
	EJumpScareFlags_MAX                      = 8,
};

// Enum OPP.EKeyLockedRoomFinalRoomType
// NumValues: 0x0004
enum class EKeyLockedRoomFinalRoomType : uint8
{
	NotSet                                   = 0,
	FinalRoom                                = 1,
	NotFinalRoom                             = 2,
	EKeyLockedRoomFinalRoomType_MAX          = 3,
};

// Enum OPP.ELeashType
// NumValues: 0x0003
enum class ELeashType : uint8
{
	CantLeave                                = 0,
	CantEnter                                = 1,
	ELeashType_MAX                           = 2,
};

// Enum OPP.ELedgeNarrowType
// NumValues: 0x0004
enum class ELedgeNarrowType : uint8
{
	Unspecified                              = 0,
	NonNarrow                                = 1,
	Narrow                                   = 2,
	ELedgeNarrowType_MAX                     = 3,
};

// Enum OPP.ELedgeCoopMoveType
// NumValues: 0x0005
enum class ELedgeCoopMoveType : uint8
{
	None                                     = 0,
	CoopWall                                 = 1,
	CoopThrowCatch                           = 2,
	CoopClimbOver                            = 3,
	ELedgeCoopMoveType_MAX                   = 4,
};

// Enum OPP.ELobbyGameEndReason
// NumValues: 0x0005
enum class ELobbyGameEndReason : uint8
{
	Win                                      = 0,
	Timeout                                  = 1,
	Withdraw                                 = 2,
	Tied                                     = 3,
	ELobbyGameEndReason_MAX                  = 4,
};

// Enum OPP.EMuffleLevel
// NumValues: 0x0004
enum class EMuffleLevel : uint8
{
	Off                                      = 0,
	Low                                      = 1,
	High                                     = 2,
	EMuffleLevel_MAX                         = 3,
};

// Enum OPP.ERBMicrophoneTestState
// NumValues: 0x0004
enum class ERBMicrophoneTestState : uint8
{
	Disabled                                 = 0,
	Connecting                               = 1,
	Connected                                = 2,
	ERBMicrophoneTestState_MAX               = 3,
};

// Enum OPP.EMinigameState
// NumValues: 0x0006
enum class EMinigameState : uint8
{
	Deactivated                              = 0,
	ActivatedNotStarted                      = 1,
	ActivatedNotCompleted                    = 2,
	ActivatedPrizeAvailable                  = 3,
	Completed                                = 4,
	EMinigameState_MAX                       = 5,
};

// Enum OPP.EMonsterClosetState
// NumValues: 0x0004
enum class EMonsterClosetState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	Moving                                   = 2,
	EMonsterClosetState_MAX                  = 3,
};

// Enum OPP.EMotionDetectorState
// NumValues: 0x0005
enum class EMotionDetectorState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Alerted                                  = 2,
	Expired                                  = 3,
	EMotionDetectorState_MAX                 = 4,
};

// Enum OPP.ERBSpecialMoveDesyncType
// NumValues: 0x000B
enum class ERBSpecialMoveDesyncType : uint16
{
	None                                     = 0,
	Timestamp                                = 1,
	SpecialMoveIndex                         = 2,
	SpecialMoveType                          = 4,
	LocomotionMoveType                       = 8,
	Interactible                             = 16,
	Stamina                                  = 32,
	Direction                                = 64,
	Location                                 = 128,
	Prediction                               = 256,
	ERBSpecialMoveDesyncType_MAX             = 257,
};

// Enum OPP.ENetworkSyncType
// NumValues: 0x0009
enum class ENetworkSyncType : uint8
{
	ForwardOnce                              = 0,
	BackwardOnce                             = 1,
	PingPong                                 = 2,
	PingPongSine                             = 3,
	ForwardLoop                              = 4,
	BackwardLoop                             = 5,
	Noise                                    = 6,
	RandomTarget                             = 7,
	ENetworkSyncType_MAX                     = 8,
};

// Enum OPP.ENPCInterruptActionType
// NumValues: 0x000F
enum class ENPCInterruptActionType : uint8
{
	None                                     = 0,
	LightBulbExplodeReact                    = 1,
	DoorTrap                                 = 2,
	ThrowableBody                            = 3,
	ThrowableHead                            = 4,
	Shove                                    = 5,
	HealSlowdown                             = 6,
	BlindMine                                = 7,
	ReactToIllness                           = 8,
	AmpHit                                   = 9,
	Amp                                      = 10,
	GoryDeath                                = 11,
	Repulsion                                = 12,
	SmallRepulsion                           = 13,
	ENPCInterruptActionType_MAX              = 14,
};

// Enum OPP.ENPCCustomizationSlot
// NumValues: 0x0007
enum class ENPCCustomizationSlot : uint8
{
	Hair                                     = 0,
	Head                                     = 1,
	Watch                                    = 2,
	UpperBody                                = 3,
	LowerBody                                = 4,
	None                                     = 5,
	ENPCCustomizationSlot_MAX                = 6,
};

// Enum OPP.ESeparatorTubeState
// NumValues: 0x0004
enum class ESeparatorTubeState : uint8
{
	AllClosed                                = 0,
	OpenOutside                              = 1,
	OpenInside                               = 2,
	ESeparatorTubeState_MAX                  = 3,
};

// Enum OPP.ENVState
// NumValues: 0x0004
enum class ENVState : uint8
{
	Off                                      = 0,
	OnPowered                                = 1,
	OnUnPowered                              = 2,
	ENVState_MAX                             = 3,
};

// Enum OPP.ENVSoundType
// NumValues: 0x0006
enum class ENVSoundType : uint8
{
	TurnOn                                   = 0,
	TurnOnLowBattery                         = 1,
	OutOfBattery                             = 2,
	Repowered                                = 3,
	TurnOff                                  = 4,
	ENVSoundType_MAX                         = 5,
};

// Enum OPP.EObjectiveGroupCompletionLogic
// NumValues: 0x0004
enum class EObjectiveGroupCompletionLogic : uint8
{
	AllObjectivesCompleted                   = 0,
	AnyObjectiveCompleted                    = 1,
	SpecificObjectivesCompleted              = 2,
	EObjectiveGroupCompletionLogic_MAX       = 3,
};

// Enum OPP.EOptionsMenuValueType
// NumValues: 0x0007
enum class EOptionsMenuValueType : uint8
{
	None                                     = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Float                                    = 3,
	IntPoint                                 = 4,
	String                                   = 5,
	EOptionsMenuValueType_MAX                = 6,
};

// Enum OPP.EControlSchemeActionType
// NumValues: 0x0017
enum class EControlSchemeActionType : uint8
{
	None                                     = 0,
	Aim                                      = 1,
	UseItem_Throw                            = 2,
	PeekLeft                                 = 3,
	PeekRight                                = 4,
	PeekAnalog                               = 5,
	Run                                      = 6,
	Move                                     = 7,
	Camera                                   = 8,
	Ping_TalkWheel                           = 9,
	InventoryScrollUp                        = 10,
	InventoryScrollDown                      = 11,
	Trade_Drop                               = 12,
	Trade                                    = 13,
	Drop                                     = 14,
	NightVision                              = 15,
	Interact                                 = 16,
	Crouch_Toggle                            = 17,
	Jump                                     = 18,
	Menu                                     = 19,
	Objective                                = 20,
	EquipRig                                 = 21,
	EControlSchemeActionType_MAX             = 22,
};

// Enum OPP.EOptionsTabType
// NumValues: 0x0008
enum class EOptionsTabType : uint8
{
	None                                     = 0,
	General                                  = 1,
	Language                                 = 2,
	Controls                                 = 3,
	Graphics                                 = 4,
	Audio                                    = 5,
	Network                                  = 6,
	EOptionsTabType_MAX                      = 7,
};

// Enum OPP.EPawnSearchFlags
// NumValues: 0x000B
enum class EPawnSearchFlags : uint16
{
	None                                     = 0,
	IgnoreBots                               = 1,
	IgnorePlayers                            = 2,
	FavorBots                                = 4,
	FavorPlayers                             = 8,
	PrioritizeBots                           = 16,
	PrioritizePlayers                        = 32,
	IgnoreSpectre                            = 64,
	IgnoreAdversarialImposters               = 128,
	IgnoreAdversarialReagents                = 256,
	EPawnSearchFlags_MAX                     = 257,
};

// Enum OPP.ETraversalLedgeAngleType
// NumValues: 0x0004
enum class ETraversalLedgeAngleType : uint8
{
	Flat                                     = 0,
	Angled45Right                            = 1,
	Angled45Left                             = 2,
	ETraversalLedgeAngleType_MAX             = 3,
};

// Enum OPP.EDizzinessType
// NumValues: 0x0005
enum class EDizzinessType : uint8
{
	Unspecified                              = 0,
	Psychosis                                = 1,
	Screamer                                 = 2,
	Scripted                                 = 3,
	EDizzinessType_MAX                       = 4,
};

// Enum OPP.ELandOntoLedgeType
// NumValues: 0x0005
enum class ELandOntoLedgeType : uint8
{
	Land25                                   = 0,
	RunJump25                                = 1,
	Land50                                   = 2,
	Land100                                  = 3,
	ELandOntoLedgeType_MAX                   = 4,
};

// Enum OPP.ECantShoveReason
// NumValues: 0x0002
enum class ECantShoveReason : uint8
{
	Cooldown                                 = 0,
	ECantShoveReason_MAX                     = 1,
};

// Enum OPP.EShowItemCategory
// NumValues: 0x0006
enum class EShowItemCategory : uint8
{
	Fist                                     = 0,
	SmallWeapon                              = 1,
	HealthItem                               = 2,
	Utility                                  = 3,
	All                                      = 4,
	EShowItemCategory_MAX                    = 5,
};

// Enum OPP.ECameraShakeType
// NumValues: 0x000A
enum class ECameraShakeType : uint8
{
	Gameplay                                 = 0,
	Scripted                                 = 1,
	Psychosis                                = 2,
	Pushable                                 = 3,
	Sliding                                  = 4,
	GruntFootstep                            = 5,
	StumblingDownStairs                      = 6,
	Screamer                                 = 7,
	Environment                              = 8,
	ECameraShakeType_MAX                     = 9,
};

// Enum OPP.EPlayerEmoteType
// NumValues: 0x0004
enum class EPlayerEmoteType : uint8
{
	Terminal                                 = 0,
	Podium                                   = 1,
	Invalid                                  = 2,
	EPlayerEmoteType_MAX                     = 3,
};

// Enum OPP.EPlayerCustomizationSexQueryType
// NumValues: 0x0004
enum class EPlayerCustomizationSexQueryType : uint8
{
	All                                      = 0,
	Male                                     = 1,
	Female                                   = 2,
	EPlayerCustomizationSexQueryType_MAX     = 3,
};

// Enum OPP.ECustomizationItemAvailability
// NumValues: 0x0008
enum class ECustomizationItemAvailability : uint8
{
	None                                     = 0,
	ForSale                                  = 1,
	Locked                                   = 2,
	LockedRequiresDLC                        = 4,
	Acquired                                 = 8,
	CantAfford                               = 16,
	LockedRequiresBattlePassPurchase         = 32,
	ECustomizationItemAvailability_MAX       = 33,
};

// Enum OPP.EPlayerGameSessionTransitionType
// NumValues: 0x0008
enum class EPlayerGameSessionTransitionType : uint8
{
	None                                     = 0,
	JoiningParty                             = 1,
	JoiningPartyGameSession                  = 2,
	FindingNewLobby                          = 3,
	LobbyFull                                = 4,
	WaitingForNewLobby                       = 5,
	ReturningToLobby                         = 6,
	EPlayerGameSessionTransitionType_MAX     = 7,
};

// Enum OPP.EMenuUpgradeItemState
// NumValues: 0x0009
enum class EMenuUpgradeItemState : uint8
{
	Locked                                   = 0,
	Available                                = 1,
	AvailableNoRessources                    = 2,
	Acquired                                 = 3,
	LockedGeneric                            = 4,
	LockedNeedPlayerLevelUp                  = 5,
	LockedNeedItem                           = 6,
	LockedNeedUnlock                         = 7,
	EMenuUpgradeItemState_MAX                = 8,
};

// Enum OPP.ERespawnerState
// NumValues: 0x0006
enum class ERespawnerState : uint8
{
	Available                                = 0,
	WaitingForPlayerToSpawn                  = 1,
	OpeningDoors                             = 2,
	WaitingForPlayerToExit                   = 3,
	ClosingDoors                             = 4,
	ERespawnerState_MAX                      = 5,
};

// Enum OPP.EPlayerStatContextType
// NumValues: 0x0004
enum class EPlayerStatContextType : uint8
{
	Global                                   = 0,
	Character                                = 1,
	Trial                                    = 2,
	EPlayerStatContextType_MAX               = 3,
};

// Enum OPP.EPlayerTrialRating
// NumValues: 0x000E
enum class EPlayerTrialRating : uint8
{
	F                                        = 0,
	D                                        = 1,
	DPlus                                    = 2,
	CMinus                                   = 3,
	C                                        = 4,
	CPlus                                    = 5,
	BMinus                                   = 6,
	B                                        = 7,
	BPlus                                    = 8,
	AMinus                                   = 9,
	A                                        = 10,
	APlus                                    = 11,
	Invalid                                  = 12,
	EPlayerTrialRating_MAX                   = 13,
};

// Enum OPP.EPlayerBadgeThresholdOperator
// NumValues: 0x0006
enum class EPlayerBadgeThresholdOperator : uint8
{
	Greater                                  = 0,
	GreaterEqual                             = 1,
	Lower                                    = 2,
	LowerEqual                               = 3,
	Equal                                    = 4,
	EPlayerBadgeThresholdOperator_MAX        = 5,
};

// Enum OPP.EPlayerStatAggregationType
// NumValues: 0x0004
enum class EPlayerStatAggregationType : uint8
{
	Increment                                = 0,
	Minimum                                  = 1,
	Maximum                                  = 2,
	EPlayerStatAggregationType_MAX           = 3,
};

// Enum OPP.EPlayerTriggerType
// NumValues: 0x0006
enum class EPlayerTriggerType : uint8
{
	SelectCondition                          = 0,
	AllPlayer                                = 1,
	HalfOfAllPlayer                          = 2,
	SpecificNumberOfPlayer                   = 3,
	SpecificTeam                             = 4,
	EPlayerTriggerType_MAX                   = 5,
};

// Enum OPP.EPressureValveType
// NumValues: 0x0006
enum class EPressureValveType : uint8
{
	Unspecified                              = 0,
	ActiveConnected                          = 1,
	ActiveDisconnected                       = 2,
	InactiveConnected                        = 3,
	InactiveDisconnected                     = 4,
	EPressureValveType_MAX                   = 5,
};

// Enum OPP.ETrialSizeTypeFilter
// NumValues: 0x0004
enum class ETrialSizeTypeFilter : uint8
{
	Minor                                    = 0,
	Major                                    = 1,
	Any                                      = 2,
	ETrialSizeTypeFilter_MAX                 = 3,
};

// Enum OPP.EProgramType
// NumValues: 0x0005
enum class EProgramType : uint8
{
	Standard                                 = 0,
	Chaining                                 = 1,
	Custom                                   = 2,
	Adversarial                              = 3,
	EProgramType_MAX                         = 4,
};

// Enum OPP.EProximityDetectorDeviceType
// NumValues: 0x0004
enum class EProximityDetectorDeviceType : uint8
{
	TriggerOnly                              = 0,
	DetectorOnly                             = 1,
	DetectorAndTrigger                       = 2,
	EProximityDetectorDeviceType_MAX         = 3,
};

// Enum OPP.EProximityDetectorZLevelState
// NumValues: 0x0005
enum class EProximityDetectorZLevelState : uint8
{
	None                                     = 0,
	TargeLeveled                             = 1,
	TargetAbove                              = 2,
	TargetBelow                              = 3,
	EProximityDetectorZLevelState_MAX        = 4,
};

// Enum OPP.EProximityDetectorDeviceState
// NumValues: 0x0004
enum class EProximityDetectorDeviceState : uint8
{
	Off                                      = 0,
	DetectedOff                              = 1,
	Charging                                 = 2,
	EProximityDetectorDeviceState_MAX        = 3,
};

// Enum OPP.EPsychosisMineState
// NumValues: 0x0007
enum class EPsychosisMineState : uint8
{
	None                                     = 0,
	Deployed                                 = 1,
	Activated                                = 2,
	Broken                                   = 3,
	Expired                                  = 4,
	Finished                                 = 5,
	EPsychosisMineState_MAX                  = 6,
};

// Enum OPP.EPushableDirection
// NumValues: 0x0005
enum class EPushableDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Right                                    = 2,
	Left                                     = 3,
	EPushableDirection_MAX                   = 4,
};

// Enum OPP.ERandomAmbientSoundType
// NumValues: 0x0004
enum class ERandomAmbientSoundType : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	ERandomAmbientSoundType_MAX              = 3,
};

// Enum OPP.ERandomGroupIgnoreRule
// NumValues: 0x0004
enum class ERandomGroupIgnoreRule : uint8
{
	RandomGroup                              = 0,
	AnyRandomActor                           = 1,
	AllRandomActor                           = 2,
	ERandomGroupIgnoreRule_MAX               = 3,
};

// Enum OPP.ERandomState
// NumValues: 0x0004
enum class ERandomState : uint8
{
	None                                     = 0,
	StateA                                   = 1,
	StateB                                   = 2,
	ERandomState_MAX                         = 3,
};

// Enum OPP.ELedgeMarkerSetup
// NumValues: 0x0003
enum class ELedgeMarkerSetup : uint8
{
	EnabledWhenHidden                        = 0,
	EnabledWhenVisible                       = 1,
	ELedgeMarkerSetup_MAX                    = 2,
};

// Enum OPP.ESoundConnectorSetup
// NumValues: 0x0004
enum class ESoundConnectorSetup : uint8
{
	ActiveOpen                               = 0,
	ActiveClosed                             = 1,
	Inactive                                 = 2,
	ESoundConnectorSetup_MAX                 = 3,
};

// Enum OPP.ERandomManagerUpdatingPriority
// NumValues: 0x0004
enum class ERandomManagerUpdatingPriority : uint8
{
	High                                     = 0,
	Normal                                   = 1,
	Low                                      = 2,
	ERandomManagerUpdatingPriority_MAX       = 3,
};

// Enum OPP.ERandomManagerPopulatingOrder
// NumValues: 0x0003
enum class ERandomManagerPopulatingOrder : uint8
{
	Gates                                    = 0,
	Traps                                    = 1,
	ERandomManagerPopulatingOrder_MAX        = 2,
};

// Enum OPP.ERandomManagerExecutionOrder
// NumValues: 0x000B
enum class ERandomManagerExecutionOrder : uint8
{
	First                                    = 0,
	Rails                                    = 1,
	Gates                                    = 2,
	Earlier                                  = 3,
	SomewhatEarlier                          = 4,
	Normal                                   = 5,
	SomewhatLater                            = 6,
	Later                                    = 7,
	Last                                     = 8,
	UsePopulatingOrderInstead                = 9,
	ERandomManagerExecutionOrder_MAX         = 10,
};

// Enum OPP.ERepulsionReactionFilter
// NumValues: 0x0004
enum class ERepulsionReactionFilter : uint8
{
	All                                      = 0,
	OnlyPlayers                              = 1,
	OnlyNPCs                                 = 2,
	ERepulsionReactionFilter_MAX             = 3,
};

// Enum OPP.ERepulsionReactionType
// NumValues: 0x0004
enum class ERepulsionReactionType : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Heavy                                    = 2,
	ERepulsionReactionType_MAX               = 3,
};

// Enum OPP.ERepulsionRuleType
// NumValues: 0x0008
enum class ERepulsionRuleType : uint8
{
	All                                      = 0,
	SpecificActors                           = 1,
	Others                                   = 2,
	AllPlayers                               = 3,
	AllNPCs                                  = 4,
	Except                                   = 5,
	None                                     = 6,
	ERepulsionRuleType_MAX                   = 7,
};

// Enum OPP.ERepulsionShape
// NumValues: 0x0003
enum class ERepulsionShape : uint8
{
	Box                                      = 0,
	Cylinder                                 = 1,
	ERepulsionShape_MAX                      = 2,
};

// Enum OPP.ERepulsionDirectionFlags
// NumValues: 0x0005
enum class ERepulsionDirectionFlags : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Right                                    = 2,
	Left                                     = 3,
	ERepulsionDirectionFlags_MAX             = 4,
};

// Enum OPP.ERewardSource
// NumValues: 0x000A
enum class ERewardSource : uint8
{
	ExpiredTasks                             = 0,
	Task                                     = 1,
	Badge                                    = 2,
	Trial                                    = 3,
	TrialChaining                            = 4,
	BattlePass                               = 5,
	LevelUp                                  = 6,
	Release                                  = 7,
	Cheat                                    = 8,
	ERewardSource_MAX                        = 9,
};

// Enum OPP.ERoomSize
// NumValues: 0x0005
enum class ERoomSize : uint8
{
	VerySmall                                = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	ERoomSize_MAX                            = 4,
};

// Enum OPP.ERoomType
// NumValues: 0x0003
enum class ERoomType : uint8
{
	Normal                                   = 0,
	CoopOnly                                 = 1,
	ERoomType_MAX                            = 2,
};

// Enum OPP.ERoomConnectionType
// NumValues: 0x0005
enum class ERoomConnectionType : uint8
{
	Normal                                   = 0,
	Coop                                     = 1,
	CrouchUnder                              = 2,
	PlayerOnly                               = 3,
	ERoomConnectionType_MAX                  = 4,
};

// Enum OPP.ERoomConnectionState
// NumValues: 0x0005
enum class ERoomConnectionState : uint8
{
	Open                                     = 0,
	Closed                                   = 1,
	ClosedTemporarily                        = 2,
	ClosedForQuery                           = 3,
	ERoomConnectionState_MAX                 = 4,
};

// Enum OPP.ESASTransitionDirection
// NumValues: 0x0006
enum class ESASTransitionDirection : uint8
{
	Invalid                                  = 0,
	MapEntrance                              = 1,
	MapExit                                  = 2,
	Random                                   = 3,
	Deprecated                               = 4,
	ESASTransitionDirection_MAX              = 5,
};

// Enum OPP.AutoDoorState
// NumValues: 0x0005
enum class EAutoDoorState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	WaitingForPlayerEnter                    = 2,
	WaitingForPlayerExit                     = 3,
	AutoDoorState_MAX                        = 4,
};

// Enum OPP.EScriptedAnimSlotType
// NumValues: 0x0004
enum class EScriptedAnimSlotType : uint8
{
	Disabled                                 = 0,
	NPC                                      = 1,
	AnimatedMesh                             = 2,
	EScriptedAnimSlotType_MAX                = 3,
};

// Enum OPP.ESimonTortureMannequinActionType
// NumValues: 0x0006
enum class ESimonTortureMannequinActionType : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Standard                                 = 2,
	Fatality                                 = 3,
	Fail                                     = 4,
	ESimonTortureMannequinActionType_MAX     = 5,
};

// Enum OPP.ESimpleObjectiveType
// NumValues: 0x0008
enum class ESimpleObjectiveType : uint8
{
	Custom                                   = 0,
	GotoTriggerVolume                        = 1,
	Interact                                 = 2,
	Operate                                  = 3,
	Trigger                                  = 4,
	MoveObjectTo                             = 5,
	UseOnObject                              = 6,
	ESimpleObjectiveType_MAX                 = 7,
};

// Enum OPP.EDoorLockType
// NumValues: 0x0004
enum class EDoorLockType : uint8
{
	SlidingLock                              = 0,
	DoubleDoorPlanks                         = 1,
	MetalBar                                 = 2,
	EDoorLockType_MAX                        = 3,
};

// Enum OPP.ESocialMenuSceneActorType
// NumValues: 0x0004
enum class ESocialMenuSceneActorType : uint8
{
	Invalid                                  = 0,
	SocialMenu                               = 1,
	PhotoFinish                              = 2,
	ESocialMenuSceneActorType_MAX            = 3,
};

// Enum OPP.ESocialMenuSceneActorSlot
// NumValues: 0x0006
enum class ESocialMenuSceneActorSlot : uint8
{
	Single                                   = 0,
	Party1                                   = 1,
	Party2                                   = 2,
	Party3                                   = 3,
	Party4                                   = 4,
	ESocialMenuSceneActorSlot_MAX            = 5,
};

// Enum OPP.ERBSocialMenuEntryFlag
// NumValues: 0x000D
enum class ERBSocialMenuEntryFlag : uint8
{
	IsSelf                                   = 0,
	InCurrentGame                            = 1,
	PartyOwner                               = 2,
	PartyMember                              = 3,
	PendingPartyInvite                       = 4,
	Friend                                   = 5,
	PlatformFriend                           = 6,
	PendingFriendRequest                     = 7,
	PendingSentFriendRequest                 = 8,
	PlatformPendingFriendRequest             = 9,
	PlatformPendingSentFriendRequest         = 10,
	PlatformBlocked                          = 11,
	ERBSocialMenuEntryFlag_MAX               = 12,
};

// Enum OPP.ERBSocialMenuEntryListType
// NumValues: 0x0008
enum class ERBSocialMenuEntryListType : uint8
{
	Unknown                                  = 0,
	Party                                    = 1,
	Friends                                  = 2,
	RecentExperiments                        = 3,
	Lobby                                    = 4,
	Blocked                                  = 5,
	PartyInvite                              = 6,
	ERBSocialMenuEntryListType_MAX           = 7,
};

// Enum OPP.ESoundTrapActivator
// NumValues: 0x0004
enum class ESoundTrapActivator : uint8
{
	NPC                                      = 0,
	Player                                   = 1,
	Projectile                               = 2,
	ESoundTrapActivator_MAX                  = 3,
};

// Enum OPP.ESoundVolumeType
// NumValues: 0x0003
enum class ESoundVolumeType : uint8
{
	ST_Volume_Interior                       = 0,
	ST_Volume_Exterior                       = 1,
	ST_Volume_MAX                            = 2,
};

// Enum OPP.EAreaExitPointType
// NumValues: 0x0005
enum class EAreaExitPointType : uint8
{
	None                                     = 0,
	Point                                    = 1,
	Line                                     = 2,
	Door                                     = 3,
	EAreaExitPointType_MAX                   = 4,
};

// Enum OPP.EStalkingObjectiveType
// NumValues: 0x0003
enum class EStalkingObjectiveType : uint8
{
	StealthStalk                             = 0,
	PackHunt                                 = 1,
	EStalkingObjectiveType_MAX               = 2,
};

// Enum OPP.EStreamingCommandType
// NumValues: 0x0005
enum class EStreamingCommandType : uint8
{
	PrepareMapChange                         = 0,
	CancelPendingMapChange                   = 1,
	UnloadLevels                             = 2,
	CommitMapChange                          = 3,
	EStreamingCommandType_MAX                = 4,
};

// Enum OPP.EStroopGameColor
// NumValues: 0x000A
enum class EStroopGameColor : uint8
{
	Black                                    = 0,
	White                                    = 1,
	Red                                      = 2,
	Orange                                   = 3,
	Yellow                                   = 4,
	Green                                    = 5,
	Blue                                     = 6,
	Purple                                   = 7,
	Pink                                     = 8,
	EStroopGameColor_MAX                     = 9,
};

// Enum OPP.EStroopDisturbanceType
// NumValues: 0x0012
enum class EStroopDisturbanceType : uint8
{
	None                                     = 0,
	TV_Flicker                               = 1,
	TV_Panner                                = 2,
	TV_Clock                                 = 3,
	TV_BackgroundColor                       = 4,
	TV_Alternate                             = 5,
	TV_DisturbingImages                      = 6,
	TV_DisturbingWords                       = 7,
	SND_Colors                               = 8,
	SND_Misc                                 = 9,
	Hallucination1                           = 10,
	Hallucination2                           = 11,
	Lights_Level1                            = 12,
	Lights_Level2                            = 13,
	Lights_Level3                            = 14,
	Buttons_Mode1                            = 15,
	Buttons_Mode2                            = 16,
	EStroopDisturbanceType_MAX               = 17,
};

// Enum OPP.EStroopButtonSelectionMode
// NumValues: 0x0007
enum class EStroopButtonSelectionMode : uint8
{
	AllButtons                               = 0,
	TopRow                                   = 1,
	MidRow                                   = 2,
	BottomRow                                = 3,
	Cross                                    = 4,
	Corners                                  = 5,
	EStroopButtonSelectionMode_MAX           = 6,
};

// Enum OPP.EStroopLevel
// NumValues: 0x0004
enum class EStroopLevel : uint8
{
	Level1                                   = 0,
	Level2                                   = 1,
	Level3                                   = 2,
	EStroopLevel_MAX                         = 3,
};

// Enum OPP.EFlipSwitchState
// NumValues: 0x0006
enum class EFlipSwitchState : uint8
{
	None                                     = 0,
	Removed                                  = 1,
	On                                       = 2,
	Off                                      = 3,
	Hidden                                   = 4,
	EFlipSwitchState_MAX                     = 5,
};

// Enum OPP.ESwitchPanelPartType
// NumValues: 0x0004
enum class ESwitchPanelPartType : uint8
{
	Toggle                                   = 0,
	LookAt                                   = 1,
	InputRotation                            = 2,
	ESwitchPanelPartType_MAX                 = 3,
};

// Enum OPP.ETaskConditionNumericOperator
// NumValues: 0x0007
enum class ETaskConditionNumericOperator : uint8
{
	GreaterThan                              = 0,
	GreaterThanEqual                         = 1,
	LessThan                                 = 2,
	LessThanEqual                            = 3,
	Equal                                    = 4,
	NotEqual                                 = 5,
	ETaskConditionNumericOperator_MAX        = 6,
};

// Enum OPP.EPlayerStatTaskConditionOperator
// NumValues: 0x0006
enum class EPlayerStatTaskConditionOperator : uint8
{
	Greater                                  = 0,
	GreaterEqual                             = 1,
	Lower                                    = 2,
	LowerEqual                               = 3,
	Equal                                    = 4,
	EPlayerStatTaskConditionOperator_MAX     = 5,
};

// Enum OPP.ETaskType
// NumValues: 0x0006
enum class ETaskType : uint8
{
	TrialAction                              = 0,
	TrialCompletion                          = 1,
	TaskCompletion                           = 2,
	Progression                              = 3,
	LobbyAction                              = 4,
	ETaskType_MAX                            = 5,
};

// Enum OPP.ETennisEventType
// NumValues: 0x000C
enum class ETennisEventType : uint8
{
	HitGround                                = 0,
	HitNet                                   = 1,
	PlayerHitStraight                        = 2,
	PlayerHitLobe                            = 3,
	PlayerHitSmash                           = 4,
	PlayerHitService                         = 5,
	ScorePoint                               = 6,
	Service                                  = 7,
	ResetBall                                = 8,
	Intro                                    = 9,
	Outro                                    = 10,
	ETennisEventType_MAX                     = 11,
};

// Enum OPP.ETennisHitType
// NumValues: 0x0004
enum class ETennisHitType : uint8
{
	Standard                                 = 0,
	Lobe                                     = 1,
	Service                                  = 2,
	ETennisHitType_MAX                       = 3,
};

// Enum OPP.ERBTextChatType
// NumValues: 0x0005
enum class ERBTextChatType : uint8
{
	Notification                             = 0,
	PartyNotification                        = 1,
	FriendNotification                       = 2,
	TalkWheel                                = 3,
	MAX                                      = 4,
};

// Enum OPP.ERBPlayerThumbnailType
// NumValues: 0x0005
enum class ERBPlayerThumbnailType : uint8
{
	Invalid                                  = 0,
	Slots                                    = 1,
	Outfits                                  = 2,
	All                                      = 3,
	ERBPlayerThumbnailType_MAX               = 4,
};

// Enum OPP.ERBThumbnailType
// NumValues: 0x0005
enum class ERBThumbnailType : uint8
{
	Invalid                                  = 0,
	Player                                   = 1,
	Cell                                     = 2,
	Emotes                                   = 3,
	ERBThumbnailType_MAX                     = 4,
};

// Enum OPP.EBreadcrumbState
// NumValues: 0x0005
enum class EBreadcrumbState : uint8
{
	None                                     = 0,
	Deactivated                              = 1,
	Activated                                = 2,
	NeedsActivation                          = 3,
	EBreadcrumbState_MAX                     = 4,
};

// Enum OPP.ETrapScenarioState
// NumValues: 0x0003
enum class ETrapScenarioState : uint8
{
	Removed                                  = 0,
	Added                                    = 1,
	ETrapScenarioState_MAX                   = 2,
};

// Enum OPP.ELinkedMarkersActivationLogic
// NumValues: 0x0005
enum class ELinkedMarkersActivationLogic : uint8
{
	ActivateOnTriggered                      = 0,
	DeactivateOnTriggered                    = 1,
	ActivateOnUntriggered                    = 2,
	DeactivateOnUntriggered                  = 3,
	ELinkedMarkersActivationLogic_MAX        = 4,
};

// Enum OPP.EOverrideOperatorAction
// NumValues: 0x0004
enum class EOverrideOperatorAction : uint8
{
	DoNothing                                = 0,
	OverrideOnActivation                     = 1,
	OverrideOnDeactivation                   = 2,
	EOverrideOperatorAction_MAX              = 3,
};

// Enum OPP.EHackClass
// NumValues: 0x0013
enum class EHackClass : uint8
{
	Undefined                                = 0,
	PadLock                                  = 1,
	ExplosiveTrap                            = 2,
	ExplosiveTripWireTrap                    = 3,
	ElectricFloorTrap                        = 4,
	ToasterDetectorGate                      = 5,
	LimitedPassageGate                       = 6,
	AudioDetectorGate                        = 7,
	TimedOpenClosedGate                      = 8,
	UnlockableGate                           = 9,
	PsychosisMine                            = 10,
	DoorTrap                                 = 11,
	ContainerTrap                            = 12,
	DeadPlayer                               = 13,
	NPC                                      = 14,
	Television                               = 15,
	RewardDoor                               = 16,
	AlarmDoor                                = 17,
	EHackClass_MAX                           = 18,
};

// Enum OPP.EUserControlMappingType
// NumValues: 0x0005
enum class EUserControlMappingType : uint8
{
	Global                                   = 0,
	Gameplay                                 = 1,
	Menu                                     = 2,
	None                                     = 3,
	EUserControlMappingType_MAX              = 4,
};

// Enum OPP.ETriggerableActionType
// NumValues: 0x0003
enum class ETriggerableActionType : uint8
{
	Trigger                                  = 0,
	Untrigger                                = 1,
	ETriggerableActionType_MAX               = 2,
};

// Enum OPP.EPlayerBarState
// NumValues: 0x0007
enum class EPlayerBarState : uint8
{
	Default                                  = 0,
	Base                                     = 1,
	Upper                                    = 2,
	Boost                                    = 3,
	Temp                                     = 4,
	Damage                                   = 5,
	EPlayerBarState_MAX                      = 6,
};

// Enum OPP.ECollectablePriority
// NumValues: 0x0004
enum class ECollectablePriority : uint8
{
	Objective                                = 0,
	Normal                                   = 1,
	VisualFluff                              = 2,
	ECollectablePriority_MAX                 = 3,
};

// Enum OPP.EMolotovSize
// NumValues: 0x0004
enum class EMolotovSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	EMolotovSize_MAX                         = 3,
};

// Enum OPP.EGamepadStick
// NumValues: 0x0004
enum class EGamepadStick : uint8
{
	Unspecified                              = 0,
	LeftStick                                = 1,
	RightStick                               = 2,
	EGamepadStick_MAX                        = 3,
};

// Enum OPP.ECameraShakeDataType
// NumValues: 0x0007
enum class ECameraShakeDataType : uint8
{
	None                                     = 0,
	GenericDamage                            = 1,
	Pushable                                 = 2,
	KnockedDownSliding                       = 3,
	FreeSliding                              = 4,
	Bash                                     = 5,
	ECameraShakeDataType_MAX                 = 6,
};

// Enum OPP.ENPCBlendOutCondition
// NumValues: 0x0006
enum class ENPCBlendOutCondition : uint8
{
	None                                     = 0,
	Chase                                    = 1,
	Running                                  = 2,
	Retiring                                 = 3,
	Always                                   = 4,
	ENPCBlendOutCondition_MAX                = 5,
};

// Enum OPP.ESubtitlePriority
// NumValues: 0x0006
enum class ESubtitlePriority : uint8
{
	Low                                      = 0,
	BelowNormal                              = 1,
	Normal                                   = 2,
	AboveNormal                              = 3,
	High                                     = 4,
	ESubtitlePriority_MAX                    = 5,
};

// Enum OPP.ELandingType
// NumValues: 0x0008
enum class ELandingType : uint8
{
	Hard                                     = 0,
	Medium                                   = 1,
	Normal                                   = 2,
	Knockdown                                = 3,
	Dead                                     = 4,
	ExhaustedFromJumpOver                    = 5,
	Exhausted                                = 6,
	ELandingType_MAX                         = 7,
};

// Enum OPP.EHitReactionState
// NumValues: 0x0004
enum class EHitReactionState : uint8
{
	DisableHitReaction                       = 0,
	EnableHitReaction                        = 1,
	CustomHitReaction                        = 2,
	EHitReactionState_MAX                    = 3,
};

// Enum OPP.EThrowableWeaponGameplayFlag
// NumValues: 0x0009
enum class EThrowableWeaponGameplayFlag : uint8
{
	None                                     = 0,
	CanCauseKnockdownReaction                = 1,
	CanInteruptActions                       = 2,
	CanInterruptGroundAndPound               = 4,
	CanBreakWindows                          = 8,
	CanBreakTraps                            = 16,
	CanStunPlayerDetector                    = 32,
	All                                      = 63,
	EThrowableWeaponGameplayFlag_MAX         = 64,
};

// Enum OPP.EStaminaCostType
// NumValues: 0x0008
enum class EStaminaCostType : uint8
{
	None                                     = 0,
	Minimum                                  = 1,
	Small                                    = 2,
	Medium                                   = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	Maximum                                  = 6,
	EStaminaCostType_MAX                     = 7,
};

// Enum OPP.EPickupType
// NumValues: 0x0005
enum class EPickupType : uint8
{
	Normal                                   = 0,
	Consume                                  = 1,
	TradeNormal                              = 2,
	TradeConsume                             = 3,
	EPickupType_MAX                          = 4,
};

// Enum OPP.EJumpType
// NumValues: 0x0005
enum class EJumpType : uint8
{
	Standing                                 = 0,
	Walking                                  = 1,
	Backward                                 = 2,
	Running                                  = 3,
	EJumpType_MAX                            = 4,
};

// Enum OPP.EGraphicsRHI
// NumValues: 0x0005
enum class EGraphicsRHI : uint8
{
	DefaultGraphicsRHI_Default               = 0,
	DefaultGraphicsRHI_DX11                  = 1,
	DefaultGraphicsRHI_DX12                  = 2,
	DefaultGraphicsRHI_Vulkan                = 3,
	DefaultGraphicsRHI_MAX                   = 4,
};

// Enum OPP.ENarrativeScreenDataTableLogic
// NumValues: 0x0006
enum class ENarrativeScreenDataTableLogic : uint8
{
	PlaySingleRow                            = 0,
	PlaySingleRandomRow                      = 1,
	PlayAllRowsInOrder                       = 2,
	PlayAllRowsInOrderAndLoop                = 3,
	PlayAllRowsRandom                        = 4,
	ENarrativeScreenDataTableLogic_MAX       = 5,
};

// Enum OPP.EClientTravelSource
// NumValues: 0x0009
enum class EClientTravelSource : uint8
{
	Unknown                                  = 0,
	MainMenu                                 = 1,
	Tutorial                                 = 2,
	Lobby                                    = 3,
	Experiment                               = 4,
	ExperimentFail                           = 5,
	Release                                  = 6,
	ReleaseFail                              = 7,
	EClientTravelSource_MAX                  = 8,
};

// Enum OPP.EUIFontSize
// NumValues: 0x0004
enum class EUIFontSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	EUIFontSize_MAX                          = 3,
};

// Enum OPP.ELoadoutCantEquipReason
// NumValues: 0x0003
enum class ELoadoutCantEquipReason : uint8
{
	None                                     = 0,
	NoFreeSlot                               = 1,
	ELoadoutCantEquipReason_MAX              = 2,
};

// Enum OPP.EHoldDurationType
// NumValues: 0x0005
enum class EHoldDurationType : uint8
{
	None                                     = 0,
	Short                                    = 1,
	Long                                     = 2,
	Progress                                 = 3,
	EHoldDurationType_MAX                    = 4,
};

// Enum OPP.EGhostAnimEvent
// NumValues: 0x0004
enum class EGhostAnimEvent : uint8
{
	Attach                                   = 0,
	Detach                                   = 1,
	Action                                   = 2,
	EGhostAnimEvent_MAX                      = 3,
};

// Enum OPP.EGameObjectiveType
// NumValues: 0x000A
enum class EGameObjectiveType : uint8
{
	Default                                  = 0,
	HotPotato                                = 1,
	Stalker                                  = 2,
	PushCart                                 = 3,
	SimpleInteract                           = 4,
	LargeInteract                            = 5,
	Exit                                     = 6,
	EscapePuzzleRoom                         = 7,
	ShootNPC                                 = 8,
	EGameObjectiveType_MAX                   = 9,
};

// Enum OPP.ECategoryButtonState
// NumValues: 0x0006
enum class ECategoryButtonState : uint8
{
	Locked                                   = 0,
	Available                                = 1,
	Acquired                                 = 2,
	Empty                                    = 3,
	Invalid                                  = 4,
	ECategoryButtonState_MAX                 = 5,
};

// Enum OPP.EPawnAnimQuality
// NumValues: 0x0006
enum class EPawnAnimQuality : uint8
{
	VeryHigh                                 = 0,
	High                                     = 1,
	Med                                      = 2,
	Low                                      = 3,
	VeryLow                                  = 4,
	EPawnAnimQuality_MAX                     = 5,
};

// Enum OPP.EDoorInvestigationType
// NumValues: 0x0008
enum class EDoorInvestigationType : uint8
{
	None                                     = 0,
	OpenInvestigateSide                      = 1,
	OpenInvestigateWide                      = 2,
	ClosedInvestigatePeek                    = 3,
	ClosedInvestigateSide                    = 4,
	ClosedInvestigateWide                    = 5,
	LockedInvestigate                        = 6,
	EDoorInvestigationType_MAX               = 7,
};

// Enum OPP.EVOBehavior
// NumValues: 0x0004
enum class EVOBehavior : uint8
{
	Queue                                    = 0,
	InterruptIfBusy                          = 1,
	SkipIfBusy                               = 2,
	EVOBehavior_MAX                          = 3,
};

// Enum OPP.EVOPriority
// NumValues: 0x0006
enum class EVOPriority : uint8
{
	VeryLow                                  = 0,
	Low                                      = 1,
	Normal                                   = 2,
	High                                     = 3,
	VeryHigh                                 = 4,
	EVOPriority_MAX                          = 5,
};

// Enum OPP.EFullTurnDirection
// NumValues: 0x000A
enum class EFullTurnDirection : uint8
{
	Forward                                  = 0,
	Right_45                                 = 1,
	Right_90                                 = 2,
	Right_135                                = 3,
	Right_180                                = 4,
	Left_45                                  = 5,
	Left_90                                  = 6,
	Left_135                                 = 7,
	Left_180                                 = 8,
	MAX                                      = 9,
};

// Enum OPP.ELocomotionTurnDirection
// NumValues: 0x0006
enum class ELocomotionTurnDirection : uint8
{
	Forward                                  = 0,
	Right_90                                 = 1,
	Right_180                                = 2,
	Left_90                                  = 3,
	Left_180                                 = 4,
	MAX                                      = 5,
};

// Enum OPP.ELocomotionMovementSpeed
// NumValues: 0x0007
enum class ELocomotionMovementSpeed : uint8
{
	Stopped                                  = 0,
	Walk                                     = 1,
	Stride                                   = 2,
	Jog                                      = 3,
	Run                                      = 4,
	Combat                                   = 5,
	MAX                                      = 6,
};

// Enum OPP.ETriggerableActionBehavior
// NumValues: 0x0004
enum class ETriggerableActionBehavior : uint8
{
	ActivateAndDeactivate                    = 0,
	OnlyActivate                             = 1,
	OnlyDeactivate                           = 2,
	ETriggerableActionBehavior_MAX           = 3,
};

// Enum OPP.EMatchCancelationReason
// NumValues: 0x0006
enum class EMatchCancelationReason : uint8
{
	Manual                                   = 0,
	PartyChanged                             = 1,
	WaitForMatchFailed                       = 2,
	WaitForPartyFailed                       = 3,
	Error                                    = 4,
	EMatchCancelationReason_MAX              = 5,
};

// Enum OPP.EPlayerSpawnType
// NumValues: 0x0007
enum class EPlayerSpawnType : uint8
{
	NewPlayer                                = 0,
	StageReset                               = 1,
	EndOfStage                               = 2,
	StageRespawn                             = 3,
	Rejoined                                 = 4,
	Cheat                                    = 5,
	EPlayerSpawnType_MAX                     = 6,
};

// Enum OPP.EHudMode
// NumValues: 0x000E
enum class EHudMode : uint8
{
	NoHUD                                    = 0,
	DebugDisplay                             = 1,
	InGameExperiment                         = 2,
	Spectator                                = 3,
	Menu                                     = 4,
	Loading                                  = 5,
	Cinematic                                = 6,
	LobbyMinigame                            = 7,
	InGameLobby                              = 8,
	SAS                                      = 9,
	StageIntro                               = 10,
	Release                                  = 11,
	Invalid                                  = 12,
	EHudMode_MAX                             = 13,
};

// Enum OPP.EPlayerTargetPriority
// NumValues: 0x0003
enum class EPlayerTargetPriority : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	EPlayerTargetPriority_MAX                = 2,
};

// Enum OPP.EUniqueVariatorType
// NumValues: 0x002E
enum class EUniqueVariatorType : uint8
{
	Invalid                                  = 0,
	NPCBashDamageMultiplier                  = 1,
	OnlyBigGrunts                            = 2,
	ForcedStartingHealth                     = 3,
	NoRigs                                   = 4,
	ForcedExtraLivesCount                    = 5,
	EnemiesPsychosisAura                     = 6,
	EnemiesStaminaDrainAura                  = 7,
	NoRunning                                = 8,
	PlayerDamageLeash                        = 9,
	NoRadioVoiceChat                         = 10,
	Hardcore                                 = 11,
	PeriodicHazard                           = 12,
	NPCPopulation_Low                        = 13,
	NPCPopulation_High                       = 14,
	NPCPopulation_VeryHigh                   = 15,
	ObjectiveDiscoveryDistanceMultiplier     = 16,
	ObjectiveIconsDisabled                   = 17,
	TrapReactionDelayMultiplier              = 18,
	NumberOfLockedContainersMultiplier       = 19,
	ExtraPsychosisOnDamage                   = 20,
	NoDeaths                                 = 21,
	ExitRush                                 = 22,
	BadTrip                                  = 23,
	HideOverheadInfo                         = 24,
	LimitPlayerUpgrades                      = 25,
	LimitRigUpgrades                         = 26,
	LimitPerks                               = 27,
	GlassDamage                              = 28,
	RunningProhibited                        = 29,
	NoRevive                                 = 30,
	VoiceDisturbance                         = 31,
	NPCChaseRedEyes                          = 32,
	NPCHeightenedStimuli                     = 33,
	InverseNPCSeePlayerInPsychosis           = 34,
	OnlyAIDirectorNPC                        = 35,
	RewardRoomCount                          = 36,
	RigInfiniteCooldown                      = 37,
	ProximityMines                           = 38,
	ExplosiveMines                           = 39,
	NoExitStageButton                        = 40,
	DamageRestartRigCooldown                 = 41,
	DamageDisableRig                         = 42,
	FreezeMines                              = 43,
	PsychosisDurationMultiplier              = 44,
	EUniqueVariatorType_MAX                  = 45,
};

// Enum OPP.ETriggerComponentNetType
// NumValues: 0x0004
enum class ETriggerComponentNetType : uint8
{
	ServerOnly                               = 0,
	ClientOnly                               = 1,
	ServerAndClients                         = 2,
	ETriggerComponentNetType_MAX             = 3,
};

// Enum OPP.EActiveSkillState
// NumValues: 0x0007
enum class EActiveSkillState : uint8
{
	None                                     = 0,
	Placed                                   = 1,
	Deployed                                 = 2,
	Activated                                = 3,
	Expired                                  = 4,
	Finished                                 = 5,
	EActiveSkillState_MAX                    = 6,
};

// Enum OPP.EQuestGiverMenuCategory
// NumValues: 0x0004
enum class EQuestGiverMenuCategory : uint8
{
	Tasks                                    = 0,
	Upgrade                                  = 1,
	Shop                                     = 2,
	MAX                                      = 3,
};

// Enum OPP.EMetaNPCType
// NumValues: 0x0007
enum class EMetaNPCType : uint8
{
	Engineer                                 = 0,
	Pharmacist                               = 1,
	ShadowyDame                              = 2,
	Director                                 = 3,
	Count                                    = 4,
	None                                     = 5,
	EMetaNPCType_MAX                         = 6,
};

// Enum OPP.EProfileUpgradeCategory
// NumValues: 0x0005
enum class EProfileUpgradeCategory : uint8
{
	Core                                     = 0,
	PerkSlot                                 = 1,
	Count                                    = 2,
	None                                     = 3,
	EProfileUpgradeCategory_MAX              = 4,
};

// Enum OPP.ERadialWheelType
// NumValues: 0x0003
enum class ERadialWheelType : uint8
{
	None                                     = 0,
	Talk                                     = 1,
	ERadialWheelType_MAX                     = 2,
};

// Enum OPP.EGameDifficulty
// NumValues: 0x0006
enum class EGameDifficulty : uint8
{
	Undefined                                = 0,
	Easy                                     = 5,
	Normal                                   = 8,
	Hard                                     = 11,
	Insane                                   = 20,
	EGameDifficulty_MAX                      = 21,
};

// Enum OPP.EMainObjectiveType
// NumValues: 0x0004
enum class EMainObjectiveType : uint8
{
	Main                                     = 0,
	Prologue                                 = 1,
	Epilogue                                 = 2,
	EMainObjectiveType_MAX                   = 3,
};

// Enum OPP.EGameEventImportanceLevel
// NumValues: 0x0004
enum class EGameEventImportanceLevel : uint8
{
	Low                                      = 0,
	Normal                                   = 1,
	High                                     = 2,
	EGameEventImportanceLevel_MAX            = 3,
};

// Enum OPP.EGameEvent
// NumValues: 0x001D
enum class EGameEvent : uint8
{
	None                                     = 0,
	StageStarted                             = 1,
	EndOfStageReached                        = 2,
	EndOfStageStats                          = 3,
	CompletedObjectiveCoordinator            = 4,
	CompletedSingleObjective                 = 5,
	PlayerIncapacitated                      = 6,
	PlayerRevived                            = 7,
	PlayerKilled                             = 8,
	PlayerLeftGame                           = 9,
	PlayerRespawned                          = 10,
	PlayerDruggedByPusher                    = 11,
	PlayerEnteredSAS                         = 12,
	PlayerExitedSAS                          = 13,
	GaveItem                                 = 14,
	UsedItem                                 = 15,
	PickupItem                               = 16,
	BotKnockedOut                            = 17,
	BotKnockedOutByDynamicObstacle           = 18,
	BotKilled                                = 19,
	CoopDoorBash                             = 20,
	CoopLedgeCatch                           = 21,
	CoopLegUp                                = 22,
	CoopLedgePull                            = 23,
	PouncersSpawned                          = 24,
	SpecialBotSpawned                        = 25,
	SpawnWave                                = 26,
	AIDirector                               = 27,
	EGameEvent_MAX                           = 28,
};

// Enum OPP.EDoorPassType
// NumValues: 0x000B
enum class EDoorPassType : uint8
{
	None                                     = 0,
	OpenedTowardToClosed                     = 1,
	OpenedOppositeToClosed                   = 2,
	OpenedTowardToLocked                     = 3,
	OpenedOppositeToLocked                   = 4,
	ClosedToOpened                           = 5,
	ClosedToClosed                           = 6,
	ClosedToLocked                           = 7,
	LockedToOpened                           = 8,
	LockedToClosed                           = 9,
	EDoorPassType_MAX                        = 10,
};

// Enum OPP.EDoorPassDirection
// NumValues: 0x0003
enum class EDoorPassDirection : uint8
{
	FrontToBack                              = 0,
	BackToFront                              = 1,
	EDoorPassDirection_MAX                   = 2,
};

// Enum OPP.EAIMusicState
// NumValues: 0x0008
enum class EAIMusicState : uint8
{
	Unset                                    = 0,
	None                                     = 1,
	Unaware                                  = 2,
	Suspicious                               = 3,
	Alerted                                  = 4,
	Chase                                    = 5,
	ChaseProximity                           = 6,
	EAIMusicState_MAX                        = 7,
};

// Enum OPP.ETutorialType
// NumValues: 0x0006
enum class ETutorialType : uint8
{
	Custom                                   = 0,
	Interaction                              = 1,
	EquippedItem                             = 2,
	Objective                                = 3,
	Inventory                                = 4,
	ETutorialType_MAX                        = 5,
};

// Enum OPP.ELargeObjectType
// NumValues: 0x0014
enum class ELargeObjectType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	LargeBox30                               = 2,
	LargeBox60                               = 3,
	Diaporama                                = 4,
	Bucket                                   = 5,
	TeddyBear                                = 6,
	ChildMannequin                           = 7,
	HotPotato                                = 8,
	CocainePackage                           = 9,
	AcidBottle                               = 10,
	Bomb                                     = 11,
	GasCanister                              = 12,
	FileBox                                  = 13,
	SeveredHead                              = 14,
	MaterialBox                              = 15,
	FlowerBox                                = 16,
	HeroinPackage                            = 17,
	PoisonBucket                             = 18,
	ELargeObjectType_MAX                     = 19,
};

// Enum OPP.EHidespotCategory
// NumValues: 0x0009
enum class EHidespotCategory : uint8
{
	StandingLeft                             = 0,
	StandingRight                            = 1,
	LyingDownLeft                            = 2,
	LyingDownRight                           = 3,
	Crouched                                 = 4,
	InsideHorizontal                         = 5,
	InsideVertical                           = 6,
	CarTrunk                                 = 7,
	EHidespotCategory_MAX                    = 8,
};

// Enum OPP.EPlayerMessageType
// NumValues: 0x002D
enum class EPlayerMessageType : uint8
{
	None                                     = 0,
	Tutorial                                 = 1,
	Custom                                   = 2,
	ObjectInteraction                        = 3,
	ObjectCannotStopInteraction              = 4,
	HelpPlayerUp                             = 5,
	HelpingPlayerUp                          = 6,
	BeingHelpedUp                            = 7,
	RevivePlayer                             = 8,
	RevivingPlayer                           = 9,
	PyschosisPlayer                          = 10,
	BeingRevived                             = 11,
	OfferHighJump                            = 12,
	OfferingHighJump                         = 13,
	AcceptHighJump                           = 14,
	OfferLongJump                            = 15,
	OfferingLongJump                         = 16,
	AcceptLongJump                           = 17,
	WakeUp                                   = 18,
	SavePlayerFromGroundAndPound             = 19,
	SavePlayerFromFatality                   = 20,
	Shove                                    = 21,
	GroundAndPoundNoItemCounter              = 22,
	GroundAndPoundThrowableCounter           = 23,
	DoorBashInteract                         = 24,
	DoorBashBlocked                          = 25,
	DropLargeObject                          = 26,
	AimingThrowable                          = 27,
	CoopTrapHelper                           = 28,
	CoopTrapVictimFreeYourself               = 29,
	CoopTrapHelperFreeFriend                 = 30,
	OfferingTrade                            = 31,
	AcceptTrade                              = 32,
	MessageZone                              = 33,
	InvestigationDone                        = 34,
	ItemHoldAction                           = 35,
	CantOperateDoorWithLargeObject           = 36,
	EnterSpectator                           = 37,
	Respawn                                  = 38,
	UseSelfRevivePerk                        = 39,
	UseSelfReviveHackingRig                  = 40,
	ActiveSkillDisabled                      = 41,
	StabPlayer                               = 42,
	KillPlayer                               = 43,
	EPlayerMessageType_MAX                   = 44,
};

// Enum OPP.ERandomStateSetup
// NumValues: 0x0005
enum class ERandomStateSetup : uint8
{
	Random                                   = 0,
	StateA                                   = 1,
	StateB                                   = 2,
	NotApplicable                            = 3,
	ERandomStateSetup_MAX                    = 4,
};

// Enum OPP.ERBFoleyType
// NumValues: 0x0005
enum class ERBFoleyType : uint8
{
	PantShort                                = 0,
	PantLong                                 = 1,
	ClothShort                               = 2,
	ClothLong                                = 3,
	ERBFoleyType_MAX                         = 4,
};

// Enum OPP.ESwitchPanelPartVariant
// NumValues: 0x0005
enum class ESwitchPanelPartVariant : uint8
{
	NoRotation                               = 0,
	Rotated90                                = 1,
	Rotated180                               = 2,
	Rotated270                               = 3,
	ESwitchPanelPartVariant_MAX              = 4,
};

// Enum OPP.EDestructibleMaterialType
// NumValues: 0x0005
enum class EDestructibleMaterialType : uint8
{
	Wood                                     = 0,
	WoodenDoor                               = 1,
	Concrete                                 = 2,
	Mannequin                                = 3,
	EDestructibleMaterialType_MAX            = 4,
};

// Enum OPP.EFallingReason
// NumValues: 0x0008
enum class EFallingReason : uint8
{
	Normal                                   = 0,
	Death                                    = 1,
	Spawning                                 = 2,
	WalkJumping                              = 3,
	RunJumping                               = 4,
	JumpOver                                 = 5,
	Combat                                   = 6,
	EFallingReason_MAX                       = 7,
};

// Enum OPP.ENPCHitReactionType
// NumValues: 0x0007
enum class ENPCHitReactionType : uint8
{
	None                                     = 0,
	Flinch                                   = 1,
	Twitch                                   = 2,
	Stagger                                  = 3,
	Stumble                                  = 4,
	Knockdown                                = 5,
	ENPCHitReactionType_MAX                  = 6,
};

// Enum OPP.EGrabType
// NumValues: 0x000C
enum class EGrabType : uint8
{
	None                                     = 0,
	Stand                                    = 1,
	Crouch                                   = 2,
	Above                                    = 3,
	HidingStandLeft                          = 4,
	HidingStandRight                         = 5,
	HidingProneLeft                          = 6,
	HidingProneRight                         = 7,
	HidingCrouch                             = 8,
	HidingContainer                          = 9,
	HidingBarrel                             = 10,
	EGrabType_MAX                            = 11,
};

// Enum OPP.EAttackType
// NumValues: 0x0010
enum class EAttackType : uint8
{
	None                                     = 0,
	Quick                                    = 1,
	QuickLow                                 = 2,
	PairedAnim                               = 3,
	Gun                                      = 4,
	BlockingAttack                           = 5,
	Push                                     = 6,
	Opener                                   = 7,
	Heavy                                    = 8,
	Punish                                   = 9,
	Grab                                     = 10,
	SpecificAnim                             = 11,
	Lunge                                    = 12,
	FixedLocation                            = 13,
	ImposterCharge                           = 14,
	EAttackType_MAX                          = 15,
};

// Enum OPP.ETraversalNotifyType
// NumValues: 0x0006
enum class ETraversalNotifyType : uint8
{
	IntroDone                                = 0,
	OutroDone                                = 1,
	ConditionalFall                          = 2,
	ConditionalLand                          = 3,
	Repulsion                                = 4,
	ETraversalNotifyType_MAX                 = 5,
};

// Enum OPP.EWeaponType
// NumValues: 0x0007
enum class EWeaponType : uint8
{
	None                                     = 0,
	Fist                                     = 1,
	Slash                                    = 2,
	Chop                                     = 3,
	LightBlunt                               = 4,
	HeavyBlunt                               = 5,
	EWeaponType_MAX                          = 6,
};

// Enum OPP.EItemAnimType
// NumValues: 0x000C
enum class EItemAnimType : uint8
{
	EmptyHanded                              = 0,
	OneHanded                                = 1,
	TwoHanded                                = 2,
	Syringe                                  = 3,
	PainKiller                               = 4,
	Bandage                                  = 5,
	Potion                                   = 6,
	RadioTransmitter                         = 7,
	Gun                                      = 8,
	AsthmaPump                               = 9,
	MotionDetection                          = 10,
	EItemAnimType_MAX                        = 11,
};

// Enum OPP.ERollingGateVariatorType
// NumValues: 0x0009
enum class ERollingGateVariatorType : uint8
{
	None                                     = 0,
	TimedOpenedClosed                        = 1,
	ClosesAfterNumberOfPassages              = 2,
	ToasterDetector                          = 3,
	Unlockable                               = 4,
	SoundDetector                            = 5,
	StageRandomMax                           = 6,
	RailObjectiveUnlockable                  = 7,
	ERollingGateVariatorType_MAX             = 8,
};

// Enum OPP.ERoomAssociationType
// NumValues: 0x000E
enum class ERoomAssociationType : uint8
{
	Default                                  = 0,
	Container                                = 1,
	Hidespot                                 = 2,
	JumpScare                                = 3,
	MonsterCloset                            = 4,
	Investigation                            = 5,
	TrapGroup                                = 6,
	Trap                                     = 7,
	PuzzleRoomNumberDecal                    = 8,
	PuzzleRoomLights                         = 9,
	PuzzleRoomLargePickupBox                 = 10,
	PuzzleRoomBlacklight                     = 11,
	KeySpawner                               = 12,
	Max                                      = 13,
};

// Enum OPP.EStageVariatorType
// NumValues: 0x0005
enum class EStageVariatorType : uint8
{
	SecondaryObjective                       = 0,
	Obstacle                                 = 1,
	RollingGate                              = 2,
	SAS                                      = 3,
	EStageVariatorType_MAX                   = 4,
};

// Enum OPP.ETriggeringStimulusType
// NumValues: 0x0006
enum class ETriggeringStimulusType : uint8
{
	MinorAudio                               = 0,
	NormalAudio                              = 1,
	ObviousAudio                             = 2,
	HighPriorityAudio                        = 3,
	Invalid                                  = 4,
	ETriggeringStimulusType_MAX              = 5,
};

// Enum OPP.ERetirementReason
// NumValues: 0x0009
enum class ERetirementReason : uint8
{
	None                                     = 0,
	RequestedByAIDirector                    = 1,
	ExplicitCommand                          = 2,
	TeleportFlee                             = 3,
	ReturnToLeashVolume                      = 4,
	SpecialistActivityCompleted              = 5,
	HitByProjectile                          = 6,
	HitByActiveSkill                         = 7,
	ERetirementReason_MAX                    = 8,
};

// Enum OPP.ENPCFlavor
// NumValues: 0x0004
enum class ENPCFlavor : uint8
{
	Normal                                   = 0,
	Light                                    = 1,
	Heavy                                    = 2,
	ENPCFlavor_MAX                           = 3,
};

// Enum OPP.ENPCInvestigationAnimCategory
// NumValues: 0x0006
enum class ENPCInvestigationAnimCategory : uint8
{
	None                                     = 0,
	Narrow                                   = 1,
	Wide                                     = 2,
	Broad                                    = 3,
	Ground                                   = 4,
	ENPCInvestigationAnimCategory_MAX        = 5,
};

// Enum OPP.ENPCInvestigationAnimIntensity
// NumValues: 0x0005
enum class ENPCInvestigationAnimIntensity : uint8
{
	None                                     = 0,
	Unaware                                  = 1,
	Suspicious                               = 2,
	Investigate                              = 3,
	ENPCInvestigationAnimIntensity_MAX       = 4,
};

// Enum OPP.EStartleSpeed
// NumValues: 0x0004
enum class EStartleSpeed : uint8
{
	Fast                                     = 0,
	Slow                                     = 1,
	Default                                  = 2,
	MAX                                      = 2,
};

// Enum OPP.EStartleVariation
// NumValues: 0x0004
enum class EStartleVariation : uint8
{
	ShootingWeapon                           = 0,
	ThrowingWeapon                           = 1,
	Default                                  = 2,
	MAX                                      = 2,
};

// Enum OPP.EStartleType
// NumValues: 0x0004
enum class EStartleType : uint8
{
	Alerted                                  = 0,
	Relaxed                                  = 1,
	Default                                  = 2,
	MAX                                      = 2,
};

// Enum OPP.EMonsterClosetSelectionMode
// NumValues: 0x0005
enum class EMonsterClosetSelectionMode : uint8
{
	Random                                   = 0,
	Quiet                                    = 1,
	CloseToTarget                            = 2,
	Explicit                                 = 3,
	EMonsterClosetSelectionMode_MAX          = 4,
};

// Enum OPP.EBotDoorPassBehavior
// NumValues: 0x0008
enum class EBotDoorPassBehavior : uint8
{
	NeverClose                               = 0,
	NeverUnlockNeverClose                    = 1,
	RandomCloseNeverLock                     = 2,
	AlwaysCloseUnlocked                      = 3,
	AlwaysCloseLocked                        = 4,
	AlwaysCloseRandomLock                    = 5,
	Random                                   = 6,
	EBotDoorPassBehavior_MAX                 = 7,
};

// Enum OPP.EAIDensityLevel
// NumValues: 0x0005
enum class EAIDensityLevel : uint8
{
	Normal                                   = 0,
	Low                                      = 1,
	High                                     = 2,
	VeryHigh                                 = 3,
	EAIDensityLevel_MAX                      = 4,
};

// Enum OPP.EGuardAttackType
// NumValues: 0x0005
enum class EGuardAttackType : uint8
{
	Attack                                   = 0,
	Push                                     = 1,
	GroundAndPound                           = 2,
	Kill                                     = 3,
	EGuardAttackType_MAX                     = 4,
};

// Enum OPP.EChaseMoveDestination
// NumValues: 0x000A
enum class EChaseMoveDestination : uint8
{
	Invalid                                  = 0,
	Player                                   = 1,
	AnticipatedPos                           = 2,
	LastKnownPos                             = 3,
	HidingSpot                               = 4,
	Pushable                                 = 5,
	ForcedLocation                           = 6,
	PathBlocking                             = 7,
	HoldingPosition                          = 8,
	EChaseMoveDestination_MAX                = 9,
};

// Enum OPP.EChaseSpecialState
// NumValues: 0x0005
enum class EChaseSpecialState : uint8
{
	None                                     = 0,
	PathBlocking                             = 1,
	Yielding                                 = 2,
	GivingUp                                 = 3,
	EChaseSpecialState_MAX                   = 4,
};

// Enum OPP.ENPCAnimStyle
// NumValues: 0x0006
enum class ENPCAnimStyle : uint8
{
	Relaxed                                  = 0,
	Suspicious                               = 1,
	Alerted                                  = 2,
	Chase                                    = 3,
	Combat                                   = 4,
	ENPCAnimStyle_MAX                        = 5,
};

// Enum OPP.EAlertedInvestigationPhase
// NumValues: 0x0008
enum class EAlertedInvestigationPhase : uint8
{
	InvestigatingStimulusSource              = 0,
	InvestigatingAround                      = 1,
	Idle                                     = 2,
	WaitingForValidInvestigationState        = 3,
	LeaveAmbientStation                      = 4,
	Startle                                  = 5,
	Invalid                                  = 6,
	EAlertedInvestigationPhase_MAX           = 7,
};

// Enum OPP.EAILogVerbosity
// NumValues: 0x0005
enum class EAILogVerbosity : uint8
{
	Verbose                                  = 0,
	Log                                      = 1,
	Event                                    = 2,
	Error                                    = 3,
	EAILogVerbosity_MAX                      = 4,
};

// Enum OPP.EVOEventResultType
// NumValues: 0x000D
enum class EVOEventResultType : uint8
{
	Undefined                                = 0,
	Played                                   = 1,
	NoMapping                                = 2,
	TooSoonAfterAnyVO                        = 3,
	TooSoonAfterSimilarVO                    = 4,
	TooSoonAfterSameVOOnPawn                 = 5,
	TooSoonAfterSameVOGlobal                 = 6,
	SkippedSelfInterrupt                     = 7,
	SkippedLowerPrio                         = 8,
	ConditionsFailed                         = 9,
	Queued                                   = 10,
	NoLine                                   = 11,
	EVOEventResultType_MAX                   = 12,
};

// Enum OPP.EVOContext
// NumValues: 0x006F
enum class EVOContext : uint8
{
	Undefined                                = 0,
	ReactToSoundDisturbanceAware             = 1,
	ReactToSoundDisturbanceUnaware           = 2,
	ReactToVisualDisturbanceAware            = 3,
	ReactToVisualDisturbanceUnaware          = 4,
	ReactToMajorDisturbance                  = 5,
	ReactToSensingDisturbance                = 6,
	InvestigateDisturbanceAware              = 7,
	InvestigateDisturbanceUnaware            = 8,
	InvestigatePoint                         = 9,
	ReachedInvestigationPoint                = 10,
	FinishedInvestigatingPoint               = 11,
	InvestigationGiveUp                      = 12,
	SuspiciousGiveUp                         = 13,
	AlertedGiveUp                            = 14,
	SawPlayerEnterHidingSpot                 = 15,
	FoundHiddenPlayer                        = 16,
	SearchForOtherPlayersAfterKnockDown      = 17,
	PullOutFromHidespot                      = 18,
	ReactToPlayerBeforeChase                 = 19,
	ReactToMultiplePlayersBeforeChase        = 20,
	StartChaseAfterReaction                  = 21,
	StartChaseNoReaction                     = 22,
	StartMoveToIncapacitatedPlayer           = 23,
	ChaseReachedLeashLimit                   = 24,
	ChaseStartGiveUp                         = 25,
	ChaseGiveUp                              = 26,
	ChaseStartYielding                       = 27,
	ChaseYield                               = 28,
	ChaseChangedTarget                       = 29,
	ChaseTaunt                               = 30,
	LostSightOfPlayer                        = 31,
	StartMoveToLostSight                     = 32,
	ReachedLastKnownPosition                 = 33,
	UnawarePlayerProximity                   = 34,
	ChasePlayerProximity                     = 35,
	ReachedPatrolWaypoint                    = 36,
	PassUnderDynamicObstacle                 = 37,
	EnterDarknessZone                        = 38,
	EnterLightZone                           = 39,
	AttackPlayer                             = 40,
	GuardingAttack                           = 41,
	PushPlayer                               = 42,
	ImposterCharge                           = 43,
	PusherAttack                             = 44,
	PairedAttackConnecting                   = 45,
	KnockedDownPlayer                        = 46,
	StartFinishingIncapacitatedPlayer        = 47,
	FinishIncapacitatedPlayer                = 48,
	DealtDamage                              = 49,
	KilledPlayer                             = 50,
	AttackOtherNPC                           = 51,
	AttackedByOtherNPC                       = 52,
	ThrowProjectile                          = 53,
	ThrownProjectileHit                      = 54,
	ThrownProjectileMiss                     = 55,
	TakeDamage                               = 56,
	HitByProjectile                          = 57,
	PairedAttackInterrupted                  = 58,
	HitReaction_Low                          = 59,
	HitReaction_Med                          = 60,
	HitReaction_High                         = 61,
	DelayedHitReaction                       = 62,
	ShovedByPlayerAware                      = 63,
	ShovedByPlayerUnaware                    = 64,
	ShovePunish                              = 65,
	KnockedOut                               = 66,
	GetUpFromKnockOut                        = 67,
	Killed                                   = 68,
	ProvocationWarning                       = 69,
	ProvokedByPlayer                         = 70,
	ReactToImperativeDisturbance             = 71,
	TurnOffImperativeDisturbance             = 72,
	SignalTackle                             = 73,
	FailedTackle                             = 74,
	SuccessfulTackle                         = 75,
	FinishedGroundAndPound                   = 76,
	PlayerAvoidanceStart                     = 77,
	PlayerAvoidanceRepath                    = 78,
	AcknowledgePlayer                        = 79,
	AcknowledgeOtherNPC                      = 80,
	ZoneDefenseBecomeAlert                   = 81,
	ZoneDefenseBlown                         = 82,
	ReactToCloseGrenade                      = 83,
	AffectedByStunGrenade                    = 84,
	RecoverFromStunGrenade                   = 85,
	AffectedByBlindPaint                     = 86,
	AffectedByHealSlowdown                   = 87,
	SleeperDisturbed                         = 88,
	SleeperScream                            = 89,
	StartRetirement                          = 90,
	RaisingWeapon                            = 91,
	GoryDeathStart                           = 92,
	Scripted                                 = 93,
	AnimNotify                               = 94,
	PawnState                                = 95,
	Announcer                                = 96,
	ContinuousVO                             = 97,
	Emote                                    = 98,
	ExitedMonsterCloset                      = 99,
	ReactToSoundDisturbance                  = 100,
	ReactToVisualDisturbance                 = 101,
	InvestigateDisturbance                   = 102,
	FirstAttack                              = 103,
	AttackAny                                = 104,
	PassiveRandom                            = 105,
	InvestigateRandomAware                   = 106,
	InvestigateRandomUnaware                 = 107,
	InvestigateRandom                        = 108,
	ChaseRandom                              = 109,
	MAX                                      = 110,
};

// Enum OPP.EInvestigationPointSelectionMode
// NumValues: 0x0004
enum class EInvestigationPointSelectionMode : uint8
{
	SelectionCriteria                        = 0,
	FullyRandom                              = 1,
	StrictOrder                              = 2,
	EInvestigationPointSelectionMode_MAX     = 3,
};

// Enum OPP.EInvestigationPointIrrelevanceReason
// NumValues: 0x000B
enum class EInvestigationPointIrrelevanceReason : uint8
{
	NoWeight                                 = 0,
	TooClose                                 = 1,
	FilteredOut                              = 2,
	FindingPlayerNotAllowed                  = 3,
	NotFindingPlayerThisTime                 = 4,
	ObstacleInPath                           = 5,
	TooCloseToOtherBot                       = 6,
	TooCloseToChasedPlayer                   = 7,
	ProhibitedByKismet                       = 8,
	DynamicStateIrrelevant                   = 9,
	EInvestigationPointIrrelevanceReason_MAX = 10,
};

// Enum OPP.EInvestigationPointType
// NumValues: 0x0007
enum class EInvestigationPointType : uint8
{
	None                                     = 0,
	SimpleLocation                           = 1,
	InvestigationPoint                       = 2,
	Door                                     = 3,
	HideSpot                                 = 4,
	SimpleInteract                           = 5,
	EInvestigationPointType_MAX              = 6,
};

// Enum OPP.EPatrolWaypointSelectionMode
// NumValues: 0x0007
enum class EPatrolWaypointSelectionMode : uint8
{
	Random                                   = 0,
	PingPong                                 = 1,
	IncrementingLoop                         = 2,
	IncrementingOnce                         = 3,
	DecrementingLoop                         = 4,
	DecrementingOnce                         = 5,
	EPatrolWaypointSelectionMode_MAX         = 6,
};

// Enum OPP.EAICommandType
// NumValues: 0x000A
enum class EAICommandType : uint8
{
	None                                     = 0,
	GotoLocation                             = 1,
	GotoWaypoint                             = 2,
	Patrol                                   = 3,
	Investigate                              = 4,
	PlayLoopingIdle                          = 5,
	PlaySingleShotAnim                       = 6,
	ScriptedAnimStation                      = 7,
	GotoAmbientMarker                        = 8,
	EAICommandType_MAX                       = 9,
};

// Enum OPP.EAISpectreVisualType
// NumValues: 0x0005
enum class EAISpectreVisualType : uint8
{
	None                                     = 0,
	CloseRange                               = 1,
	MediumRange                              = 2,
	FarRange                                 = 3,
	EAISpectreVisualType_MAX                 = 4,
};

// Enum OPP.EAIAttackClearanceType
// NumValues: 0x0006
enum class EAIAttackClearanceType : uint8
{
	Normal                                   = 0,
	FullBody                                 = 1,
	Grab                                     = 2,
	LowAttack                                = 3,
	Standing                                 = 4,
	EAIAttackClearanceType_MAX               = 5,
};

// Enum OPP.EAIActivity
// NumValues: 0x0014
enum class EAIActivity : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Ambient                                  = 2,
	Patrol                                   = 3,
	Retirement                               = 4,
	Sneak                                    = 5,
	SeekingHidingSpot                        = 6,
	Investigate                              = 7,
	InvestigateAggressive                    = 8,
	Chase                                    = 9,
	PlayerAvoidance                          = 10,
	ImperativeAction                         = 11,
	Ambush                                   = 12,
	MonsterCloset                            = 13,
	GroundAndPound                           = 14,
	Knockout                                 = 15,
	Scripted                                 = 16,
	Dead                                     = 17,
	Limbo                                    = 18,
	MAX                                      = 19,
};

// Enum OPP.EAIAwarenessStateType
// NumValues: 0x0009
enum class EAIAwarenessStateType : uint8
{
	None                                     = 0,
	Scripted                                 = 1,
	Ambient                                  = 2,
	Unaware                                  = 3,
	Suspicious                               = 4,
	Chase                                    = 5,
	Alerted                                  = 6,
	Sneak                                    = 7,
	EAIAwarenessStateType_MAX                = 8,
};

// Enum OPP.EQuestItemType
// NumValues: 0x0005
enum class EQuestItemType : uint8
{
	TypeA                                    = 0,
	TypeB                                    = 1,
	TypeC                                    = 2,
	TypeD                                    = 3,
	EQuestItemType_MAX                       = 4,
};

// Enum OPP.EPipeJunctionType
// NumValues: 0x0012
enum class EPipeJunctionType : uint8
{
	Cross                                    = 0,
	DoubleCurveLeft                          = 1,
	DoubleCurveRight                         = 2,
	OverUnderVertical                        = 3,
	OverUnderHorizontal                      = 4,
	Straight                                 = 5,
	Straight110cm                            = 6,
	Straight110cmSide                        = 7,
	StraightBroken                           = 8,
	SingleCurve_ForwardToRight               = 9,
	SingleCurve_RightToBack                  = 10,
	SingleCurve_BackToLeft                   = 11,
	SingleCurve_LeftToForward                = 12,
	T_Forward                                = 13,
	T_Right                                  = 14,
	T_Left                                   = 15,
	T_Backward                               = 16,
	EPipeJunctionType_MAX                    = 17,
};

// Enum OPP.EPeriodicHazardType
// NumValues: 0x0006
enum class EPeriodicHazardType : uint8
{
	ColdSnap                                 = 0,
	ColdFrost                                = 1,
	Psychosis                                = 2,
	Electric                                 = 3,
	Gas                                      = 4,
	EPeriodicHazardType_MAX                  = 5,
};

// Enum OPP.ERBVoiceChatMode
// NumValues: 0x0003
enum class ERBVoiceChatMode : uint8
{
	Party                                    = 0,
	Game                                     = 1,
	ERBVoiceChatMode_MAX                     = 2,
};

// Enum OPP.ERBVoiceChatEngineState
// NumValues: 0x0004
enum class ERBVoiceChatEngineState : uint8
{
	Disconnected                             = 0,
	Connecting                               = 1,
	Connected                                = 2,
	ERBVoiceChatEngineState_MAX              = 3,
};

// Enum OPP.EContinuousSoundNPCState
// NumValues: 0x000C
enum class EContinuousSoundNPCState : uint8
{
	None                                     = 0,
	Hiding                                   = 1,
	Unaware                                  = 2,
	Suspicious                               = 3,
	Alerted                                  = 4,
	Chase                                    = 5,
	AffectedByBrainAmp                       = 6,
	Normal                                   = 7,
	AffectedBySpineAmp                       = 8,
	AffectedByRagePaint                      = 9,
	AffectedByBlindPaint                     = 10,
	EContinuousSoundNPCState_MAX             = 11,
};

// Enum OPP.RBWaypointVersion
// NumValues: 0x0004
enum class ERBWaypointVersion : uint8
{
	Initial                                  = 0,
	MinMaxWaitTime                           = 1,
	Current                                  = 1,
	RBWaypointVersion_MAX                    = 2,
};

// Enum OPP.ETrapBatteryState
// NumValues: 0x0004
enum class ETrapBatteryState : uint8
{
	Armed                                    = 0,
	Disarmed                                 = 1,
	Destroyed                                = 2,
	ETrapBatteryState_MAX                    = 3,
};

// Enum OPP.EWorldPopulatingStepClient
// NumValues: 0x0013
enum class EWorldPopulatingStepClient : uint8
{
	None                                     = 0,
	WorldPopulate_Start                      = 1,
	PopulateInterfaceObjectWorldFullyLoaded  = 2,
	BuildRegisterNavmeshActorList            = 3,
	RegisterNavmeshActors                    = 4,
	PopulateMissionActorManagers             = 5,
	InitializeRoomData                       = 6,
	BuildRoomCaches                          = 7,
	LinkRoomConnectors                       = 8,
	AssociateRooms                           = 9,
	BuildRoomGroupsCaches                    = 10,
	ApplyRandomizedSharedStates              = 11,
	PopulateLightCaches                      = 12,
	PopulateInterfaceObjectPostPopulate      = 13,
	RemovingNavigationBuildingLock           = 14,
	BuildingRoomPaths                        = 15,
	PopulateLedgeMarkers                     = 16,
	WorldPopulate_Done                       = 17,
	EWorldPopulatingStepClient_MAX           = 18,
};

// Enum OPP.EWorldPopulatingStep
// NumValues: 0x003C
enum class EWorldPopulatingStep : uint8
{
	None                                     = 0,
	WorldPopulate_Start                      = 1,
	PopulateInterfaceObjectWorldFullyLoaded  = 2,
	BuildRegisterNavmeshActorList            = 3,
	RegisterNavmeshActors                    = 4,
	PopulateGameMode                         = 5,
	PopulateMissionActorManagers             = 6,
	InitializeRoomData                       = 7,
	BuildRoomCaches                          = 8,
	LinkRoomConnectors                       = 9,
	AssociateRooms                           = 10,
	BuildRoomGroupsCaches                    = 11,
	PrepareMissionRoomGroups                 = 12,
	PopulateMissionRoomGroups                = 13,
	PopulateObjectiveManager                 = 14,
	SortRandomizedArrays                     = 15,
	PrepareRandomManager                     = 16,
	PrepareObjectiveCoordinators             = 17,
	Editor_ValidateBlockable                 = 18,
	RandomizeObjectiveRails                  = 19,
	RandomizeObjectiveClosedRooms            = 20,
	PopulatePuzzleRooms                      = 21,
	PopulateRewardRooms                      = 22,
	RandomizeManagers_Gates                  = 23,
	RandomizeBlockableStage                  = 24,
	RandomizeBlockableRoomGroups             = 25,
	RandomizeDoorsStage                      = 26,
	RandomizeDoorsRoomGroups                 = 27,
	RandomizeRollingGateVariator             = 28,
	PopulateRollingGateVariator              = 29,
	PopulateObjectiveCoordinators            = 30,
	SetupObjectiveCoordinators               = 31,
	PopulateSecondaryObjectiveCoordinators   = 32,
	SetupSecondaryObjectiveCoordinators      = 33,
	RandomizeHidespotsStage                  = 34,
	RandomizeHidespotsRoomGroups             = 35,
	ComputeObjectiveProximity                = 36,
	RandomizeManagers_Traps                  = 37,
	ComputeObstacleCount                     = 38,
	TrapGroups                               = 39,
	ObstacleVariatorTraps                    = 40,
	ComputeTrapProximity                     = 41,
	PopulateRandomManagers                   = 42,
	ApplyRandomizedSharedStates              = 43,
	PopulateActors                           = 44,
	SpawnExtraPickables                      = 45,
	PopulateItemManagers                     = 46,
	PopulateLightCaches                      = 47,
	PopulateInterfaceObjectPostPopulate      = 48,
	RemovingNavigationBuildingLock           = 49,
	BuildingRoomPaths                        = 50,
	WaitingForNavMeshBuild                   = 51,
	PopulateLedgeMarkers                     = 52,
	PopulateWaypointGroups                   = 53,
	PopulateAISpawnersInit                   = 54,
	PopulatingAIDirector                     = 55,
	PopulateAISpawnersSpawn                  = 56,
	PopulateWaitForServerConfiguration       = 57,
	WorldPopulate_Done                       = 58,
	EWorldPopulatingStep_MAX                 = 59,
};

// Enum OPP.EWWWPlaybackSpeed
// NumValues: 0x0007
enum class EWWWPlaybackSpeed : uint8
{
	Speed1x                                  = 0,
	Speed2x                                  = 1,
	Speed4x                                  = 2,
	Speed8x                                  = 3,
	Speed16x                                 = 4,
	Speed32x                                 = 5,
	EWWWPlaybackSpeed_MAX                    = 6,
};

// Enum OPP.EWWWTrackDrawLength
// NumValues: 0x0007
enum class EWWWTrackDrawLength : uint8
{
	Unlimited                                = 0,
	Last5s                                   = 1,
	Last10s                                  = 2,
	Last30s                                  = 3,
	LastMin                                  = 4,
	Last5Min                                 = 5,
	EWWWTrackDrawLength_MAX                  = 6,
};

// Enum OPP.EWWWTrackDrawSelection
// NumValues: 0x0004
enum class EWWWTrackDrawSelection : uint8
{
	All                                      = 0,
	Focused                                  = 1,
	None                                     = 2,
	EWWWTrackDrawSelection_MAX               = 3,
};

// Enum OPP.ERelationshipErrorCodes
// NumValues: 0x0007
enum class ERelationshipErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	MaximumFriendsReached                    = 1,
	MaximumSentFriendRequestsReached         = 2,
	MaximumPendingFriendRequestsReached      = 3,
	FriendRequestNotFound                    = 4,
	InvalidRelationship                      = 5,
	ERelationshipErrorCodes_MAX              = 6,
};

// Enum OPP.ERTAErrorCodes
// NumValues: 0x0005
enum class ERTAErrorCodes : uint8
{
	MissingBaseServiceUrl                    = 0,
	ConnectionFailed                         = 1,
	ConnectionClosed                         = 2,
	InvalidIncomingMessageFormat             = 3,
	ERTAErrorCodes_MAX                       = 4,
};

// Enum OPP.EStatsErrorCodes
// NumValues: 0x0002
enum class EStatsErrorCodes : uint8
{
	Dummy                                    = 0,
	EStatsErrorCodes_MAX                     = 1,
};

// Enum OPP.EStoreErrorCodes
// NumValues: 0x000D
enum class EStoreErrorCodes : uint8
{
	OrderFailed_Generic                      = 0,
	OrderFailed_NotApprovedByUser            = 1,
	OrderFailed_UserNotLoggedIn              = 2,
	OrderFailed_AccountUnavailable           = 3,
	OrderFailed_TransactionDenied            = 4,
	OrderFailed_TransactionDeniedRestrictedCountry = 5,
	OrderFailed_InsufficientFunds            = 6,
	OrderFailed_FinalizationTimeLimitExceeded = 7,
	OrderFailed_AccountDisabled              = 8,
	OrderFailed_AccountNotAllowedPurchase    = 9,
	OrderFailed_TransactionDeniedFraudDetection = 10,
	OrderFailed_NoCachedPaymentMethod        = 11,
	OrderFailed_MAX                          = 12,
};

// ScriptStruct OPP.AIPerPlayerTraceInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FAIPerPlayerTraceInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPerPlayerTraceInfo) == 0x000004, "Wrong alignment on FAIPerPlayerTraceInfo");
static_assert(sizeof(FAIPerPlayerTraceInfo) == 0x000020, "Wrong size on FAIPerPlayerTraceInfo");

// ScriptStruct OPP.AIPerPlayerDebugData
// 0x00A0 (0x00A0 - 0x0000)
struct FAIPerPlayerDebugData final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerVisibilityType                         VisibilityType;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibilityModifier;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerVisibilityState                        CurrentVisibilityState;                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIPerPlayerTraceInfo                  LastEyeTraceInfo;                                  // 0x0014(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPerPlayerTraceInfo                  LastTorsoTraceInfo;                                // 0x0034(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastPlayerVisionUpdatedTime;                       // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioOcclusion;                                    // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathedDistance;                                    // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSeenLocation;                                  // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastVisibleLocation;                               // 0x006C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastHeardLocation;                                 // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnticipatedLocationWhenVisibilityWasLost;          // 0x0084(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAwarenessState                         AwarenessState;                                    // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAwareOfSpecialLocation;                           // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvisibleCheat;                                   // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerOutsideLeash;                               // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerUnreachable;                                // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceIgnorePlayerUntilTime;                        // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceAwarenessUntilTime;                           // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPerPlayerDebugData) == 0x000008, "Wrong alignment on FAIPerPlayerDebugData");
static_assert(sizeof(FAIPerPlayerDebugData) == 0x0000A0, "Wrong size on FAIPerPlayerDebugData");
static_assert(offsetof(FAIPerPlayerDebugData, Player) == 0x000000, "Member 'FAIPerPlayerDebugData::Player' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, VisibilityType) == 0x000008, "Member 'FAIPerPlayerDebugData::VisibilityType' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, VisibilityModifier) == 0x00000C, "Member 'FAIPerPlayerDebugData::VisibilityModifier' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, CurrentVisibilityState) == 0x000010, "Member 'FAIPerPlayerDebugData::CurrentVisibilityState' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastEyeTraceInfo) == 0x000014, "Member 'FAIPerPlayerDebugData::LastEyeTraceInfo' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastTorsoTraceInfo) == 0x000034, "Member 'FAIPerPlayerDebugData::LastTorsoTraceInfo' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastPlayerVisionUpdatedTime) == 0x000054, "Member 'FAIPerPlayerDebugData::LastPlayerVisionUpdatedTime' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, AudioOcclusion) == 0x000058, "Member 'FAIPerPlayerDebugData::AudioOcclusion' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, PathedDistance) == 0x00005C, "Member 'FAIPerPlayerDebugData::PathedDistance' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastSeenLocation) == 0x000060, "Member 'FAIPerPlayerDebugData::LastSeenLocation' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastVisibleLocation) == 0x00006C, "Member 'FAIPerPlayerDebugData::LastVisibleLocation' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, LastHeardLocation) == 0x000078, "Member 'FAIPerPlayerDebugData::LastHeardLocation' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, AnticipatedLocationWhenVisibilityWasLost) == 0x000084, "Member 'FAIPerPlayerDebugData::AnticipatedLocationWhenVisibilityWasLost' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, AwarenessState) == 0x000090, "Member 'FAIPerPlayerDebugData::AwarenessState' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, bAwareOfSpecialLocation) == 0x000091, "Member 'FAIPerPlayerDebugData::bAwareOfSpecialLocation' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, bInvisibleCheat) == 0x000092, "Member 'FAIPerPlayerDebugData::bInvisibleCheat' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, bPlayerOutsideLeash) == 0x000093, "Member 'FAIPerPlayerDebugData::bPlayerOutsideLeash' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, bPlayerUnreachable) == 0x000094, "Member 'FAIPerPlayerDebugData::bPlayerUnreachable' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, ForceIgnorePlayerUntilTime) == 0x000098, "Member 'FAIPerPlayerDebugData::ForceIgnorePlayerUntilTime' has a wrong offset!");
static_assert(offsetof(FAIPerPlayerDebugData, ForceAwarenessUntilTime) == 0x00009C, "Member 'FAIPerPlayerDebugData::ForceAwarenessUntilTime' has a wrong offset!");

// ScriptStruct OPP.BCAnimatedStartData
// 0x0030 (0x0030 - 0x0000)
struct FBCAnimatedStartData final
{
public:
	class UAnimSequence*                          RefStartAnim;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBCAnimatedStartData) == 0x000008, "Wrong alignment on FBCAnimatedStartData");
static_assert(sizeof(FBCAnimatedStartData) == 0x000030, "Wrong size on FBCAnimatedStartData");
static_assert(offsetof(FBCAnimatedStartData, RefStartAnim) == 0x000000, "Member 'FBCAnimatedStartData::RefStartAnim' has a wrong offset!");

// ScriptStruct OPP.TrialChainingWeightedUpgradeType
// 0x0008 (0x0008 - 0x0000)
struct FTrialChainingWeightedUpgradeType final
{
public:
	ETrialChainingUpgradeType                     UpgradeType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingWeightedUpgradeType) == 0x000004, "Wrong alignment on FTrialChainingWeightedUpgradeType");
static_assert(sizeof(FTrialChainingWeightedUpgradeType) == 0x000008, "Wrong size on FTrialChainingWeightedUpgradeType");
static_assert(offsetof(FTrialChainingWeightedUpgradeType, UpgradeType) == 0x000000, "Member 'FTrialChainingWeightedUpgradeType::UpgradeType' has a wrong offset!");
static_assert(offsetof(FTrialChainingWeightedUpgradeType, Weight) == 0x000004, "Member 'FTrialChainingWeightedUpgradeType::Weight' has a wrong offset!");

// ScriptStruct OPP.RBPlayerCustomizationInfo
// 0x0050 (0x0050 - 0x0000)
struct FRBPlayerCustomizationInfo final
{
public:
	class URBCustomizationOutfit*                 LegendaryOutfit;                                   // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBPlayerCustomizationOption*>   Options;                                           // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class URBVoiceCustomizationOption*            VoiceOption;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconOption;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconBorderOption;                            // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBEmoteCustomizationOption*            PodiumEmoteOption;                                 // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBEmoteCustomizationOption*            TerminalEmoteOption;                               // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HairColor;                                         // 0x0044(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerCustomizationInfo) == 0x000008, "Wrong alignment on FRBPlayerCustomizationInfo");
static_assert(sizeof(FRBPlayerCustomizationInfo) == 0x000050, "Wrong size on FRBPlayerCustomizationInfo");
static_assert(offsetof(FRBPlayerCustomizationInfo, LegendaryOutfit) == 0x000000, "Member 'FRBPlayerCustomizationInfo::LegendaryOutfit' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, Options) == 0x000008, "Member 'FRBPlayerCustomizationInfo::Options' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, VoiceOption) == 0x000018, "Member 'FRBPlayerCustomizationInfo::VoiceOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, PlayerIconOption) == 0x000020, "Member 'FRBPlayerCustomizationInfo::PlayerIconOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, PlayerIconBorderOption) == 0x000028, "Member 'FRBPlayerCustomizationInfo::PlayerIconBorderOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, PodiumEmoteOption) == 0x000030, "Member 'FRBPlayerCustomizationInfo::PodiumEmoteOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, TerminalEmoteOption) == 0x000038, "Member 'FRBPlayerCustomizationInfo::TerminalEmoteOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, bIsFemale) == 0x000040, "Member 'FRBPlayerCustomizationInfo::bIsFemale' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationInfo, HairColor) == 0x000044, "Member 'FRBPlayerCustomizationInfo::HairColor' has a wrong offset!");

// ScriptStruct OPP.NPCAnimatedStopData
// 0x0078 (0x0078 - 0x0000)
struct FNPCAnimatedStopData final
{
public:
	bool                                          bImmediateStop;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSpeed;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalStopDistance;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetYaw;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStartTime;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAggressiveStance;                                 // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartPosition;                                     // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartYaw;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSteeringYaw;                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NaturalYawAtDestination;                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAnimatedStopData) == 0x000004, "Wrong alignment on FNPCAnimatedStopData");
static_assert(sizeof(FNPCAnimatedStopData) == 0x000078, "Wrong size on FNPCAnimatedStopData");
static_assert(offsetof(FNPCAnimatedStopData, bImmediateStop) == 0x000000, "Member 'FNPCAnimatedStopData::bImmediateStop' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, StartSpeed) == 0x000004, "Member 'FNPCAnimatedStopData::StartSpeed' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, FinalStopDistance) == 0x000008, "Member 'FNPCAnimatedStopData::FinalStopDistance' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, TargetYaw) == 0x00000C, "Member 'FNPCAnimatedStopData::TargetYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, AnimStartTime) == 0x000010, "Member 'FNPCAnimatedStopData::AnimStartTime' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, bAggressiveStance) == 0x000014, "Member 'FNPCAnimatedStopData::bAggressiveStance' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, StartPosition) == 0x000018, "Member 'FNPCAnimatedStopData::StartPosition' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, StartYaw) == 0x000024, "Member 'FNPCAnimatedStopData::StartYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, StartingSteeringYaw) == 0x000028, "Member 'FNPCAnimatedStopData::StartingSteeringYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStopData, NaturalYawAtDestination) == 0x00002C, "Member 'FNPCAnimatedStopData::NaturalYawAtDestination' has a wrong offset!");

// ScriptStruct OPP.RecordedScoringEvent
// 0x001C (0x001C - 0x0000)
struct FRecordedScoringEvent final
{
public:
	class FName                                   RuleId;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MurkoffDollars;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumEvents;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEventTime;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecordedScoringEvent) == 0x000004, "Wrong alignment on FRecordedScoringEvent");
static_assert(sizeof(FRecordedScoringEvent) == 0x00001C, "Wrong size on FRecordedScoringEvent");
static_assert(offsetof(FRecordedScoringEvent, RuleId) == 0x000000, "Member 'FRecordedScoringEvent::RuleId' has a wrong offset!");
static_assert(offsetof(FRecordedScoringEvent, Score) == 0x000008, "Member 'FRecordedScoringEvent::Score' has a wrong offset!");
static_assert(offsetof(FRecordedScoringEvent, Xp) == 0x00000C, "Member 'FRecordedScoringEvent::Xp' has a wrong offset!");
static_assert(offsetof(FRecordedScoringEvent, MurkoffDollars) == 0x000010, "Member 'FRecordedScoringEvent::MurkoffDollars' has a wrong offset!");
static_assert(offsetof(FRecordedScoringEvent, NumEvents) == 0x000014, "Member 'FRecordedScoringEvent::NumEvents' has a wrong offset!");
static_assert(offsetof(FRecordedScoringEvent, LastEventTime) == 0x000018, "Member 'FRecordedScoringEvent::LastEventTime' has a wrong offset!");

// ScriptStruct OPP.ScoringPlayerDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FScoringPlayerDebugInfo final
{
public:
	class ARBPlayerState*                         RBPlayerState;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRecordedScoringEvent>          RecordedScoringEvents;                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringPlayerDebugInfo) == 0x000008, "Wrong alignment on FScoringPlayerDebugInfo");
static_assert(sizeof(FScoringPlayerDebugInfo) == 0x000028, "Wrong size on FScoringPlayerDebugInfo");
static_assert(offsetof(FScoringPlayerDebugInfo, RBPlayerState) == 0x000000, "Member 'FScoringPlayerDebugInfo::RBPlayerState' has a wrong offset!");
static_assert(offsetof(FScoringPlayerDebugInfo, PlayerName) == 0x000008, "Member 'FScoringPlayerDebugInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FScoringPlayerDebugInfo, RecordedScoringEvents) == 0x000018, "Member 'FScoringPlayerDebugInfo::RecordedScoringEvents' has a wrong offset!");

// ScriptStruct OPP.RBPlayerId
// 0x0010 (0x0010 - 0x0000)
struct FRBPlayerId final
{
public:
	class FString                                 IdStr;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRBPlayerId) == 0x000008, "Wrong alignment on FRBPlayerId");
static_assert(sizeof(FRBPlayerId) == 0x000010, "Wrong size on FRBPlayerId");
static_assert(offsetof(FRBPlayerId, IdStr) == 0x000000, "Member 'FRBPlayerId::IdStr' has a wrong offset!");

// ScriptStruct OPP.HallucinationData
// 0x0050 (0x0050 - 0x0000)
struct FHallucinationData final
{
public:
	EHallucinationType                            Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              TargetPlayer;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBHallucinationConfig*                 Config;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetIntensity;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestartingActiveHallu;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBNPC*                                 SpectreNPC;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertedAngle;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BurstTimestamp;                                    // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHallucinationData) == 0x000008, "Wrong alignment on FHallucinationData");
static_assert(sizeof(FHallucinationData) == 0x000050, "Wrong size on FHallucinationData");
static_assert(offsetof(FHallucinationData, Type) == 0x000000, "Member 'FHallucinationData::Type' has a wrong offset!");
static_assert(offsetof(FHallucinationData, TargetPlayer) == 0x000008, "Member 'FHallucinationData::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FHallucinationData, Config) == 0x000010, "Member 'FHallucinationData::Config' has a wrong offset!");
static_assert(offsetof(FHallucinationData, Duration) == 0x000018, "Member 'FHallucinationData::Duration' has a wrong offset!");
static_assert(offsetof(FHallucinationData, TargetIntensity) == 0x00001C, "Member 'FHallucinationData::TargetIntensity' has a wrong offset!");
static_assert(offsetof(FHallucinationData, bRestartingActiveHallu) == 0x000020, "Member 'FHallucinationData::bRestartingActiveHallu' has a wrong offset!");
static_assert(offsetof(FHallucinationData, SpectreNPC) == 0x000028, "Member 'FHallucinationData::SpectreNPC' has a wrong offset!");
static_assert(offsetof(FHallucinationData, bInvertedAngle) == 0x000030, "Member 'FHallucinationData::bInvertedAngle' has a wrong offset!");
static_assert(offsetof(FHallucinationData, BurstTimestamp) == 0x000048, "Member 'FHallucinationData::BurstTimestamp' has a wrong offset!");

// ScriptStruct OPP.NPCAmbientPropData
// 0x0018 (0x0018 - 0x0000)
struct FNPCAmbientPropData final
{
public:
	class UPrimitiveComponent*                    PropComponent;                                     // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PropStaticMesh;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBone;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCAmbientPropData) == 0x000008, "Wrong alignment on FNPCAmbientPropData");
static_assert(sizeof(FNPCAmbientPropData) == 0x000018, "Wrong size on FNPCAmbientPropData");
static_assert(offsetof(FNPCAmbientPropData, PropComponent) == 0x000000, "Member 'FNPCAmbientPropData::PropComponent' has a wrong offset!");
static_assert(offsetof(FNPCAmbientPropData, PropStaticMesh) == 0x000008, "Member 'FNPCAmbientPropData::PropStaticMesh' has a wrong offset!");
static_assert(offsetof(FNPCAmbientPropData, AttachBone) == 0x000010, "Member 'FNPCAmbientPropData::AttachBone' has a wrong offset!");

// ScriptStruct OPP.NPCAmbientConfig
// 0x0160 (0x0160 - 0x0000)
struct FNPCAmbientConfig final
{
public:
	struct FGameplayTagContainer                  EnableOnlyForNPCTags;                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DisableForNPCTags;                                 // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EntryAnim;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        IdleAnim;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ActiveStateBS;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        PassiveToActiveBS;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ActiveToPassiveBS;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReactionToJammerAnim;                              // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  IdleBreakers;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IdleBreakerBlendInTime;                            // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleBreakerBlendOutTime;                           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ExitAnimNormal;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DisturbanceAnim;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  DisturbanceVariations;                             // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRequiresExitAnimWhenStarted;                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ExitAnimDisturbed;                                 // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalExitOnCycleEnd;                             // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullVisibilityVisionRangeMultiplier;               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartialVisibilityVisionRangeMultiplier;            // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnwareDetectionMeterIncreaseMultiplier;            // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOmnidirectional;                                  // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideIdleDuration;                             // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverriddenMinDuration;                             // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverriddenMaxDuration;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHitReaction;                                 // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecenterCollisionOnHips;                          // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockNavmesh;                                     // 0x00D6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomVisionBoneTransform;                     // 0x00D7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CustomVisionBoneTransform;                         // 0x00E0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLookAtPlayer;                                     // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAngleRangeLeft;                              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAngleRangeRight;                             // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtDistanceRange;                               // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtApproachCoeff;                               // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartSoundEvent;                                   // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopSoundEvent;                                    // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAnchorReference;                              // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawVisionRange;                                  // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x2];                                      // 0x013A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviewAnimTime;                                   // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviewSadFaceHeightOffset;                        // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCAmbientPropData                    AmbientPropData;                                   // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCAmbientConfig) == 0x000010, "Wrong alignment on FNPCAmbientConfig");
static_assert(sizeof(FNPCAmbientConfig) == 0x000160, "Wrong size on FNPCAmbientConfig");
static_assert(offsetof(FNPCAmbientConfig, EnableOnlyForNPCTags) == 0x000000, "Member 'FNPCAmbientConfig::EnableOnlyForNPCTags' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, DisableForNPCTags) == 0x000020, "Member 'FNPCAmbientConfig::DisableForNPCTags' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, EntryAnim) == 0x000040, "Member 'FNPCAmbientConfig::EntryAnim' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, IdleAnim) == 0x000048, "Member 'FNPCAmbientConfig::IdleAnim' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, ActiveStateBS) == 0x000050, "Member 'FNPCAmbientConfig::ActiveStateBS' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, PassiveToActiveBS) == 0x000058, "Member 'FNPCAmbientConfig::PassiveToActiveBS' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, ActiveToPassiveBS) == 0x000060, "Member 'FNPCAmbientConfig::ActiveToPassiveBS' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, ReactionToJammerAnim) == 0x000068, "Member 'FNPCAmbientConfig::ReactionToJammerAnim' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, IdleBreakers) == 0x000070, "Member 'FNPCAmbientConfig::IdleBreakers' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, IdleBreakerBlendInTime) == 0x000080, "Member 'FNPCAmbientConfig::IdleBreakerBlendInTime' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, IdleBreakerBlendOutTime) == 0x000084, "Member 'FNPCAmbientConfig::IdleBreakerBlendOutTime' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, ExitAnimNormal) == 0x000088, "Member 'FNPCAmbientConfig::ExitAnimNormal' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, DisturbanceAnim) == 0x000090, "Member 'FNPCAmbientConfig::DisturbanceAnim' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, DisturbanceVariations) == 0x000098, "Member 'FNPCAmbientConfig::DisturbanceVariations' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bRequiresExitAnimWhenStarted) == 0x0000A8, "Member 'FNPCAmbientConfig::bRequiresExitAnimWhenStarted' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, ExitAnimDisturbed) == 0x0000B0, "Member 'FNPCAmbientConfig::ExitAnimDisturbed' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bNormalExitOnCycleEnd) == 0x0000B8, "Member 'FNPCAmbientConfig::bNormalExitOnCycleEnd' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, FullVisibilityVisionRangeMultiplier) == 0x0000BC, "Member 'FNPCAmbientConfig::FullVisibilityVisionRangeMultiplier' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, PartialVisibilityVisionRangeMultiplier) == 0x0000C0, "Member 'FNPCAmbientConfig::PartialVisibilityVisionRangeMultiplier' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, UnwareDetectionMeterIncreaseMultiplier) == 0x0000C4, "Member 'FNPCAmbientConfig::UnwareDetectionMeterIncreaseMultiplier' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bOmnidirectional) == 0x0000C8, "Member 'FNPCAmbientConfig::bOmnidirectional' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bOverrideIdleDuration) == 0x0000C9, "Member 'FNPCAmbientConfig::bOverrideIdleDuration' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, OverriddenMinDuration) == 0x0000CC, "Member 'FNPCAmbientConfig::OverriddenMinDuration' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, OverriddenMaxDuration) == 0x0000D0, "Member 'FNPCAmbientConfig::OverriddenMaxDuration' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bAllowHitReaction) == 0x0000D4, "Member 'FNPCAmbientConfig::bAllowHitReaction' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bRecenterCollisionOnHips) == 0x0000D5, "Member 'FNPCAmbientConfig::bRecenterCollisionOnHips' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bBlockNavmesh) == 0x0000D6, "Member 'FNPCAmbientConfig::bBlockNavmesh' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bUseCustomVisionBoneTransform) == 0x0000D7, "Member 'FNPCAmbientConfig::bUseCustomVisionBoneTransform' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, CustomVisionBoneTransform) == 0x0000E0, "Member 'FNPCAmbientConfig::CustomVisionBoneTransform' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bLookAtPlayer) == 0x000110, "Member 'FNPCAmbientConfig::bLookAtPlayer' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, LookAtAngleRangeLeft) == 0x000114, "Member 'FNPCAmbientConfig::LookAtAngleRangeLeft' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, LookAtAngleRangeRight) == 0x000118, "Member 'FNPCAmbientConfig::LookAtAngleRangeRight' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, LookAtDistanceRange) == 0x00011C, "Member 'FNPCAmbientConfig::LookAtDistanceRange' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, LookAtApproachCoeff) == 0x000120, "Member 'FNPCAmbientConfig::LookAtApproachCoeff' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, StartSoundEvent) == 0x000128, "Member 'FNPCAmbientConfig::StartSoundEvent' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, StopSoundEvent) == 0x000130, "Member 'FNPCAmbientConfig::StopSoundEvent' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bDrawAnchorReference) == 0x000138, "Member 'FNPCAmbientConfig::bDrawAnchorReference' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, bDrawVisionRange) == 0x000139, "Member 'FNPCAmbientConfig::bDrawVisionRange' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, PreviewAnimTime) == 0x00013C, "Member 'FNPCAmbientConfig::PreviewAnimTime' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, PreviewSadFaceHeightOffset) == 0x000140, "Member 'FNPCAmbientConfig::PreviewSadFaceHeightOffset' has a wrong offset!");
static_assert(offsetof(FNPCAmbientConfig, AmbientPropData) == 0x000148, "Member 'FNPCAmbientConfig::AmbientPropData' has a wrong offset!");

// ScriptStruct OPP.LookingIdlesAnimParams
// 0x0030 (0x0030 - 0x0000)
struct FLookingIdlesAnimParams final
{
public:
	class UAnimSequence*                          RelaxIdle;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RelaxLook;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlertIdle;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AlertLook;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AlertToRelax;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        RelaxToAlert;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookingIdlesAnimParams) == 0x000008, "Wrong alignment on FLookingIdlesAnimParams");
static_assert(sizeof(FLookingIdlesAnimParams) == 0x000030, "Wrong size on FLookingIdlesAnimParams");
static_assert(offsetof(FLookingIdlesAnimParams, RelaxIdle) == 0x000000, "Member 'FLookingIdlesAnimParams::RelaxIdle' has a wrong offset!");
static_assert(offsetof(FLookingIdlesAnimParams, RelaxLook) == 0x000008, "Member 'FLookingIdlesAnimParams::RelaxLook' has a wrong offset!");
static_assert(offsetof(FLookingIdlesAnimParams, AlertIdle) == 0x000010, "Member 'FLookingIdlesAnimParams::AlertIdle' has a wrong offset!");
static_assert(offsetof(FLookingIdlesAnimParams, AlertLook) == 0x000018, "Member 'FLookingIdlesAnimParams::AlertLook' has a wrong offset!");
static_assert(offsetof(FLookingIdlesAnimParams, AlertToRelax) == 0x000020, "Member 'FLookingIdlesAnimParams::AlertToRelax' has a wrong offset!");
static_assert(offsetof(FLookingIdlesAnimParams, RelaxToAlert) == 0x000028, "Member 'FLookingIdlesAnimParams::RelaxToAlert' has a wrong offset!");

// ScriptStruct OPP.DamageParameters
// 0x0014 (0x0014 - 0x0000)
struct FDamageParameters final
{
public:
	bool                                          bCanReact;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKnockdown;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKill;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBloodParticles;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScreenBloodColumns;                               // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDamageBoost;                                   // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCausesBleeding;                                   // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHurtVOType                                   LowDamageVO;                                       // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHurtVOType                                   MediumDamageVO;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHurtVOType                                   HighDamageVO;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HurtVOStopDelay;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageSoundMaterial                          DamageSoundMaterial;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageParameters) == 0x000004, "Wrong alignment on FDamageParameters");
static_assert(sizeof(FDamageParameters) == 0x000014, "Wrong size on FDamageParameters");
static_assert(offsetof(FDamageParameters, bCanReact) == 0x000000, "Member 'FDamageParameters::bCanReact' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bCanKnockdown) == 0x000001, "Member 'FDamageParameters::bCanKnockdown' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bCanKill) == 0x000002, "Member 'FDamageParameters::bCanKill' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bBloodParticles) == 0x000003, "Member 'FDamageParameters::bBloodParticles' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bScreenBloodColumns) == 0x000004, "Member 'FDamageParameters::bScreenBloodColumns' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bCanDamageBoost) == 0x000005, "Member 'FDamageParameters::bCanDamageBoost' has a wrong offset!");
static_assert(offsetof(FDamageParameters, bCausesBleeding) == 0x000006, "Member 'FDamageParameters::bCausesBleeding' has a wrong offset!");
static_assert(offsetof(FDamageParameters, LowDamageVO) == 0x000007, "Member 'FDamageParameters::LowDamageVO' has a wrong offset!");
static_assert(offsetof(FDamageParameters, MediumDamageVO) == 0x000008, "Member 'FDamageParameters::MediumDamageVO' has a wrong offset!");
static_assert(offsetof(FDamageParameters, HighDamageVO) == 0x000009, "Member 'FDamageParameters::HighDamageVO' has a wrong offset!");
static_assert(offsetof(FDamageParameters, HurtVOStopDelay) == 0x00000C, "Member 'FDamageParameters::HurtVOStopDelay' has a wrong offset!");
static_assert(offsetof(FDamageParameters, DamageSoundMaterial) == 0x000010, "Member 'FDamageParameters::DamageSoundMaterial' has a wrong offset!");

// ScriptStruct OPP.DamageInfo
// 0x0050 (0x0050 - 0x0000)
struct FDamageInfo final
{
public:
	EDamageType                                   Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageParameters                      Params;                                            // 0x0004(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ENPCWeapon                                    NPCWeaponType;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialHealth;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DmgAmount;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DmgLocation;                                       // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DmgDirection;                                      // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SrcActor;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceKill;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnTime;                                          // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageInfo) == 0x000008, "Wrong alignment on FDamageInfo");
static_assert(sizeof(FDamageInfo) == 0x000050, "Wrong size on FDamageInfo");
static_assert(offsetof(FDamageInfo, Type) == 0x000000, "Member 'FDamageInfo::Type' has a wrong offset!");
static_assert(offsetof(FDamageInfo, Params) == 0x000004, "Member 'FDamageInfo::Params' has a wrong offset!");
static_assert(offsetof(FDamageInfo, NPCWeaponType) == 0x000018, "Member 'FDamageInfo::NPCWeaponType' has a wrong offset!");
static_assert(offsetof(FDamageInfo, InitialHealth) == 0x00001C, "Member 'FDamageInfo::InitialHealth' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DmgAmount) == 0x000020, "Member 'FDamageInfo::DmgAmount' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DmgLocation) == 0x000024, "Member 'FDamageInfo::DmgLocation' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DmgDirection) == 0x000030, "Member 'FDamageInfo::DmgDirection' has a wrong offset!");
static_assert(offsetof(FDamageInfo, SrcActor) == 0x000040, "Member 'FDamageInfo::SrcActor' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bForceKill) == 0x000048, "Member 'FDamageInfo::bForceKill' has a wrong offset!");
static_assert(offsetof(FDamageInfo, PawnTime) == 0x00004C, "Member 'FDamageInfo::PawnTime' has a wrong offset!");

// ScriptStruct OPP.NPCScriptedAnimData
// 0x0018 (0x0018 - 0x0000)
struct FNPCScriptedAnimData final
{
public:
	class ARBScriptedAnimStation*                 Station;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MeshTarget;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCScriptedAnimData) == 0x000008, "Wrong alignment on FNPCScriptedAnimData");
static_assert(sizeof(FNPCScriptedAnimData) == 0x000018, "Wrong size on FNPCScriptedAnimData");
static_assert(offsetof(FNPCScriptedAnimData, Station) == 0x000000, "Member 'FNPCScriptedAnimData::Station' has a wrong offset!");
static_assert(offsetof(FNPCScriptedAnimData, MeshTarget) == 0x000008, "Member 'FNPCScriptedAnimData::MeshTarget' has a wrong offset!");

// ScriptStruct OPP.WorldIconData
// 0x0100 (0x0100 - 0x0000)
struct FWorldIconData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 IconInstigator;                                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldZOffset;                                      // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocationRelativeToActor;                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0074(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Icon;                                              // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CloseSize;                                         // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FarSize;                                           // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDistance;                                     // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInSpectatorMode;                              // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URBHUDWorldIconWidget*                  WorldIconWidget;                                   // 0x00B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               DistanceLimit;                                     // 0x00C0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldIconData) == 0x000010, "Wrong alignment on FWorldIconData");
static_assert(sizeof(FWorldIconData) == 0x000100, "Wrong size on FWorldIconData");
static_assert(offsetof(FWorldIconData, Actor) == 0x000050, "Member 'FWorldIconData::Actor' has a wrong offset!");
static_assert(offsetof(FWorldIconData, IconInstigator) == 0x000058, "Member 'FWorldIconData::IconInstigator' has a wrong offset!");
static_assert(offsetof(FWorldIconData, Location) == 0x000060, "Member 'FWorldIconData::Location' has a wrong offset!");
static_assert(offsetof(FWorldIconData, WorldZOffset) == 0x00006C, "Member 'FWorldIconData::WorldZOffset' has a wrong offset!");
static_assert(offsetof(FWorldIconData, bLocationRelativeToActor) == 0x000070, "Member 'FWorldIconData::bLocationRelativeToActor' has a wrong offset!");
static_assert(offsetof(FWorldIconData, Color) == 0x000074, "Member 'FWorldIconData::Color' has a wrong offset!");
static_assert(offsetof(FWorldIconData, Icon) == 0x000088, "Member 'FWorldIconData::Icon' has a wrong offset!");
static_assert(offsetof(FWorldIconData, CloseSize) == 0x000090, "Member 'FWorldIconData::CloseSize' has a wrong offset!");
static_assert(offsetof(FWorldIconData, FarSize) == 0x000098, "Member 'FWorldIconData::FarSize' has a wrong offset!");
static_assert(offsetof(FWorldIconData, ActionName) == 0x0000A0, "Member 'FWorldIconData::ActionName' has a wrong offset!");
static_assert(offsetof(FWorldIconData, bShowDistance) == 0x0000A8, "Member 'FWorldIconData::bShowDistance' has a wrong offset!");
static_assert(offsetof(FWorldIconData, bShowInSpectatorMode) == 0x0000A9, "Member 'FWorldIconData::bShowInSpectatorMode' has a wrong offset!");
static_assert(offsetof(FWorldIconData, WorldIconWidget) == 0x0000B0, "Member 'FWorldIconData::WorldIconWidget' has a wrong offset!");
static_assert(offsetof(FWorldIconData, DistanceLimit) == 0x0000C0, "Member 'FWorldIconData::DistanceLimit' has a wrong offset!");

// ScriptStruct OPP.ProfileId
// 0x0010 (0x0010 - 0x0000)
struct FProfileId final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         B;                                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         C;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         D;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FProfileId) == 0x000004, "Wrong alignment on FProfileId");
static_assert(sizeof(FProfileId) == 0x000010, "Wrong size on FProfileId");
static_assert(offsetof(FProfileId, A) == 0x000000, "Member 'FProfileId::A' has a wrong offset!");
static_assert(offsetof(FProfileId, B) == 0x000004, "Member 'FProfileId::B' has a wrong offset!");
static_assert(offsetof(FProfileId, C) == 0x000008, "Member 'FProfileId::C' has a wrong offset!");
static_assert(offsetof(FProfileId, D) == 0x00000C, "Member 'FProfileId::D' has a wrong offset!");

// ScriptStruct OPP.EndStageBadgeInfo
// 0x0008 (0x0008 - 0x0000)
struct FEndStageBadgeInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndStageBadgeInfo) == 0x000004, "Wrong alignment on FEndStageBadgeInfo");
static_assert(sizeof(FEndStageBadgeInfo) == 0x000008, "Wrong size on FEndStageBadgeInfo");
static_assert(offsetof(FEndStageBadgeInfo, ID) == 0x000000, "Member 'FEndStageBadgeInfo::ID' has a wrong offset!");

// ScriptStruct OPP.RewardUIData
// 0x0020 (0x0020 - 0x0000)
struct FRewardUIData final
{
public:
	ERewardType                                   RewardType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBCustomizationOption*                 CustomizationOption;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCustomizationRarity                    Rarity;                                            // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomRewardPoolId;                                // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardUIData) == 0x000008, "Wrong alignment on FRewardUIData");
static_assert(sizeof(FRewardUIData) == 0x000020, "Wrong size on FRewardUIData");
static_assert(offsetof(FRewardUIData, RewardType) == 0x000000, "Member 'FRewardUIData::RewardType' has a wrong offset!");
static_assert(offsetof(FRewardUIData, Amount) == 0x000004, "Member 'FRewardUIData::Amount' has a wrong offset!");
static_assert(offsetof(FRewardUIData, CustomizationOption) == 0x000008, "Member 'FRewardUIData::CustomizationOption' has a wrong offset!");
static_assert(offsetof(FRewardUIData, CurrencyType) == 0x000010, "Member 'FRewardUIData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FRewardUIData, Rarity) == 0x000011, "Member 'FRewardUIData::Rarity' has a wrong offset!");
static_assert(offsetof(FRewardUIData, RandomRewardPoolId) == 0x000014, "Member 'FRewardUIData::RandomRewardPoolId' has a wrong offset!");

// ScriptStruct OPP.RBRewardUIDataList
// 0x0010 (0x0010 - 0x0000)
struct FRBRewardUIDataList final
{
public:
	TArray<struct FRewardUIData>                  Rewards;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBRewardUIDataList) == 0x000008, "Wrong alignment on FRBRewardUIDataList");
static_assert(sizeof(FRBRewardUIDataList) == 0x000010, "Wrong size on FRBRewardUIDataList");
static_assert(offsetof(FRBRewardUIDataList, Rewards) == 0x000000, "Member 'FRBRewardUIDataList::Rewards' has a wrong offset!");

// ScriptStruct OPP.RBUIXPGainInfo
// 0x0040 (0x0040 - 0x0000)
struct FRBUIXPGainInfo final
{
public:
	EXPGainType                                   XPGainType;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewLevel;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartLevel;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartXp;                                           // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRatio;                                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewRatio;                                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProcessedXP;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardUIData>                  AssociatedRewards;                                 // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRBRewardUIDataList>            LevelUpRewards;                                    // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBUIXPGainInfo) == 0x000008, "Wrong alignment on FRBUIXPGainInfo");
static_assert(sizeof(FRBUIXPGainInfo) == 0x000040, "Wrong size on FRBUIXPGainInfo");
static_assert(offsetof(FRBUIXPGainInfo, XPGainType) == 0x000000, "Member 'FRBUIXPGainInfo::XPGainType' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, NewLevel) == 0x000004, "Member 'FRBUIXPGainInfo::NewLevel' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, StartLevel) == 0x000008, "Member 'FRBUIXPGainInfo::StartLevel' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, StartXp) == 0x00000C, "Member 'FRBUIXPGainInfo::StartXp' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, StartRatio) == 0x000010, "Member 'FRBUIXPGainInfo::StartRatio' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, NewRatio) == 0x000014, "Member 'FRBUIXPGainInfo::NewRatio' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, Xp) == 0x000018, "Member 'FRBUIXPGainInfo::Xp' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, ProcessedXP) == 0x00001C, "Member 'FRBUIXPGainInfo::ProcessedXP' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, AssociatedRewards) == 0x000020, "Member 'FRBUIXPGainInfo::AssociatedRewards' has a wrong offset!");
static_assert(offsetof(FRBUIXPGainInfo, LevelUpRewards) == 0x000030, "Member 'FRBUIXPGainInfo::LevelUpRewards' has a wrong offset!");

// ScriptStruct OPP.RBUIProgressionInfo
// 0x0010 (0x0010 - 0x0000)
struct FRBUIProgressionInfo final
{
public:
	TArray<struct FRBUIXPGainInfo>                XPGainInfos;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBUIProgressionInfo) == 0x000008, "Wrong alignment on FRBUIProgressionInfo");
static_assert(sizeof(FRBUIProgressionInfo) == 0x000010, "Wrong size on FRBUIProgressionInfo");
static_assert(offsetof(FRBUIProgressionInfo, XPGainInfos) == 0x000000, "Member 'FRBUIProgressionInfo::XPGainInfos' has a wrong offset!");

// ScriptStruct OPP.RBTrialChainingCompletedPlayerTrialEntry
// 0x000C (0x000C - 0x0000)
struct FRBTrialChainingCompletedPlayerTrialEntry final
{
public:
	int32                                         TrialChainIndex;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerScore;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeathCount;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialChainingCompletedPlayerTrialEntry) == 0x000004, "Wrong alignment on FRBTrialChainingCompletedPlayerTrialEntry");
static_assert(sizeof(FRBTrialChainingCompletedPlayerTrialEntry) == 0x00000C, "Wrong size on FRBTrialChainingCompletedPlayerTrialEntry");
static_assert(offsetof(FRBTrialChainingCompletedPlayerTrialEntry, TrialChainIndex) == 0x000000, "Member 'FRBTrialChainingCompletedPlayerTrialEntry::TrialChainIndex' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedPlayerTrialEntry, PlayerScore) == 0x000004, "Member 'FRBTrialChainingCompletedPlayerTrialEntry::PlayerScore' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedPlayerTrialEntry, PlayerDeathCount) == 0x000008, "Member 'FRBTrialChainingCompletedPlayerTrialEntry::PlayerDeathCount' has a wrong offset!");

// ScriptStruct OPP.EndStagePlayerInfo
// 0x0108 (0x0108 - 0x0000)
struct FEndStagePlayerInfo final
{
public:
	struct FProfileId                             ProfileId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         Team;                                              // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconBorder;                                        // 0x0078(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseCount;                                      // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProfilePlatform                              Platform;                                          // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerSlotIndex;                                   // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndStageBadgeInfo>             Badges;                                            // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRBUIProgressionInfo                   PlayerProgressionInfo;                             // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDead;                                             // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeathCount;                                        // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndHealthRatio;                                    // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRecordedScoringEvent>          RecordedScoringEvents;                             // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasLeveledUp;                                     // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerLevel;                                       // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBTrialChainingCompletedPlayerTrialEntry> TrialChainingCompletedTrialEntries;                // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndStagePlayerInfo) == 0x000008, "Wrong alignment on FEndStagePlayerInfo");
static_assert(sizeof(FEndStagePlayerInfo) == 0x000108, "Wrong size on FEndStagePlayerInfo");
static_assert(offsetof(FEndStagePlayerInfo, ProfileId) == 0x000000, "Member 'FEndStagePlayerInfo::ProfileId' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, PlayerId) == 0x000010, "Member 'FEndStagePlayerInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, PlayerName) == 0x000038, "Member 'FEndStagePlayerInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, Team) == 0x000048, "Member 'FEndStagePlayerInfo::Team' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, Icon) == 0x000050, "Member 'FEndStagePlayerInfo::Icon' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, IconBorder) == 0x000078, "Member 'FEndStagePlayerInfo::IconBorder' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, ReleaseCount) == 0x0000A0, "Member 'FEndStagePlayerInfo::ReleaseCount' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, Platform) == 0x0000A4, "Member 'FEndStagePlayerInfo::Platform' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, PlayerSlotIndex) == 0x0000A8, "Member 'FEndStagePlayerInfo::PlayerSlotIndex' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, Badges) == 0x0000B0, "Member 'FEndStagePlayerInfo::Badges' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, PlayerProgressionInfo) == 0x0000C0, "Member 'FEndStagePlayerInfo::PlayerProgressionInfo' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, Score) == 0x0000D0, "Member 'FEndStagePlayerInfo::Score' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, bDead) == 0x0000D4, "Member 'FEndStagePlayerInfo::bDead' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, DeathCount) == 0x0000D8, "Member 'FEndStagePlayerInfo::DeathCount' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, EndHealthRatio) == 0x0000DC, "Member 'FEndStagePlayerInfo::EndHealthRatio' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, RecordedScoringEvents) == 0x0000E0, "Member 'FEndStagePlayerInfo::RecordedScoringEvents' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, bHasLeveledUp) == 0x0000F0, "Member 'FEndStagePlayerInfo::bHasLeveledUp' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, PlayerLevel) == 0x0000F4, "Member 'FEndStagePlayerInfo::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FEndStagePlayerInfo, TrialChainingCompletedTrialEntries) == 0x0000F8, "Member 'FEndStagePlayerInfo::TrialChainingCompletedTrialEntries' has a wrong offset!");

// ScriptStruct OPP.RBItemProgressionData
// 0x0170 (0x0170 - 0x0000)
struct FRBItemProgressionData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemProgressionCategory                      Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x17];                                       // 0x0009(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rank;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActiveSkillType                              AssociatedActiveSkillType;                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProfileUpgradeCategory                       ProfileUpgradeCategory;                            // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPerkCategory                                 PerkCategory;                                      // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x004B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysAcquired;                                   // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredLevel;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequiredItems;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, int32>                    CurrencyCost;                                      // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, int32>                    Currencies;                                        // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   BattlePassId;                                      // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassPageIndex;                               // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassPageItemIndex;                           // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 BattlePassCurrencyType;                            // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BattlePassCurrencyCost;                            // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Effects;                                           // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayFeatureSwitch;                              // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrialChainingWeight;                               // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrialChainingWeightInSolo;                         // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TrialChainingRequiredItemIds;                      // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   LinkedEvent;                                       // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBItemProgressionData) == 0x000008, "Wrong alignment on FRBItemProgressionData");
static_assert(sizeof(FRBItemProgressionData) == 0x000170, "Wrong size on FRBItemProgressionData");
static_assert(offsetof(FRBItemProgressionData, ID) == 0x000000, "Member 'FRBItemProgressionData::ID' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Category) == 0x000008, "Member 'FRBItemProgressionData::Category' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Rank) == 0x000020, "Member 'FRBItemProgressionData::Rank' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Order) == 0x000024, "Member 'FRBItemProgressionData::Order' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, DisplayName) == 0x000028, "Member 'FRBItemProgressionData::DisplayName' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Icon) == 0x000040, "Member 'FRBItemProgressionData::Icon' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, AssociatedActiveSkillType) == 0x000048, "Member 'FRBItemProgressionData::AssociatedActiveSkillType' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, ProfileUpgradeCategory) == 0x000049, "Member 'FRBItemProgressionData::ProfileUpgradeCategory' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, PerkCategory) == 0x00004A, "Member 'FRBItemProgressionData::PerkCategory' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, bAvailable) == 0x00004B, "Member 'FRBItemProgressionData::bAvailable' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, bAlwaysAcquired) == 0x00004C, "Member 'FRBItemProgressionData::bAlwaysAcquired' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, RequiredLevel) == 0x000050, "Member 'FRBItemProgressionData::RequiredLevel' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, RequiredItems) == 0x000058, "Member 'FRBItemProgressionData::RequiredItems' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, CurrencyCost) == 0x000068, "Member 'FRBItemProgressionData::CurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Currencies) == 0x0000B8, "Member 'FRBItemProgressionData::Currencies' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, BattlePassId) == 0x000108, "Member 'FRBItemProgressionData::BattlePassId' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, BattlePassPageIndex) == 0x000110, "Member 'FRBItemProgressionData::BattlePassPageIndex' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, BattlePassPageItemIndex) == 0x000114, "Member 'FRBItemProgressionData::BattlePassPageItemIndex' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, BattlePassCurrencyType) == 0x000118, "Member 'FRBItemProgressionData::BattlePassCurrencyType' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, BattlePassCurrencyCost) == 0x00011C, "Member 'FRBItemProgressionData::BattlePassCurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, Effects) == 0x000120, "Member 'FRBItemProgressionData::Effects' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, FeatureSwitch) == 0x000130, "Member 'FRBItemProgressionData::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, DisplayFeatureSwitch) == 0x000140, "Member 'FRBItemProgressionData::DisplayFeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, TrialChainingWeight) == 0x000150, "Member 'FRBItemProgressionData::TrialChainingWeight' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, TrialChainingWeightInSolo) == 0x000154, "Member 'FRBItemProgressionData::TrialChainingWeightInSolo' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, TrialChainingRequiredItemIds) == 0x000158, "Member 'FRBItemProgressionData::TrialChainingRequiredItemIds' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionData, LinkedEvent) == 0x000168, "Member 'FRBItemProgressionData::LinkedEvent' has a wrong offset!");

// ScriptStruct OPP.TrialChainingUpgradeChoiceItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FTrialChainingUpgradeChoiceItemInfo final
{
public:
	ETrialChainingUpgradeType                     UpgradeType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingUpgradeChoiceItemInfo) == 0x000004, "Wrong alignment on FTrialChainingUpgradeChoiceItemInfo");
static_assert(sizeof(FTrialChainingUpgradeChoiceItemInfo) == 0x000010, "Wrong size on FTrialChainingUpgradeChoiceItemInfo");
static_assert(offsetof(FTrialChainingUpgradeChoiceItemInfo, UpgradeType) == 0x000000, "Member 'FTrialChainingUpgradeChoiceItemInfo::UpgradeType' has a wrong offset!");
static_assert(offsetof(FTrialChainingUpgradeChoiceItemInfo, ItemId) == 0x000004, "Member 'FTrialChainingUpgradeChoiceItemInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FTrialChainingUpgradeChoiceItemInfo, UserIndex) == 0x00000C, "Member 'FTrialChainingUpgradeChoiceItemInfo::UserIndex' has a wrong offset!");

// ScriptStruct OPP.TrialChainingUpgradeChoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FTrialChainingUpgradeChoiceInfo final
{
public:
	ETrialChainingUpgradeChoiceType               ChoiceType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTrialChainingUpgradeChoiceItemInfo> ItemInfos;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingUpgradeChoiceInfo) == 0x000008, "Wrong alignment on FTrialChainingUpgradeChoiceInfo");
static_assert(sizeof(FTrialChainingUpgradeChoiceInfo) == 0x000018, "Wrong size on FTrialChainingUpgradeChoiceInfo");
static_assert(offsetof(FTrialChainingUpgradeChoiceInfo, ChoiceType) == 0x000000, "Member 'FTrialChainingUpgradeChoiceInfo::ChoiceType' has a wrong offset!");
static_assert(offsetof(FTrialChainingUpgradeChoiceInfo, ItemInfos) == 0x000008, "Member 'FTrialChainingUpgradeChoiceInfo::ItemInfos' has a wrong offset!");

// ScriptStruct OPP.RBAnimRef
// 0x0030 (0x0030 - 0x0000)
struct FRBAnimRef final
{
public:
	class UAnimationAsset*                        ThirdPersonAnim;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ThirdPersonAnim : 1;                     // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        FirstPersonAnim;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FirstPersonAnim : 1;                     // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AlertedStanceAnim;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AlertedStanceAnim : 1;                   // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBAnimRef) == 0x000008, "Wrong alignment on FRBAnimRef");
static_assert(sizeof(FRBAnimRef) == 0x000030, "Wrong size on FRBAnimRef");
static_assert(offsetof(FRBAnimRef, ThirdPersonAnim) == 0x000000, "Member 'FRBAnimRef::ThirdPersonAnim' has a wrong offset!");
static_assert(offsetof(FRBAnimRef, FirstPersonAnim) == 0x000010, "Member 'FRBAnimRef::FirstPersonAnim' has a wrong offset!");
static_assert(offsetof(FRBAnimRef, AlertedStanceAnim) == 0x000020, "Member 'FRBAnimRef::AlertedStanceAnim' has a wrong offset!");

// ScriptStruct OPP.PlayerReviveAnimSet
// 0x0188 (0x0188 - 0x0000)
struct FPlayerReviveAnimSet final
{
public:
	struct FRBAnimRef                             Entry_Follower;                                    // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Entry_Follower : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Entry_Leader;                                      // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Entry_Leader : 1;                        // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Try_Follower;                                      // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Try_Follower : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Try_Leader;                                        // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Try_Leader : 1;                          // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Leave_Leader;                                      // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Leave_Leader : 1;                        // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Success_Follower;                                  // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Success_Follower : 1;                    // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Success_Leader;                                    // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Success_Leader : 1;                      // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerReviveAnimSet) == 0x000008, "Wrong alignment on FPlayerReviveAnimSet");
static_assert(sizeof(FPlayerReviveAnimSet) == 0x000188, "Wrong size on FPlayerReviveAnimSet");
static_assert(offsetof(FPlayerReviveAnimSet, Entry_Follower) == 0x000000, "Member 'FPlayerReviveAnimSet::Entry_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Entry_Leader) == 0x000038, "Member 'FPlayerReviveAnimSet::Entry_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Try_Follower) == 0x000070, "Member 'FPlayerReviveAnimSet::Try_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Try_Leader) == 0x0000A8, "Member 'FPlayerReviveAnimSet::Try_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Leave_Leader) == 0x0000E0, "Member 'FPlayerReviveAnimSet::Leave_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Success_Follower) == 0x000118, "Member 'FPlayerReviveAnimSet::Success_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimSet, Success_Leader) == 0x000150, "Member 'FPlayerReviveAnimSet::Success_Leader' has a wrong offset!");

// ScriptStruct OPP.PlayerReviveAnimRefs
// 0x0640 (0x0640 - 0x0000)
struct FPlayerReviveAnimRefs final
{
public:
	struct FPlayerReviveAnimSet                   Forward;                                           // 0x0000(0x0188)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Forward : 1;                             // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerReviveAnimSet                   Backward;                                          // 0x0190(0x0188)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Backward : 1;                            // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerReviveAnimSet                   Right;                                             // 0x0320(0x0188)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Right : 1;                               // 0x04A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerReviveAnimSet                   Left;                                              // 0x04B0(0x0188)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Left : 1;                                // 0x0638(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerReviveAnimRefs) == 0x000008, "Wrong alignment on FPlayerReviveAnimRefs");
static_assert(sizeof(FPlayerReviveAnimRefs) == 0x000640, "Wrong size on FPlayerReviveAnimRefs");
static_assert(offsetof(FPlayerReviveAnimRefs, Forward) == 0x000000, "Member 'FPlayerReviveAnimRefs::Forward' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimRefs, Backward) == 0x000190, "Member 'FPlayerReviveAnimRefs::Backward' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimRefs, Right) == 0x000320, "Member 'FPlayerReviveAnimRefs::Right' has a wrong offset!");
static_assert(offsetof(FPlayerReviveAnimRefs, Left) == 0x0004B0, "Member 'FPlayerReviveAnimRefs::Left' has a wrong offset!");

// ScriptStruct OPP.PatrolConfig
// 0x0060 (0x0060 - 0x0000)
struct FPatrolConfig final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBWaypoint*>                    WaypointList;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBWaypoint*                            DestinationWaypoint;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URBAmbientStationComponent*             DestinationAmbientStation;                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatrolConfig) == 0x000008, "Wrong alignment on FPatrolConfig");
static_assert(sizeof(FPatrolConfig) == 0x000060, "Wrong size on FPatrolConfig");
static_assert(offsetof(FPatrolConfig, WaypointList) == 0x000018, "Member 'FPatrolConfig::WaypointList' has a wrong offset!");
static_assert(offsetof(FPatrolConfig, DestinationWaypoint) == 0x000030, "Member 'FPatrolConfig::DestinationWaypoint' has a wrong offset!");
static_assert(offsetof(FPatrolConfig, DestinationAmbientStation) == 0x000050, "Member 'FPatrolConfig::DestinationAmbientStation' has a wrong offset!");

// ScriptStruct OPP.AIPerPlayerData
// 0x0178 (0x0178 - 0x0000)
struct FAIPerPlayerData final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x170];                                      // 0x0008(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPerPlayerData) == 0x000008, "Wrong alignment on FAIPerPlayerData");
static_assert(sizeof(FAIPerPlayerData) == 0x000178, "Wrong size on FAIPerPlayerData");
static_assert(offsetof(FAIPerPlayerData, Player) == 0x000000, "Member 'FAIPerPlayerData::Player' has a wrong offset!");

// ScriptStruct OPP.AICycleBreakerData
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAICycleBreakerData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAICycleBreakerData) == 0x000004, "Wrong alignment on FAICycleBreakerData");
static_assert(sizeof(FAICycleBreakerData) == 0x000004, "Wrong size on FAICycleBreakerData");

// ScriptStruct OPP.AIHealthConfig
// 0x0024 (0x0024 - 0x0000)
struct FAIHealthConfig final
{
public:
	bool                                          bRegenHealth;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRegenHealth : 1;                        // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenDelay;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RegenDelay : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenRate;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RegenRate : 1;                           // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanBeKnockedOut;                                  // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanBeKnockedOut : 1;                    // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinKnockoutDuration;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinKnockoutDuration : 1;                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxKnockoutDuration;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxKnockoutDuration : 1;                 // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIHealthConfig) == 0x000004, "Wrong alignment on FAIHealthConfig");
static_assert(sizeof(FAIHealthConfig) == 0x000024, "Wrong size on FAIHealthConfig");
static_assert(offsetof(FAIHealthConfig, bRegenHealth) == 0x000000, "Member 'FAIHealthConfig::bRegenHealth' has a wrong offset!");
static_assert(offsetof(FAIHealthConfig, RegenDelay) == 0x000004, "Member 'FAIHealthConfig::RegenDelay' has a wrong offset!");
static_assert(offsetof(FAIHealthConfig, RegenRate) == 0x00000C, "Member 'FAIHealthConfig::RegenRate' has a wrong offset!");
static_assert(offsetof(FAIHealthConfig, bCanBeKnockedOut) == 0x000011, "Member 'FAIHealthConfig::bCanBeKnockedOut' has a wrong offset!");
static_assert(offsetof(FAIHealthConfig, MinKnockoutDuration) == 0x000014, "Member 'FAIHealthConfig::MinKnockoutDuration' has a wrong offset!");
static_assert(offsetof(FAIHealthConfig, MaxKnockoutDuration) == 0x00001C, "Member 'FAIHealthConfig::MaxKnockoutDuration' has a wrong offset!");

// ScriptStruct OPP.FindPartyState
// 0x0028 (0x0028 - 0x0000)
struct FFindPartyState final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBLobbyPlayerState*                    Owner;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeCanceled;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MemberCount;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgramId;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFindPartyState) == 0x000008, "Wrong alignment on FFindPartyState");
static_assert(sizeof(FFindPartyState) == 0x000028, "Wrong size on FFindPartyState");
static_assert(offsetof(FFindPartyState, bActive) == 0x000000, "Member 'FFindPartyState::bActive' has a wrong offset!");
static_assert(offsetof(FFindPartyState, Owner) == 0x000008, "Member 'FFindPartyState::Owner' has a wrong offset!");
static_assert(offsetof(FFindPartyState, bCanBeCanceled) == 0x000010, "Member 'FFindPartyState::bCanBeCanceled' has a wrong offset!");
static_assert(offsetof(FFindPartyState, MemberCount) == 0x000014, "Member 'FFindPartyState::MemberCount' has a wrong offset!");
static_assert(offsetof(FFindPartyState, ProgramId) == 0x000018, "Member 'FFindPartyState::ProgramId' has a wrong offset!");
static_assert(offsetof(FFindPartyState, ProgramDifficulty) == 0x000020, "Member 'FFindPartyState::ProgramDifficulty' has a wrong offset!");

// ScriptStruct OPP.InternalFloatByDifficulty
// 0x0020 (0x0020 - 0x0000)
struct FInternalFloatByDifficulty final
{
public:
	bool                                          bOverrideEasyLocalValue;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EasyLocalValue;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNormalLocalValue;                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalLocalValue;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHardLocalValue;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HardLocalValue;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInsaneLocalValue;                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InsaneLocalValue;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInternalFloatByDifficulty) == 0x000004, "Wrong alignment on FInternalFloatByDifficulty");
static_assert(sizeof(FInternalFloatByDifficulty) == 0x000020, "Wrong size on FInternalFloatByDifficulty");
static_assert(offsetof(FInternalFloatByDifficulty, bOverrideEasyLocalValue) == 0x000000, "Member 'FInternalFloatByDifficulty::bOverrideEasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, EasyLocalValue) == 0x000004, "Member 'FInternalFloatByDifficulty::EasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, bOverrideNormalLocalValue) == 0x000008, "Member 'FInternalFloatByDifficulty::bOverrideNormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, NormalLocalValue) == 0x00000C, "Member 'FInternalFloatByDifficulty::NormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, bOverrideHardLocalValue) == 0x000010, "Member 'FInternalFloatByDifficulty::bOverrideHardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, HardLocalValue) == 0x000014, "Member 'FInternalFloatByDifficulty::HardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, bOverrideInsaneLocalValue) == 0x000018, "Member 'FInternalFloatByDifficulty::bOverrideInsaneLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalFloatByDifficulty, InsaneLocalValue) == 0x00001C, "Member 'FInternalFloatByDifficulty::InsaneLocalValue' has a wrong offset!");

// ScriptStruct OPP.ConfigurableValue
// 0x0038 (0x0038 - 0x0000)
struct FConfigurableValue
{
public:
	EConfigValueType                              ValueType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ValueName;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomName;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0xF];                                       // 0x0029(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConfigurableValue) == 0x000008, "Wrong alignment on FConfigurableValue");
static_assert(sizeof(FConfigurableValue) == 0x000038, "Wrong size on FConfigurableValue");
static_assert(offsetof(FConfigurableValue, ValueType) == 0x000000, "Member 'FConfigurableValue::ValueType' has a wrong offset!");
static_assert(offsetof(FConfigurableValue, ValueName) == 0x000008, "Member 'FConfigurableValue::ValueName' has a wrong offset!");
static_assert(offsetof(FConfigurableValue, DefaultName) == 0x000018, "Member 'FConfigurableValue::DefaultName' has a wrong offset!");
static_assert(offsetof(FConfigurableValue, bCustomName) == 0x000028, "Member 'FConfigurableValue::bCustomName' has a wrong offset!");

// ScriptStruct OPP.ConfigurableFloat
// 0x0090 (0x00C8 - 0x0038)
struct FConfigurableFloat final : public FConfigurableValue
{
public:
	struct FInternalFloatByDifficulty             DefaultValues;                                     // 0x0038(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor1P;                               // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalFloatByDifficulty             Values1P;                                          // 0x005C(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor2P;                               // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalFloatByDifficulty             Values2P;                                          // 0x0080(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor3P;                               // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalFloatByDifficulty             Values3P;                                          // 0x00A4(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConfigurableFloat) == 0x000008, "Wrong alignment on FConfigurableFloat");
static_assert(sizeof(FConfigurableFloat) == 0x0000C8, "Wrong size on FConfigurableFloat");
static_assert(offsetof(FConfigurableFloat, DefaultValues) == 0x000038, "Member 'FConfigurableFloat::DefaultValues' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, bLocalOverrideFor1P) == 0x000058, "Member 'FConfigurableFloat::bLocalOverrideFor1P' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, Values1P) == 0x00005C, "Member 'FConfigurableFloat::Values1P' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, bLocalOverrideFor2P) == 0x00007C, "Member 'FConfigurableFloat::bLocalOverrideFor2P' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, Values2P) == 0x000080, "Member 'FConfigurableFloat::Values2P' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, bLocalOverrideFor3P) == 0x0000A0, "Member 'FConfigurableFloat::bLocalOverrideFor3P' has a wrong offset!");
static_assert(offsetof(FConfigurableFloat, Values3P) == 0x0000A4, "Member 'FConfigurableFloat::Values3P' has a wrong offset!");

// ScriptStruct OPP.AIStimulusInfo
// 0x0028 (0x0028 - 0x0000)
struct FAIStimulusInfo final
{
public:
	float                                         OccuranceTimestamp;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStimulusType                                 Type;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StimulusStrengthMultiplier;                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStimulusInfo) == 0x000008, "Wrong alignment on FAIStimulusInfo");
static_assert(sizeof(FAIStimulusInfo) == 0x000028, "Wrong size on FAIStimulusInfo");
static_assert(offsetof(FAIStimulusInfo, OccuranceTimestamp) == 0x000000, "Member 'FAIStimulusInfo::OccuranceTimestamp' has a wrong offset!");
static_assert(offsetof(FAIStimulusInfo, Location) == 0x000004, "Member 'FAIStimulusInfo::Location' has a wrong offset!");
static_assert(offsetof(FAIStimulusInfo, SourceActor) == 0x000010, "Member 'FAIStimulusInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(FAIStimulusInfo, Type) == 0x000018, "Member 'FAIStimulusInfo::Type' has a wrong offset!");
static_assert(offsetof(FAIStimulusInfo, StimulusStrengthMultiplier) == 0x00001C, "Member 'FAIStimulusInfo::StimulusStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(FAIStimulusInfo, Duration) == 0x000020, "Member 'FAIStimulusInfo::Duration' has a wrong offset!");

// ScriptStruct OPP.ArmWreslingPlayerRoundData
// 0x0038 (0x0038 - 0x0000)
struct FArmWreslingPlayerRoundData final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumConsecutiveHits;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 HitList;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumRevolution;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmWreslingPanelInputFailType                FailType;                                          // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URBArmWreslingPanelComponent*           Panel;                                             // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              Player;                                            // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmWreslingPlayerRoundData) == 0x000008, "Wrong alignment on FArmWreslingPlayerRoundData");
static_assert(sizeof(FArmWreslingPlayerRoundData) == 0x000038, "Wrong size on FArmWreslingPlayerRoundData");
static_assert(offsetof(FArmWreslingPlayerRoundData, Multiplier) == 0x000000, "Member 'FArmWreslingPlayerRoundData::Multiplier' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, NumConsecutiveHits) == 0x000004, "Member 'FArmWreslingPlayerRoundData::NumConsecutiveHits' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, HitList) == 0x000008, "Member 'FArmWreslingPlayerRoundData::HitList' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, NumRevolution) == 0x000018, "Member 'FArmWreslingPlayerRoundData::NumRevolution' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, FailType) == 0x00001C, "Member 'FArmWreslingPlayerRoundData::FailType' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, Panel) == 0x000020, "Member 'FArmWreslingPlayerRoundData::Panel' has a wrong offset!");
static_assert(offsetof(FArmWreslingPlayerRoundData, Player) == 0x000028, "Member 'FArmWreslingPlayerRoundData::Player' has a wrong offset!");

// ScriptStruct OPP.AISabotageConfig
// 0x0024 (0x0024 - 0x0000)
struct FAISabotageConfig final
{
public:
	bool                                          bCanSabotage;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanSabotage : 1;                        // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfTotalSabotage;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxNumberOfTotalSabotage : 1;            // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfSabotageAtSameTime;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxNumberOfSabotageAtSameTime : 1;       // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeSabotage;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeSabotage : 1;                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenSabotage;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBetweenSabotage : 1;                // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISabotageConfig) == 0x000004, "Wrong alignment on FAISabotageConfig");
static_assert(sizeof(FAISabotageConfig) == 0x000024, "Wrong size on FAISabotageConfig");
static_assert(offsetof(FAISabotageConfig, bCanSabotage) == 0x000000, "Member 'FAISabotageConfig::bCanSabotage' has a wrong offset!");
static_assert(offsetof(FAISabotageConfig, MaxNumberOfTotalSabotage) == 0x000004, "Member 'FAISabotageConfig::MaxNumberOfTotalSabotage' has a wrong offset!");
static_assert(offsetof(FAISabotageConfig, MaxNumberOfSabotageAtSameTime) == 0x00000C, "Member 'FAISabotageConfig::MaxNumberOfSabotageAtSameTime' has a wrong offset!");
static_assert(offsetof(FAISabotageConfig, DelayBeforeSabotage) == 0x000014, "Member 'FAISabotageConfig::DelayBeforeSabotage' has a wrong offset!");
static_assert(offsetof(FAISabotageConfig, DelayBetweenSabotage) == 0x00001C, "Member 'FAISabotageConfig::DelayBetweenSabotage' has a wrong offset!");

// ScriptStruct OPP.ScheduledProperty
// 0x0068 (0x0068 - 0x0000)
struct FScheduledProperty
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorOwner;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NetRoleOverrideActor;                              // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetValue_ServerTimestamp;                          // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnValueChanged;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, RepSkip, NativeAccessSpecifierPublic)
	float                                         DesiredTargetTime;                                 // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScheduled;                                        // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x13];                                      // 0x0045(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> ApplyDesiredStateCallback;                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FScheduledProperty) == 0x000008, "Wrong alignment on FScheduledProperty");
static_assert(sizeof(FScheduledProperty) == 0x000068, "Wrong size on FScheduledProperty");
static_assert(offsetof(FScheduledProperty, PropertyName) == 0x000008, "Member 'FScheduledProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, Owner) == 0x000010, "Member 'FScheduledProperty::Owner' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, ActorOwner) == 0x000018, "Member 'FScheduledProperty::ActorOwner' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, NetRoleOverrideActor) == 0x000020, "Member 'FScheduledProperty::NetRoleOverrideActor' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, SetValue_ServerTimestamp) == 0x000028, "Member 'FScheduledProperty::SetValue_ServerTimestamp' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, OnValueChanged) == 0x000030, "Member 'FScheduledProperty::OnValueChanged' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, DesiredTargetTime) == 0x000040, "Member 'FScheduledProperty::DesiredTargetTime' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, bScheduled) == 0x000044, "Member 'FScheduledProperty::bScheduled' has a wrong offset!");
static_assert(offsetof(FScheduledProperty, ApplyDesiredStateCallback) == 0x000058, "Member 'FScheduledProperty::ApplyDesiredStateCallback' has a wrong offset!");

// ScriptStruct OPP.ScheduledFloat
// 0x0010 (0x0078 - 0x0068)
struct FScheduledFloat final : public FScheduledProperty
{
public:
	float                                         InitialValue;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastValue;                                         // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredValue;                                      // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledFloat) == 0x000008, "Wrong alignment on FScheduledFloat");
static_assert(sizeof(FScheduledFloat) == 0x000078, "Wrong size on FScheduledFloat");
static_assert(offsetof(FScheduledFloat, InitialValue) == 0x000068, "Member 'FScheduledFloat::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledFloat, LastValue) == 0x00006C, "Member 'FScheduledFloat::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledFloat, CurrentValue) == 0x000070, "Member 'FScheduledFloat::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledFloat, DesiredValue) == 0x000074, "Member 'FScheduledFloat::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.RBPlayerLoadout
// 0x0018 (0x0018 - 0x0000)
struct FRBPlayerLoadout final
{
public:
	TArray<class FName>                           Perks;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EActiveSkillType                              ActiveSkillType;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerLoadout) == 0x000008, "Wrong alignment on FRBPlayerLoadout");
static_assert(sizeof(FRBPlayerLoadout) == 0x000018, "Wrong size on FRBPlayerLoadout");
static_assert(offsetof(FRBPlayerLoadout, Perks) == 0x000000, "Member 'FRBPlayerLoadout::Perks' has a wrong offset!");
static_assert(offsetof(FRBPlayerLoadout, ActiveSkillType) == 0x000010, "Member 'FRBPlayerLoadout::ActiveSkillType' has a wrong offset!");

// ScriptStruct OPP.RBHairColorOption
// 0x0028 (0x0028 - 0x0000)
struct FRBHairColorOption final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InGameColor;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UIColor;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBHairColorOption) == 0x000004, "Wrong alignment on FRBHairColorOption");
static_assert(sizeof(FRBHairColorOption) == 0x000028, "Wrong size on FRBHairColorOption");
static_assert(offsetof(FRBHairColorOption, ID) == 0x000000, "Member 'FRBHairColorOption::ID' has a wrong offset!");
static_assert(offsetof(FRBHairColorOption, InGameColor) == 0x000008, "Member 'FRBHairColorOption::InGameColor' has a wrong offset!");
static_assert(offsetof(FRBHairColorOption, UIColor) == 0x000018, "Member 'FRBHairColorOption::UIColor' has a wrong offset!");

// ScriptStruct OPP.SpecialMoveMulticastData
// 0x0048 (0x0048 - 0x0000)
struct FSpecialMoveMulticastData final
{
public:
	int32                                         SpecialMoveIndex;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPredicted : 1;                                    // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartedMovementTimestamp;                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  SpecialMove;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SpecialMoveSubType;                                // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPosition;                                    // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDirection;                                   // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalPosition;                                  // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalDirectionYaw;                              // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Interactable;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialMoveMulticastData) == 0x000008, "Wrong alignment on FSpecialMoveMulticastData");
static_assert(sizeof(FSpecialMoveMulticastData) == 0x000048, "Wrong size on FSpecialMoveMulticastData");
static_assert(offsetof(FSpecialMoveMulticastData, SpecialMoveIndex) == 0x000000, "Member 'FSpecialMoveMulticastData::SpecialMoveIndex' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, StartedMovementTimestamp) == 0x000008, "Member 'FSpecialMoveMulticastData::StartedMovementTimestamp' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, SpecialMove) == 0x00000C, "Member 'FSpecialMoveMulticastData::SpecialMove' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, SpecialMoveSubType) == 0x00000D, "Member 'FSpecialMoveMulticastData::SpecialMoveSubType' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, TargetPosition) == 0x000010, "Member 'FSpecialMoveMulticastData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, TargetDirection) == 0x00001C, "Member 'FSpecialMoveMulticastData::TargetDirection' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, OriginalPosition) == 0x000028, "Member 'FSpecialMoveMulticastData::OriginalPosition' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, OriginalDirectionYaw) == 0x000034, "Member 'FSpecialMoveMulticastData::OriginalDirectionYaw' has a wrong offset!");
static_assert(offsetof(FSpecialMoveMulticastData, Interactable) == 0x000038, "Member 'FSpecialMoveMulticastData::Interactable' has a wrong offset!");

// ScriptStruct OPP.ScheduledSpecialMoveData
// 0x0070 (0x0070 - 0x0000)
struct FScheduledSpecialMoveData final
{
public:
	float                                         PawnTime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteruptable;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialMoveMulticastData              SpecialMoveData;                                   // 0x0010(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	ESpecialMove                                  CancelledSpecialMove;                              // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CancelledSpecialMoveIndex;                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScheduleOnPawnTime;                               // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScheduledTime;                                     // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManuallyTriggered;                                // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledSpecialMoveData) == 0x000008, "Wrong alignment on FScheduledSpecialMoveData");
static_assert(sizeof(FScheduledSpecialMoveData) == 0x000070, "Wrong size on FScheduledSpecialMoveData");
static_assert(offsetof(FScheduledSpecialMoveData, PawnTime) == 0x000000, "Member 'FScheduledSpecialMoveData::PawnTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, ServerTime) == 0x000004, "Member 'FScheduledSpecialMoveData::ServerTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, bInteruptable) == 0x000008, "Member 'FScheduledSpecialMoveData::bInteruptable' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, SpecialMoveData) == 0x000010, "Member 'FScheduledSpecialMoveData::SpecialMoveData' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, CancelledSpecialMove) == 0x000058, "Member 'FScheduledSpecialMoveData::CancelledSpecialMove' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, CancelledSpecialMoveIndex) == 0x00005C, "Member 'FScheduledSpecialMoveData::CancelledSpecialMoveIndex' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, bScheduleOnPawnTime) == 0x000060, "Member 'FScheduledSpecialMoveData::bScheduleOnPawnTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, ScheduledTime) == 0x000064, "Member 'FScheduledSpecialMoveData::ScheduledTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveData, bManuallyTriggered) == 0x000068, "Member 'FScheduledSpecialMoveData::bManuallyTriggered' has a wrong offset!");

// ScriptStruct OPP.RotationRateLimitData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FRotationRateLimitData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRotationRateLimitData) == 0x000004, "Wrong alignment on FRotationRateLimitData");
static_assert(sizeof(FRotationRateLimitData) == 0x00001C, "Wrong size on FRotationRateLimitData");

// ScriptStruct OPP.AISpawnerUICustomizationProxy
// 0x0008 (0x0008 - 0x0000)
struct FAISpawnerUICustomizationProxy final
{
public:
	class ARBAISpawner*                           OwnerSpawner;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISpawnerUICustomizationProxy) == 0x000008, "Wrong alignment on FAISpawnerUICustomizationProxy");
static_assert(sizeof(FAISpawnerUICustomizationProxy) == 0x000008, "Wrong size on FAISpawnerUICustomizationProxy");
static_assert(offsetof(FAISpawnerUICustomizationProxy, OwnerSpawner) == 0x000000, "Member 'FAISpawnerUICustomizationProxy::OwnerSpawner' has a wrong offset!");

// ScriptStruct OPP.RemoteDebuggingState
// 0x0020 (0x0020 - 0x0000)
struct FRemoteDebuggingState final
{
public:
	bool                                          bDebugAI;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPlayer;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAIConfig;                                    // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugStreaming;                                   // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugScoring;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMusic;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDoorRandomization;                           // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverseer;                                         // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugNPCRandomization;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPlayerStats;                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAnalytics;                                   // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBNPC*                                 NPCToDebug;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              PlayerToDebug;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRemoteDebuggingState) == 0x000008, "Wrong alignment on FRemoteDebuggingState");
static_assert(sizeof(FRemoteDebuggingState) == 0x000020, "Wrong size on FRemoteDebuggingState");
static_assert(offsetof(FRemoteDebuggingState, bDebugAI) == 0x000000, "Member 'FRemoteDebuggingState::bDebugAI' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugPlayer) == 0x000001, "Member 'FRemoteDebuggingState::bDebugPlayer' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugAIConfig) == 0x000002, "Member 'FRemoteDebuggingState::bDebugAIConfig' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugStreaming) == 0x000003, "Member 'FRemoteDebuggingState::bDebugStreaming' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugScoring) == 0x000004, "Member 'FRemoteDebuggingState::bDebugScoring' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugMusic) == 0x000005, "Member 'FRemoteDebuggingState::bDebugMusic' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugDoorRandomization) == 0x000006, "Member 'FRemoteDebuggingState::bDebugDoorRandomization' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bOverseer) == 0x000007, "Member 'FRemoteDebuggingState::bOverseer' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugNPCRandomization) == 0x000008, "Member 'FRemoteDebuggingState::bDebugNPCRandomization' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugPlayerStats) == 0x000009, "Member 'FRemoteDebuggingState::bDebugPlayerStats' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, bDebugAnalytics) == 0x00000A, "Member 'FRemoteDebuggingState::bDebugAnalytics' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, NPCToDebug) == 0x000010, "Member 'FRemoteDebuggingState::NPCToDebug' has a wrong offset!");
static_assert(offsetof(FRemoteDebuggingState, PlayerToDebug) == 0x000018, "Member 'FRemoteDebuggingState::PlayerToDebug' has a wrong offset!");

// ScriptStruct OPP.RoomPathingSearchParams
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FRoomPathingSearchParams final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomPathingSearchParams) == 0x000004, "Wrong alignment on FRoomPathingSearchParams");
static_assert(sizeof(FRoomPathingSearchParams) == 0x000028, "Wrong size on FRoomPathingSearchParams");

// ScriptStruct OPP.AIAdvancedSpeedConfig
// 0x00A0 (0x00A0 - 0x0000)
struct FAIAdvancedSpeedConfig final
{
public:
	float                                         AccelCoeffNormal;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AccelCoeffNormal : 1;                    // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccelCoeffAfterTurn;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AccelCoeffAfterTurn : 1;                 // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelCoeffNormal;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DecelCoeffNormal : 1;                    // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelCoeffSharpTurn;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DecelCoeffSharpTurn : 1;                 // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelCoeffApproachDest;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DecelCoeffApproachDest : 1;              // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestApprochTargetDecel;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DestApprochTargetDecel : 1;              // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmallRotationSpeed;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SmallRotationSpeed : 1;                  // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HighRotationSpeed;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighRotationSpeed : 1;                   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedForRotationSlowDown;                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpeedForRotationSlowDown : 1;            // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedForMaxRotationSlowDown;                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpeedForMaxRotationSlowDown : 1;         // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowedDownSpeedForRotation;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowedDownSpeedForRotation : 1;          // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnApproachDistForStartSlowDown;                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TurnApproachDistForStartSlowDown : 1;    // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnApproachDistForMaxSlowDown;                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TurnApproachDistForMaxSlowDown : 1;      // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAnticipatedAngleForSlowDown;                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinAnticipatedAngleForSlowDown : 1;      // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAnticipatedAngleForSlowDown;                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAnticipatedAngleForSlowDown : 1;      // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPlayerAwaySpeedForSlowdown;                     // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPlayerAwaySpeedForSlowdown : 1;       // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistToObstacle;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDistToObstacle : 1;                   // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistToObstacle;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistToObstacle : 1;                   // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowDownAfterTurnDuration;                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowDownAfterTurnDuration : 1;           // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxReasonableGroundSpeed;                          // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxReasonableGroundSpeed : 1;            // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAdvancedSpeedConfig) == 0x000004, "Wrong alignment on FAIAdvancedSpeedConfig");
static_assert(sizeof(FAIAdvancedSpeedConfig) == 0x0000A0, "Wrong size on FAIAdvancedSpeedConfig");
static_assert(offsetof(FAIAdvancedSpeedConfig, AccelCoeffNormal) == 0x000000, "Member 'FAIAdvancedSpeedConfig::AccelCoeffNormal' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, AccelCoeffAfterTurn) == 0x000008, "Member 'FAIAdvancedSpeedConfig::AccelCoeffAfterTurn' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, DecelCoeffNormal) == 0x000010, "Member 'FAIAdvancedSpeedConfig::DecelCoeffNormal' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, DecelCoeffSharpTurn) == 0x000018, "Member 'FAIAdvancedSpeedConfig::DecelCoeffSharpTurn' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, DecelCoeffApproachDest) == 0x000020, "Member 'FAIAdvancedSpeedConfig::DecelCoeffApproachDest' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, DestApprochTargetDecel) == 0x000028, "Member 'FAIAdvancedSpeedConfig::DestApprochTargetDecel' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, SmallRotationSpeed) == 0x000030, "Member 'FAIAdvancedSpeedConfig::SmallRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, HighRotationSpeed) == 0x000038, "Member 'FAIAdvancedSpeedConfig::HighRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, SpeedForRotationSlowDown) == 0x000040, "Member 'FAIAdvancedSpeedConfig::SpeedForRotationSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, SpeedForMaxRotationSlowDown) == 0x000048, "Member 'FAIAdvancedSpeedConfig::SpeedForMaxRotationSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, SlowedDownSpeedForRotation) == 0x000050, "Member 'FAIAdvancedSpeedConfig::SlowedDownSpeedForRotation' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, TurnApproachDistForStartSlowDown) == 0x000058, "Member 'FAIAdvancedSpeedConfig::TurnApproachDistForStartSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, TurnApproachDistForMaxSlowDown) == 0x000060, "Member 'FAIAdvancedSpeedConfig::TurnApproachDistForMaxSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MinAnticipatedAngleForSlowDown) == 0x000068, "Member 'FAIAdvancedSpeedConfig::MinAnticipatedAngleForSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MaxAnticipatedAngleForSlowDown) == 0x000070, "Member 'FAIAdvancedSpeedConfig::MaxAnticipatedAngleForSlowDown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MaxPlayerAwaySpeedForSlowdown) == 0x000078, "Member 'FAIAdvancedSpeedConfig::MaxPlayerAwaySpeedForSlowdown' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MinDistToObstacle) == 0x000080, "Member 'FAIAdvancedSpeedConfig::MinDistToObstacle' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MaxDistToObstacle) == 0x000088, "Member 'FAIAdvancedSpeedConfig::MaxDistToObstacle' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, SlowDownAfterTurnDuration) == 0x000090, "Member 'FAIAdvancedSpeedConfig::SlowDownAfterTurnDuration' has a wrong offset!");
static_assert(offsetof(FAIAdvancedSpeedConfig, MaxReasonableGroundSpeed) == 0x000098, "Member 'FAIAdvancedSpeedConfig::MaxReasonableGroundSpeed' has a wrong offset!");

// ScriptStruct OPP.RBPlayerUpgradeEffectDataRow
// 0x0048 (0x0050 - 0x0008)
struct FRBPlayerUpgradeEffectDataRow final : public FTableRowBase
{
public:
	class FName                                   EffectId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SettingName;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAttributeType                        AttributeType;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAttributeModifierType                ModifierType;                                      // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayEffect;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayModifier;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FeatureSwitch;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerUpgradeEffectDataRow) == 0x000008, "Wrong alignment on FRBPlayerUpgradeEffectDataRow");
static_assert(sizeof(FRBPlayerUpgradeEffectDataRow) == 0x000050, "Wrong size on FRBPlayerUpgradeEffectDataRow");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, EffectId) == 0x000008, "Member 'FRBPlayerUpgradeEffectDataRow::EffectId' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, Description) == 0x000010, "Member 'FRBPlayerUpgradeEffectDataRow::Description' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, SettingName) == 0x000028, "Member 'FRBPlayerUpgradeEffectDataRow::SettingName' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, AttributeType) == 0x000030, "Member 'FRBPlayerUpgradeEffectDataRow::AttributeType' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, ModifierType) == 0x000031, "Member 'FRBPlayerUpgradeEffectDataRow::ModifierType' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, Value) == 0x000034, "Member 'FRBPlayerUpgradeEffectDataRow::Value' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, bDisplayEffect) == 0x000038, "Member 'FRBPlayerUpgradeEffectDataRow::bDisplayEffect' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, bDisplayModifier) == 0x000039, "Member 'FRBPlayerUpgradeEffectDataRow::bDisplayModifier' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectDataRow, FeatureSwitch) == 0x000040, "Member 'FRBPlayerUpgradeEffectDataRow::FeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.RBMurkoffAnnouncentAudioData
// 0x0010 (0x0010 - 0x0000)
struct FRBMurkoffAnnouncentAudioData final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedAudioLength;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBMurkoffAnnouncentAudioData) == 0x000008, "Wrong alignment on FRBMurkoffAnnouncentAudioData");
static_assert(sizeof(FRBMurkoffAnnouncentAudioData) == 0x000010, "Wrong size on FRBMurkoffAnnouncentAudioData");
static_assert(offsetof(FRBMurkoffAnnouncentAudioData, AudioEvent) == 0x000000, "Member 'FRBMurkoffAnnouncentAudioData::AudioEvent' has a wrong offset!");
static_assert(offsetof(FRBMurkoffAnnouncentAudioData, FixedAudioLength) == 0x000008, "Member 'FRBMurkoffAnnouncentAudioData::FixedAudioLength' has a wrong offset!");

// ScriptStruct OPP.RandomRewardPoolDisplayDetails
// 0x0030 (0x0030 - 0x0000)
struct FRandomRewardPoolDisplayDetails final
{
public:
	class FName                                   RewardPoolId;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BackgroundImage;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconTint;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRarityColor;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomRewardPoolDisplayDetails) == 0x000008, "Wrong alignment on FRandomRewardPoolDisplayDetails");
static_assert(sizeof(FRandomRewardPoolDisplayDetails) == 0x000030, "Wrong size on FRandomRewardPoolDisplayDetails");
static_assert(offsetof(FRandomRewardPoolDisplayDetails, RewardPoolId) == 0x000000, "Member 'FRandomRewardPoolDisplayDetails::RewardPoolId' has a wrong offset!");
static_assert(offsetof(FRandomRewardPoolDisplayDetails, BackgroundImage) == 0x000008, "Member 'FRandomRewardPoolDisplayDetails::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FRandomRewardPoolDisplayDetails, Icon) == 0x000010, "Member 'FRandomRewardPoolDisplayDetails::Icon' has a wrong offset!");
static_assert(offsetof(FRandomRewardPoolDisplayDetails, IconTint) == 0x000018, "Member 'FRandomRewardPoolDisplayDetails::IconTint' has a wrong offset!");
static_assert(offsetof(FRandomRewardPoolDisplayDetails, bUseRarityColor) == 0x000028, "Member 'FRandomRewardPoolDisplayDetails::bUseRarityColor' has a wrong offset!");

// ScriptStruct OPP.InternalIntByDifficulty
// 0x0020 (0x0020 - 0x0000)
struct FInternalIntByDifficulty final
{
public:
	bool                                          bOverrideEasyLocalValue;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EasyLocalValue;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNormalLocalValue;                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NormalLocalValue;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHardLocalValue;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HardLocalValue;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInsaneLocalValue;                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InsaneLocalValue;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInternalIntByDifficulty) == 0x000004, "Wrong alignment on FInternalIntByDifficulty");
static_assert(sizeof(FInternalIntByDifficulty) == 0x000020, "Wrong size on FInternalIntByDifficulty");
static_assert(offsetof(FInternalIntByDifficulty, bOverrideEasyLocalValue) == 0x000000, "Member 'FInternalIntByDifficulty::bOverrideEasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, EasyLocalValue) == 0x000004, "Member 'FInternalIntByDifficulty::EasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, bOverrideNormalLocalValue) == 0x000008, "Member 'FInternalIntByDifficulty::bOverrideNormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, NormalLocalValue) == 0x00000C, "Member 'FInternalIntByDifficulty::NormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, bOverrideHardLocalValue) == 0x000010, "Member 'FInternalIntByDifficulty::bOverrideHardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, HardLocalValue) == 0x000014, "Member 'FInternalIntByDifficulty::HardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, bOverrideInsaneLocalValue) == 0x000018, "Member 'FInternalIntByDifficulty::bOverrideInsaneLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalIntByDifficulty, InsaneLocalValue) == 0x00001C, "Member 'FInternalIntByDifficulty::InsaneLocalValue' has a wrong offset!");

// ScriptStruct OPP.ConfigurableInt
// 0x0090 (0x00C8 - 0x0038)
struct FConfigurableInt final : public FConfigurableValue
{
public:
	struct FInternalIntByDifficulty               DefaultValues;                                     // 0x0038(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor1P;                               // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalIntByDifficulty               Values1P;                                          // 0x005C(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor2P;                               // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalIntByDifficulty               Values2P;                                          // 0x0080(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor3P;                               // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInternalIntByDifficulty               Values3P;                                          // 0x00A4(0x0020)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConfigurableInt) == 0x000008, "Wrong alignment on FConfigurableInt");
static_assert(sizeof(FConfigurableInt) == 0x0000C8, "Wrong size on FConfigurableInt");
static_assert(offsetof(FConfigurableInt, DefaultValues) == 0x000038, "Member 'FConfigurableInt::DefaultValues' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, bLocalOverrideFor1P) == 0x000058, "Member 'FConfigurableInt::bLocalOverrideFor1P' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, Values1P) == 0x00005C, "Member 'FConfigurableInt::Values1P' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, bLocalOverrideFor2P) == 0x00007C, "Member 'FConfigurableInt::bLocalOverrideFor2P' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, Values2P) == 0x000080, "Member 'FConfigurableInt::Values2P' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, bLocalOverrideFor3P) == 0x0000A0, "Member 'FConfigurableInt::bLocalOverrideFor3P' has a wrong offset!");
static_assert(offsetof(FConfigurableInt, Values3P) == 0x0000A4, "Member 'FConfigurableInt::Values3P' has a wrong offset!");

// ScriptStruct OPP.RandomSettings
// 0x0320 (0x0320 - 0x0000)
struct FRandomSettings final
{
public:
	struct FConfigurableFloat                     MinRatio;                                          // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MaxRatio;                                          // 0x00C8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MinCount;                                          // 0x0190(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MaxCount;                                          // 0x0258(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomSettings) == 0x000008, "Wrong alignment on FRandomSettings");
static_assert(sizeof(FRandomSettings) == 0x000320, "Wrong size on FRandomSettings");
static_assert(offsetof(FRandomSettings, MinRatio) == 0x000000, "Member 'FRandomSettings::MinRatio' has a wrong offset!");
static_assert(offsetof(FRandomSettings, MaxRatio) == 0x0000C8, "Member 'FRandomSettings::MaxRatio' has a wrong offset!");
static_assert(offsetof(FRandomSettings, MinCount) == 0x000190, "Member 'FRandomSettings::MinCount' has a wrong offset!");
static_assert(offsetof(FRandomSettings, MaxCount) == 0x000258, "Member 'FRandomSettings::MaxCount' has a wrong offset!");

// ScriptStruct OPP.DamageResult
// 0x0020 (0x0020 - 0x0000)
struct FDamageResult final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageInstigator;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageResult) == 0x000008, "Wrong alignment on FDamageResult");
static_assert(sizeof(FDamageResult) == 0x000020, "Wrong size on FDamageResult");
static_assert(offsetof(FDamageResult, DamageInstigator) == 0x000018, "Member 'FDamageResult::DamageInstigator' has a wrong offset!");

// ScriptStruct OPP.RBGameplayAttributeModifier
// 0x000C (0x000C - 0x0000)
struct FRBGameplayAttributeModifier final
{
public:
	EGameplayAttributeType                        AttributeType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAttributeModifierType                ModifierType;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplay;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBGameplayAttributeModifier) == 0x000004, "Wrong alignment on FRBGameplayAttributeModifier");
static_assert(sizeof(FRBGameplayAttributeModifier) == 0x00000C, "Wrong size on FRBGameplayAttributeModifier");
static_assert(offsetof(FRBGameplayAttributeModifier, AttributeType) == 0x000000, "Member 'FRBGameplayAttributeModifier::AttributeType' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifier, ModifierType) == 0x000001, "Member 'FRBGameplayAttributeModifier::ModifierType' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifier, Value) == 0x000004, "Member 'FRBGameplayAttributeModifier::Value' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifier, bDisplay) == 0x000008, "Member 'FRBGameplayAttributeModifier::bDisplay' has a wrong offset!");

// ScriptStruct OPP.RBGameplayAttributeModifierInfo
// 0x0018 (0x0018 - 0x0000)
struct FRBGameplayAttributeModifierInfo final
{
public:
	struct FRBGameplayAttributeModifier           Modifier;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoseOnRespawn;                                    // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoseOnTrialEnd;                                   // 0x0015(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBGameplayAttributeModifierInfo) == 0x000004, "Wrong alignment on FRBGameplayAttributeModifierInfo");
static_assert(sizeof(FRBGameplayAttributeModifierInfo) == 0x000018, "Wrong size on FRBGameplayAttributeModifierInfo");
static_assert(offsetof(FRBGameplayAttributeModifierInfo, Modifier) == 0x000000, "Member 'FRBGameplayAttributeModifierInfo::Modifier' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifierInfo, ID) == 0x00000C, "Member 'FRBGameplayAttributeModifierInfo::ID' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifierInfo, bLoseOnRespawn) == 0x000014, "Member 'FRBGameplayAttributeModifierInfo::bLoseOnRespawn' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifierInfo, bLoseOnTrialEnd) == 0x000015, "Member 'FRBGameplayAttributeModifierInfo::bLoseOnTrialEnd' has a wrong offset!");

// ScriptStruct OPP.PlayerRejoinInfo
// 0x0028 (0x0028 - 0x0000)
struct FPlayerRejoinInfo final
{
public:
	float                                         HealthF;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVBatteryLevel;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PsychosisBracket;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigCooldownTimeRemaining;                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigCooldownRatio;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBGameplayAttributeModifierInfo> PlayerSpecificUpgrades;                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRejoinInfo) == 0x000008, "Wrong alignment on FPlayerRejoinInfo");
static_assert(sizeof(FPlayerRejoinInfo) == 0x000028, "Wrong size on FPlayerRejoinInfo");
static_assert(offsetof(FPlayerRejoinInfo, HealthF) == 0x000000, "Member 'FPlayerRejoinInfo::HealthF' has a wrong offset!");
static_assert(offsetof(FPlayerRejoinInfo, NVBatteryLevel) == 0x000004, "Member 'FPlayerRejoinInfo::NVBatteryLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRejoinInfo, PsychosisBracket) == 0x000008, "Member 'FPlayerRejoinInfo::PsychosisBracket' has a wrong offset!");
static_assert(offsetof(FPlayerRejoinInfo, RigCooldownTimeRemaining) == 0x00000C, "Member 'FPlayerRejoinInfo::RigCooldownTimeRemaining' has a wrong offset!");
static_assert(offsetof(FPlayerRejoinInfo, RigCooldownRatio) == 0x000010, "Member 'FPlayerRejoinInfo::RigCooldownRatio' has a wrong offset!");
static_assert(offsetof(FPlayerRejoinInfo, PlayerSpecificUpgrades) == 0x000018, "Member 'FPlayerRejoinInfo::PlayerSpecificUpgrades' has a wrong offset!");

// ScriptStruct OPP.RandomizationLotSetupData
// 0x0328 (0x0328 - 0x0000)
struct FRandomizationLotSetupData final
{
public:
	ERandomStateSetup                             BaseState;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomStateSetup                             DesiredState;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DesiredStateCount;                                 // 0x0008(0x0320)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomizationLotSetupData) == 0x000008, "Wrong alignment on FRandomizationLotSetupData");
static_assert(sizeof(FRandomizationLotSetupData) == 0x000328, "Wrong size on FRandomizationLotSetupData");
static_assert(offsetof(FRandomizationLotSetupData, BaseState) == 0x000000, "Member 'FRandomizationLotSetupData::BaseState' has a wrong offset!");
static_assert(offsetof(FRandomizationLotSetupData, DesiredState) == 0x000001, "Member 'FRandomizationLotSetupData::DesiredState' has a wrong offset!");
static_assert(offsetof(FRandomizationLotSetupData, DesiredStateCount) == 0x000008, "Member 'FRandomizationLotSetupData::DesiredStateCount' has a wrong offset!");

// ScriptStruct OPP.DelayedActionHandle
// 0x0028 (0x0028 - 0x0000)
struct FDelayedActionHandle final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             Callback;                                          // 0x0018(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelayedActionHandle) == 0x000008, "Wrong alignment on FDelayedActionHandle");
static_assert(sizeof(FDelayedActionHandle) == 0x000028, "Wrong size on FDelayedActionHandle");
static_assert(offsetof(FDelayedActionHandle, Owner) == 0x000000, "Member 'FDelayedActionHandle::Owner' has a wrong offset!");
static_assert(offsetof(FDelayedActionHandle, Callback) == 0x000018, "Member 'FDelayedActionHandle::Callback' has a wrong offset!");

// ScriptStruct OPP.OfficerVOs
// 0x0030 (0x0030 - 0x0000)
struct FOfficerVOs final
{
public:
	class UAkAudioEvent*                          ApproachLockedFirstTime;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ApproachLocked;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          InteractWhenReleaseAvailableFirstTime;             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          InteractWhenReleaseAvailable;                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AcceptRelease;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Exit;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfficerVOs) == 0x000008, "Wrong alignment on FOfficerVOs");
static_assert(sizeof(FOfficerVOs) == 0x000030, "Wrong size on FOfficerVOs");
static_assert(offsetof(FOfficerVOs, ApproachLockedFirstTime) == 0x000000, "Member 'FOfficerVOs::ApproachLockedFirstTime' has a wrong offset!");
static_assert(offsetof(FOfficerVOs, ApproachLocked) == 0x000008, "Member 'FOfficerVOs::ApproachLocked' has a wrong offset!");
static_assert(offsetof(FOfficerVOs, InteractWhenReleaseAvailableFirstTime) == 0x000010, "Member 'FOfficerVOs::InteractWhenReleaseAvailableFirstTime' has a wrong offset!");
static_assert(offsetof(FOfficerVOs, InteractWhenReleaseAvailable) == 0x000018, "Member 'FOfficerVOs::InteractWhenReleaseAvailable' has a wrong offset!");
static_assert(offsetof(FOfficerVOs, AcceptRelease) == 0x000020, "Member 'FOfficerVOs::AcceptRelease' has a wrong offset!");
static_assert(offsetof(FOfficerVOs, Exit) == 0x000028, "Member 'FOfficerVOs::Exit' has a wrong offset!");

// ScriptStruct OPP.DelayedSpawnActionInfo
// 0x0020 (0x0020 - 0x0000)
struct FDelayedSpawnActionInfo final
{
public:
	struct FLatentActionInfo                      LatentActionInfo;                                  // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelayedSpawnActionInfo) == 0x000008, "Wrong alignment on FDelayedSpawnActionInfo");
static_assert(sizeof(FDelayedSpawnActionInfo) == 0x000020, "Wrong size on FDelayedSpawnActionInfo");
static_assert(offsetof(FDelayedSpawnActionInfo, LatentActionInfo) == 0x000000, "Member 'FDelayedSpawnActionInfo::LatentActionInfo' has a wrong offset!");

// ScriptStruct OPP.NPCConfigRedirector
// 0x0028 (0x0028 - 0x0000)
struct FNPCConfigRedirector final
{
public:
	class URBAIConfig*                            ConfigToRedirect;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            EasyConfig;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            NormalConfig;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            HardConfig;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            InsaneConfig;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCConfigRedirector) == 0x000008, "Wrong alignment on FNPCConfigRedirector");
static_assert(sizeof(FNPCConfigRedirector) == 0x000028, "Wrong size on FNPCConfigRedirector");
static_assert(offsetof(FNPCConfigRedirector, ConfigToRedirect) == 0x000000, "Member 'FNPCConfigRedirector::ConfigToRedirect' has a wrong offset!");
static_assert(offsetof(FNPCConfigRedirector, EasyConfig) == 0x000008, "Member 'FNPCConfigRedirector::EasyConfig' has a wrong offset!");
static_assert(offsetof(FNPCConfigRedirector, NormalConfig) == 0x000010, "Member 'FNPCConfigRedirector::NormalConfig' has a wrong offset!");
static_assert(offsetof(FNPCConfigRedirector, HardConfig) == 0x000018, "Member 'FNPCConfigRedirector::HardConfig' has a wrong offset!");
static_assert(offsetof(FNPCConfigRedirector, InsaneConfig) == 0x000020, "Member 'FNPCConfigRedirector::InsaneConfig' has a wrong offset!");

// ScriptStruct OPP.FaceAnimRow
// 0x0008 (0x0010 - 0x0008)
struct FFaceAnimRow final : public FTableRowBase
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFaceAnimRow) == 0x000008, "Wrong alignment on FFaceAnimRow");
static_assert(sizeof(FFaceAnimRow) == 0x000010, "Wrong size on FFaceAnimRow");
static_assert(offsetof(FFaceAnimRow, Sequence) == 0x000008, "Member 'FFaceAnimRow::Sequence' has a wrong offset!");

// ScriptStruct OPP.NPCHidespotPeekAnimData
// 0x0010 (0x0010 - 0x0000)
struct FNPCHidespotPeekAnimData final
{
public:
	class UAnimSequence*                          PeekAnimation;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCHidespotPeekDistance                      Distance;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCHidespotPeekAnimData) == 0x000008, "Wrong alignment on FNPCHidespotPeekAnimData");
static_assert(sizeof(FNPCHidespotPeekAnimData) == 0x000010, "Wrong size on FNPCHidespotPeekAnimData");
static_assert(offsetof(FNPCHidespotPeekAnimData, PeekAnimation) == 0x000000, "Member 'FNPCHidespotPeekAnimData::PeekAnimation' has a wrong offset!");
static_assert(offsetof(FNPCHidespotPeekAnimData, Distance) == 0x000008, "Member 'FNPCHidespotPeekAnimData::Distance' has a wrong offset!");

// ScriptStruct OPP.SingleHidespotInteractionsAnimRefs
// 0x0048 (0x0048 - 0x0000)
struct FSingleHidespotInteractionsAnimRefs final
{
public:
	class UAnimSequenceBase*                      Enter;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      EnterJumpScare;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Peek;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNPCHidespotPeekAnimData>       NPCPeeks;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ExitPeek;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              Investigate;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      KnockdownExit;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleHidespotInteractionsAnimRefs) == 0x000008, "Wrong alignment on FSingleHidespotInteractionsAnimRefs");
static_assert(sizeof(FSingleHidespotInteractionsAnimRefs) == 0x000048, "Wrong size on FSingleHidespotInteractionsAnimRefs");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, Enter) == 0x000000, "Member 'FSingleHidespotInteractionsAnimRefs::Enter' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, EnterJumpScare) == 0x000008, "Member 'FSingleHidespotInteractionsAnimRefs::EnterJumpScare' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, Peek) == 0x000010, "Member 'FSingleHidespotInteractionsAnimRefs::Peek' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, NPCPeeks) == 0x000018, "Member 'FSingleHidespotInteractionsAnimRefs::NPCPeeks' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, ExitPeek) == 0x000028, "Member 'FSingleHidespotInteractionsAnimRefs::ExitPeek' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, Investigate) == 0x000030, "Member 'FSingleHidespotInteractionsAnimRefs::Investigate' has a wrong offset!");
static_assert(offsetof(FSingleHidespotInteractionsAnimRefs, KnockdownExit) == 0x000040, "Member 'FSingleHidespotInteractionsAnimRefs::KnockdownExit' has a wrong offset!");

// ScriptStruct OPP.CurrencyEntry
// 0x0008 (0x0008 - 0x0000)
struct FCurrencyEntry final
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyEntry) == 0x000004, "Wrong alignment on FCurrencyEntry");
static_assert(sizeof(FCurrencyEntry) == 0x000008, "Wrong size on FCurrencyEntry");
static_assert(offsetof(FCurrencyEntry, CurrencyType) == 0x000000, "Member 'FCurrencyEntry::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyEntry, Count) == 0x000004, "Member 'FCurrencyEntry::Count' has a wrong offset!");

// ScriptStruct OPP.ThreatLevelInfo
// 0x0018 (0x0018 - 0x0000)
struct FThreatLevelInfo final
{
public:
	class ARBNPC*                                 ThreateningNPC;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatLevelRTPC;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThreatLevelInfo) == 0x000008, "Wrong alignment on FThreatLevelInfo");
static_assert(sizeof(FThreatLevelInfo) == 0x000018, "Wrong size on FThreatLevelInfo");
static_assert(offsetof(FThreatLevelInfo, ThreateningNPC) == 0x000000, "Member 'FThreatLevelInfo::ThreateningNPC' has a wrong offset!");
static_assert(offsetof(FThreatLevelInfo, ThreatLevelRTPC) == 0x000008, "Member 'FThreatLevelInfo::ThreatLevelRTPC' has a wrong offset!");

// ScriptStruct OPP.QueuedTrialChainingItemSpawnInfo
// 0x0002 (0x0002 - 0x0000)
struct FQueuedTrialChainingItemSpawnInfo final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPack;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuedTrialChainingItemSpawnInfo) == 0x000001, "Wrong alignment on FQueuedTrialChainingItemSpawnInfo");
static_assert(sizeof(FQueuedTrialChainingItemSpawnInfo) == 0x000002, "Wrong size on FQueuedTrialChainingItemSpawnInfo");
static_assert(offsetof(FQueuedTrialChainingItemSpawnInfo, ItemType) == 0x000000, "Member 'FQueuedTrialChainingItemSpawnInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FQueuedTrialChainingItemSpawnInfo, bIsPack) == 0x000001, "Member 'FQueuedTrialChainingItemSpawnInfo::bIsPack' has a wrong offset!");

// ScriptStruct OPP.ProceduralTranslationAnimData
// 0x003C (0x003C - 0x0000)
struct FProceduralTranslationAnimData final
{
public:
	struct FVector                                PositionDelta;                                     // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralAnimInterpType                     InterpType;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScheduledPawnTime;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScheduledServerTime;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantSpeedContrib;                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeLeft;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForNotify;                                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeDataAfterNotify;                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RecomputeDesiredPosition;                          // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralTranslationAnimData) == 0x000004, "Wrong alignment on FProceduralTranslationAnimData");
static_assert(sizeof(FProceduralTranslationAnimData) == 0x00003C, "Wrong size on FProceduralTranslationAnimData");
static_assert(offsetof(FProceduralTranslationAnimData, PositionDelta) == 0x000000, "Member 'FProceduralTranslationAnimData::PositionDelta' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, InterpType) == 0x00000C, "Member 'FProceduralTranslationAnimData::InterpType' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, ScheduledPawnTime) == 0x000010, "Member 'FProceduralTranslationAnimData::ScheduledPawnTime' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, ScheduledServerTime) == 0x000014, "Member 'FProceduralTranslationAnimData::ScheduledServerTime' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, ConstantSpeedContrib) == 0x000018, "Member 'FProceduralTranslationAnimData::ConstantSpeedContrib' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, DelayTimeLeft) == 0x00001C, "Member 'FProceduralTranslationAnimData::DelayTimeLeft' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, TotalTime) == 0x000020, "Member 'FProceduralTranslationAnimData::TotalTime' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, ElapsedTime) == 0x000024, "Member 'FProceduralTranslationAnimData::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, bWaitForNotify) == 0x000028, "Member 'FProceduralTranslationAnimData::bWaitForNotify' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, bRecomputeDataAfterNotify) == 0x000029, "Member 'FProceduralTranslationAnimData::bRecomputeDataAfterNotify' has a wrong offset!");
static_assert(offsetof(FProceduralTranslationAnimData, RecomputeDesiredPosition) == 0x00002C, "Member 'FProceduralTranslationAnimData::RecomputeDesiredPosition' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningManagerTypeStats
// 0x0068 (0x0068 - 0x0000)
struct FItemSpawningManagerTypeStats final
{
public:
	int32                                         NumberOfItemsRandomized;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsSpawnedInStage;                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNumberOfItemsSpawnedInRewardRooms;            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsAddedBySwap;                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsLocked;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NumberOfItemsSpawnedInVolumes;                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBRoomGroup*>                   UsedSectionOverrides;                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NumberOfItemsSpawnedInSectionOverride;             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         UsedRewardRooms;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NumberOfItemsSpawnedInRewardRooms;                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawningManagerTypeStats) == 0x000008, "Wrong alignment on FItemSpawningManagerTypeStats");
static_assert(sizeof(FItemSpawningManagerTypeStats) == 0x000068, "Wrong size on FItemSpawningManagerTypeStats");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsRandomized) == 0x000000, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsRandomized' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsSpawnedInStage) == 0x000004, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsSpawnedInStage' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, TotalNumberOfItemsSpawnedInRewardRooms) == 0x000008, "Member 'FItemSpawningManagerTypeStats::TotalNumberOfItemsSpawnedInRewardRooms' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsAddedBySwap) == 0x00000C, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsAddedBySwap' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsLocked) == 0x000010, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsLocked' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsSpawnedInVolumes) == 0x000018, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsSpawnedInVolumes' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, UsedSectionOverrides) == 0x000028, "Member 'FItemSpawningManagerTypeStats::UsedSectionOverrides' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsSpawnedInSectionOverride) == 0x000038, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsSpawnedInSectionOverride' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, UsedRewardRooms) == 0x000048, "Member 'FItemSpawningManagerTypeStats::UsedRewardRooms' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerTypeStats, NumberOfItemsSpawnedInRewardRooms) == 0x000058, "Member 'FItemSpawningManagerTypeStats::NumberOfItemsSpawnedInRewardRooms' has a wrong offset!");

// ScriptStruct OPP.NPCWeaponThrowingParameters
// 0x0028 (0x0028 - 0x0000)
struct FNPCWeaponThrowingParameters final
{
public:
	float                                         DesiredSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumSpeed;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumSpeed;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredPitch;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumPitch;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumPitch;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredYaw;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumYaw;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumYaw;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Imprecision;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCWeaponThrowingParameters) == 0x000004, "Wrong alignment on FNPCWeaponThrowingParameters");
static_assert(sizeof(FNPCWeaponThrowingParameters) == 0x000028, "Wrong size on FNPCWeaponThrowingParameters");
static_assert(offsetof(FNPCWeaponThrowingParameters, DesiredSpeed) == 0x000000, "Member 'FNPCWeaponThrowingParameters::DesiredSpeed' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MinimumSpeed) == 0x000004, "Member 'FNPCWeaponThrowingParameters::MinimumSpeed' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MaximumSpeed) == 0x000008, "Member 'FNPCWeaponThrowingParameters::MaximumSpeed' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, DesiredPitch) == 0x00000C, "Member 'FNPCWeaponThrowingParameters::DesiredPitch' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MinimumPitch) == 0x000010, "Member 'FNPCWeaponThrowingParameters::MinimumPitch' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MaximumPitch) == 0x000014, "Member 'FNPCWeaponThrowingParameters::MaximumPitch' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, DesiredYaw) == 0x000018, "Member 'FNPCWeaponThrowingParameters::DesiredYaw' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MinimumYaw) == 0x00001C, "Member 'FNPCWeaponThrowingParameters::MinimumYaw' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, MaximumYaw) == 0x000020, "Member 'FNPCWeaponThrowingParameters::MaximumYaw' has a wrong offset!");
static_assert(offsetof(FNPCWeaponThrowingParameters, Imprecision) == 0x000024, "Member 'FNPCWeaponThrowingParameters::Imprecision' has a wrong offset!");

// ScriptStruct OPP.AIAmbientAnimData
// 0x0020 (0x0020 - 0x0000)
struct FAIAmbientAnimData final
{
public:
	bool                                          bActiveAmbientAnim;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingAmbientBlendspace;                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        AmbientIdleBlendSpace;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientIdleRelativeYaw;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientIdleRelativePitch;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AmbientIdleSequence;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAmbientAnimData) == 0x000008, "Wrong alignment on FAIAmbientAnimData");
static_assert(sizeof(FAIAmbientAnimData) == 0x000020, "Wrong size on FAIAmbientAnimData");
static_assert(offsetof(FAIAmbientAnimData, bActiveAmbientAnim) == 0x000000, "Member 'FAIAmbientAnimData::bActiveAmbientAnim' has a wrong offset!");
static_assert(offsetof(FAIAmbientAnimData, bPlayingAmbientBlendspace) == 0x000001, "Member 'FAIAmbientAnimData::bPlayingAmbientBlendspace' has a wrong offset!");
static_assert(offsetof(FAIAmbientAnimData, AmbientIdleBlendSpace) == 0x000008, "Member 'FAIAmbientAnimData::AmbientIdleBlendSpace' has a wrong offset!");
static_assert(offsetof(FAIAmbientAnimData, AmbientIdleRelativeYaw) == 0x000010, "Member 'FAIAmbientAnimData::AmbientIdleRelativeYaw' has a wrong offset!");
static_assert(offsetof(FAIAmbientAnimData, AmbientIdleRelativePitch) == 0x000014, "Member 'FAIAmbientAnimData::AmbientIdleRelativePitch' has a wrong offset!");
static_assert(offsetof(FAIAmbientAnimData, AmbientIdleSequence) == 0x000018, "Member 'FAIAmbientAnimData::AmbientIdleSequence' has a wrong offset!");

// ScriptStruct OPP.QueuedTrialChainingUpgradeChoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FQueuedTrialChainingUpgradeChoiceInfo final
{
public:
	TArray<struct FTrialChainingWeightedUpgradeType> PossibleUpgradeTypes;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ETrialChainingUpgradeChoiceType               ChoiceType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireAcquired;                                  // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueuedTrialChainingUpgradeChoiceInfo) == 0x000008, "Wrong alignment on FQueuedTrialChainingUpgradeChoiceInfo");
static_assert(sizeof(FQueuedTrialChainingUpgradeChoiceInfo) == 0x000018, "Wrong size on FQueuedTrialChainingUpgradeChoiceInfo");
static_assert(offsetof(FQueuedTrialChainingUpgradeChoiceInfo, PossibleUpgradeTypes) == 0x000000, "Member 'FQueuedTrialChainingUpgradeChoiceInfo::PossibleUpgradeTypes' has a wrong offset!");
static_assert(offsetof(FQueuedTrialChainingUpgradeChoiceInfo, ChoiceType) == 0x000010, "Member 'FQueuedTrialChainingUpgradeChoiceInfo::ChoiceType' has a wrong offset!");
static_assert(offsetof(FQueuedTrialChainingUpgradeChoiceInfo, bRequireAcquired) == 0x000011, "Member 'FQueuedTrialChainingUpgradeChoiceInfo::bRequireAcquired' has a wrong offset!");

// ScriptStruct OPP.AvailablePeriodicTask
// 0x0010 (0x0010 - 0x0000)
struct FAvailablePeriodicTask final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskId;                                            // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskCategory                                 Category;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailablePeriodicTask) == 0x000004, "Wrong alignment on FAvailablePeriodicTask");
static_assert(sizeof(FAvailablePeriodicTask) == 0x000010, "Wrong size on FAvailablePeriodicTask");
static_assert(offsetof(FAvailablePeriodicTask, Seed) == 0x000000, "Member 'FAvailablePeriodicTask::Seed' has a wrong offset!");
static_assert(offsetof(FAvailablePeriodicTask, TaskId) == 0x000004, "Member 'FAvailablePeriodicTask::TaskId' has a wrong offset!");
static_assert(offsetof(FAvailablePeriodicTask, Category) == 0x00000C, "Member 'FAvailablePeriodicTask::Category' has a wrong offset!");

// ScriptStruct OPP.RandomLoopingAnimParams
// 0x0020 (0x0020 - 0x0000)
struct FRandomLoopingAnimParams final
{
public:
	class UAnimationAsset*                        LoopingIdle;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionOnCycleBoundary;                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeOdds;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayDuration;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayDuration;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayerDistance;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomLoopingAnimParams) == 0x000008, "Wrong alignment on FRandomLoopingAnimParams");
static_assert(sizeof(FRandomLoopingAnimParams) == 0x000020, "Wrong size on FRandomLoopingAnimParams");
static_assert(offsetof(FRandomLoopingAnimParams, LoopingIdle) == 0x000000, "Member 'FRandomLoopingAnimParams::LoopingIdle' has a wrong offset!");
static_assert(offsetof(FRandomLoopingAnimParams, bTransitionOnCycleBoundary) == 0x000008, "Member 'FRandomLoopingAnimParams::bTransitionOnCycleBoundary' has a wrong offset!");
static_assert(offsetof(FRandomLoopingAnimParams, RelativeOdds) == 0x00000C, "Member 'FRandomLoopingAnimParams::RelativeOdds' has a wrong offset!");
static_assert(offsetof(FRandomLoopingAnimParams, MinPlayDuration) == 0x000010, "Member 'FRandomLoopingAnimParams::MinPlayDuration' has a wrong offset!");
static_assert(offsetof(FRandomLoopingAnimParams, MaxPlayDuration) == 0x000014, "Member 'FRandomLoopingAnimParams::MaxPlayDuration' has a wrong offset!");
static_assert(offsetof(FRandomLoopingAnimParams, MaxPlayerDistance) == 0x000018, "Member 'FRandomLoopingAnimParams::MaxPlayerDistance' has a wrong offset!");

// ScriptStruct OPP.RandomOneOffAnimParams
// 0x0018 (0x0018 - 0x0000)
struct FRandomOneOffAnimParams final
{
public:
	class UAnimationAsset*                        AnimAsset;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeOdds;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinReplayInterval;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayerDistance;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomOneOffAnimParams) == 0x000008, "Wrong alignment on FRandomOneOffAnimParams");
static_assert(sizeof(FRandomOneOffAnimParams) == 0x000018, "Wrong size on FRandomOneOffAnimParams");
static_assert(offsetof(FRandomOneOffAnimParams, AnimAsset) == 0x000000, "Member 'FRandomOneOffAnimParams::AnimAsset' has a wrong offset!");
static_assert(offsetof(FRandomOneOffAnimParams, RelativeOdds) == 0x000008, "Member 'FRandomOneOffAnimParams::RelativeOdds' has a wrong offset!");
static_assert(offsetof(FRandomOneOffAnimParams, MinReplayInterval) == 0x00000C, "Member 'FRandomOneOffAnimParams::MinReplayInterval' has a wrong offset!");
static_assert(offsetof(FRandomOneOffAnimParams, MaxPlayerDistance) == 0x000010, "Member 'FRandomOneOffAnimParams::MaxPlayerDistance' has a wrong offset!");

// ScriptStruct OPP.BCReactionAnimParams
// 0x0020 (0x0020 - 0x0000)
struct FBCReactionAnimParams final
{
public:
	bool                                          bEnableOnPlayerAttacked;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOnWorldDisturbance;                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDisturbanceDistance;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisturbanceHeightThreshold;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AnimAsset;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeOdds;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinReplayInterval;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBCReactionAnimParams) == 0x000008, "Wrong alignment on FBCReactionAnimParams");
static_assert(sizeof(FBCReactionAnimParams) == 0x000020, "Wrong size on FBCReactionAnimParams");
static_assert(offsetof(FBCReactionAnimParams, bEnableOnPlayerAttacked) == 0x000000, "Member 'FBCReactionAnimParams::bEnableOnPlayerAttacked' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, bEnableOnWorldDisturbance) == 0x000001, "Member 'FBCReactionAnimParams::bEnableOnWorldDisturbance' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, MaxDisturbanceDistance) == 0x000004, "Member 'FBCReactionAnimParams::MaxDisturbanceDistance' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, DisturbanceHeightThreshold) == 0x000008, "Member 'FBCReactionAnimParams::DisturbanceHeightThreshold' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, AnimAsset) == 0x000010, "Member 'FBCReactionAnimParams::AnimAsset' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, RelativeOdds) == 0x000018, "Member 'FBCReactionAnimParams::RelativeOdds' has a wrong offset!");
static_assert(offsetof(FBCReactionAnimParams, MinReplayInterval) == 0x00001C, "Member 'FBCReactionAnimParams::MinReplayInterval' has a wrong offset!");

// ScriptStruct OPP.RBBackgroundCharacterStationParams
// 0x0060 (0x0060 - 0x0000)
struct FRBBackgroundCharacterStationParams final
{
public:
	TArray<struct FRandomLoopingAnimParams>       LoopingIdles;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLookingIdlesAnimParams                LookingIdles;                                      // 0x0010(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FRandomOneOffAnimParams>        OneOffBreakers;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBCReactionAnimParams>          ReactionAnims;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBackgroundCharacterStationParams) == 0x000008, "Wrong alignment on FRBBackgroundCharacterStationParams");
static_assert(sizeof(FRBBackgroundCharacterStationParams) == 0x000060, "Wrong size on FRBBackgroundCharacterStationParams");
static_assert(offsetof(FRBBackgroundCharacterStationParams, LoopingIdles) == 0x000000, "Member 'FRBBackgroundCharacterStationParams::LoopingIdles' has a wrong offset!");
static_assert(offsetof(FRBBackgroundCharacterStationParams, LookingIdles) == 0x000010, "Member 'FRBBackgroundCharacterStationParams::LookingIdles' has a wrong offset!");
static_assert(offsetof(FRBBackgroundCharacterStationParams, OneOffBreakers) == 0x000040, "Member 'FRBBackgroundCharacterStationParams::OneOffBreakers' has a wrong offset!");
static_assert(offsetof(FRBBackgroundCharacterStationParams, ReactionAnims) == 0x000050, "Member 'FRBBackgroundCharacterStationParams::ReactionAnims' has a wrong offset!");

// ScriptStruct OPP.FeatureSwitchDefaultValueConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FFeatureSwitchDefaultValueConfiguration final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultValue;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFeatureSwitchDefaultValueConfiguration) == 0x000008, "Wrong alignment on FFeatureSwitchDefaultValueConfiguration");
static_assert(sizeof(FFeatureSwitchDefaultValueConfiguration) == 0x000018, "Wrong size on FFeatureSwitchDefaultValueConfiguration");
static_assert(offsetof(FFeatureSwitchDefaultValueConfiguration, Key) == 0x000000, "Member 'FFeatureSwitchDefaultValueConfiguration::Key' has a wrong offset!");
static_assert(offsetof(FFeatureSwitchDefaultValueConfiguration, bDefaultValue) == 0x000010, "Member 'FFeatureSwitchDefaultValueConfiguration::bDefaultValue' has a wrong offset!");

// ScriptStruct OPP.RBTaskHudProgressDisplayDetails
// 0x0010 (0x0010 - 0x0000)
struct FRBTaskHudProgressDisplayDetails final
{
public:
	TArray<class FName>                           TaskIds;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTaskHudProgressDisplayDetails) == 0x000008, "Wrong alignment on FRBTaskHudProgressDisplayDetails");
static_assert(sizeof(FRBTaskHudProgressDisplayDetails) == 0x000010, "Wrong size on FRBTaskHudProgressDisplayDetails");
static_assert(offsetof(FRBTaskHudProgressDisplayDetails, TaskIds) == 0x000000, "Member 'FRBTaskHudProgressDisplayDetails::TaskIds' has a wrong offset!");

// ScriptStruct OPP.RBTaskProgressionEntry
// 0x001C (0x001C - 0x0000)
struct FRBTaskProgressionEntry final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingProgress;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCompleted;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasConsumedReward;                                // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumedReward;                                   // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTaskProgressionEntry) == 0x000004, "Wrong alignment on FRBTaskProgressionEntry");
static_assert(sizeof(FRBTaskProgressionEntry) == 0x00001C, "Wrong size on FRBTaskProgressionEntry");
static_assert(offsetof(FRBTaskProgressionEntry, Seed) == 0x000000, "Member 'FRBTaskProgressionEntry::Seed' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, ID) == 0x000004, "Member 'FRBTaskProgressionEntry::ID' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, bSelected) == 0x00000C, "Member 'FRBTaskProgressionEntry::bSelected' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, StartingProgress) == 0x000010, "Member 'FRBTaskProgressionEntry::StartingProgress' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, Progress) == 0x000014, "Member 'FRBTaskProgressionEntry::Progress' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, bWasCompleted) == 0x000018, "Member 'FRBTaskProgressionEntry::bWasCompleted' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, bCompleted) == 0x000019, "Member 'FRBTaskProgressionEntry::bCompleted' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, bWasConsumedReward) == 0x00001A, "Member 'FRBTaskProgressionEntry::bWasConsumedReward' has a wrong offset!");
static_assert(offsetof(FRBTaskProgressionEntry, bConsumedReward) == 0x00001B, "Member 'FRBTaskProgressionEntry::bConsumedReward' has a wrong offset!");

// ScriptStruct OPP.ClimbOverAnimRefs
// 0x00E0 (0x00E0 - 0x0000)
struct FClimbOverAnimRefs final
{
public:
	struct FRBAnimRef                             ClimbOver_150to200;                                // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOver_150to200 : 1;                  // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOver_200to300;                                // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOver_200to300 : 1;                  // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOver_Down_100to150;                           // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOver_Down_100to150 : 1;             // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOver_Down_ToFall;                             // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOver_Down_ToFall : 1;               // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClimbOverAnimRefs) == 0x000008, "Wrong alignment on FClimbOverAnimRefs");
static_assert(sizeof(FClimbOverAnimRefs) == 0x0000E0, "Wrong size on FClimbOverAnimRefs");
static_assert(offsetof(FClimbOverAnimRefs, ClimbOver_150to200) == 0x000000, "Member 'FClimbOverAnimRefs::ClimbOver_150to200' has a wrong offset!");
static_assert(offsetof(FClimbOverAnimRefs, ClimbOver_200to300) == 0x000038, "Member 'FClimbOverAnimRefs::ClimbOver_200to300' has a wrong offset!");
static_assert(offsetof(FClimbOverAnimRefs, ClimbOver_Down_100to150) == 0x000070, "Member 'FClimbOverAnimRefs::ClimbOver_Down_100to150' has a wrong offset!");
static_assert(offsetof(FClimbOverAnimRefs, ClimbOver_Down_ToFall) == 0x0000A8, "Member 'FClimbOverAnimRefs::ClimbOver_Down_ToFall' has a wrong offset!");

// ScriptStruct OPP.JumpOverAnimRefs
// 0x0590 (0x0590 - 0x0000)
struct FJumpOverAnimRefs final
{
public:
	struct FRBAnimRef                             JumpOver_Running_25to100;                          // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Running_25to100 : 1;            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Running_LowHeight_25to100;                // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Running_LowHeight_25to100 : 1;  // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Running_LowHeight_100to150;               // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Running_LowHeight_100to150 : 1; // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Running_100to150;                         // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Running_100to150 : 1;           // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Walking_25to100;                          // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Walking_25to100 : 1;            // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Walking_LowHeight_25to100;                // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Walking_LowHeight_25to100 : 1;  // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_NoContact_25to100;                        // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_NoContact_25to100 : 1;          // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_NoContact_100to150;                       // 0x0188(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_NoContact_100to150 : 1;         // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Narrow_25to100;                           // 0x01C0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Narrow_25to100 : 1;             // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_Narrow_100to150;                          // 0x01F8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_Narrow_100to150 : 1;            // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbOverAnimRefs                     JumpOver_ClimbOver_Flat;                           // 0x0230(0x00E0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_ClimbOver_Flat : 1;             // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbOverAnimRefs                     JumpOver_ClimbOver_Angled45Right;                  // 0x0318(0x00E0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_ClimbOver_Angled45Right : 1;    // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbOverAnimRefs                     JumpOver_ClimbOver_Angled45Left;                   // 0x0400(0x00E0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_ClimbOver_Angled45Left : 1;     // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_SlideOver;                                // 0x04E8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_SlideOver : 1;                  // 0x0518(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_LowSlideOver;                             // 0x0520(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_LowSlideOver : 1;               // 0x0550(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpOver_BigGruntLowClearance_100to150;            // 0x0558(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_BigGruntLowClearance_100to150 : 1; // 0x0588(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpOverAnimRefs) == 0x000008, "Wrong alignment on FJumpOverAnimRefs");
static_assert(sizeof(FJumpOverAnimRefs) == 0x000590, "Wrong size on FJumpOverAnimRefs");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Running_25to100) == 0x000000, "Member 'FJumpOverAnimRefs::JumpOver_Running_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Running_LowHeight_25to100) == 0x000038, "Member 'FJumpOverAnimRefs::JumpOver_Running_LowHeight_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Running_LowHeight_100to150) == 0x000070, "Member 'FJumpOverAnimRefs::JumpOver_Running_LowHeight_100to150' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Running_100to150) == 0x0000A8, "Member 'FJumpOverAnimRefs::JumpOver_Running_100to150' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Walking_25to100) == 0x0000E0, "Member 'FJumpOverAnimRefs::JumpOver_Walking_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Walking_LowHeight_25to100) == 0x000118, "Member 'FJumpOverAnimRefs::JumpOver_Walking_LowHeight_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_NoContact_25to100) == 0x000150, "Member 'FJumpOverAnimRefs::JumpOver_NoContact_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_NoContact_100to150) == 0x000188, "Member 'FJumpOverAnimRefs::JumpOver_NoContact_100to150' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Narrow_25to100) == 0x0001C0, "Member 'FJumpOverAnimRefs::JumpOver_Narrow_25to100' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_Narrow_100to150) == 0x0001F8, "Member 'FJumpOverAnimRefs::JumpOver_Narrow_100to150' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_ClimbOver_Flat) == 0x000230, "Member 'FJumpOverAnimRefs::JumpOver_ClimbOver_Flat' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_ClimbOver_Angled45Right) == 0x000318, "Member 'FJumpOverAnimRefs::JumpOver_ClimbOver_Angled45Right' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_ClimbOver_Angled45Left) == 0x000400, "Member 'FJumpOverAnimRefs::JumpOver_ClimbOver_Angled45Left' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_SlideOver) == 0x0004E8, "Member 'FJumpOverAnimRefs::JumpOver_SlideOver' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_LowSlideOver) == 0x000520, "Member 'FJumpOverAnimRefs::JumpOver_LowSlideOver' has a wrong offset!");
static_assert(offsetof(FJumpOverAnimRefs, JumpOver_BigGruntLowClearance_100to150) == 0x000558, "Member 'FJumpOverAnimRefs::JumpOver_BigGruntLowClearance_100to150' has a wrong offset!");

// ScriptStruct OPP.RBReleaseTrialSelectionDetails
// 0x0020 (0x0020 - 0x0000)
struct FRBReleaseTrialSelectionDetails final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumReleaseCount;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumReleaseCount;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBReleaseTrialSelectionDetails) == 0x000004, "Wrong alignment on FRBReleaseTrialSelectionDetails");
static_assert(sizeof(FRBReleaseTrialSelectionDetails) == 0x000020, "Wrong size on FRBReleaseTrialSelectionDetails");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, ProgramId) == 0x000000, "Member 'FRBReleaseTrialSelectionDetails::ProgramId' has a wrong offset!");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, TrialId) == 0x000008, "Member 'FRBReleaseTrialSelectionDetails::TrialId' has a wrong offset!");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, ProgramDifficulty) == 0x000010, "Member 'FRBReleaseTrialSelectionDetails::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, MinimumReleaseCount) == 0x000014, "Member 'FRBReleaseTrialSelectionDetails::MinimumReleaseCount' has a wrong offset!");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, MaximumReleaseCount) == 0x000018, "Member 'FRBReleaseTrialSelectionDetails::MaximumReleaseCount' has a wrong offset!");
static_assert(offsetof(FRBReleaseTrialSelectionDetails, Weight) == 0x00001C, "Member 'FRBReleaseTrialSelectionDetails::Weight' has a wrong offset!");

// ScriptStruct OPP.RBFeatureSwitchOverride
// 0x0018 (0x0018 - 0x0000)
struct FRBFeatureSwitchOverride final
{
public:
	class FString                                 FeatureSwitch;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBFeatureSwitchOverride) == 0x000008, "Wrong alignment on FRBFeatureSwitchOverride");
static_assert(sizeof(FRBFeatureSwitchOverride) == 0x000018, "Wrong size on FRBFeatureSwitchOverride");
static_assert(offsetof(FRBFeatureSwitchOverride, FeatureSwitch) == 0x000000, "Member 'FRBFeatureSwitchOverride::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBFeatureSwitchOverride, bEnabled) == 0x000010, "Member 'FRBFeatureSwitchOverride::bEnabled' has a wrong offset!");

// ScriptStruct OPP.StreamingCommand
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FStreamingCommand final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamingCommand) == 0x000008, "Wrong alignment on FStreamingCommand");
static_assert(sizeof(FStreamingCommand) == 0x000018, "Wrong size on FStreamingCommand");

// ScriptStruct OPP.RBStatEntry
// 0x0008 (0x0008 - 0x0000)
struct FRBStatEntry final
{
public:
	EPlayerStat                                   PlayerStat;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBStatEntry) == 0x000004, "Wrong alignment on FRBStatEntry");
static_assert(sizeof(FRBStatEntry) == 0x000008, "Wrong size on FRBStatEntry");
static_assert(offsetof(FRBStatEntry, PlayerStat) == 0x000000, "Member 'FRBStatEntry::PlayerStat' has a wrong offset!");
static_assert(offsetof(FRBStatEntry, Value) == 0x000004, "Member 'FRBStatEntry::Value' has a wrong offset!");

// ScriptStruct OPP.RBVariatorNPCVOMappingOverride
// 0x0040 (0x0040 - 0x0000)
struct FRBVariatorNPCVOMappingOverride final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URBVOMappingOverride>    VOMappingOverrideRef;                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBGameCondition*>               Conditions;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBVariatorNPCVOMappingOverride) == 0x000008, "Wrong alignment on FRBVariatorNPCVOMappingOverride");
static_assert(sizeof(FRBVariatorNPCVOMappingOverride) == 0x000040, "Wrong size on FRBVariatorNPCVOMappingOverride");
static_assert(offsetof(FRBVariatorNPCVOMappingOverride, NPCType) == 0x000000, "Member 'FRBVariatorNPCVOMappingOverride::NPCType' has a wrong offset!");
static_assert(offsetof(FRBVariatorNPCVOMappingOverride, NPCFlavor) == 0x000001, "Member 'FRBVariatorNPCVOMappingOverride::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FRBVariatorNPCVOMappingOverride, VOMappingOverrideRef) == 0x000008, "Member 'FRBVariatorNPCVOMappingOverride::VOMappingOverrideRef' has a wrong offset!");
static_assert(offsetof(FRBVariatorNPCVOMappingOverride, Conditions) == 0x000030, "Member 'FRBVariatorNPCVOMappingOverride::Conditions' has a wrong offset!");

// ScriptStruct OPP.RBEvalCorridorHelperCmpDebugInfo
// 0x0038 (0x0038 - 0x0000)
struct FRBEvalCorridorHelperCmpDebugInfo final
{
public:
	class URBEvalCorridorHelperComponent*         HelperCmp;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            LinkedCollisions;                                  // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ARBPlayer*>                      DisabledCollisionsForPlayers_Server;               // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBPlayer*>                      DisabledCollisionsForPlayers_Local;                // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBEvalCorridorHelperCmpDebugInfo) == 0x000008, "Wrong alignment on FRBEvalCorridorHelperCmpDebugInfo");
static_assert(sizeof(FRBEvalCorridorHelperCmpDebugInfo) == 0x000038, "Wrong size on FRBEvalCorridorHelperCmpDebugInfo");
static_assert(offsetof(FRBEvalCorridorHelperCmpDebugInfo, HelperCmp) == 0x000000, "Member 'FRBEvalCorridorHelperCmpDebugInfo::HelperCmp' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorHelperCmpDebugInfo, LinkedCollisions) == 0x000008, "Member 'FRBEvalCorridorHelperCmpDebugInfo::LinkedCollisions' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorHelperCmpDebugInfo, DisabledCollisionsForPlayers_Server) == 0x000018, "Member 'FRBEvalCorridorHelperCmpDebugInfo::DisabledCollisionsForPlayers_Server' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorHelperCmpDebugInfo, DisabledCollisionsForPlayers_Local) == 0x000028, "Member 'FRBEvalCorridorHelperCmpDebugInfo::DisabledCollisionsForPlayers_Local' has a wrong offset!");

// ScriptStruct OPP.RBEvalCorridorDebugInfo
// 0x0038 (0x0038 - 0x0000)
struct FRBEvalCorridorDebugInfo final
{
public:
	class ARBPlayer*                              DebugRequester;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBPlayer*>                      PlayersInEvalCorridor;                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            ComponentsToIgnoreOnRequester;                     // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FRBEvalCorridorHelperCmpDebugInfo> EvalCorridorHelperCmpDebugInfos;                   // 0x0028(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBEvalCorridorDebugInfo) == 0x000008, "Wrong alignment on FRBEvalCorridorDebugInfo");
static_assert(sizeof(FRBEvalCorridorDebugInfo) == 0x000038, "Wrong size on FRBEvalCorridorDebugInfo");
static_assert(offsetof(FRBEvalCorridorDebugInfo, DebugRequester) == 0x000000, "Member 'FRBEvalCorridorDebugInfo::DebugRequester' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorDebugInfo, PlayersInEvalCorridor) == 0x000008, "Member 'FRBEvalCorridorDebugInfo::PlayersInEvalCorridor' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorDebugInfo, ComponentsToIgnoreOnRequester) == 0x000018, "Member 'FRBEvalCorridorDebugInfo::ComponentsToIgnoreOnRequester' has a wrong offset!");
static_assert(offsetof(FRBEvalCorridorDebugInfo, EvalCorridorHelperCmpDebugInfos) == 0x000028, "Member 'FRBEvalCorridorDebugInfo::EvalCorridorHelperCmpDebugInfos' has a wrong offset!");

// ScriptStruct OPP.TrialProgressionEntry
// 0x0014 (0x0014 - 0x0000)
struct FTrialProgressionEntry final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerfect;                                          // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrialProgressionEntry) == 0x000004, "Wrong alignment on FTrialProgressionEntry");
static_assert(sizeof(FTrialProgressionEntry) == 0x000014, "Wrong size on FTrialProgressionEntry");
static_assert(offsetof(FTrialProgressionEntry, ProgramId) == 0x000000, "Member 'FTrialProgressionEntry::ProgramId' has a wrong offset!");
static_assert(offsetof(FTrialProgressionEntry, TrialId) == 0x000008, "Member 'FTrialProgressionEntry::TrialId' has a wrong offset!");
static_assert(offsetof(FTrialProgressionEntry, ProgramDifficulty) == 0x000010, "Member 'FTrialProgressionEntry::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FTrialProgressionEntry, bCompleted) == 0x000011, "Member 'FTrialProgressionEntry::bCompleted' has a wrong offset!");
static_assert(offsetof(FTrialProgressionEntry, bPerfect) == 0x000012, "Member 'FTrialProgressionEntry::bPerfect' has a wrong offset!");

// ScriptStruct OPP.TrialProgression
// 0x0010 (0x0010 - 0x0000)
struct FTrialProgression final
{
public:
	TArray<struct FTrialProgressionEntry>         Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialProgression) == 0x000008, "Wrong alignment on FTrialProgression");
static_assert(sizeof(FTrialProgression) == 0x000010, "Wrong size on FTrialProgression");
static_assert(offsetof(FTrialProgression, Entries) == 0x000000, "Member 'FTrialProgression::Entries' has a wrong offset!");

// ScriptStruct OPP.UICustomizationItem
// 0x0058 (0x0058 - 0x0000)
struct FUICustomizationItem final
{
public:
	class URBPlayerCustomizationOption*           CustomizationOption;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBCustomizationOutfit*                 Outfit;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBVoiceCustomizationOption*            VoiceOption;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconOption;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconBorderOption;                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBEmoteCustomizationOption*            PodiumEmoteOption;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBEmoteCustomizationOption*            TerminalEmoteOption;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerCellItemDefinition*            CellOption;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationInteractionType                 InteractionType;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDLC;                                            // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayOrder;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkedEvent;                                       // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUICustomizationItem) == 0x000008, "Wrong alignment on FUICustomizationItem");
static_assert(sizeof(FUICustomizationItem) == 0x000058, "Wrong size on FUICustomizationItem");
static_assert(offsetof(FUICustomizationItem, CustomizationOption) == 0x000000, "Member 'FUICustomizationItem::CustomizationOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, Outfit) == 0x000008, "Member 'FUICustomizationItem::Outfit' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, VoiceOption) == 0x000010, "Member 'FUICustomizationItem::VoiceOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, PlayerIconOption) == 0x000018, "Member 'FUICustomizationItem::PlayerIconOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, PlayerIconBorderOption) == 0x000020, "Member 'FUICustomizationItem::PlayerIconBorderOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, PodiumEmoteOption) == 0x000028, "Member 'FUICustomizationItem::PodiumEmoteOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, TerminalEmoteOption) == 0x000030, "Member 'FUICustomizationItem::TerminalEmoteOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, CellOption) == 0x000038, "Member 'FUICustomizationItem::CellOption' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, bIsEquipped) == 0x000040, "Member 'FUICustomizationItem::bIsEquipped' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, InteractionType) == 0x000041, "Member 'FUICustomizationItem::InteractionType' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, bIsFemale) == 0x000042, "Member 'FUICustomizationItem::bIsFemale' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, bIsNew) == 0x000043, "Member 'FUICustomizationItem::bIsNew' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, bIsDLC) == 0x000044, "Member 'FUICustomizationItem::bIsDLC' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, DisplayOrder) == 0x000048, "Member 'FUICustomizationItem::DisplayOrder' has a wrong offset!");
static_assert(offsetof(FUICustomizationItem, LinkedEvent) == 0x00004C, "Member 'FUICustomizationItem::LinkedEvent' has a wrong offset!");

// ScriptStruct OPP.StroopRoundData
// 0x0014 (0x0014 - 0x0000)
struct FStroopRoundData final
{
public:
	EStroopGameColor                              ColorName;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStroopGameColor                              FontColor;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestionIndex;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundDuration;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimestamp;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStroopLevel                                  Level;                                             // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStroopButtonSelectionMode                    StroopButtonSelectionModeP1;                       // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStroopButtonSelectionMode                    StroopButtonSelectionModeP2;                       // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStroopRoundData) == 0x000004, "Wrong alignment on FStroopRoundData");
static_assert(sizeof(FStroopRoundData) == 0x000014, "Wrong size on FStroopRoundData");
static_assert(offsetof(FStroopRoundData, ColorName) == 0x000000, "Member 'FStroopRoundData::ColorName' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, FontColor) == 0x000001, "Member 'FStroopRoundData::FontColor' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, QuestionIndex) == 0x000004, "Member 'FStroopRoundData::QuestionIndex' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, RoundDuration) == 0x000008, "Member 'FStroopRoundData::RoundDuration' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, RoundTimestamp) == 0x00000C, "Member 'FStroopRoundData::RoundTimestamp' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, Level) == 0x000010, "Member 'FStroopRoundData::Level' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, StroopButtonSelectionModeP1) == 0x000011, "Member 'FStroopRoundData::StroopButtonSelectionModeP1' has a wrong offset!");
static_assert(offsetof(FStroopRoundData, StroopButtonSelectionModeP2) == 0x000012, "Member 'FStroopRoundData::StroopButtonSelectionModeP2' has a wrong offset!");

// ScriptStruct OPP.PawnBreadcrumb
// 0x0024 (0x0024 - 0x0000)
struct FPawnBreadcrumb final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PawnTime;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimatedStartAnim;                              // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimatedStopAnim;                               // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimMoving;                                     // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimAgressiveStance;                            // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoTickPose;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnBreadcrumb) == 0x000004, "Wrong alignment on FPawnBreadcrumb");
static_assert(sizeof(FPawnBreadcrumb) == 0x000024, "Wrong size on FPawnBreadcrumb");
static_assert(offsetof(FPawnBreadcrumb, Location) == 0x000000, "Member 'FPawnBreadcrumb::Location' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, Rotation) == 0x00000C, "Member 'FPawnBreadcrumb::Rotation' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, PawnTime) == 0x000018, "Member 'FPawnBreadcrumb::PawnTime' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, bIsAnimatedStartAnim) == 0x00001C, "Member 'FPawnBreadcrumb::bIsAnimatedStartAnim' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, bIsAnimatedStopAnim) == 0x00001D, "Member 'FPawnBreadcrumb::bIsAnimatedStopAnim' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, bIsAnimMoving) == 0x00001E, "Member 'FPawnBreadcrumb::bIsAnimMoving' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, bIsAnimAgressiveStance) == 0x00001F, "Member 'FPawnBreadcrumb::bIsAnimAgressiveStance' has a wrong offset!");
static_assert(offsetof(FPawnBreadcrumb, bNoTickPose) == 0x000020, "Member 'FPawnBreadcrumb::bNoTickPose' has a wrong offset!");

// ScriptStruct OPP.HUDTutorialTextData
// 0x0040 (0x0040 - 0x0000)
struct FHUDTutorialTextData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   TutorialId;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDisplayCount;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatDelay;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDTutorialTextData) == 0x000008, "Wrong alignment on FHUDTutorialTextData");
static_assert(sizeof(FHUDTutorialTextData) == 0x000040, "Wrong size on FHUDTutorialTextData");
static_assert(offsetof(FHUDTutorialTextData, Title) == 0x000000, "Member 'FHUDTutorialTextData::Title' has a wrong offset!");
static_assert(offsetof(FHUDTutorialTextData, Text) == 0x000018, "Member 'FHUDTutorialTextData::Text' has a wrong offset!");
static_assert(offsetof(FHUDTutorialTextData, TutorialId) == 0x000030, "Member 'FHUDTutorialTextData::TutorialId' has a wrong offset!");
static_assert(offsetof(FHUDTutorialTextData, MaxDisplayCount) == 0x000038, "Member 'FHUDTutorialTextData::MaxDisplayCount' has a wrong offset!");
static_assert(offsetof(FHUDTutorialTextData, RepeatDelay) == 0x00003C, "Member 'FHUDTutorialTextData::RepeatDelay' has a wrong offset!");

// ScriptStruct OPP.CoopMoveEntry
// 0x0078 (0x0078 - 0x0000)
struct FCoopMoveEntry final
{
public:
	struct FUniqueNetIdRepl                       PlayerANetId;                                      // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerBNetId;                                      // 0x0028(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  CoopMoveActor;                                     // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoopMoveEntry) == 0x000008, "Wrong alignment on FCoopMoveEntry");
static_assert(sizeof(FCoopMoveEntry) == 0x000078, "Wrong size on FCoopMoveEntry");
static_assert(offsetof(FCoopMoveEntry, PlayerANetId) == 0x000000, "Member 'FCoopMoveEntry::PlayerANetId' has a wrong offset!");
static_assert(offsetof(FCoopMoveEntry, PlayerBNetId) == 0x000028, "Member 'FCoopMoveEntry::PlayerBNetId' has a wrong offset!");
static_assert(offsetof(FCoopMoveEntry, CoopMoveActor) == 0x000050, "Member 'FCoopMoveEntry::CoopMoveActor' has a wrong offset!");

// ScriptStruct OPP.MusicStateChangeEvent
// 0x0028 (0x0028 - 0x0000)
struct FMusicStateChangeEvent final
{
public:
	float                                         ChangedTime;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMusicState                                 NewState;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetPlayerName;                                  // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicStateChangeEvent) == 0x000008, "Wrong alignment on FMusicStateChangeEvent");
static_assert(sizeof(FMusicStateChangeEvent) == 0x000028, "Wrong size on FMusicStateChangeEvent");
static_assert(offsetof(FMusicStateChangeEvent, ChangedTime) == 0x000000, "Member 'FMusicStateChangeEvent::ChangedTime' has a wrong offset!");
static_assert(offsetof(FMusicStateChangeEvent, NewState) == 0x000004, "Member 'FMusicStateChangeEvent::NewState' has a wrong offset!");
static_assert(offsetof(FMusicStateChangeEvent, BotName) == 0x000008, "Member 'FMusicStateChangeEvent::BotName' has a wrong offset!");
static_assert(offsetof(FMusicStateChangeEvent, TargetPlayerName) == 0x000018, "Member 'FMusicStateChangeEvent::TargetPlayerName' has a wrong offset!");

// ScriptStruct OPP.PawnRepulsionData
// 0x0014 (0x0014 - 0x0000)
struct FPawnRepulsionData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPawnRepulsionType                            Type;                                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitReactionOnPlayer;                              // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnRepulsionData) == 0x000004, "Wrong alignment on FPawnRepulsionData");
static_assert(sizeof(FPawnRepulsionData) == 0x000014, "Wrong size on FPawnRepulsionData");
static_assert(offsetof(FPawnRepulsionData, Location) == 0x000000, "Member 'FPawnRepulsionData::Location' has a wrong offset!");
static_assert(offsetof(FPawnRepulsionData, Rotation) == 0x00000C, "Member 'FPawnRepulsionData::Rotation' has a wrong offset!");
static_assert(offsetof(FPawnRepulsionData, Type) == 0x000010, "Member 'FPawnRepulsionData::Type' has a wrong offset!");
static_assert(offsetof(FPawnRepulsionData, bHitReactionOnPlayer) == 0x000011, "Member 'FPawnRepulsionData::bHitReactionOnPlayer' has a wrong offset!");

// ScriptStruct OPP.RBBreadcrumbs
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FRBBreadcrumbs final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBBreadcrumbs) == 0x000008, "Wrong alignment on FRBBreadcrumbs");
static_assert(sizeof(FRBBreadcrumbs) == 0x000020, "Wrong size on FRBBreadcrumbs");

// ScriptStruct OPP.RBGameplayAttribute
// 0x0030 (0x0030 - 0x0000)
struct FRBGameplayAttribute final
{
public:
	EGameplayAttributeType                        AttributeType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAttributeValueChanged;                           // 0x0018(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBGameplayAttribute) == 0x000008, "Wrong alignment on FRBGameplayAttribute");
static_assert(sizeof(FRBGameplayAttribute) == 0x000030, "Wrong size on FRBGameplayAttribute");
static_assert(offsetof(FRBGameplayAttribute, AttributeType) == 0x000000, "Member 'FRBGameplayAttribute::AttributeType' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttribute, DefaultValue) == 0x000004, "Member 'FRBGameplayAttribute::DefaultValue' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttribute, Owner) == 0x000008, "Member 'FRBGameplayAttribute::Owner' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttribute, Value) == 0x000010, "Member 'FRBGameplayAttribute::Value' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttribute, OnAttributeValueChanged) == 0x000018, "Member 'FRBGameplayAttribute::OnAttributeValueChanged' has a wrong offset!");

// ScriptStruct OPP.ItemDefinition
// 0x0050 (0x0050 - 0x0000)
struct FItemDefinition final
{
public:
	TSubclassOf<class AActor>                     ItemClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemValue;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsHolster;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsInstantUse;                               // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInstantItemSelectionDuringHoldConsume;       // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransferableBetweenTrials;                        // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	bool                                          bOverrideCategoryColor;                            // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           InventoryItemColor;                                // 0x003C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemDefinition) == 0x000008, "Wrong alignment on FItemDefinition");
static_assert(sizeof(FItemDefinition) == 0x000050, "Wrong size on FItemDefinition");
static_assert(offsetof(FItemDefinition, ItemClass) == 0x000000, "Member 'FItemDefinition::ItemClass' has a wrong offset!");
static_assert(offsetof(FItemDefinition, ItemCategory) == 0x000008, "Member 'FItemDefinition::ItemCategory' has a wrong offset!");
static_assert(offsetof(FItemDefinition, ItemType) == 0x000009, "Member 'FItemDefinition::ItemType' has a wrong offset!");
static_assert(offsetof(FItemDefinition, ItemValue) == 0x00000C, "Member 'FItemDefinition::ItemValue' has a wrong offset!");
static_assert(offsetof(FItemDefinition, bSupportsHolster) == 0x000010, "Member 'FItemDefinition::bSupportsHolster' has a wrong offset!");
static_assert(offsetof(FItemDefinition, bSupportsInstantUse) == 0x000011, "Member 'FItemDefinition::bSupportsInstantUse' has a wrong offset!");
static_assert(offsetof(FItemDefinition, bAllowInstantItemSelectionDuringHoldConsume) == 0x000012, "Member 'FItemDefinition::bAllowInstantItemSelectionDuringHoldConsume' has a wrong offset!");
static_assert(offsetof(FItemDefinition, bTransferableBetweenTrials) == 0x000013, "Member 'FItemDefinition::bTransferableBetweenTrials' has a wrong offset!");
static_assert(offsetof(FItemDefinition, Icon) == 0x000018, "Member 'FItemDefinition::Icon' has a wrong offset!");
static_assert(offsetof(FItemDefinition, DisplayName) == 0x000020, "Member 'FItemDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FItemDefinition, bOverrideCategoryColor) == 0x000038, "Member 'FItemDefinition::bOverrideCategoryColor' has a wrong offset!");
static_assert(offsetof(FItemDefinition, InventoryItemColor) == 0x00003C, "Member 'FItemDefinition::InventoryItemColor' has a wrong offset!");

// ScriptStruct OPP.OwnedItemSettings
// 0x0060 (0x0060 - 0x0000)
struct FOwnedItemSettings final
{
public:
	struct FItemDefinition                        ItemDefinition;                                    // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class ARBPickup*                              SpawnedItem;                                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquippableInventorySlot;                           // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOwnedItemSettings) == 0x000008, "Wrong alignment on FOwnedItemSettings");
static_assert(sizeof(FOwnedItemSettings) == 0x000060, "Wrong size on FOwnedItemSettings");
static_assert(offsetof(FOwnedItemSettings, ItemDefinition) == 0x000000, "Member 'FOwnedItemSettings::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOwnedItemSettings, SpawnedItem) == 0x000050, "Member 'FOwnedItemSettings::SpawnedItem' has a wrong offset!");
static_assert(offsetof(FOwnedItemSettings, EquippableInventorySlot) == 0x000058, "Member 'FOwnedItemSettings::EquippableInventorySlot' has a wrong offset!");

// ScriptStruct OPP.RBGameplayModifierRuntimeInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FRBGameplayModifierRuntimeInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBGameplayModifierRuntimeInfo) == 0x000004, "Wrong alignment on FRBGameplayModifierRuntimeInfo");
static_assert(sizeof(FRBGameplayModifierRuntimeInfo) == 0x000014, "Wrong size on FRBGameplayModifierRuntimeInfo");

// ScriptStruct OPP.RBWorldIconUpdateContext
// 0x0060 (0x0060 - 0x0000)
struct FRBWorldIconUpdateContext final
{
public:
	class URBGlobalUIConfig*                      GlobalUIConfig;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBSpatialReasoning*                    SpatialReasoning;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              LocalPawn;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         LocalPlayerState;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoloMode;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideIconVariatorActive;                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URBHUDOverheadInfo*                     CurrentClosestPlayerIcon;                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBHUDOverheadInfo*                     CurrentClosestIncapacitatedPlayerIcon;             // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBHUDObjectiveInWorld*                 CurrentClosestObjectiveIcon;                       // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastClosestsObjectivesUpdateTimestamp;             // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInLobby;                                        // 0x005C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingMinigame;                                // 0x005D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdversarial;                                    // 0x005E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBWorldIconUpdateContext) == 0x000008, "Wrong alignment on FRBWorldIconUpdateContext");
static_assert(sizeof(FRBWorldIconUpdateContext) == 0x000060, "Wrong size on FRBWorldIconUpdateContext");
static_assert(offsetof(FRBWorldIconUpdateContext, GlobalUIConfig) == 0x000000, "Member 'FRBWorldIconUpdateContext::GlobalUIConfig' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, SpatialReasoning) == 0x000008, "Member 'FRBWorldIconUpdateContext::SpatialReasoning' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, LocalPawn) == 0x000010, "Member 'FRBWorldIconUpdateContext::LocalPawn' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, LocalPlayerState) == 0x000018, "Member 'FRBWorldIconUpdateContext::LocalPlayerState' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, bIsSoloMode) == 0x000020, "Member 'FRBWorldIconUpdateContext::bIsSoloMode' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, bIsHideIconVariatorActive) == 0x000021, "Member 'FRBWorldIconUpdateContext::bIsHideIconVariatorActive' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, ViewLocation) == 0x000024, "Member 'FRBWorldIconUpdateContext::ViewLocation' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, ViewRotation) == 0x000030, "Member 'FRBWorldIconUpdateContext::ViewRotation' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, CurrentClosestPlayerIcon) == 0x000040, "Member 'FRBWorldIconUpdateContext::CurrentClosestPlayerIcon' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, CurrentClosestIncapacitatedPlayerIcon) == 0x000048, "Member 'FRBWorldIconUpdateContext::CurrentClosestIncapacitatedPlayerIcon' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, CurrentClosestObjectiveIcon) == 0x000050, "Member 'FRBWorldIconUpdateContext::CurrentClosestObjectiveIcon' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, LastClosestsObjectivesUpdateTimestamp) == 0x000058, "Member 'FRBWorldIconUpdateContext::LastClosestsObjectivesUpdateTimestamp' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, bIsInLobby) == 0x00005C, "Member 'FRBWorldIconUpdateContext::bIsInLobby' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, bIsPlayingMinigame) == 0x00005D, "Member 'FRBWorldIconUpdateContext::bIsPlayingMinigame' has a wrong offset!");
static_assert(offsetof(FRBWorldIconUpdateContext, bIsAdversarial) == 0x00005E, "Member 'FRBWorldIconUpdateContext::bIsAdversarial' has a wrong offset!");

// ScriptStruct OPP.AudioPathNode
// 0x0030 (0x0030 - 0x0000)
struct FAudioPathNode final
{
public:
	class URBSoundConnectorComponent*             Connector;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioPathNode) == 0x000008, "Wrong alignment on FAudioPathNode");
static_assert(sizeof(FAudioPathNode) == 0x000030, "Wrong size on FAudioPathNode");
static_assert(offsetof(FAudioPathNode, Connector) == 0x000000, "Member 'FAudioPathNode::Connector' has a wrong offset!");

// ScriptStruct OPP.ChessPieceData
// 0x0018 (0x0018 - 0x0000)
struct FChessPieceData final
{
public:
	EChessPieceType                               PieceType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChessTeam                                    Team;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMoved;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnPassant;                                        // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutOfGame;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OutOfGameIndex;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChecked;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              Coordinates;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChessPieceData) == 0x000004, "Wrong alignment on FChessPieceData");
static_assert(sizeof(FChessPieceData) == 0x000018, "Wrong size on FChessPieceData");
static_assert(offsetof(FChessPieceData, PieceType) == 0x000000, "Member 'FChessPieceData::PieceType' has a wrong offset!");
static_assert(offsetof(FChessPieceData, Team) == 0x000001, "Member 'FChessPieceData::Team' has a wrong offset!");
static_assert(offsetof(FChessPieceData, bHasMoved) == 0x000002, "Member 'FChessPieceData::bHasMoved' has a wrong offset!");
static_assert(offsetof(FChessPieceData, bEnPassant) == 0x000003, "Member 'FChessPieceData::bEnPassant' has a wrong offset!");
static_assert(offsetof(FChessPieceData, bIsOutOfGame) == 0x000004, "Member 'FChessPieceData::bIsOutOfGame' has a wrong offset!");
static_assert(offsetof(FChessPieceData, OutOfGameIndex) == 0x000008, "Member 'FChessPieceData::OutOfGameIndex' has a wrong offset!");
static_assert(offsetof(FChessPieceData, bIsChecked) == 0x00000C, "Member 'FChessPieceData::bIsChecked' has a wrong offset!");
static_assert(offsetof(FChessPieceData, Coordinates) == 0x000010, "Member 'FChessPieceData::Coordinates' has a wrong offset!");

// ScriptStruct OPP.AIPerPlayerMemory
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x04) FAIPerPlayerMemory final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPerPlayerMemory) == 0x000004, "Wrong alignment on FAIPerPlayerMemory");
static_assert(sizeof(FAIPerPlayerMemory) == 0x0000A0, "Wrong size on FAIPerPlayerMemory");

// ScriptStruct OPP.BackgroundCharacterStopData
// 0x0018 (0x0018 - 0x0000)
struct FBackgroundCharacterStopData final
{
public:
	class UAnimationAsset*                        StopAnim;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBlendOutDuration;                              // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomBlendOutDuration;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBackgroundCharacterStopData) == 0x000008, "Wrong alignment on FBackgroundCharacterStopData");
static_assert(sizeof(FBackgroundCharacterStopData) == 0x000018, "Wrong size on FBackgroundCharacterStopData");
static_assert(offsetof(FBackgroundCharacterStopData, StopAnim) == 0x000000, "Member 'FBackgroundCharacterStopData::StopAnim' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterStopData, MaxDistance) == 0x000008, "Member 'FBackgroundCharacterStopData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterStopData, MinDistance) == 0x00000C, "Member 'FBackgroundCharacterStopData::MinDistance' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterStopData, AutoBlendOutDuration) == 0x000010, "Member 'FBackgroundCharacterStopData::AutoBlendOutDuration' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterStopData, CustomBlendOutDuration) == 0x000014, "Member 'FBackgroundCharacterStopData::CustomBlendOutDuration' has a wrong offset!");

// ScriptStruct OPP.RBPlayerCellCustomizationEntry
// 0x000C (0x000C - 0x0000)
struct FRBPlayerCellCustomizationEntry final
{
public:
	ECustomizationMenuCategory                    Slot;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnlineUnlockId;                                    // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerCellCustomizationEntry) == 0x000004, "Wrong alignment on FRBPlayerCellCustomizationEntry");
static_assert(sizeof(FRBPlayerCellCustomizationEntry) == 0x00000C, "Wrong size on FRBPlayerCellCustomizationEntry");
static_assert(offsetof(FRBPlayerCellCustomizationEntry, Slot) == 0x000000, "Member 'FRBPlayerCellCustomizationEntry::Slot' has a wrong offset!");
static_assert(offsetof(FRBPlayerCellCustomizationEntry, OnlineUnlockId) == 0x000004, "Member 'FRBPlayerCellCustomizationEntry::OnlineUnlockId' has a wrong offset!");

// ScriptStruct OPP.MatchState
// 0x0020 (0x0020 - 0x0000)
struct FMatchState final
{
public:
	class ARBLobbyPlayerState*                    Owner;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchCancelationGracePeriodServerTime;             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchStartServerTime;                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyToTravelToMatch;                             // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllReadyToTravelToMatch;                          // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeavingForMatch;                                  // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeCanceled;                                    // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberCount;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRelease;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchState) == 0x000008, "Wrong alignment on FMatchState");
static_assert(sizeof(FMatchState) == 0x000020, "Wrong size on FMatchState");
static_assert(offsetof(FMatchState, Owner) == 0x000000, "Member 'FMatchState::Owner' has a wrong offset!");
static_assert(offsetof(FMatchState, MatchCancelationGracePeriodServerTime) == 0x000008, "Member 'FMatchState::MatchCancelationGracePeriodServerTime' has a wrong offset!");
static_assert(offsetof(FMatchState, MatchStartServerTime) == 0x00000C, "Member 'FMatchState::MatchStartServerTime' has a wrong offset!");
static_assert(offsetof(FMatchState, bReadyToTravelToMatch) == 0x000010, "Member 'FMatchState::bReadyToTravelToMatch' has a wrong offset!");
static_assert(offsetof(FMatchState, bAllReadyToTravelToMatch) == 0x000011, "Member 'FMatchState::bAllReadyToTravelToMatch' has a wrong offset!");
static_assert(offsetof(FMatchState, bLeavingForMatch) == 0x000012, "Member 'FMatchState::bLeavingForMatch' has a wrong offset!");
static_assert(offsetof(FMatchState, bCanBeCanceled) == 0x000013, "Member 'FMatchState::bCanBeCanceled' has a wrong offset!");
static_assert(offsetof(FMatchState, MemberCount) == 0x000014, "Member 'FMatchState::MemberCount' has a wrong offset!");
static_assert(offsetof(FMatchState, bIsRelease) == 0x000018, "Member 'FMatchState::bIsRelease' has a wrong offset!");

// ScriptStruct OPP.SystemsSoundRefs
// 0x0050 (0x0050 - 0x0000)
struct FSystemsSoundRefs final
{
public:
	class UAkAudioEvent*                          ResetStates;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ResetStates : 1;                         // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PauseOn;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PauseOn : 1;                             // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PauseOff;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PauseOff : 1;                            // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TestIntercomOn;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TestIntercomOn : 1;                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TestIntercomOff;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TestIntercomOff : 1;                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSystemsSoundRefs) == 0x000008, "Wrong alignment on FSystemsSoundRefs");
static_assert(sizeof(FSystemsSoundRefs) == 0x000050, "Wrong size on FSystemsSoundRefs");
static_assert(offsetof(FSystemsSoundRefs, ResetStates) == 0x000000, "Member 'FSystemsSoundRefs::ResetStates' has a wrong offset!");
static_assert(offsetof(FSystemsSoundRefs, PauseOn) == 0x000010, "Member 'FSystemsSoundRefs::PauseOn' has a wrong offset!");
static_assert(offsetof(FSystemsSoundRefs, PauseOff) == 0x000020, "Member 'FSystemsSoundRefs::PauseOff' has a wrong offset!");
static_assert(offsetof(FSystemsSoundRefs, TestIntercomOn) == 0x000030, "Member 'FSystemsSoundRefs::TestIntercomOn' has a wrong offset!");
static_assert(offsetof(FSystemsSoundRefs, TestIntercomOff) == 0x000040, "Member 'FSystemsSoundRefs::TestIntercomOff' has a wrong offset!");

// ScriptStruct OPP.DizzinessInertialDriftConfig
// 0x0040 (0x0040 - 0x0000)
struct FDizzinessInertialDriftConfig final
{
public:
	float                                         YawDriftInertialFactor;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDriftInertialFactorLimit;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawNonLinearSpringAngleStart;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMaxInertialDrift;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawInertialDamping;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawInertialFriction;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYawDampingOnVelocity;                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchDriftInertialFactor;                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchDriftInertialFactorLimit;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchNonLinearSpringAngleStart;                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMaxInertialDrift;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchInertialDamping;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchInertialFriction;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPitchDampingOnVelocity;                           // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleDriftWeightApproachDown;                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleDriftWeightApproachUp;                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDizzinessInertialDriftConfig) == 0x000004, "Wrong alignment on FDizzinessInertialDriftConfig");
static_assert(sizeof(FDizzinessInertialDriftConfig) == 0x000040, "Wrong size on FDizzinessInertialDriftConfig");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawDriftInertialFactor) == 0x000000, "Member 'FDizzinessInertialDriftConfig::YawDriftInertialFactor' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawDriftInertialFactorLimit) == 0x000004, "Member 'FDizzinessInertialDriftConfig::YawDriftInertialFactorLimit' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawNonLinearSpringAngleStart) == 0x000008, "Member 'FDizzinessInertialDriftConfig::YawNonLinearSpringAngleStart' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawMaxInertialDrift) == 0x00000C, "Member 'FDizzinessInertialDriftConfig::YawMaxInertialDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawInertialDamping) == 0x000010, "Member 'FDizzinessInertialDriftConfig::YawInertialDamping' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, YawInertialFriction) == 0x000014, "Member 'FDizzinessInertialDriftConfig::YawInertialFriction' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, bYawDampingOnVelocity) == 0x000018, "Member 'FDizzinessInertialDriftConfig::bYawDampingOnVelocity' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchDriftInertialFactor) == 0x00001C, "Member 'FDizzinessInertialDriftConfig::PitchDriftInertialFactor' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchDriftInertialFactorLimit) == 0x000020, "Member 'FDizzinessInertialDriftConfig::PitchDriftInertialFactorLimit' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchNonLinearSpringAngleStart) == 0x000024, "Member 'FDizzinessInertialDriftConfig::PitchNonLinearSpringAngleStart' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchMaxInertialDrift) == 0x000028, "Member 'FDizzinessInertialDriftConfig::PitchMaxInertialDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchInertialDamping) == 0x00002C, "Member 'FDizzinessInertialDriftConfig::PitchInertialDamping' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, PitchInertialFriction) == 0x000030, "Member 'FDizzinessInertialDriftConfig::PitchInertialFriction' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, bPitchDampingOnVelocity) == 0x000034, "Member 'FDizzinessInertialDriftConfig::bPitchDampingOnVelocity' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, IdleDriftWeightApproachDown) == 0x000038, "Member 'FDizzinessInertialDriftConfig::IdleDriftWeightApproachDown' has a wrong offset!");
static_assert(offsetof(FDizzinessInertialDriftConfig, IdleDriftWeightApproachUp) == 0x00003C, "Member 'FDizzinessInertialDriftConfig::IdleDriftWeightApproachUp' has a wrong offset!");

// ScriptStruct OPP.MatchSettings
// 0x0048 (0x0048 - 0x0000)
struct FMatchSettings final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VariatorIds;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   StageName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionName;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrialChainIndex;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchmake;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchSettings) == 0x000008, "Wrong alignment on FMatchSettings");
static_assert(sizeof(FMatchSettings) == 0x000048, "Wrong size on FMatchSettings");
static_assert(offsetof(FMatchSettings, ProgramId) == 0x000000, "Member 'FMatchSettings::ProgramId' has a wrong offset!");
static_assert(offsetof(FMatchSettings, TrialId) == 0x000008, "Member 'FMatchSettings::TrialId' has a wrong offset!");
static_assert(offsetof(FMatchSettings, ProgramDifficulty) == 0x000010, "Member 'FMatchSettings::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FMatchSettings, VariatorIds) == 0x000018, "Member 'FMatchSettings::VariatorIds' has a wrong offset!");
static_assert(offsetof(FMatchSettings, StageName) == 0x000028, "Member 'FMatchSettings::StageName' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MissionName) == 0x000030, "Member 'FMatchSettings::MissionName' has a wrong offset!");
static_assert(offsetof(FMatchSettings, Seed) == 0x000038, "Member 'FMatchSettings::Seed' has a wrong offset!");
static_assert(offsetof(FMatchSettings, TrialChainIndex) == 0x00003C, "Member 'FMatchSettings::TrialChainIndex' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bMatchmake) == 0x000040, "Member 'FMatchSettings::bMatchmake' has a wrong offset!");

// ScriptStruct OPP.BotActivityParams
// 0x000B (0x000B - 0x0000)
struct FBotActivityParams final
{
public:
	bool                                          bAlwaysIgnorePlayers;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMoving;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRepulsion;                                   // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLookAt;                                      // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeDisturbed;                                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCycleBreakers;                               // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowIdleTargetLookAt;                            // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReactToImperativeAction;                       // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysAllowRetirement;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowForcedRetirement;                            // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreathing;                                        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotActivityParams) == 0x000001, "Wrong alignment on FBotActivityParams");
static_assert(sizeof(FBotActivityParams) == 0x00000B, "Wrong size on FBotActivityParams");
static_assert(offsetof(FBotActivityParams, bAlwaysIgnorePlayers) == 0x000000, "Member 'FBotActivityParams::bAlwaysIgnorePlayers' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowMoving) == 0x000001, "Member 'FBotActivityParams::bAllowMoving' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowRepulsion) == 0x000002, "Member 'FBotActivityParams::bAllowRepulsion' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowLookAt) == 0x000003, "Member 'FBotActivityParams::bAllowLookAt' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bCanBeDisturbed) == 0x000004, "Member 'FBotActivityParams::bCanBeDisturbed' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowCycleBreakers) == 0x000005, "Member 'FBotActivityParams::bAllowCycleBreakers' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowIdleTargetLookAt) == 0x000006, "Member 'FBotActivityParams::bAllowIdleTargetLookAt' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bCanReactToImperativeAction) == 0x000007, "Member 'FBotActivityParams::bCanReactToImperativeAction' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAlwaysAllowRetirement) == 0x000008, "Member 'FBotActivityParams::bAlwaysAllowRetirement' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bAllowForcedRetirement) == 0x000009, "Member 'FBotActivityParams::bAllowForcedRetirement' has a wrong offset!");
static_assert(offsetof(FBotActivityParams, bBreathing) == 0x00000A, "Member 'FBotActivityParams::bBreathing' has a wrong offset!");

// ScriptStruct OPP.TalkWheelStatusTexts
// 0x0040 (0x0040 - 0x0000)
struct FTalkWheelStatusTexts final
{
public:
	TArray<class FText>                           Crawling;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Chase;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Danger;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           CoopMove;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkWheelStatusTexts) == 0x000008, "Wrong alignment on FTalkWheelStatusTexts");
static_assert(sizeof(FTalkWheelStatusTexts) == 0x000040, "Wrong size on FTalkWheelStatusTexts");
static_assert(offsetof(FTalkWheelStatusTexts, Crawling) == 0x000000, "Member 'FTalkWheelStatusTexts::Crawling' has a wrong offset!");
static_assert(offsetof(FTalkWheelStatusTexts, Chase) == 0x000010, "Member 'FTalkWheelStatusTexts::Chase' has a wrong offset!");
static_assert(offsetof(FTalkWheelStatusTexts, Danger) == 0x000020, "Member 'FTalkWheelStatusTexts::Danger' has a wrong offset!");
static_assert(offsetof(FTalkWheelStatusTexts, CoopMove) == 0x000030, "Member 'FTalkWheelStatusTexts::CoopMove' has a wrong offset!");

// ScriptStruct OPP.TalkWheelActiveSkillTexts
// 0x0040 (0x0040 - 0x0000)
struct FTalkWheelActiveSkillTexts final
{
public:
	TArray<class FText>                           NoneEquipped;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Empty;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Cooldown;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Ready;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkWheelActiveSkillTexts) == 0x000008, "Wrong alignment on FTalkWheelActiveSkillTexts");
static_assert(sizeof(FTalkWheelActiveSkillTexts) == 0x000040, "Wrong size on FTalkWheelActiveSkillTexts");
static_assert(offsetof(FTalkWheelActiveSkillTexts, NoneEquipped) == 0x000000, "Member 'FTalkWheelActiveSkillTexts::NoneEquipped' has a wrong offset!");
static_assert(offsetof(FTalkWheelActiveSkillTexts, Empty) == 0x000010, "Member 'FTalkWheelActiveSkillTexts::Empty' has a wrong offset!");
static_assert(offsetof(FTalkWheelActiveSkillTexts, Cooldown) == 0x000020, "Member 'FTalkWheelActiveSkillTexts::Cooldown' has a wrong offset!");
static_assert(offsetof(FTalkWheelActiveSkillTexts, Ready) == 0x000030, "Member 'FTalkWheelActiveSkillTexts::Ready' has a wrong offset!");

// ScriptStruct OPP.TalkWheelTexts
// 0x0148 (0x0148 - 0x0000)
struct FTalkWheelTexts final
{
public:
	TArray<class FText>                           Help;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Acknowledge;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Regroup;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Wait;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Danger;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Thanks;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           OnMyWay;                                           // 0x0060(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Hello;                                             // 0x0070(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Trade;                                             // 0x0080(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Drop;                                              // 0x0090(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           PingFallback;                                      // 0x00A0(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTalkWheelStatusTexts                  Status;                                            // 0x00B0(0x0040)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTalkWheelActiveSkillTexts             ActiveSkill;                                       // 0x00F0(0x0040)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Throttled;                                         // 0x0130(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkWheelTexts) == 0x000008, "Wrong alignment on FTalkWheelTexts");
static_assert(sizeof(FTalkWheelTexts) == 0x000148, "Wrong size on FTalkWheelTexts");
static_assert(offsetof(FTalkWheelTexts, Help) == 0x000000, "Member 'FTalkWheelTexts::Help' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Acknowledge) == 0x000010, "Member 'FTalkWheelTexts::Acknowledge' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Regroup) == 0x000020, "Member 'FTalkWheelTexts::Regroup' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Wait) == 0x000030, "Member 'FTalkWheelTexts::Wait' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Danger) == 0x000040, "Member 'FTalkWheelTexts::Danger' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Thanks) == 0x000050, "Member 'FTalkWheelTexts::Thanks' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, OnMyWay) == 0x000060, "Member 'FTalkWheelTexts::OnMyWay' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Hello) == 0x000070, "Member 'FTalkWheelTexts::Hello' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Trade) == 0x000080, "Member 'FTalkWheelTexts::Trade' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Drop) == 0x000090, "Member 'FTalkWheelTexts::Drop' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, PingFallback) == 0x0000A0, "Member 'FTalkWheelTexts::PingFallback' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Status) == 0x0000B0, "Member 'FTalkWheelTexts::Status' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, ActiveSkill) == 0x0000F0, "Member 'FTalkWheelTexts::ActiveSkill' has a wrong offset!");
static_assert(offsetof(FTalkWheelTexts, Throttled) == 0x000130, "Member 'FTalkWheelTexts::Throttled' has a wrong offset!");

// ScriptStruct OPP.RBTrialChainingCompletedTrialEntry
// 0x0030 (0x0030 - 0x0000)
struct FRBTrialChainingCompletedTrialEntry final
{
public:
	int32                                         TrialChainIndex;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VariatorIds;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GroupScore;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupDeathCount;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSeconds;                                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTrialChainingCompletedTrialEntry) == 0x000008, "Wrong alignment on FRBTrialChainingCompletedTrialEntry");
static_assert(sizeof(FRBTrialChainingCompletedTrialEntry) == 0x000030, "Wrong size on FRBTrialChainingCompletedTrialEntry");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, TrialChainIndex) == 0x000000, "Member 'FRBTrialChainingCompletedTrialEntry::TrialChainIndex' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, TrialId) == 0x000004, "Member 'FRBTrialChainingCompletedTrialEntry::TrialId' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, ProgramDifficulty) == 0x00000C, "Member 'FRBTrialChainingCompletedTrialEntry::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, VariatorIds) == 0x000010, "Member 'FRBTrialChainingCompletedTrialEntry::VariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, GroupScore) == 0x000020, "Member 'FRBTrialChainingCompletedTrialEntry::GroupScore' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, GroupDeathCount) == 0x000024, "Member 'FRBTrialChainingCompletedTrialEntry::GroupDeathCount' has a wrong offset!");
static_assert(offsetof(FRBTrialChainingCompletedTrialEntry, DurationSeconds) == 0x000028, "Member 'FRBTrialChainingCompletedTrialEntry::DurationSeconds' has a wrong offset!");

// ScriptStruct OPP.EndStageInfo
// 0x0058 (0x0058 - 0x0000)
struct FEndStageInfo final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelSeed;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucceeded;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndStagePlayerInfo>            PlayerInfos;                                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeToComplete;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathCount;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBTrialChainingCompletedTrialEntry> TrialChainingCompletedTrialEntries;                // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TrialChainingCompletedTrials;                      // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndStageInfo) == 0x000008, "Wrong alignment on FEndStageInfo");
static_assert(sizeof(FEndStageInfo) == 0x000058, "Wrong size on FEndStageInfo");
static_assert(offsetof(FEndStageInfo, ProgramId) == 0x000000, "Member 'FEndStageInfo::ProgramId' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, TrialId) == 0x000008, "Member 'FEndStageInfo::TrialId' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, ProgramDifficulty) == 0x000010, "Member 'FEndStageInfo::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, LevelSeed) == 0x000014, "Member 'FEndStageInfo::LevelSeed' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, bSucceeded) == 0x000018, "Member 'FEndStageInfo::bSucceeded' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, PlayerInfos) == 0x000020, "Member 'FEndStageInfo::PlayerInfos' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, TimeToComplete) == 0x000030, "Member 'FEndStageInfo::TimeToComplete' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, TotalTime) == 0x000034, "Member 'FEndStageInfo::TotalTime' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, DeathCount) == 0x000038, "Member 'FEndStageInfo::DeathCount' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, Score) == 0x00003C, "Member 'FEndStageInfo::Score' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, TrialChainingCompletedTrialEntries) == 0x000040, "Member 'FEndStageInfo::TrialChainingCompletedTrialEntries' has a wrong offset!");
static_assert(offsetof(FEndStageInfo, TrialChainingCompletedTrials) == 0x000050, "Member 'FEndStageInfo::TrialChainingCompletedTrials' has a wrong offset!");

// ScriptStruct OPP.CustomContainerPickupAnimationSettings
// 0x0038 (0x0038 - 0x0000)
struct FCustomContainerPickupAnimationSettings final
{
public:
	class UAnimSequenceBase*                      Pickup1PAnimSequence;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CrouchedPickup1PAnimSequence;                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Pickup3PAnimSequence;                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CrouchedPickup3PAnimSequence;                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URBGhostAnimInstance>       GhostAnimInstance;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCrouch;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedBothHandsForAnim;                             // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomAttachItemBone;                              // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimAnchorForPosition;                         // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseParentActorForAnchorReference;                 // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationFacingActorRef;                          // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationXForward;                                // 0x0037(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomContainerPickupAnimationSettings) == 0x000008, "Wrong alignment on FCustomContainerPickupAnimationSettings");
static_assert(sizeof(FCustomContainerPickupAnimationSettings) == 0x000038, "Wrong size on FCustomContainerPickupAnimationSettings");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, Pickup1PAnimSequence) == 0x000000, "Member 'FCustomContainerPickupAnimationSettings::Pickup1PAnimSequence' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, CrouchedPickup1PAnimSequence) == 0x000008, "Member 'FCustomContainerPickupAnimationSettings::CrouchedPickup1PAnimSequence' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, Pickup3PAnimSequence) == 0x000010, "Member 'FCustomContainerPickupAnimationSettings::Pickup3PAnimSequence' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, CrouchedPickup3PAnimSequence) == 0x000018, "Member 'FCustomContainerPickupAnimationSettings::CrouchedPickup3PAnimSequence' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, GhostAnimInstance) == 0x000020, "Member 'FCustomContainerPickupAnimationSettings::GhostAnimInstance' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bForceCrouch) == 0x000028, "Member 'FCustomContainerPickupAnimationSettings::bForceCrouch' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bNeedBothHandsForAnim) == 0x000029, "Member 'FCustomContainerPickupAnimationSettings::bNeedBothHandsForAnim' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, CustomAttachItemBone) == 0x00002C, "Member 'FCustomContainerPickupAnimationSettings::CustomAttachItemBone' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bUseAnimAnchorForPosition) == 0x000034, "Member 'FCustomContainerPickupAnimationSettings::bUseAnimAnchorForPosition' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bUseParentActorForAnchorReference) == 0x000035, "Member 'FCustomContainerPickupAnimationSettings::bUseParentActorForAnchorReference' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bAnimationFacingActorRef) == 0x000036, "Member 'FCustomContainerPickupAnimationSettings::bAnimationFacingActorRef' has a wrong offset!");
static_assert(offsetof(FCustomContainerPickupAnimationSettings, bAnimationXForward) == 0x000037, "Member 'FCustomContainerPickupAnimationSettings::bAnimationXForward' has a wrong offset!");

// ScriptStruct OPP.DeadBodyJumpScareSetting
// 0x0040 (0x0040 - 0x0000)
struct FDeadBodyJumpScareSetting final
{
public:
	struct FCustomContainerPickupAnimationSettings PlayerAnimationSettings;                           // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      DeadBodyAnimSequence;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeadBodyJumpScareSetting) == 0x000008, "Wrong alignment on FDeadBodyJumpScareSetting");
static_assert(sizeof(FDeadBodyJumpScareSetting) == 0x000040, "Wrong size on FDeadBodyJumpScareSetting");
static_assert(offsetof(FDeadBodyJumpScareSetting, PlayerAnimationSettings) == 0x000000, "Member 'FDeadBodyJumpScareSetting::PlayerAnimationSettings' has a wrong offset!");
static_assert(offsetof(FDeadBodyJumpScareSetting, DeadBodyAnimSequence) == 0x000038, "Member 'FDeadBodyJumpScareSetting::DeadBodyAnimSequence' has a wrong offset!");

// ScriptStruct OPP.ProjectileTrajectory
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FProjectileTrajectory final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileTrajectory) == 0x000010, "Wrong alignment on FProjectileTrajectory");
static_assert(sizeof(FProjectileTrajectory) == 0x000080, "Wrong size on FProjectileTrajectory");

// ScriptStruct OPP.RecentlySeenPlayer
// 0x0018 (0x0018 - 0x0000)
struct FRecentlySeenPlayer final
{
public:
	struct FProfileId                             ProfileId;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecentlySeenPlayer) == 0x000008, "Wrong alignment on FRecentlySeenPlayer");
static_assert(sizeof(FRecentlySeenPlayer) == 0x000018, "Wrong size on FRecentlySeenPlayer");
static_assert(offsetof(FRecentlySeenPlayer, ProfileId) == 0x000000, "Member 'FRecentlySeenPlayer::ProfileId' has a wrong offset!");
static_assert(offsetof(FRecentlySeenPlayer, Timestamp) == 0x000010, "Member 'FRecentlySeenPlayer::Timestamp' has a wrong offset!");

// ScriptStruct OPP.RBMurkoffAnnouncentLineData
// 0x0020 (0x0020 - 0x0000)
struct FRBMurkoffAnnouncentLineData final
{
public:
	class FString                                 AnnouncementLinesName;                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBMurkoffAnnouncentAudioData>  LineChoices;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBMurkoffAnnouncentLineData) == 0x000008, "Wrong alignment on FRBMurkoffAnnouncentLineData");
static_assert(sizeof(FRBMurkoffAnnouncentLineData) == 0x000020, "Wrong size on FRBMurkoffAnnouncentLineData");
static_assert(offsetof(FRBMurkoffAnnouncentLineData, AnnouncementLinesName) == 0x000000, "Member 'FRBMurkoffAnnouncentLineData::AnnouncementLinesName' has a wrong offset!");
static_assert(offsetof(FRBMurkoffAnnouncentLineData, LineChoices) == 0x000010, "Member 'FRBMurkoffAnnouncentLineData::LineChoices' has a wrong offset!");

// ScriptStruct OPP.PlayerStatTrackingConfig
// 0x0003 (0x0003 - 0x0000)
struct FPlayerStatTrackingConfig final
{
public:
	bool                                          bGlobal;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacter;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrial;                                            // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStatTrackingConfig) == 0x000001, "Wrong alignment on FPlayerStatTrackingConfig");
static_assert(sizeof(FPlayerStatTrackingConfig) == 0x000003, "Wrong size on FPlayerStatTrackingConfig");
static_assert(offsetof(FPlayerStatTrackingConfig, bGlobal) == 0x000000, "Member 'FPlayerStatTrackingConfig::bGlobal' has a wrong offset!");
static_assert(offsetof(FPlayerStatTrackingConfig, bCharacter) == 0x000001, "Member 'FPlayerStatTrackingConfig::bCharacter' has a wrong offset!");
static_assert(offsetof(FPlayerStatTrackingConfig, bTrial) == 0x000002, "Member 'FPlayerStatTrackingConfig::bTrial' has a wrong offset!");

// ScriptStruct OPP.RBPlayerStatConfig
// 0x0060 (0x0060 - 0x0000)
struct FRBPlayerStatConfig final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStat                                   PlayerStat;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStatAggregationType                    AggregationType;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 InWorldDisplayName;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayMultiplier;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayDigits;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSortAscending;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerStatTrackingConfig              TrackingConfig;                                    // 0x0059(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerStatConfig) == 0x000008, "Wrong alignment on FRBPlayerStatConfig");
static_assert(sizeof(FRBPlayerStatConfig) == 0x000060, "Wrong size on FRBPlayerStatConfig");
static_assert(offsetof(FRBPlayerStatConfig, ID) == 0x000000, "Member 'FRBPlayerStatConfig::ID' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, PlayerStat) == 0x000008, "Member 'FRBPlayerStatConfig::PlayerStat' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, AggregationType) == 0x000009, "Member 'FRBPlayerStatConfig::AggregationType' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, DefaultValue) == 0x00000C, "Member 'FRBPlayerStatConfig::DefaultValue' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, DisplayName) == 0x000010, "Member 'FRBPlayerStatConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, InWorldDisplayName) == 0x000028, "Member 'FRBPlayerStatConfig::InWorldDisplayName' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, Icon) == 0x000038, "Member 'FRBPlayerStatConfig::Icon' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, DisplayMultiplier) == 0x000050, "Member 'FRBPlayerStatConfig::DisplayMultiplier' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, DisplayDigits) == 0x000054, "Member 'FRBPlayerStatConfig::DisplayDigits' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, bSortAscending) == 0x000058, "Member 'FRBPlayerStatConfig::bSortAscending' has a wrong offset!");
static_assert(offsetof(FRBPlayerStatConfig, TrackingConfig) == 0x000059, "Member 'FRBPlayerStatConfig::TrackingConfig' has a wrong offset!");

// ScriptStruct OPP.SkelMeshActorOptimData
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshActorOptimData final
{
public:
	class ASkeletalMeshActor*                     SkelMeshActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkelMeshActorOptimData) == 0x000008, "Wrong alignment on FSkelMeshActorOptimData");
static_assert(sizeof(FSkelMeshActorOptimData) == 0x000010, "Wrong size on FSkelMeshActorOptimData");
static_assert(offsetof(FSkelMeshActorOptimData, SkelMeshActor) == 0x000000, "Member 'FSkelMeshActorOptimData::SkelMeshActor' has a wrong offset!");

// ScriptStruct OPP.DLCContentPackItem
// 0x0058 (0x0058 - 0x0000)
struct FDLCContentPackItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnSale;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RegularDisplayPrice;                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayPrice;                                      // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwned;                                            // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2DDynamic*                      BannerTexture;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCContentPackItem) == 0x000008, "Wrong alignment on FDLCContentPackItem");
static_assert(sizeof(FDLCContentPackItem) == 0x000058, "Wrong size on FDLCContentPackItem");
static_assert(offsetof(FDLCContentPackItem, ID) == 0x000000, "Member 'FDLCContentPackItem::ID' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, Name) == 0x000010, "Member 'FDLCContentPackItem::Name' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, bOnSale) == 0x000020, "Member 'FDLCContentPackItem::bOnSale' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, RegularDisplayPrice) == 0x000028, "Member 'FDLCContentPackItem::RegularDisplayPrice' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, DisplayPrice) == 0x000038, "Member 'FDLCContentPackItem::DisplayPrice' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, bOwned) == 0x000048, "Member 'FDLCContentPackItem::bOwned' has a wrong offset!");
static_assert(offsetof(FDLCContentPackItem, BannerTexture) == 0x000050, "Member 'FDLCContentPackItem::BannerTexture' has a wrong offset!");

// ScriptStruct OPP.PipeSegment
// 0x0010 (0x0010 - 0x0000)
struct FPipeSegment final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPipeSegment) == 0x000008, "Wrong alignment on FPipeSegment");
static_assert(sizeof(FPipeSegment) == 0x000010, "Wrong size on FPipeSegment");
static_assert(offsetof(FPipeSegment, Length) == 0x000000, "Member 'FPipeSegment::Length' has a wrong offset!");
static_assert(offsetof(FPipeSegment, StaticMesh) == 0x000008, "Member 'FPipeSegment::StaticMesh' has a wrong offset!");

// ScriptStruct OPP.ScheduledSpecialMoveBlendOut
// 0x0020 (0x0020 - 0x0000)
struct FScheduledSpecialMoveBlendOut final
{
public:
	ESpecialMove                                  SpecialMove;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecialMoveIndex;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForAction;                                    // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnTime;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialMoveEndPawnTime;                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialMoveEndServerTime;                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledSpecialMoveBlendOut) == 0x000004, "Wrong alignment on FScheduledSpecialMoveBlendOut");
static_assert(sizeof(FScheduledSpecialMoveBlendOut) == 0x000020, "Wrong size on FScheduledSpecialMoveBlendOut");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, SpecialMove) == 0x000000, "Member 'FScheduledSpecialMoveBlendOut::SpecialMove' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, SpecialMoveIndex) == 0x000004, "Member 'FScheduledSpecialMoveBlendOut::SpecialMoveIndex' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, BlendOutDuration) == 0x000008, "Member 'FScheduledSpecialMoveBlendOut::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, bWaitForAction) == 0x00000C, "Member 'FScheduledSpecialMoveBlendOut::bWaitForAction' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, PawnTime) == 0x000010, "Member 'FScheduledSpecialMoveBlendOut::PawnTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, ServerTime) == 0x000014, "Member 'FScheduledSpecialMoveBlendOut::ServerTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, SpecialMoveEndPawnTime) == 0x000018, "Member 'FScheduledSpecialMoveBlendOut::SpecialMoveEndPawnTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialMoveBlendOut, SpecialMoveEndServerTime) == 0x00001C, "Member 'FScheduledSpecialMoveBlendOut::SpecialMoveEndServerTime' has a wrong offset!");

// ScriptStruct OPP.RBDoorBlockerData
// 0x0010 (0x0010 - 0x0000)
struct FRBDoorBlockerData final
{
public:
	class AActor*                                 Blocker;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBDoorBlockerData) == 0x000008, "Wrong alignment on FRBDoorBlockerData");
static_assert(sizeof(FRBDoorBlockerData) == 0x000010, "Wrong size on FRBDoorBlockerData");
static_assert(offsetof(FRBDoorBlockerData, Blocker) == 0x000000, "Member 'FRBDoorBlockerData::Blocker' has a wrong offset!");
static_assert(offsetof(FRBDoorBlockerData, Target) == 0x000008, "Member 'FRBDoorBlockerData::Target' has a wrong offset!");

// ScriptStruct OPP.CameraParameters
// 0x0034 (0x0034 - 0x0000)
struct FCameraParameters final
{
public:
	float                                         MinYaw;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchWS;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchWS;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchCS;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchCS;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewLimitsApproachCoeff;                           // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVOverride;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalSpaceControl;                                // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseLookSensibilityMultiplier;                    // 0x0024(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GamepadLookSensibilityMultiplier;                  // 0x002C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraParameters) == 0x000004, "Wrong alignment on FCameraParameters");
static_assert(sizeof(FCameraParameters) == 0x000034, "Wrong size on FCameraParameters");
static_assert(offsetof(FCameraParameters, MinYaw) == 0x000000, "Member 'FCameraParameters::MinYaw' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MaxYaw) == 0x000004, "Member 'FCameraParameters::MaxYaw' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MinPitchWS) == 0x000008, "Member 'FCameraParameters::MinPitchWS' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MaxPitchWS) == 0x00000C, "Member 'FCameraParameters::MaxPitchWS' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MinPitchCS) == 0x000010, "Member 'FCameraParameters::MinPitchCS' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MaxPitchCS) == 0x000014, "Member 'FCameraParameters::MaxPitchCS' has a wrong offset!");
static_assert(offsetof(FCameraParameters, ViewLimitsApproachCoeff) == 0x000018, "Member 'FCameraParameters::ViewLimitsApproachCoeff' has a wrong offset!");
static_assert(offsetof(FCameraParameters, FOVOverride) == 0x00001C, "Member 'FCameraParameters::FOVOverride' has a wrong offset!");
static_assert(offsetof(FCameraParameters, bLocalSpaceControl) == 0x000020, "Member 'FCameraParameters::bLocalSpaceControl' has a wrong offset!");
static_assert(offsetof(FCameraParameters, MouseLookSensibilityMultiplier) == 0x000024, "Member 'FCameraParameters::MouseLookSensibilityMultiplier' has a wrong offset!");
static_assert(offsetof(FCameraParameters, GamepadLookSensibilityMultiplier) == 0x00002C, "Member 'FCameraParameters::GamepadLookSensibilityMultiplier' has a wrong offset!");

// ScriptStruct OPP.PairedAnim
// 0x0018 (0x0018 - 0x0000)
struct FPairedAnim final
{
public:
	class UAnimationAsset*                        NPCAnim;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        PlayerAnim;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        PlayerAnim3P;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPairedAnim) == 0x000008, "Wrong alignment on FPairedAnim");
static_assert(sizeof(FPairedAnim) == 0x000018, "Wrong size on FPairedAnim");
static_assert(offsetof(FPairedAnim, NPCAnim) == 0x000000, "Member 'FPairedAnim::NPCAnim' has a wrong offset!");
static_assert(offsetof(FPairedAnim, PlayerAnim) == 0x000008, "Member 'FPairedAnim::PlayerAnim' has a wrong offset!");
static_assert(offsetof(FPairedAnim, PlayerAnim3P) == 0x000010, "Member 'FPairedAnim::PlayerAnim3P' has a wrong offset!");

// ScriptStruct OPP.GrabExitData
// 0x0060 (0x0060 - 0x0000)
struct FGrabExitData final
{
public:
	struct FPairedAnim                            ExitForward;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            ExitLeft;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            ExitRight;                                         // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            ExitBack;                                          // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrabExitData) == 0x000008, "Wrong alignment on FGrabExitData");
static_assert(sizeof(FGrabExitData) == 0x000060, "Wrong size on FGrabExitData");
static_assert(offsetof(FGrabExitData, ExitForward) == 0x000000, "Member 'FGrabExitData::ExitForward' has a wrong offset!");
static_assert(offsetof(FGrabExitData, ExitLeft) == 0x000018, "Member 'FGrabExitData::ExitLeft' has a wrong offset!");
static_assert(offsetof(FGrabExitData, ExitRight) == 0x000030, "Member 'FGrabExitData::ExitRight' has a wrong offset!");
static_assert(offsetof(FGrabExitData, ExitBack) == 0x000048, "Member 'FGrabExitData::ExitBack' has a wrong offset!");

// ScriptStruct OPP.HidespotsAnimRefs
// 0x02A0 (0x02A0 - 0x0000)
struct FHidespotsAnimRefs final
{
public:
	struct FSingleHidespotInteractionsAnimRefs    StandingLeft;                                      // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    StandingRight;                                     // 0x0048(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    ProneLeft;                                         // 0x0090(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    ProneRight;                                        // 0x00D8(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    Crouched;                                          // 0x0120(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    InsideHorizontal;                                  // 0x0168(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    InsideVertical;                                    // 0x01B0(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FSingleHidespotInteractionsAnimRefs    CarTrunk;                                          // 0x01F8(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FGrabExitData                          GrabExitData;                                      // 0x0240(0x0060)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHidespotsAnimRefs) == 0x000008, "Wrong alignment on FHidespotsAnimRefs");
static_assert(sizeof(FHidespotsAnimRefs) == 0x0002A0, "Wrong size on FHidespotsAnimRefs");
static_assert(offsetof(FHidespotsAnimRefs, StandingLeft) == 0x000000, "Member 'FHidespotsAnimRefs::StandingLeft' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, StandingRight) == 0x000048, "Member 'FHidespotsAnimRefs::StandingRight' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, ProneLeft) == 0x000090, "Member 'FHidespotsAnimRefs::ProneLeft' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, ProneRight) == 0x0000D8, "Member 'FHidespotsAnimRefs::ProneRight' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, Crouched) == 0x000120, "Member 'FHidespotsAnimRefs::Crouched' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, InsideHorizontal) == 0x000168, "Member 'FHidespotsAnimRefs::InsideHorizontal' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, InsideVertical) == 0x0001B0, "Member 'FHidespotsAnimRefs::InsideVertical' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, CarTrunk) == 0x0001F8, "Member 'FHidespotsAnimRefs::CarTrunk' has a wrong offset!");
static_assert(offsetof(FHidespotsAnimRefs, GrabExitData) == 0x000240, "Member 'FHidespotsAnimRefs::GrabExitData' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBRotateRelative
// 0x0030 (0x00F8 - 0x00C8)
struct FAnimNode_RBRotateRelative final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         RotateBone;                                        // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RelativeBone;                                      // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RBRotateRelative) == 0x000008, "Wrong alignment on FAnimNode_RBRotateRelative");
static_assert(sizeof(FAnimNode_RBRotateRelative) == 0x0000F8, "Wrong size on FAnimNode_RBRotateRelative");
static_assert(offsetof(FAnimNode_RBRotateRelative, RotateBone) == 0x0000C8, "Member 'FAnimNode_RBRotateRelative::RotateBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBRotateRelative, RelativeBone) == 0x0000D8, "Member 'FAnimNode_RBRotateRelative::RelativeBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBRotateRelative, Rotation) == 0x0000E8, "Member 'FAnimNode_RBRotateRelative::Rotation' has a wrong offset!");

// ScriptStruct OPP.RBVariatorAIStageSpawningBlockInfo
// 0x0002 (0x0002 - 0x0000)
struct FRBVariatorAIStageSpawningBlockInfo final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBVariatorAIStageSpawningBlockInfo) == 0x000001, "Wrong alignment on FRBVariatorAIStageSpawningBlockInfo");
static_assert(sizeof(FRBVariatorAIStageSpawningBlockInfo) == 0x000002, "Wrong size on FRBVariatorAIStageSpawningBlockInfo");
static_assert(offsetof(FRBVariatorAIStageSpawningBlockInfo, NPCType) == 0x000000, "Member 'FRBVariatorAIStageSpawningBlockInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FRBVariatorAIStageSpawningBlockInfo, NPCFlavor) == 0x000001, "Member 'FRBVariatorAIStageSpawningBlockInfo::NPCFlavor' has a wrong offset!");

// ScriptStruct OPP.TennisGameData
// 0x000C (0x000C - 0x0000)
struct FTennisGameData final
{
public:
	ELobbyGameTeam                                NextServiceTeam;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyGameTeam                                NextHitTeam_Server;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyGameTeam                                NextHitTeam_Local;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Player1Bounces;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Player2Bounces;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTennisGameData) == 0x000004, "Wrong alignment on FTennisGameData");
static_assert(sizeof(FTennisGameData) == 0x00000C, "Wrong size on FTennisGameData");
static_assert(offsetof(FTennisGameData, NextServiceTeam) == 0x000000, "Member 'FTennisGameData::NextServiceTeam' has a wrong offset!");
static_assert(offsetof(FTennisGameData, NextHitTeam_Server) == 0x000001, "Member 'FTennisGameData::NextHitTeam_Server' has a wrong offset!");
static_assert(offsetof(FTennisGameData, NextHitTeam_Local) == 0x000002, "Member 'FTennisGameData::NextHitTeam_Local' has a wrong offset!");
static_assert(offsetof(FTennisGameData, Player1Bounces) == 0x000004, "Member 'FTennisGameData::Player1Bounces' has a wrong offset!");
static_assert(offsetof(FTennisGameData, Player2Bounces) == 0x000008, "Member 'FTennisGameData::Player2Bounces' has a wrong offset!");

// ScriptStruct OPP.TrackingFootstepInfo
// 0x0020 (0x0020 - 0x0000)
struct FTrackingFootstepInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponent;                                    // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackingFootstepInfo) == 0x000008, "Wrong alignment on FTrackingFootstepInfo");
static_assert(sizeof(FTrackingFootstepInfo) == 0x000020, "Wrong size on FTrackingFootstepInfo");
static_assert(offsetof(FTrackingFootstepInfo, DecalComponent) == 0x000018, "Member 'FTrackingFootstepInfo::DecalComponent' has a wrong offset!");

// ScriptStruct OPP.RBUIReleasedCharacterDetails
// 0x0010 (0x0010 - 0x0000)
struct FRBUIReleasedCharacterDetails final
{
public:
	int32                                         InmateId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBUIReleasedCharacterDetails) == 0x000008, "Wrong alignment on FRBUIReleasedCharacterDetails");
static_assert(sizeof(FRBUIReleasedCharacterDetails) == 0x000010, "Wrong size on FRBUIReleasedCharacterDetails");
static_assert(offsetof(FRBUIReleasedCharacterDetails, InmateId) == 0x000000, "Member 'FRBUIReleasedCharacterDetails::InmateId' has a wrong offset!");
static_assert(offsetof(FRBUIReleasedCharacterDetails, Level) == 0x000004, "Member 'FRBUIReleasedCharacterDetails::Level' has a wrong offset!");
static_assert(offsetof(FRBUIReleasedCharacterDetails, Timestamp) == 0x000008, "Member 'FRBUIReleasedCharacterDetails::Timestamp' has a wrong offset!");

// ScriptStruct OPP.RBLobbyStatBoardEntry
// 0x0020 (0x0020 - 0x0000)
struct FRBLobbyStatBoardEntry final
{
public:
	class ARBPlayerState*                         RBPlayerState;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stat;                                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBLobbyStatBoardEntry) == 0x000008, "Wrong alignment on FRBLobbyStatBoardEntry");
static_assert(sizeof(FRBLobbyStatBoardEntry) == 0x000020, "Wrong size on FRBLobbyStatBoardEntry");
static_assert(offsetof(FRBLobbyStatBoardEntry, RBPlayerState) == 0x000000, "Member 'FRBLobbyStatBoardEntry::RBPlayerState' has a wrong offset!");
static_assert(offsetof(FRBLobbyStatBoardEntry, DisplayName) == 0x000008, "Member 'FRBLobbyStatBoardEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FRBLobbyStatBoardEntry, Stat) == 0x000018, "Member 'FRBLobbyStatBoardEntry::Stat' has a wrong offset!");

// ScriptStruct OPP.BaseZoneModifierData
// 0x0020 (0x0020 - 0x0000)
struct FBaseZoneModifierData
{
public:
	class ARBPlayer*                              TriggeringPlayer;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseZoneModifierData) == 0x000008, "Wrong alignment on FBaseZoneModifierData");
static_assert(sizeof(FBaseZoneModifierData) == 0x000020, "Wrong size on FBaseZoneModifierData");
static_assert(offsetof(FBaseZoneModifierData, TriggeringPlayer) == 0x000000, "Member 'FBaseZoneModifierData::TriggeringPlayer' has a wrong offset!");

// ScriptStruct OPP.RBActiveEvent
// 0x0028 (0x0028 - 0x0000)
struct FRBActiveEvent final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EndTimestamp;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBFeatureSwitchOverride>       FeatureSwitchOverrides;                            // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBActiveEvent) == 0x000008, "Wrong alignment on FRBActiveEvent");
static_assert(sizeof(FRBActiveEvent) == 0x000028, "Wrong size on FRBActiveEvent");
static_assert(offsetof(FRBActiveEvent, ID) == 0x000000, "Member 'FRBActiveEvent::ID' has a wrong offset!");
static_assert(offsetof(FRBActiveEvent, EndTimestamp) == 0x000010, "Member 'FRBActiveEvent::EndTimestamp' has a wrong offset!");
static_assert(offsetof(FRBActiveEvent, FeatureSwitchOverrides) == 0x000018, "Member 'FRBActiveEvent::FeatureSwitchOverrides' has a wrong offset!");

// ScriptStruct OPP.ContinuousAttackDamage
// 0x0028 (0x0028 - 0x0000)
struct FContinuousAttackDamage final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPawn*                                Target;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContinuousAttackDamage) == 0x000008, "Wrong alignment on FContinuousAttackDamage");
static_assert(sizeof(FContinuousAttackDamage) == 0x000028, "Wrong size on FContinuousAttackDamage");
static_assert(offsetof(FContinuousAttackDamage, Target) == 0x000020, "Member 'FContinuousAttackDamage::Target' has a wrong offset!");

// ScriptStruct OPP.TrialChainingWeightedItemType
// 0x0008 (0x0008 - 0x0000)
struct FTrialChainingWeightedItemType final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingWeightedItemType) == 0x000004, "Wrong alignment on FTrialChainingWeightedItemType");
static_assert(sizeof(FTrialChainingWeightedItemType) == 0x000008, "Wrong size on FTrialChainingWeightedItemType");
static_assert(offsetof(FTrialChainingWeightedItemType, ItemType) == 0x000000, "Member 'FTrialChainingWeightedItemType::ItemType' has a wrong offset!");
static_assert(offsetof(FTrialChainingWeightedItemType, Weight) == 0x000004, "Member 'FTrialChainingWeightedItemType::Weight' has a wrong offset!");

// ScriptStruct OPP.RBStatContext
// 0x0020 (0x0020 - 0x0000)
struct FRBStatContext final
{
public:
	class FString                                 Context;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBStatEntry>                   Entries;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBStatContext) == 0x000008, "Wrong alignment on FRBStatContext");
static_assert(sizeof(FRBStatContext) == 0x000020, "Wrong size on FRBStatContext");
static_assert(offsetof(FRBStatContext, Context) == 0x000000, "Member 'FRBStatContext::Context' has a wrong offset!");
static_assert(offsetof(FRBStatContext, Entries) == 0x000010, "Member 'FRBStatContext::Entries' has a wrong offset!");

// ScriptStruct OPP.RichInputWidgetRow
// 0x0018 (0x0020 - 0x0008)
struct FRichInputWidgetRow final : public FTableRowBase
{
public:
	struct FSoftClassPath                         WidgetClass;                                       // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichInputWidgetRow) == 0x000008, "Wrong alignment on FRichInputWidgetRow");
static_assert(sizeof(FRichInputWidgetRow) == 0x000020, "Wrong size on FRichInputWidgetRow");
static_assert(offsetof(FRichInputWidgetRow, WidgetClass) == 0x000008, "Member 'FRichInputWidgetRow::WidgetClass' has a wrong offset!");

// ScriptStruct OPP.RBStageID
// 0x0028 (0x0028 - 0x0000)
struct FRBStageID final
{
public:
	TSoftObjectPtr<class URBStageInfo>            StageInfo;                                         // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBStageID) == 0x000008, "Wrong alignment on FRBStageID");
static_assert(sizeof(FRBStageID) == 0x000028, "Wrong size on FRBStageID");
static_assert(offsetof(FRBStageID, StageInfo) == 0x000000, "Member 'FRBStageID::StageInfo' has a wrong offset!");

// ScriptStruct OPP.RBMissionID
// 0x0028 (0x0028 - 0x0000)
struct FRBMissionID final
{
public:
	TSoftObjectPtr<class URBMissionInfo>          MissionInfo;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBMissionID) == 0x000008, "Wrong alignment on FRBMissionID");
static_assert(sizeof(FRBMissionID) == 0x000028, "Wrong size on FRBMissionID");
static_assert(offsetof(FRBMissionID, MissionInfo) == 0x000000, "Member 'FRBMissionID::MissionInfo' has a wrong offset!");

// ScriptStruct OPP.RBGameStageInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FRBGameStageInfo final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrialChainIndex;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrialChainSeed;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TrialChainHash;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrialChainAcquiredUpgrades;                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrialChainLastTrialUpgrades;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBStageID                             StageID;                                           // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRBMissionID                           MissionID;                                         // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           CustomTrialVariatorIds;                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EObstacleVariatorType                         ObstacleVariatorType;                              // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESASVariatorType                              SASVariatorType;                                   // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      NonDefaultPrimeAssetType;                          // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBGameStageInfo) == 0x000008, "Wrong alignment on FRBGameStageInfo");
static_assert(sizeof(FRBGameStageInfo) == 0x0000B8, "Wrong size on FRBGameStageInfo");
static_assert(offsetof(FRBGameStageInfo, ProgramId) == 0x000000, "Member 'FRBGameStageInfo::ProgramId' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialId) == 0x000008, "Member 'FRBGameStageInfo::TrialId' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, ProgramDifficulty) == 0x000010, "Member 'FRBGameStageInfo::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialChainIndex) == 0x000014, "Member 'FRBGameStageInfo::TrialChainIndex' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialChainSeed) == 0x000018, "Member 'FRBGameStageInfo::TrialChainSeed' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialChainHash) == 0x000020, "Member 'FRBGameStageInfo::TrialChainHash' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialChainAcquiredUpgrades) == 0x000030, "Member 'FRBGameStageInfo::TrialChainAcquiredUpgrades' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, TrialChainLastTrialUpgrades) == 0x000040, "Member 'FRBGameStageInfo::TrialChainLastTrialUpgrades' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, StageID) == 0x000050, "Member 'FRBGameStageInfo::StageID' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, MissionID) == 0x000078, "Member 'FRBGameStageInfo::MissionID' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, CustomTrialVariatorIds) == 0x0000A0, "Member 'FRBGameStageInfo::CustomTrialVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, ObstacleVariatorType) == 0x0000B0, "Member 'FRBGameStageInfo::ObstacleVariatorType' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, SASVariatorType) == 0x0000B1, "Member 'FRBGameStageInfo::SASVariatorType' has a wrong offset!");
static_assert(offsetof(FRBGameStageInfo, NonDefaultPrimeAssetType) == 0x0000B2, "Member 'FRBGameStageInfo::NonDefaultPrimeAssetType' has a wrong offset!");

// ScriptStruct OPP.IKBones
// 0x0024 (0x0024 - 0x0000)
struct FIKBones final
{
public:
	struct FBoneReference                         IKFootBone;                                        // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FKFootBone;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumBonesInLimb;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKBones) == 0x000004, "Wrong alignment on FIKBones");
static_assert(sizeof(FIKBones) == 0x000024, "Wrong size on FIKBones");
static_assert(offsetof(FIKBones, IKFootBone) == 0x000000, "Member 'FIKBones::IKFootBone' has a wrong offset!");
static_assert(offsetof(FIKBones, FKFootBone) == 0x000010, "Member 'FIKBones::FKFootBone' has a wrong offset!");
static_assert(offsetof(FIKBones, NumBonesInLimb) == 0x000020, "Member 'FIKBones::NumBonesInLimb' has a wrong offset!");

// ScriptStruct OPP.PelvisAdjustmentInterp
// 0x0008 (0x0008 - 0x0000)
struct FPelvisAdjustmentInterp final
{
public:
	float                                         Stiffness;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dampen;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPelvisAdjustmentInterp) == 0x000004, "Wrong alignment on FPelvisAdjustmentInterp");
static_assert(sizeof(FPelvisAdjustmentInterp) == 0x000008, "Wrong size on FPelvisAdjustmentInterp");
static_assert(offsetof(FPelvisAdjustmentInterp, Stiffness) == 0x000000, "Member 'FPelvisAdjustmentInterp::Stiffness' has a wrong offset!");
static_assert(offsetof(FPelvisAdjustmentInterp, Dampen) == 0x000004, "Member 'FPelvisAdjustmentInterp::Dampen' has a wrong offset!");

// ScriptStruct OPP.AnimNode_SpeedWarping
// 0x0098 (0x0160 - 0x00C8)
struct FAnimNode_SpeedWarping final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKFootRootBone;                                    // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FIKBones>                       FeetDefinitions;                                   // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EIKFootRootLocalAxis                          SpeedWarpingAxisMode;                              // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedScaling;                                      // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisAdjustmentAlpha;                             // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIter;                                           // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPelvisAdjustmentInterp                PelvisAdjustmentInterp;                            // 0x0108(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ClampIKUsingFKLeg;                                 // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x4F];                                     // 0x0111(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SpeedWarping) == 0x000008, "Wrong alignment on FAnimNode_SpeedWarping");
static_assert(sizeof(FAnimNode_SpeedWarping) == 0x000160, "Wrong size on FAnimNode_SpeedWarping");
static_assert(offsetof(FAnimNode_SpeedWarping, IKFootRootBone) == 0x0000C8, "Member 'FAnimNode_SpeedWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, FeetDefinitions) == 0x0000D8, "Member 'FAnimNode_SpeedWarping::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, PelvisBone) == 0x0000E8, "Member 'FAnimNode_SpeedWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpeedWarpingAxisMode) == 0x0000F8, "Member 'FAnimNode_SpeedWarping::SpeedWarpingAxisMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpeedScaling) == 0x0000FC, "Member 'FAnimNode_SpeedWarping::SpeedScaling' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, PelvisAdjustmentAlpha) == 0x000100, "Member 'FAnimNode_SpeedWarping::PelvisAdjustmentAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, MaxIter) == 0x000104, "Member 'FAnimNode_SpeedWarping::MaxIter' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, PelvisAdjustmentInterp) == 0x000108, "Member 'FAnimNode_SpeedWarping::PelvisAdjustmentInterp' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, ClampIKUsingFKLeg) == 0x000110, "Member 'FAnimNode_SpeedWarping::ClampIKUsingFKLeg' has a wrong offset!");

// ScriptStruct OPP.CurrencyPackMenuItem
// 0x0060 (0x0060 - 0x0000)
struct FCurrencyPackMenuItem final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Currency;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayPrice;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyPackMenuItem) == 0x000008, "Wrong alignment on FCurrencyPackMenuItem");
static_assert(sizeof(FCurrencyPackMenuItem) == 0x000060, "Wrong size on FCurrencyPackMenuItem");
static_assert(offsetof(FCurrencyPackMenuItem, Name) == 0x000000, "Member 'FCurrencyPackMenuItem::Name' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, CurrencyType) == 0x000010, "Member 'FCurrencyPackMenuItem::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, Quantity) == 0x000014, "Member 'FCurrencyPackMenuItem::Quantity' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, Currency) == 0x000018, "Member 'FCurrencyPackMenuItem::Currency' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, Price) == 0x000028, "Member 'FCurrencyPackMenuItem::Price' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, DisplayPrice) == 0x000030, "Member 'FCurrencyPackMenuItem::DisplayPrice' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, Title) == 0x000040, "Member 'FCurrencyPackMenuItem::Title' has a wrong offset!");
static_assert(offsetof(FCurrencyPackMenuItem, Description) == 0x000050, "Member 'FCurrencyPackMenuItem::Description' has a wrong offset!");

// ScriptStruct OPP.InputAxesCurveData
// 0x0050 (0x0050 - 0x0000)
struct FInputAxesCurveData final
{
public:
	TMap<EGamepadStick, struct FRuntimeFloatCurve> InputAxisCurvesMap;                                // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputAxesCurveData) == 0x000008, "Wrong alignment on FInputAxesCurveData");
static_assert(sizeof(FInputAxesCurveData) == 0x000050, "Wrong size on FInputAxesCurveData");
static_assert(offsetof(FInputAxesCurveData, InputAxisCurvesMap) == 0x000000, "Member 'FInputAxesCurveData::InputAxisCurvesMap' has a wrong offset!");

// ScriptStruct OPP.TextureCachedData
// 0x0010 (0x0010 - 0x0000)
struct FTextureCachedData final
{
public:
	TArray<struct FColor>                         ColorData;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureCachedData) == 0x000008, "Wrong alignment on FTextureCachedData");
static_assert(sizeof(FTextureCachedData) == 0x000010, "Wrong size on FTextureCachedData");
static_assert(offsetof(FTextureCachedData, ColorData) == 0x000000, "Member 'FTextureCachedData::ColorData' has a wrong offset!");

// ScriptStruct OPP.PlayerReleaseState
// 0x0028 (0x0028 - 0x0000)
struct FPlayerReleaseState final
{
public:
	class ARBLobbyPlayerState*                    PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerReleasePending;                             // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerReleaseExpirationServerTime;                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerReleasing;                                  // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x17];                                      // 0x0011(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerReleaseState) == 0x000008, "Wrong alignment on FPlayerReleaseState");
static_assert(sizeof(FPlayerReleaseState) == 0x000028, "Wrong size on FPlayerReleaseState");
static_assert(offsetof(FPlayerReleaseState, PlayerState) == 0x000000, "Member 'FPlayerReleaseState::PlayerState' has a wrong offset!");
static_assert(offsetof(FPlayerReleaseState, bPlayerReleasePending) == 0x000008, "Member 'FPlayerReleaseState::bPlayerReleasePending' has a wrong offset!");
static_assert(offsetof(FPlayerReleaseState, PlayerReleaseExpirationServerTime) == 0x00000C, "Member 'FPlayerReleaseState::PlayerReleaseExpirationServerTime' has a wrong offset!");
static_assert(offsetof(FPlayerReleaseState, bPlayerReleasing) == 0x000010, "Member 'FPlayerReleaseState::bPlayerReleasing' has a wrong offset!");

// ScriptStruct OPP.NarrativeSoundEventsInfo
// 0x0020 (0x0020 - 0x0000)
struct FNarrativeSoundEventsInfo final
{
public:
	TArray<class UAkAudioEvent*>                  StartEvents;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAkAudioEvent*>                  StopEvents;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNarrativeSoundEventsInfo) == 0x000008, "Wrong alignment on FNarrativeSoundEventsInfo");
static_assert(sizeof(FNarrativeSoundEventsInfo) == 0x000020, "Wrong size on FNarrativeSoundEventsInfo");
static_assert(offsetof(FNarrativeSoundEventsInfo, StartEvents) == 0x000000, "Member 'FNarrativeSoundEventsInfo::StartEvents' has a wrong offset!");
static_assert(offsetof(FNarrativeSoundEventsInfo, StopEvents) == 0x000010, "Member 'FNarrativeSoundEventsInfo::StopEvents' has a wrong offset!");

// ScriptStruct OPP.ValidActorForUnlockableGateInfo
// 0x0010 (0x0010 - 0x0000)
struct FValidActorForUnlockableGateInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOnRail;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FValidActorForUnlockableGateInfo) == 0x000008, "Wrong alignment on FValidActorForUnlockableGateInfo");
static_assert(sizeof(FValidActorForUnlockableGateInfo) == 0x000010, "Wrong size on FValidActorForUnlockableGateInfo");
static_assert(offsetof(FValidActorForUnlockableGateInfo, Actor) == 0x000000, "Member 'FValidActorForUnlockableGateInfo::Actor' has a wrong offset!");
static_assert(offsetof(FValidActorForUnlockableGateInfo, DistanceOnRail) == 0x000008, "Member 'FValidActorForUnlockableGateInfo::DistanceOnRail' has a wrong offset!");

// ScriptStruct OPP.RBMurkoffAnnouncentData
// 0x0020 (0x0020 - 0x0000)
struct FRBMurkoffAnnouncentData final
{
public:
	class FString                                 AnnouncementName;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBMurkoffAnnouncentLineData>   AnnouncementList;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBMurkoffAnnouncentData) == 0x000008, "Wrong alignment on FRBMurkoffAnnouncentData");
static_assert(sizeof(FRBMurkoffAnnouncentData) == 0x000020, "Wrong size on FRBMurkoffAnnouncentData");
static_assert(offsetof(FRBMurkoffAnnouncentData, AnnouncementName) == 0x000000, "Member 'FRBMurkoffAnnouncentData::AnnouncementName' has a wrong offset!");
static_assert(offsetof(FRBMurkoffAnnouncentData, AnnouncementList) == 0x000010, "Member 'FRBMurkoffAnnouncentData::AnnouncementList' has a wrong offset!");

// ScriptStruct OPP.GameMessageAudioParams
// 0x0010 (0x0010 - 0x0000)
struct FGameMessageAudioParams final
{
public:
	class UAkAudioEvent*                          Sound;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Voice;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameMessageAudioParams) == 0x000008, "Wrong alignment on FGameMessageAudioParams");
static_assert(sizeof(FGameMessageAudioParams) == 0x000010, "Wrong size on FGameMessageAudioParams");
static_assert(offsetof(FGameMessageAudioParams, Sound) == 0x000000, "Member 'FGameMessageAudioParams::Sound' has a wrong offset!");
static_assert(offsetof(FGameMessageAudioParams, Voice) == 0x000008, "Member 'FGameMessageAudioParams::Voice' has a wrong offset!");

// ScriptStruct OPP.PendingFindPartyRequestDetails
// 0x0058 (0x0058 - 0x0000)
struct FPendingFindPartyRequestDetails final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBLobbyPlayerState*                    Owner;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBLobbyPlayerState*>            Members;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x38];                                      // 0x0020(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingFindPartyRequestDetails) == 0x000008, "Wrong alignment on FPendingFindPartyRequestDetails");
static_assert(sizeof(FPendingFindPartyRequestDetails) == 0x000058, "Wrong size on FPendingFindPartyRequestDetails");
static_assert(offsetof(FPendingFindPartyRequestDetails, Owner) == 0x000008, "Member 'FPendingFindPartyRequestDetails::Owner' has a wrong offset!");
static_assert(offsetof(FPendingFindPartyRequestDetails, Members) == 0x000010, "Member 'FPendingFindPartyRequestDetails::Members' has a wrong offset!");

// ScriptStruct OPP.RTPCComponentDebugInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FRTPCComponentDebugInfo final
{
public:
	TMap<class FString, float>                    RTPCValue;                                         // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            SwitchValue;                                       // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StateValue;                                        // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRTPCComponentDebugInfo) == 0x000008, "Wrong alignment on FRTPCComponentDebugInfo");
static_assert(sizeof(FRTPCComponentDebugInfo) == 0x0000F0, "Wrong size on FRTPCComponentDebugInfo");
static_assert(offsetof(FRTPCComponentDebugInfo, RTPCValue) == 0x000000, "Member 'FRTPCComponentDebugInfo::RTPCValue' has a wrong offset!");
static_assert(offsetof(FRTPCComponentDebugInfo, SwitchValue) == 0x000050, "Member 'FRTPCComponentDebugInfo::SwitchValue' has a wrong offset!");
static_assert(offsetof(FRTPCComponentDebugInfo, StateValue) == 0x0000A0, "Member 'FRTPCComponentDebugInfo::StateValue' has a wrong offset!");

// ScriptStruct OPP.PlayerPingIconMapping
// 0x0020 (0x0020 - 0x0000)
struct FPlayerPingIconMapping final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerPingIconMapping) == 0x000008, "Wrong alignment on FPlayerPingIconMapping");
static_assert(sizeof(FPlayerPingIconMapping) == 0x000020, "Wrong size on FPlayerPingIconMapping");
static_assert(offsetof(FPlayerPingIconMapping, Player) == 0x000000, "Member 'FPlayerPingIconMapping::Player' has a wrong offset!");
static_assert(offsetof(FPlayerPingIconMapping, TargetActor) == 0x000008, "Member 'FPlayerPingIconMapping::TargetActor' has a wrong offset!");

// ScriptStruct OPP.LocalSoundRefs
// 0x0090 (0x0090 - 0x0000)
struct FLocalSoundRefs final
{
public:
	class UAkAudioEvent*                          RadioStart;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RadioStart : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          RadioStop;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RadioStop : 1;                           // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ObjectiveMessageNotifySound;                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ObjectiveMessageNotifySound : 1;         // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartEntityFollowVoiceEvent;                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StartEntityFollowVoiceEvent : 1;         // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StopEntityFollowVoiceEvent;                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StopEntityFollowVoiceEvent : 1;          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartEntityFollowSFXEvent;                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StartEntityFollowSFXEvent : 1;           // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StopEntityFollowSFXEvent;                          // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StopEntityFollowSFXEvent : 1;            // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          JumpScare;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpScare : 1;                           // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          DisturbanceWarning;                                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DisturbanceWarning : 1;                  // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocalSoundRefs) == 0x000008, "Wrong alignment on FLocalSoundRefs");
static_assert(sizeof(FLocalSoundRefs) == 0x000090, "Wrong size on FLocalSoundRefs");
static_assert(offsetof(FLocalSoundRefs, RadioStart) == 0x000000, "Member 'FLocalSoundRefs::RadioStart' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, RadioStop) == 0x000010, "Member 'FLocalSoundRefs::RadioStop' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, ObjectiveMessageNotifySound) == 0x000020, "Member 'FLocalSoundRefs::ObjectiveMessageNotifySound' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, StartEntityFollowVoiceEvent) == 0x000030, "Member 'FLocalSoundRefs::StartEntityFollowVoiceEvent' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, StopEntityFollowVoiceEvent) == 0x000040, "Member 'FLocalSoundRefs::StopEntityFollowVoiceEvent' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, StartEntityFollowSFXEvent) == 0x000050, "Member 'FLocalSoundRefs::StartEntityFollowSFXEvent' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, StopEntityFollowSFXEvent) == 0x000060, "Member 'FLocalSoundRefs::StopEntityFollowSFXEvent' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, JumpScare) == 0x000070, "Member 'FLocalSoundRefs::JumpScare' has a wrong offset!");
static_assert(offsetof(FLocalSoundRefs, DisturbanceWarning) == 0x000080, "Member 'FLocalSoundRefs::DisturbanceWarning' has a wrong offset!");

// ScriptStruct OPP.ActiveEffectTrackingData
// 0x0010 (0x0010 - 0x0000)
struct FActiveEffectTrackingData final
{
public:
	class FName                                   EffectId;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UntilServerTime;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValue;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveEffectTrackingData) == 0x000004, "Wrong alignment on FActiveEffectTrackingData");
static_assert(sizeof(FActiveEffectTrackingData) == 0x000010, "Wrong size on FActiveEffectTrackingData");
static_assert(offsetof(FActiveEffectTrackingData, EffectId) == 0x000000, "Member 'FActiveEffectTrackingData::EffectId' has a wrong offset!");
static_assert(offsetof(FActiveEffectTrackingData, UntilServerTime) == 0x000008, "Member 'FActiveEffectTrackingData::UntilServerTime' has a wrong offset!");
static_assert(offsetof(FActiveEffectTrackingData, DisplayValue) == 0x00000C, "Member 'FActiveEffectTrackingData::DisplayValue' has a wrong offset!");

// ScriptStruct OPP.LargeObjectPoseData
// 0x0030 (0x0030 - 0x0000)
struct FLargeObjectPoseData final
{
public:
	class UAnimSequence*                          LargeItemPose;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LargeItemPoseCrouched;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LargeItemCradlePose;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LargeItemCrouchedCradlePose;                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TossAnim;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PutDownAnim;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLargeObjectPoseData) == 0x000008, "Wrong alignment on FLargeObjectPoseData");
static_assert(sizeof(FLargeObjectPoseData) == 0x000030, "Wrong size on FLargeObjectPoseData");
static_assert(offsetof(FLargeObjectPoseData, LargeItemPose) == 0x000000, "Member 'FLargeObjectPoseData::LargeItemPose' has a wrong offset!");
static_assert(offsetof(FLargeObjectPoseData, LargeItemPoseCrouched) == 0x000008, "Member 'FLargeObjectPoseData::LargeItemPoseCrouched' has a wrong offset!");
static_assert(offsetof(FLargeObjectPoseData, LargeItemCradlePose) == 0x000010, "Member 'FLargeObjectPoseData::LargeItemCradlePose' has a wrong offset!");
static_assert(offsetof(FLargeObjectPoseData, LargeItemCrouchedCradlePose) == 0x000018, "Member 'FLargeObjectPoseData::LargeItemCrouchedCradlePose' has a wrong offset!");
static_assert(offsetof(FLargeObjectPoseData, TossAnim) == 0x000020, "Member 'FLargeObjectPoseData::TossAnim' has a wrong offset!");
static_assert(offsetof(FLargeObjectPoseData, PutDownAnim) == 0x000028, "Member 'FLargeObjectPoseData::PutDownAnim' has a wrong offset!");

// ScriptStruct OPP.ClueData
// 0x0008 (0x0008 - 0x0000)
struct FClueData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClueData) == 0x000004, "Wrong alignment on FClueData");
static_assert(sizeof(FClueData) == 0x000008, "Wrong size on FClueData");
static_assert(offsetof(FClueData, Name) == 0x000000, "Member 'FClueData::Name' has a wrong offset!");

// ScriptStruct OPP.CluePanelOrderInfo
// 0x0020 (0x0020 - 0x0000)
struct FCluePanelOrderInfo final
{
public:
	class AActor*                                 ClueActor;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderIndex;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClueData                              Clue;                                              // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URBInteractiblePanelComponent*          Panel;                                             // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCluePanelOrderInfo) == 0x000008, "Wrong alignment on FCluePanelOrderInfo");
static_assert(sizeof(FCluePanelOrderInfo) == 0x000020, "Wrong size on FCluePanelOrderInfo");
static_assert(offsetof(FCluePanelOrderInfo, ClueActor) == 0x000000, "Member 'FCluePanelOrderInfo::ClueActor' has a wrong offset!");
static_assert(offsetof(FCluePanelOrderInfo, OrderIndex) == 0x000008, "Member 'FCluePanelOrderInfo::OrderIndex' has a wrong offset!");
static_assert(offsetof(FCluePanelOrderInfo, Clue) == 0x00000C, "Member 'FCluePanelOrderInfo::Clue' has a wrong offset!");
static_assert(offsetof(FCluePanelOrderInfo, Panel) == 0x000018, "Member 'FCluePanelOrderInfo::Panel' has a wrong offset!");

// ScriptStruct OPP.FootstepData
// 0x0038 (0x0038 - 0x0000)
struct FFootstepData final
{
public:
	EFootStepModifierType                         FootstepModifier;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepModifierAlpha;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      FootstepBaseMaterial;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftFoot;                                       // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepTime;                                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootLocation;                                      // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsObvious;                                        // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x0025(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         OverrideFootstepVFX;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFootstepVFXFlag;                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootstepData) == 0x000008, "Wrong alignment on FFootstepData");
static_assert(sizeof(FFootstepData) == 0x000038, "Wrong size on FFootstepData");
static_assert(offsetof(FFootstepData, FootstepModifier) == 0x000000, "Member 'FFootstepData::FootstepModifier' has a wrong offset!");
static_assert(offsetof(FFootstepData, FootstepModifierAlpha) == 0x000004, "Member 'FFootstepData::FootstepModifierAlpha' has a wrong offset!");
static_assert(offsetof(FFootstepData, FootstepBaseMaterial) == 0x000008, "Member 'FFootstepData::FootstepBaseMaterial' has a wrong offset!");
static_assert(offsetof(FFootstepData, bIsLeftFoot) == 0x000010, "Member 'FFootstepData::bIsLeftFoot' has a wrong offset!");
static_assert(offsetof(FFootstepData, StepTime) == 0x000014, "Member 'FFootstepData::StepTime' has a wrong offset!");
static_assert(offsetof(FFootstepData, FootLocation) == 0x000018, "Member 'FFootstepData::FootLocation' has a wrong offset!");
static_assert(offsetof(FFootstepData, bIsObvious) == 0x000024, "Member 'FFootstepData::bIsObvious' has a wrong offset!");
static_assert(offsetof(FFootstepData, bIsRunning) == 0x000025, "Member 'FFootstepData::bIsRunning' has a wrong offset!");
static_assert(offsetof(FFootstepData, OverrideFootstepVFX) == 0x000028, "Member 'FFootstepData::OverrideFootstepVFX' has a wrong offset!");
static_assert(offsetof(FFootstepData, bOverrideFootstepVFXFlag) == 0x000030, "Member 'FFootstepData::bOverrideFootstepVFXFlag' has a wrong offset!");

// ScriptStruct OPP.AILeashParameters
// 0x0040 (0x0040 - 0x0000)
struct FAILeashParameters final
{
public:
	float                                         SlowdownDuration;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowdownDuration : 1;                    // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bSlowDownInChaseOutsideLeash;                      // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bSlowDownInChaseOutsideLeash : 1;        // 0x0006(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOutsideLeashBeforeConsideration;               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeOutsideLeashBeforeConsideration : 1; // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIgnoreIfChasingCloseToTarget;                     // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bIgnoreIfChasingCloseToTarget : 1;       // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDistanceThreshold;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TargetDistanceThreshold : 1;             // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceFromLeashBeforeUsingCloset;             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceFromLeashBeforeUsingCloset : 1; // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVerticalDistanceFromLeashBeforeUsingCloset;     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxVerticalDistanceFromLeashBeforeUsingCloset : 1; // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bDiscardSoundStimulusOutsideLeash;                 // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDiscardSoundStimulusOutsideLeash : 1;   // 0x0026(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullVisionRangeMultiplierForTargetOutsideLeash;    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullVisionRangeMultiplierForTargetOutsideLeash : 1; // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartialVisionRangeMultiplierForTargetOutsideLeash; // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PartialVisionRangeMultiplierForTargetOutsideLeash : 1; // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HearingRangeMultiplierForTargetOutsideLeash;       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HearingRangeMultiplierForTargetOutsideLeash : 1; // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILeashParameters) == 0x000004, "Wrong alignment on FAILeashParameters");
static_assert(sizeof(FAILeashParameters) == 0x000040, "Wrong size on FAILeashParameters");
static_assert(offsetof(FAILeashParameters, SlowdownDuration) == 0x000000, "Member 'FAILeashParameters::SlowdownDuration' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, bSlowDownInChaseOutsideLeash) == 0x000005, "Member 'FAILeashParameters::bSlowDownInChaseOutsideLeash' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, TimeOutsideLeashBeforeConsideration) == 0x000008, "Member 'FAILeashParameters::TimeOutsideLeashBeforeConsideration' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, bIgnoreIfChasingCloseToTarget) == 0x00000D, "Member 'FAILeashParameters::bIgnoreIfChasingCloseToTarget' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, TargetDistanceThreshold) == 0x000010, "Member 'FAILeashParameters::TargetDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, MaxDistanceFromLeashBeforeUsingCloset) == 0x000018, "Member 'FAILeashParameters::MaxDistanceFromLeashBeforeUsingCloset' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, MaxVerticalDistanceFromLeashBeforeUsingCloset) == 0x000020, "Member 'FAILeashParameters::MaxVerticalDistanceFromLeashBeforeUsingCloset' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, bDiscardSoundStimulusOutsideLeash) == 0x000025, "Member 'FAILeashParameters::bDiscardSoundStimulusOutsideLeash' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, FullVisionRangeMultiplierForTargetOutsideLeash) == 0x000028, "Member 'FAILeashParameters::FullVisionRangeMultiplierForTargetOutsideLeash' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, PartialVisionRangeMultiplierForTargetOutsideLeash) == 0x000030, "Member 'FAILeashParameters::PartialVisionRangeMultiplierForTargetOutsideLeash' has a wrong offset!");
static_assert(offsetof(FAILeashParameters, HearingRangeMultiplierForTargetOutsideLeash) == 0x000038, "Member 'FAILeashParameters::HearingRangeMultiplierForTargetOutsideLeash' has a wrong offset!");

// ScriptStruct OPP.QuickGraphEntry
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FQuickGraphEntry final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuickGraphEntry) == 0x000004, "Wrong alignment on FQuickGraphEntry");
static_assert(sizeof(FQuickGraphEntry) == 0x00000C, "Wrong size on FQuickGraphEntry");

// ScriptStruct OPP.RBTrialChainInfo
// 0x0020 (0x0020 - 0x0000)
struct FRBTrialChainInfo final
{
public:
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ForcedVariatorIds;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VariatorPoints;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumVariatorPointValue;                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialChainInfo) == 0x000008, "Wrong alignment on FRBTrialChainInfo");
static_assert(sizeof(FRBTrialChainInfo) == 0x000020, "Wrong size on FRBTrialChainInfo");
static_assert(offsetof(FRBTrialChainInfo, ProgramDifficulty) == 0x000000, "Member 'FRBTrialChainInfo::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfo, ForcedVariatorIds) == 0x000008, "Member 'FRBTrialChainInfo::ForcedVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfo, VariatorPoints) == 0x000018, "Member 'FRBTrialChainInfo::VariatorPoints' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfo, MinimumVariatorPointValue) == 0x00001C, "Member 'FRBTrialChainInfo::MinimumVariatorPointValue' has a wrong offset!");

// ScriptStruct OPP.NPCDoorInteractionAnimData
// 0x0040 (0x0040 - 0x0000)
struct FNPCDoorInteractionAnimData
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnchorTranslation;                                 // 0x0008(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnchorOffsetAtAdjustmentLimit;                     // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalYawAtAdjustmentLimit;                         // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdjustmentDistance;                             // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdjustmentDuration;                             // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryPhase;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntrySpeed;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBlendOutDuration;                              // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomBlendOutDuration;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCDoorInteractionAnimData) == 0x000008, "Wrong alignment on FNPCDoorInteractionAnimData");
static_assert(sizeof(FNPCDoorInteractionAnimData) == 0x000040, "Wrong size on FNPCDoorInteractionAnimData");
static_assert(offsetof(FNPCDoorInteractionAnimData, Sequence) == 0x000000, "Member 'FNPCDoorInteractionAnimData::Sequence' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, AnchorTranslation) == 0x000008, "Member 'FNPCDoorInteractionAnimData::AnchorTranslation' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, AnchorOffsetAtAdjustmentLimit) == 0x000014, "Member 'FNPCDoorInteractionAnimData::AnchorOffsetAtAdjustmentLimit' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, LocalYawAtAdjustmentLimit) == 0x000020, "Member 'FNPCDoorInteractionAnimData::LocalYawAtAdjustmentLimit' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, MaxAdjustmentDistance) == 0x000024, "Member 'FNPCDoorInteractionAnimData::MaxAdjustmentDistance' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, MaxAdjustmentDuration) == 0x000028, "Member 'FNPCDoorInteractionAnimData::MaxAdjustmentDuration' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, EntryPhase) == 0x00002C, "Member 'FNPCDoorInteractionAnimData::EntryPhase' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, EntrySpeed) == 0x000030, "Member 'FNPCDoorInteractionAnimData::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, AutoBlendOutDuration) == 0x000034, "Member 'FNPCDoorInteractionAnimData::AutoBlendOutDuration' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionAnimData, CustomBlendOutDuration) == 0x000038, "Member 'FNPCDoorInteractionAnimData::CustomBlendOutDuration' has a wrong offset!");

// ScriptStruct OPP.NPCDoorPassthroughAnimDataHalfSet
// 0x0210 (0x0210 - 0x0000)
struct FNPCDoorPassthroughAnimDataHalfSet final
{
public:
	struct FNPCDoorInteractionAnimData            OpenedToClosed;                                    // 0x0000(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            OpenedToLocked;                                    // 0x0040(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            OpenedToClosedBack;                                // 0x0080(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            OpenedToLockedBack;                                // 0x00C0(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FNPCDoorInteractionAnimData>    ClosedToOpened_List;                               // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            ClosedToClosed;                                    // 0x0110(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            ClosedToLocked;                                    // 0x0150(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            LockedToOpened;                                    // 0x0190(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            LockedToClosed;                                    // 0x01D0(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCDoorPassthroughAnimDataHalfSet) == 0x000008, "Wrong alignment on FNPCDoorPassthroughAnimDataHalfSet");
static_assert(sizeof(FNPCDoorPassthroughAnimDataHalfSet) == 0x000210, "Wrong size on FNPCDoorPassthroughAnimDataHalfSet");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, OpenedToClosed) == 0x000000, "Member 'FNPCDoorPassthroughAnimDataHalfSet::OpenedToClosed' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, OpenedToLocked) == 0x000040, "Member 'FNPCDoorPassthroughAnimDataHalfSet::OpenedToLocked' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, OpenedToClosedBack) == 0x000080, "Member 'FNPCDoorPassthroughAnimDataHalfSet::OpenedToClosedBack' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, OpenedToLockedBack) == 0x0000C0, "Member 'FNPCDoorPassthroughAnimDataHalfSet::OpenedToLockedBack' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, ClosedToOpened_List) == 0x000100, "Member 'FNPCDoorPassthroughAnimDataHalfSet::ClosedToOpened_List' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, ClosedToClosed) == 0x000110, "Member 'FNPCDoorPassthroughAnimDataHalfSet::ClosedToClosed' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, ClosedToLocked) == 0x000150, "Member 'FNPCDoorPassthroughAnimDataHalfSet::ClosedToLocked' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, LockedToOpened) == 0x000190, "Member 'FNPCDoorPassthroughAnimDataHalfSet::LockedToOpened' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataHalfSet, LockedToClosed) == 0x0001D0, "Member 'FNPCDoorPassthroughAnimDataHalfSet::LockedToClosed' has a wrong offset!");

// ScriptStruct OPP.NetworkFloat
// 0x0010 (0x0010 - 0x0000)
struct FNetworkFloat final
{
public:
	float                                         ReplicatedValue;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkFloat) == 0x000004, "Wrong alignment on FNetworkFloat");
static_assert(sizeof(FNetworkFloat) == 0x000010, "Wrong size on FNetworkFloat");
static_assert(offsetof(FNetworkFloat, ReplicatedValue) == 0x000000, "Member 'FNetworkFloat::ReplicatedValue' has a wrong offset!");

// ScriptStruct OPP.PsychosisMineData
// 0x0050 (0x0050 - 0x0000)
struct FPsychosisMineData final
{
public:
	class ARBBot*                                 bot;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPsychosisMine*                       MineActor;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBPlayer*>                      AffectedPlayers;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychosisMineData) == 0x000008, "Wrong alignment on FPsychosisMineData");
static_assert(sizeof(FPsychosisMineData) == 0x000050, "Wrong size on FPsychosisMineData");
static_assert(offsetof(FPsychosisMineData, bot) == 0x000000, "Member 'FPsychosisMineData::bot' has a wrong offset!");
static_assert(offsetof(FPsychosisMineData, MineActor) == 0x000038, "Member 'FPsychosisMineData::MineActor' has a wrong offset!");
static_assert(offsetof(FPsychosisMineData, AffectedPlayers) == 0x000040, "Member 'FPsychosisMineData::AffectedPlayers' has a wrong offset!");

// ScriptStruct OPP.DelayedBugIt
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDelayedBugIt final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelayedBugIt) == 0x000008, "Wrong alignment on FDelayedBugIt");
static_assert(sizeof(FDelayedBugIt) == 0x000018, "Wrong size on FDelayedBugIt");

// ScriptStruct OPP.InteractionComponentReparentingData
// 0x0050 (0x0050 - 0x0000)
struct FInteractionComponentReparentingData final
{
public:
	class USceneComponent*                        TargetComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ParentComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OriginalOffset;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnTransformToOriginalLocation;                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionComponentReparentingData) == 0x000010, "Wrong alignment on FInteractionComponentReparentingData");
static_assert(sizeof(FInteractionComponentReparentingData) == 0x000050, "Wrong size on FInteractionComponentReparentingData");
static_assert(offsetof(FInteractionComponentReparentingData, TargetComponent) == 0x000000, "Member 'FInteractionComponentReparentingData::TargetComponent' has a wrong offset!");
static_assert(offsetof(FInteractionComponentReparentingData, ParentComponent) == 0x000008, "Member 'FInteractionComponentReparentingData::ParentComponent' has a wrong offset!");
static_assert(offsetof(FInteractionComponentReparentingData, OriginalOffset) == 0x000010, "Member 'FInteractionComponentReparentingData::OriginalOffset' has a wrong offset!");
static_assert(offsetof(FInteractionComponentReparentingData, ReturnTransformToOriginalLocation) == 0x000040, "Member 'FInteractionComponentReparentingData::ReturnTransformToOriginalLocation' has a wrong offset!");

// ScriptStruct OPP.WaypointSelectionDebugData
// 0x0040 (0x0040 - 0x0000)
struct FWaypointSelectionDebugData final
{
public:
	class ARBWaypoint*                            Waypoint;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaypointSelectionDebugData) == 0x000008, "Wrong alignment on FWaypointSelectionDebugData");
static_assert(sizeof(FWaypointSelectionDebugData) == 0x000040, "Wrong size on FWaypointSelectionDebugData");
static_assert(offsetof(FWaypointSelectionDebugData, Waypoint) == 0x000000, "Member 'FWaypointSelectionDebugData::Waypoint' has a wrong offset!");

// ScriptStruct OPP.StroopDisturbanceData
// 0x0030 (0x0030 - 0x0000)
struct FStroopDisturbanceData final
{
public:
	EStroopDisturbanceType                        Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTimestampPlayer1;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimestampPlayer2;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTimestampPlayer1;                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTimestampPlayer2;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivePlayer1;                                    // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivePlayer2;                                    // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerPercentage;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDownDuration;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinToxicityLevel;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRound;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRound;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStroopDisturbanceData) == 0x000004, "Wrong alignment on FStroopDisturbanceData");
static_assert(sizeof(FStroopDisturbanceData) == 0x000030, "Wrong size on FStroopDisturbanceData");
static_assert(offsetof(FStroopDisturbanceData, Type) == 0x000000, "Member 'FStroopDisturbanceData::Type' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, StartTimestampPlayer1) == 0x000004, "Member 'FStroopDisturbanceData::StartTimestampPlayer1' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, StartTimestampPlayer2) == 0x000008, "Member 'FStroopDisturbanceData::StartTimestampPlayer2' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, StopTimestampPlayer1) == 0x00000C, "Member 'FStroopDisturbanceData::StopTimestampPlayer1' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, StopTimestampPlayer2) == 0x000010, "Member 'FStroopDisturbanceData::StopTimestampPlayer2' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, bActivePlayer1) == 0x000014, "Member 'FStroopDisturbanceData::bActivePlayer1' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, bActivePlayer2) == 0x000015, "Member 'FStroopDisturbanceData::bActivePlayer2' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, TriggerPercentage) == 0x000018, "Member 'FStroopDisturbanceData::TriggerPercentage' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, Duration) == 0x00001C, "Member 'FStroopDisturbanceData::Duration' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, CoolDownDuration) == 0x000020, "Member 'FStroopDisturbanceData::CoolDownDuration' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, MinToxicityLevel) == 0x000024, "Member 'FStroopDisturbanceData::MinToxicityLevel' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, MinRound) == 0x000028, "Member 'FStroopDisturbanceData::MinRound' has a wrong offset!");
static_assert(offsetof(FStroopDisturbanceData, MaxRound) == 0x00002C, "Member 'FStroopDisturbanceData::MaxRound' has a wrong offset!");

// ScriptStruct OPP.CameraDestructionSoundState
// 0x0028 (0x0028 - 0x0000)
struct FCameraDestructionSoundState final
{
public:
	class UAkAudioEvent*                          StartEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SuccessEvent;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartInteractionEvent;                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopInteractionEvent;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraDestructionSoundState) == 0x000008, "Wrong alignment on FCameraDestructionSoundState");
static_assert(sizeof(FCameraDestructionSoundState) == 0x000028, "Wrong size on FCameraDestructionSoundState");
static_assert(offsetof(FCameraDestructionSoundState, StartEvent) == 0x000000, "Member 'FCameraDestructionSoundState::StartEvent' has a wrong offset!");
static_assert(offsetof(FCameraDestructionSoundState, StopEvent) == 0x000008, "Member 'FCameraDestructionSoundState::StopEvent' has a wrong offset!");
static_assert(offsetof(FCameraDestructionSoundState, SuccessEvent) == 0x000010, "Member 'FCameraDestructionSoundState::SuccessEvent' has a wrong offset!");
static_assert(offsetof(FCameraDestructionSoundState, StartInteractionEvent) == 0x000018, "Member 'FCameraDestructionSoundState::StartInteractionEvent' has a wrong offset!");
static_assert(offsetof(FCameraDestructionSoundState, StopInteractionEvent) == 0x000020, "Member 'FCameraDestructionSoundState::StopInteractionEvent' has a wrong offset!");

// ScriptStruct OPP.ScheduledUObject
// 0x0020 (0x0088 - 0x0068)
struct FScheduledUObject final : public FScheduledProperty
{
public:
	class UObject*                                InitialValue;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                LastValue;                                         // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CurrentValue;                                      // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DesiredValue;                                      // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledUObject) == 0x000008, "Wrong alignment on FScheduledUObject");
static_assert(sizeof(FScheduledUObject) == 0x000088, "Wrong size on FScheduledUObject");
static_assert(offsetof(FScheduledUObject, InitialValue) == 0x000068, "Member 'FScheduledUObject::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledUObject, LastValue) == 0x000070, "Member 'FScheduledUObject::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledUObject, CurrentValue) == 0x000078, "Member 'FScheduledUObject::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledUObject, DesiredValue) == 0x000080, "Member 'FScheduledUObject::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.AIRetirementConfig
// 0x0020 (0x0020 - 0x0000)
struct FAIRetirementConfig final
{
public:
	bool                                          bEnterLimboAfterSpecialistActivity;                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnterLimboAfterSpecialistActivity : 1;  // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRetireAfterHitByActiveSkill;                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRetireAfterHitByActiveSkill : 1;        // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnterLimboAfterHitByActiveSkill;                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnterLimboAfterHitByActiveSkill : 1;    // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRetireAfterHitByProjectile;                       // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRetireAfterHitByProjectile : 1;         // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnterLimboAfterHitByProjectile;                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnterLimboAfterHitByProjectile : 1;     // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeInLimbo;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinTimeInLimbo : 1;                      // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeInLimbo;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxTimeInLimbo : 1;                      // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRespawnFromLimboCloseToAPlayer;                   // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRespawnFromLimboCloseToAPlayer : 1;     // 0x001A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRespawnFromLimboAtQuietCloset;                    // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRespawnFromLimboAtQuietCloset : 1;      // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRetirementConfig) == 0x000004, "Wrong alignment on FAIRetirementConfig");
static_assert(sizeof(FAIRetirementConfig) == 0x000020, "Wrong size on FAIRetirementConfig");
static_assert(offsetof(FAIRetirementConfig, bEnterLimboAfterSpecialistActivity) == 0x000000, "Member 'FAIRetirementConfig::bEnterLimboAfterSpecialistActivity' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bRetireAfterHitByActiveSkill) == 0x000002, "Member 'FAIRetirementConfig::bRetireAfterHitByActiveSkill' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bEnterLimboAfterHitByActiveSkill) == 0x000004, "Member 'FAIRetirementConfig::bEnterLimboAfterHitByActiveSkill' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bRetireAfterHitByProjectile) == 0x000006, "Member 'FAIRetirementConfig::bRetireAfterHitByProjectile' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bEnterLimboAfterHitByProjectile) == 0x000008, "Member 'FAIRetirementConfig::bEnterLimboAfterHitByProjectile' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, MinTimeInLimbo) == 0x00000C, "Member 'FAIRetirementConfig::MinTimeInLimbo' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, MaxTimeInLimbo) == 0x000014, "Member 'FAIRetirementConfig::MaxTimeInLimbo' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bRespawnFromLimboCloseToAPlayer) == 0x000019, "Member 'FAIRetirementConfig::bRespawnFromLimboCloseToAPlayer' has a wrong offset!");
static_assert(offsetof(FAIRetirementConfig, bRespawnFromLimboAtQuietCloset) == 0x00001B, "Member 'FAIRetirementConfig::bRespawnFromLimboAtQuietCloset' has a wrong offset!");

// ScriptStruct OPP.RBVariatorNPCAIConfigOverride
// 0x0010 (0x0010 - 0x0000)
struct FRBVariatorNPCAIConfigOverride final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URBPartialAIConfig*                     Override;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBVariatorNPCAIConfigOverride) == 0x000008, "Wrong alignment on FRBVariatorNPCAIConfigOverride");
static_assert(sizeof(FRBVariatorNPCAIConfigOverride) == 0x000010, "Wrong size on FRBVariatorNPCAIConfigOverride");
static_assert(offsetof(FRBVariatorNPCAIConfigOverride, NPCType) == 0x000000, "Member 'FRBVariatorNPCAIConfigOverride::NPCType' has a wrong offset!");
static_assert(offsetof(FRBVariatorNPCAIConfigOverride, NPCFlavor) == 0x000001, "Member 'FRBVariatorNPCAIConfigOverride::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FRBVariatorNPCAIConfigOverride, Override) == 0x000008, "Member 'FRBVariatorNPCAIConfigOverride::Override' has a wrong offset!");

// ScriptStruct OPP.AIVOConfig
// 0x0070 (0x0070 - 0x0000)
struct FAIVOConfig final
{
public:
	bool                                          bPlayContinuousSound;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bPlayContinuousSound : 1;                // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinActivityTimeForRandomVO;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinActivityTimeForRandomVO : 1;          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnawareMinTimeForRandomVO;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnawareMinTimeForRandomVO : 1;           // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnawareMaxTimeForRandomVO;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnawareMaxTimeForRandomVO : 1;           // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigateMinTimeForRandomVO;                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InvestigateMinTimeForRandomVO : 1;       // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigateMaxTimeForRandomVO;                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InvestigateMaxTimeForRandomVO : 1;       // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChaseMinTimeForRandomVO;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChaseMinTimeForRandomVO : 1;             // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChaseMaxTimeForRandomVO;                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChaseMaxTimeForRandomVO : 1;             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInterruptVOOnDisturbance;                         // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bInterruptVOOnDisturbance : 1;           // 0x003A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinChaseDurationForLKPVO;                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinChaseDurationForLKPVO : 1;            // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayAfterLostSightForReachedLKPVO;             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayAfterLostSightForReachedLKPVO : 1; // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LKPEventDelay;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LKPEventDelay : 1;                       // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinChaseTimeForLostSightVO;                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinChaseTimeForLostSightVO : 1;          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinInvestigationTimeForInvestigatePointVO;         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinInvestigationTimeForInvestigatePointVO : 1; // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeAfterDamageForContinuous;                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinTimeAfterDamageForContinuous : 1;     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAmbientPlayRandomVOInPassiveState;                // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAmbientPlayRandomVOInPassiveState : 1;  // 0x006A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAmbientPlayRandomVOInActiveState;                 // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAmbientPlayRandomVOInActiveState : 1;   // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIVOConfig) == 0x000004, "Wrong alignment on FAIVOConfig");
static_assert(sizeof(FAIVOConfig) == 0x000070, "Wrong size on FAIVOConfig");
static_assert(offsetof(FAIVOConfig, bPlayContinuousSound) == 0x000000, "Member 'FAIVOConfig::bPlayContinuousSound' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinActivityTimeForRandomVO) == 0x000004, "Member 'FAIVOConfig::MinActivityTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, UnawareMinTimeForRandomVO) == 0x00000C, "Member 'FAIVOConfig::UnawareMinTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, UnawareMaxTimeForRandomVO) == 0x000014, "Member 'FAIVOConfig::UnawareMaxTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, InvestigateMinTimeForRandomVO) == 0x00001C, "Member 'FAIVOConfig::InvestigateMinTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, InvestigateMaxTimeForRandomVO) == 0x000024, "Member 'FAIVOConfig::InvestigateMaxTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, ChaseMinTimeForRandomVO) == 0x00002C, "Member 'FAIVOConfig::ChaseMinTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, ChaseMaxTimeForRandomVO) == 0x000034, "Member 'FAIVOConfig::ChaseMaxTimeForRandomVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, bInterruptVOOnDisturbance) == 0x000039, "Member 'FAIVOConfig::bInterruptVOOnDisturbance' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinChaseDurationForLKPVO) == 0x00003C, "Member 'FAIVOConfig::MinChaseDurationForLKPVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinDelayAfterLostSightForReachedLKPVO) == 0x000044, "Member 'FAIVOConfig::MinDelayAfterLostSightForReachedLKPVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, LKPEventDelay) == 0x00004C, "Member 'FAIVOConfig::LKPEventDelay' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinChaseTimeForLostSightVO) == 0x000054, "Member 'FAIVOConfig::MinChaseTimeForLostSightVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinInvestigationTimeForInvestigatePointVO) == 0x00005C, "Member 'FAIVOConfig::MinInvestigationTimeForInvestigatePointVO' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, MinTimeAfterDamageForContinuous) == 0x000064, "Member 'FAIVOConfig::MinTimeAfterDamageForContinuous' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, bAmbientPlayRandomVOInPassiveState) == 0x000069, "Member 'FAIVOConfig::bAmbientPlayRandomVOInPassiveState' has a wrong offset!");
static_assert(offsetof(FAIVOConfig, bAmbientPlayRandomVOInActiveState) == 0x00006B, "Member 'FAIVOConfig::bAmbientPlayRandomVOInActiveState' has a wrong offset!");

// ScriptStruct OPP.StandardFatalityData
// 0x0040 (0x0040 - 0x0000)
struct FStandardFatalityData final
{
public:
	class ARBPawn*                                Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              Victim;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasicDirection                               Direction;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AttackerAnim;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          VictimAnim;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackerEnterLocation;                             // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackerEnterDirection;                            // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandardFatalityData) == 0x000008, "Wrong alignment on FStandardFatalityData");
static_assert(sizeof(FStandardFatalityData) == 0x000040, "Wrong size on FStandardFatalityData");
static_assert(offsetof(FStandardFatalityData, Attacker) == 0x000000, "Member 'FStandardFatalityData::Attacker' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, Victim) == 0x000008, "Member 'FStandardFatalityData::Victim' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, Direction) == 0x000010, "Member 'FStandardFatalityData::Direction' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, AttackerAnim) == 0x000018, "Member 'FStandardFatalityData::AttackerAnim' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, VictimAnim) == 0x000020, "Member 'FStandardFatalityData::VictimAnim' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, AttackerEnterLocation) == 0x000028, "Member 'FStandardFatalityData::AttackerEnterLocation' has a wrong offset!");
static_assert(offsetof(FStandardFatalityData, AttackerEnterDirection) == 0x000034, "Member 'FStandardFatalityData::AttackerEnterDirection' has a wrong offset!");

// ScriptStruct OPP.DamageVolume
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FDamageVolume final
{
public:
	class UShapeComponent*                        Comp;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachComp;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageVolume) == 0x000010, "Wrong alignment on FDamageVolume");
static_assert(sizeof(FDamageVolume) == 0x000060, "Wrong size on FDamageVolume");
static_assert(offsetof(FDamageVolume, Comp) == 0x000000, "Member 'FDamageVolume::Comp' has a wrong offset!");
static_assert(offsetof(FDamageVolume, AttachComp) == 0x000008, "Member 'FDamageVolume::AttachComp' has a wrong offset!");

// ScriptStruct OPP.AIPusherConfig
// 0x0028 (0x0028 - 0x0000)
struct FAIPusherConfig final
{
public:
	float                                         MinIntervalGasAttacksOnSamePlayer;                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinIntervalGasAttacksOnSamePlayer : 1;   // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayAfterPlayerPsychosis;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayAfterPlayerPsychosis : 1;        // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GasAttackRange;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GasAttackRange : 1;                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanDoGroupGasAttack;                              // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanDoGroupGasAttack : 1;                // 0x0016(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroupGasAttackAngle;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GroupGasAttackAngle : 1;                 // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroupGasAttackRange;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GroupGasAttackRange : 1;                 // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPusherConfig) == 0x000004, "Wrong alignment on FAIPusherConfig");
static_assert(sizeof(FAIPusherConfig) == 0x000028, "Wrong size on FAIPusherConfig");
static_assert(offsetof(FAIPusherConfig, MinIntervalGasAttacksOnSamePlayer) == 0x000000, "Member 'FAIPusherConfig::MinIntervalGasAttacksOnSamePlayer' has a wrong offset!");
static_assert(offsetof(FAIPusherConfig, MinDelayAfterPlayerPsychosis) == 0x000008, "Member 'FAIPusherConfig::MinDelayAfterPlayerPsychosis' has a wrong offset!");
static_assert(offsetof(FAIPusherConfig, GasAttackRange) == 0x000010, "Member 'FAIPusherConfig::GasAttackRange' has a wrong offset!");
static_assert(offsetof(FAIPusherConfig, bCanDoGroupGasAttack) == 0x000015, "Member 'FAIPusherConfig::bCanDoGroupGasAttack' has a wrong offset!");
static_assert(offsetof(FAIPusherConfig, GroupGasAttackAngle) == 0x000018, "Member 'FAIPusherConfig::GroupGasAttackAngle' has a wrong offset!");
static_assert(offsetof(FAIPusherConfig, GroupGasAttackRange) == 0x000020, "Member 'FAIPusherConfig::GroupGasAttackRange' has a wrong offset!");

// ScriptStruct OPP.NPCFatalityPrepareData
// 0x0058 (0x0058 - 0x0000)
struct FNPCFatalityPrepareData final
{
public:
	TSoftObjectPtr<class UAnimSequence>           AttackAnimRefToPrepare;                            // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           VictimAnimRefToPrepare;                            // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasicDirection                               Direction;                                         // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCFatalityPrepareData) == 0x000008, "Wrong alignment on FNPCFatalityPrepareData");
static_assert(sizeof(FNPCFatalityPrepareData) == 0x000058, "Wrong size on FNPCFatalityPrepareData");
static_assert(offsetof(FNPCFatalityPrepareData, AttackAnimRefToPrepare) == 0x000000, "Member 'FNPCFatalityPrepareData::AttackAnimRefToPrepare' has a wrong offset!");
static_assert(offsetof(FNPCFatalityPrepareData, VictimAnimRefToPrepare) == 0x000028, "Member 'FNPCFatalityPrepareData::VictimAnimRefToPrepare' has a wrong offset!");
static_assert(offsetof(FNPCFatalityPrepareData, Direction) == 0x000050, "Member 'FNPCFatalityPrepareData::Direction' has a wrong offset!");

// ScriptStruct OPP.SpawnedAnimPropData
// 0x0010 (0x0010 - 0x0000)
struct FSpawnedAnimPropData final
{
public:
	class URBAnimNotifyState_AttachNewObject*     AnimNotifyOwner;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SpawnedProp;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnedAnimPropData) == 0x000008, "Wrong alignment on FSpawnedAnimPropData");
static_assert(sizeof(FSpawnedAnimPropData) == 0x000010, "Wrong size on FSpawnedAnimPropData");
static_assert(offsetof(FSpawnedAnimPropData, AnimNotifyOwner) == 0x000000, "Member 'FSpawnedAnimPropData::AnimNotifyOwner' has a wrong offset!");
static_assert(offsetof(FSpawnedAnimPropData, SpawnedProp) == 0x000008, "Member 'FSpawnedAnimPropData::SpawnedProp' has a wrong offset!");

// ScriptStruct OPP.RBTaskDataRow
// 0x01B8 (0x01C0 - 0x0008)
struct FRBTaskDataRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskCategory                                 Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroupID;                                           // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GroupName;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   SectionId;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SectionName;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RewardDataIds;                                     // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETaskType                                     Type;                                              // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistProgress;                                  // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnStageFailure;                               // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerEvent>                          Progress_PlayerEvents;                             // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerStat>                           Progress_PlayerStats;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Progress_ConditionId;                              // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reset_ConditionId;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Failure_ConditionId;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPlayerEvent>                          Failure_PlayerEvents;                              // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerStat>                           Failure_PlayerStats;                               // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ProgramIds;                                        // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EProgramDifficulty>                    ProgramDifficulties;                               // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TrialIds;                                          // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TaskIds;                                           // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           VariatorIds;                                       // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ETaskCategory>                         RequiredTaskCategories;                            // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ItemIds;                                           // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Requirements_TaskIds;                              // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Requirements_ItemIds;                              // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTaskDataRow) == 0x000008, "Wrong alignment on FRBTaskDataRow");
static_assert(sizeof(FRBTaskDataRow) == 0x0001C0, "Wrong size on FRBTaskDataRow");
static_assert(offsetof(FRBTaskDataRow, ID) == 0x000008, "Member 'FRBTaskDataRow::ID' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Category) == 0x000010, "Member 'FRBTaskDataRow::Category' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, GroupID) == 0x000014, "Member 'FRBTaskDataRow::GroupID' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, GroupName) == 0x000020, "Member 'FRBTaskDataRow::GroupName' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, SectionId) == 0x000038, "Member 'FRBTaskDataRow::SectionId' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, SectionName) == 0x000040, "Member 'FRBTaskDataRow::SectionName' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Order) == 0x000058, "Member 'FRBTaskDataRow::Order' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Title) == 0x000060, "Member 'FRBTaskDataRow::Title' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Icon) == 0x000078, "Member 'FRBTaskDataRow::Icon' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, RewardDataIds) == 0x0000A0, "Member 'FRBTaskDataRow::RewardDataIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Type) == 0x0000B0, "Member 'FRBTaskDataRow::Type' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Amount) == 0x0000B4, "Member 'FRBTaskDataRow::Amount' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, bPersistProgress) == 0x0000B8, "Member 'FRBTaskDataRow::bPersistProgress' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, bStopOnStageFailure) == 0x0000B9, "Member 'FRBTaskDataRow::bStopOnStageFailure' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Progress_PlayerEvents) == 0x0000C0, "Member 'FRBTaskDataRow::Progress_PlayerEvents' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Progress_PlayerStats) == 0x0000D0, "Member 'FRBTaskDataRow::Progress_PlayerStats' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Progress_ConditionId) == 0x0000E0, "Member 'FRBTaskDataRow::Progress_ConditionId' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Reset_ConditionId) == 0x0000E8, "Member 'FRBTaskDataRow::Reset_ConditionId' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Failure_ConditionId) == 0x0000F0, "Member 'FRBTaskDataRow::Failure_ConditionId' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Failure_PlayerEvents) == 0x0000F8, "Member 'FRBTaskDataRow::Failure_PlayerEvents' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Failure_PlayerStats) == 0x000108, "Member 'FRBTaskDataRow::Failure_PlayerStats' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, ProgramIds) == 0x000118, "Member 'FRBTaskDataRow::ProgramIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, ProgramDifficulties) == 0x000128, "Member 'FRBTaskDataRow::ProgramDifficulties' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, TrialIds) == 0x000138, "Member 'FRBTaskDataRow::TrialIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, TaskIds) == 0x000148, "Member 'FRBTaskDataRow::TaskIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, VariatorIds) == 0x000158, "Member 'FRBTaskDataRow::VariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, RequiredTaskCategories) == 0x000168, "Member 'FRBTaskDataRow::RequiredTaskCategories' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, ItemIds) == 0x000178, "Member 'FRBTaskDataRow::ItemIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, FeatureSwitch) == 0x000188, "Member 'FRBTaskDataRow::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Requirements_TaskIds) == 0x000198, "Member 'FRBTaskDataRow::Requirements_TaskIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, Requirements_ItemIds) == 0x0001A8, "Member 'FRBTaskDataRow::Requirements_ItemIds' has a wrong offset!");
static_assert(offsetof(FRBTaskDataRow, bHidden) == 0x0001B8, "Member 'FRBTaskDataRow::bHidden' has a wrong offset!");

// ScriptStruct OPP.StrikeDamageSettings
// 0x0004 (0x0004 - 0x0000)
struct FStrikeDamageSettings final
{
public:
	EDamageValue                                  DamageValue;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKnockbackValue                               KnockbackValue;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageVolumeType                             StrikeDamageType;                                  // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeaponHit;                                      // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrikeDamageSettings) == 0x000001, "Wrong alignment on FStrikeDamageSettings");
static_assert(sizeof(FStrikeDamageSettings) == 0x000004, "Wrong size on FStrikeDamageSettings");
static_assert(offsetof(FStrikeDamageSettings, DamageValue) == 0x000000, "Member 'FStrikeDamageSettings::DamageValue' has a wrong offset!");
static_assert(offsetof(FStrikeDamageSettings, KnockbackValue) == 0x000001, "Member 'FStrikeDamageSettings::KnockbackValue' has a wrong offset!");
static_assert(offsetof(FStrikeDamageSettings, StrikeDamageType) == 0x000002, "Member 'FStrikeDamageSettings::StrikeDamageType' has a wrong offset!");
static_assert(offsetof(FStrikeDamageSettings, bIsWeaponHit) == 0x000003, "Member 'FStrikeDamageSettings::bIsWeaponHit' has a wrong offset!");

// ScriptStruct OPP.PlayerStatsChaseDetails
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FPlayerStatsChaseDetails final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastChaseStopTime;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveNPCs;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNPCs;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x54];                                      // 0x0014(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTookDamage;                                       // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncapacitated;                                    // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedHidingSpot;                                   // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStatsChaseDetails) == 0x000008, "Wrong alignment on FPlayerStatsChaseDetails");
static_assert(sizeof(FPlayerStatsChaseDetails) == 0x000070, "Wrong size on FPlayerStatsChaseDetails");
static_assert(offsetof(FPlayerStatsChaseDetails, bActive) == 0x000000, "Member 'FPlayerStatsChaseDetails::bActive' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, StartTime) == 0x000004, "Member 'FPlayerStatsChaseDetails::StartTime' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, LastChaseStopTime) == 0x000008, "Member 'FPlayerStatsChaseDetails::LastChaseStopTime' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, ActiveNPCs) == 0x00000C, "Member 'FPlayerStatsChaseDetails::ActiveNPCs' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, TotalNPCs) == 0x000010, "Member 'FPlayerStatsChaseDetails::TotalNPCs' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, bTookDamage) == 0x000068, "Member 'FPlayerStatsChaseDetails::bTookDamage' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, bIncapacitated) == 0x000069, "Member 'FPlayerStatsChaseDetails::bIncapacitated' has a wrong offset!");
static_assert(offsetof(FPlayerStatsChaseDetails, bUsedHidingSpot) == 0x00006A, "Member 'FPlayerStatsChaseDetails::bUsedHidingSpot' has a wrong offset!");

// ScriptStruct OPP.StatsRuntimeData
// 0x1760 (0x1760 - 0x0000)
struct FStatsRuntimeData final
{
public:
	class ARBController*                          RBController;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         RBPlayerState;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProfileId                             ProfileId;                                         // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerStatsConfig*                   RBPlayerStatsConfig;                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlayerStat, float>                      CurrentMainObjectiveStats;                         // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	TMap<EPlayerStat, float>                      StageStats;                                        // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x1A0];                                     // 0x00C8(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NVStartTime;                                       // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HidespotStartTime;                                 // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastIncapacitatedTime;                             // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastKilledTime;                                    // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastElectricFloorTrapDamageTime;                   // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychosisStartTime;                                // 0x027C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerStatsChaseDetails               ChaseDetails;                                      // 0x0280(0x0070)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x1470];                                   // 0x02F0(0x1470)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatsRuntimeData) == 0x000008, "Wrong alignment on FStatsRuntimeData");
static_assert(sizeof(FStatsRuntimeData) == 0x001760, "Wrong size on FStatsRuntimeData");
static_assert(offsetof(FStatsRuntimeData, RBController) == 0x000000, "Member 'FStatsRuntimeData::RBController' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, RBPlayerState) == 0x000008, "Member 'FStatsRuntimeData::RBPlayerState' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, ProfileId) == 0x000010, "Member 'FStatsRuntimeData::ProfileId' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, RBPlayerStatsConfig) == 0x000020, "Member 'FStatsRuntimeData::RBPlayerStatsConfig' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, CurrentMainObjectiveStats) == 0x000028, "Member 'FStatsRuntimeData::CurrentMainObjectiveStats' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, StageStats) == 0x000078, "Member 'FStatsRuntimeData::StageStats' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, NVStartTime) == 0x000268, "Member 'FStatsRuntimeData::NVStartTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, HidespotStartTime) == 0x00026C, "Member 'FStatsRuntimeData::HidespotStartTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, LastIncapacitatedTime) == 0x000270, "Member 'FStatsRuntimeData::LastIncapacitatedTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, LastKilledTime) == 0x000274, "Member 'FStatsRuntimeData::LastKilledTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, LastElectricFloorTrapDamageTime) == 0x000278, "Member 'FStatsRuntimeData::LastElectricFloorTrapDamageTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, PsychosisStartTime) == 0x00027C, "Member 'FStatsRuntimeData::PsychosisStartTime' has a wrong offset!");
static_assert(offsetof(FStatsRuntimeData, ChaseDetails) == 0x000280, "Member 'FStatsRuntimeData::ChaseDetails' has a wrong offset!");

// ScriptStruct OPP.ScheduledNextSpecialMoveLocomotionModeData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FScheduledNextSpecialMoveLocomotionModeData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledNextSpecialMoveLocomotionModeData) == 0x000004, "Wrong alignment on FScheduledNextSpecialMoveLocomotionModeData");
static_assert(sizeof(FScheduledNextSpecialMoveLocomotionModeData) == 0x000008, "Wrong size on FScheduledNextSpecialMoveLocomotionModeData");

// ScriptStruct OPP.ScheduledCompleteSpecialMoveData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FScheduledCompleteSpecialMoveData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledCompleteSpecialMoveData) == 0x000004, "Wrong alignment on FScheduledCompleteSpecialMoveData");
static_assert(sizeof(FScheduledCompleteSpecialMoveData) == 0x000010, "Wrong size on FScheduledCompleteSpecialMoveData");

// ScriptStruct OPP.BotRetirementConfig
// 0x0018 (0x0018 - 0x0000)
struct FBotRetirementConfig final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBMonsterCloset*                       SpecificCloset;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotRetirementConfig) == 0x000008, "Wrong alignment on FBotRetirementConfig");
static_assert(sizeof(FBotRetirementConfig) == 0x000018, "Wrong size on FBotRetirementConfig");
static_assert(offsetof(FBotRetirementConfig, SpecificCloset) == 0x000010, "Member 'FBotRetirementConfig::SpecificCloset' has a wrong offset!");

// ScriptStruct OPP.SoundEmitterTransaction
// 0x0020 (0x0020 - 0x0000)
struct FSoundEmitterTransaction final
{
public:
	class URBSoundComponent*                      SoundEmitter;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundEmitterTransaction) == 0x000008, "Wrong alignment on FSoundEmitterTransaction");
static_assert(sizeof(FSoundEmitterTransaction) == 0x000020, "Wrong size on FSoundEmitterTransaction");
static_assert(offsetof(FSoundEmitterTransaction, SoundEmitter) == 0x000000, "Member 'FSoundEmitterTransaction::SoundEmitter' has a wrong offset!");

// ScriptStruct OPP.ScheduledLocomotionData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FScheduledLocomotionData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledLocomotionData) == 0x000004, "Wrong alignment on FScheduledLocomotionData");
static_assert(sizeof(FScheduledLocomotionData) == 0x00000C, "Wrong size on FScheduledLocomotionData");

// ScriptStruct OPP.ScarejumpPlacementTransformData
// 0x0040 (0x0040 - 0x0000)
struct FScarejumpPlacementTransformData final
{
public:
	TSubclassOf<class AActor>                     ScareJumpClass;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScarejumpPlacementTransformData) == 0x000010, "Wrong alignment on FScarejumpPlacementTransformData");
static_assert(sizeof(FScarejumpPlacementTransformData) == 0x000040, "Wrong size on FScarejumpPlacementTransformData");
static_assert(offsetof(FScarejumpPlacementTransformData, ScareJumpClass) == 0x000000, "Member 'FScarejumpPlacementTransformData::ScareJumpClass' has a wrong offset!");
static_assert(offsetof(FScarejumpPlacementTransformData, Transform) == 0x000010, "Member 'FScarejumpPlacementTransformData::Transform' has a wrong offset!");

// ScriptStruct OPP.ScarejumpPlacementData
// 0x0020 (0x0020 - 0x0000)
struct FScarejumpPlacementData final
{
public:
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScarejumpPlacementTransformData> ScareJumps;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScarejumpPlacementData) == 0x000008, "Wrong alignment on FScarejumpPlacementData");
static_assert(sizeof(FScarejumpPlacementData) == 0x000020, "Wrong size on FScarejumpPlacementData");
static_assert(offsetof(FScarejumpPlacementData, TargetActorClass) == 0x000000, "Member 'FScarejumpPlacementData::TargetActorClass' has a wrong offset!");
static_assert(offsetof(FScarejumpPlacementData, ScareJumps) == 0x000008, "Member 'FScarejumpPlacementData::ScareJumps' has a wrong offset!");
static_assert(offsetof(FScarejumpPlacementData, StaticMesh) == 0x000018, "Member 'FScarejumpPlacementData::StaticMesh' has a wrong offset!");

// ScriptStruct OPP.PlayerInZoneInfo
// 0x0010 (0x0010 - 0x0000)
struct FPlayerInZoneInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBRoom*                                Room;                                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInZoneInfo) == 0x000008, "Wrong alignment on FPlayerInZoneInfo");
static_assert(sizeof(FPlayerInZoneInfo) == 0x000010, "Wrong size on FPlayerInZoneInfo");
static_assert(offsetof(FPlayerInZoneInfo, Player) == 0x000000, "Member 'FPlayerInZoneInfo::Player' has a wrong offset!");
static_assert(offsetof(FPlayerInZoneInfo, Room) == 0x000008, "Member 'FPlayerInZoneInfo::Room' has a wrong offset!");

// ScriptStruct OPP.TurningOnSpotData
// 0x0060 (0x0060 - 0x0000)
struct FTurningOnSpotData final
{
public:
	TMap<EFullTurnDirection, class UAnimSequence*> TurnOnSpotSequences;                               // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace1D*                 LookAimSpace;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOnSpotSafeAngle;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOnSpotForceTurnAngle;                          // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTurningOnSpotData) == 0x000008, "Wrong alignment on FTurningOnSpotData");
static_assert(sizeof(FTurningOnSpotData) == 0x000060, "Wrong size on FTurningOnSpotData");
static_assert(offsetof(FTurningOnSpotData, TurnOnSpotSequences) == 0x000000, "Member 'FTurningOnSpotData::TurnOnSpotSequences' has a wrong offset!");
static_assert(offsetof(FTurningOnSpotData, LookAimSpace) == 0x000050, "Member 'FTurningOnSpotData::LookAimSpace' has a wrong offset!");
static_assert(offsetof(FTurningOnSpotData, TurnOnSpotSafeAngle) == 0x000058, "Member 'FTurningOnSpotData::TurnOnSpotSafeAngle' has a wrong offset!");
static_assert(offsetof(FTurningOnSpotData, TurnOnSpotForceTurnAngle) == 0x00005C, "Member 'FTurningOnSpotData::TurnOnSpotForceTurnAngle' has a wrong offset!");

// ScriptStruct OPP.FarLedgeCandidateData
// 0x0030 (0x0030 - 0x0000)
struct FFarLedgeCandidateData final
{
public:
	class ARBLedgeMarker*                         LedgeMarker;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFarLedgeCandidateData) == 0x000008, "Wrong alignment on FFarLedgeCandidateData");
static_assert(sizeof(FFarLedgeCandidateData) == 0x000030, "Wrong size on FFarLedgeCandidateData");
static_assert(offsetof(FFarLedgeCandidateData, LedgeMarker) == 0x000000, "Member 'FFarLedgeCandidateData::LedgeMarker' has a wrong offset!");

// ScriptStruct OPP.FoleysSoundRefs
// 0x00B0 (0x00B0 - 0x0000)
struct FFoleysSoundRefs final
{
public:
	class UAkAudioEvent*                          FootStepWalk3P;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FootStepWalk3P : 1;                      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FootStepRun3P;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FootStepRun3P : 1;                       // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FootStepWalk1P;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FootStepWalk1P : 1;                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FootStepRun1P;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FootStepRun1P : 1;                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FullBody_Start;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullBody_Start : 1;                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FullBody_Stop;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullBody_Stop : 1;                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          LegsShort;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LegsShort : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          LegsLong;                                          // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LegsLong : 1;                            // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TorsoShort;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TorsoShort : 1;                          // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TorsoLong;                                         // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TorsoLong : 1;                           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Damage;                                            // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Damage : 1;                              // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoleysSoundRefs) == 0x000008, "Wrong alignment on FFoleysSoundRefs");
static_assert(sizeof(FFoleysSoundRefs) == 0x0000B0, "Wrong size on FFoleysSoundRefs");
static_assert(offsetof(FFoleysSoundRefs, FootStepWalk3P) == 0x000000, "Member 'FFoleysSoundRefs::FootStepWalk3P' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, FootStepRun3P) == 0x000010, "Member 'FFoleysSoundRefs::FootStepRun3P' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, FootStepWalk1P) == 0x000020, "Member 'FFoleysSoundRefs::FootStepWalk1P' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, FootStepRun1P) == 0x000030, "Member 'FFoleysSoundRefs::FootStepRun1P' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, FullBody_Start) == 0x000040, "Member 'FFoleysSoundRefs::FullBody_Start' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, FullBody_Stop) == 0x000050, "Member 'FFoleysSoundRefs::FullBody_Stop' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, LegsShort) == 0x000060, "Member 'FFoleysSoundRefs::LegsShort' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, LegsLong) == 0x000070, "Member 'FFoleysSoundRefs::LegsLong' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, TorsoShort) == 0x000080, "Member 'FFoleysSoundRefs::TorsoShort' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, TorsoLong) == 0x000090, "Member 'FFoleysSoundRefs::TorsoLong' has a wrong offset!");
static_assert(offsetof(FFoleysSoundRefs, Damage) == 0x0000A0, "Member 'FFoleysSoundRefs::Damage' has a wrong offset!");

// ScriptStruct OPP.PlayerStateSoundRefs
// 0x0190 (0x0190 - 0x0000)
struct FPlayerStateSoundRefs final
{
public:
	class UAkAudioEvent*                          PlayerHealthLowStart;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerHealthLowStart : 1;                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerHealthLowStop;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerHealthLowStop : 1;                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerLSDEffectStart;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerLSDEffectStart : 1;                // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerLSDEffectStop;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerLSDEffectStop : 1;                 // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerReducedHearingStart;                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerReducedHearingStart : 1;           // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerReducedHearingStop;                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerReducedHearingStop : 1;            // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PsychosisBoost;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PsychosisBoost : 1;                      // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StaminaBoostStart;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StaminaBoostStart : 1;                   // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StaminaBoostStop;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StaminaBoostStop : 1;                    // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StunnedByScreamerStart;                            // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StunnedByScreamerStart : 1;              // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StunnedByScreamerStopFade;                         // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StunnedByScreamerStopFade : 1;           // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StunnedByScreamerStopKill;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StunnedByScreamerStopKill : 1;           // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerBreathStart;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerBreathStart : 1;                   // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerBreathStopNormal;                            // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerBreathStopNormal : 1;              // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerBreathStopFast;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerBreathStopFast : 1;                // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartPlayerHurtVO;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StartPlayerHurtVO : 1;                   // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StopPlayerHurtVO;                                  // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StopPlayerHurtVO : 1;                    // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerCough;                                       // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerCough : 1;                         // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderPsychosisAuraEffect;                          // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderPsychosisAuraEffect : 1;            // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderPsychosisAuraEffectStart;                     // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderPsychosisAuraEffectStart : 1;       // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderPsychosisAuraEffectStop;                      // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderPsychosisAuraEffectStop : 1;        // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderStaminaDrainAuraEffect;                       // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderStaminaDrainAuraEffect : 1;         // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderStaminaDrainAuraEffectStart;                  // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderStaminaDrainAuraEffectStart : 1;    // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          UnderStaminaDrainAuraEffectStop;                   // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnderStaminaDrainAuraEffectStop : 1;     // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          DefaultDeathVO;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultDeathVO : 1;                      // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStateSoundRefs) == 0x000008, "Wrong alignment on FPlayerStateSoundRefs");
static_assert(sizeof(FPlayerStateSoundRefs) == 0x000190, "Wrong size on FPlayerStateSoundRefs");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerHealthLowStart) == 0x000000, "Member 'FPlayerStateSoundRefs::PlayerHealthLowStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerHealthLowStop) == 0x000010, "Member 'FPlayerStateSoundRefs::PlayerHealthLowStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerLSDEffectStart) == 0x000020, "Member 'FPlayerStateSoundRefs::PlayerLSDEffectStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerLSDEffectStop) == 0x000030, "Member 'FPlayerStateSoundRefs::PlayerLSDEffectStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerReducedHearingStart) == 0x000040, "Member 'FPlayerStateSoundRefs::PlayerReducedHearingStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerReducedHearingStop) == 0x000050, "Member 'FPlayerStateSoundRefs::PlayerReducedHearingStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PsychosisBoost) == 0x000060, "Member 'FPlayerStateSoundRefs::PsychosisBoost' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StaminaBoostStart) == 0x000070, "Member 'FPlayerStateSoundRefs::StaminaBoostStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StaminaBoostStop) == 0x000080, "Member 'FPlayerStateSoundRefs::StaminaBoostStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StunnedByScreamerStart) == 0x000090, "Member 'FPlayerStateSoundRefs::StunnedByScreamerStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StunnedByScreamerStopFade) == 0x0000A0, "Member 'FPlayerStateSoundRefs::StunnedByScreamerStopFade' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StunnedByScreamerStopKill) == 0x0000B0, "Member 'FPlayerStateSoundRefs::StunnedByScreamerStopKill' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerBreathStart) == 0x0000C0, "Member 'FPlayerStateSoundRefs::PlayerBreathStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerBreathStopNormal) == 0x0000D0, "Member 'FPlayerStateSoundRefs::PlayerBreathStopNormal' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerBreathStopFast) == 0x0000E0, "Member 'FPlayerStateSoundRefs::PlayerBreathStopFast' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StartPlayerHurtVO) == 0x0000F0, "Member 'FPlayerStateSoundRefs::StartPlayerHurtVO' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, StopPlayerHurtVO) == 0x000100, "Member 'FPlayerStateSoundRefs::StopPlayerHurtVO' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, PlayerCough) == 0x000110, "Member 'FPlayerStateSoundRefs::PlayerCough' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderPsychosisAuraEffect) == 0x000120, "Member 'FPlayerStateSoundRefs::UnderPsychosisAuraEffect' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderPsychosisAuraEffectStart) == 0x000130, "Member 'FPlayerStateSoundRefs::UnderPsychosisAuraEffectStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderPsychosisAuraEffectStop) == 0x000140, "Member 'FPlayerStateSoundRefs::UnderPsychosisAuraEffectStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderStaminaDrainAuraEffect) == 0x000150, "Member 'FPlayerStateSoundRefs::UnderStaminaDrainAuraEffect' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderStaminaDrainAuraEffectStart) == 0x000160, "Member 'FPlayerStateSoundRefs::UnderStaminaDrainAuraEffectStart' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, UnderStaminaDrainAuraEffectStop) == 0x000170, "Member 'FPlayerStateSoundRefs::UnderStaminaDrainAuraEffectStop' has a wrong offset!");
static_assert(offsetof(FPlayerStateSoundRefs, DefaultDeathVO) == 0x000180, "Member 'FPlayerStateSoundRefs::DefaultDeathVO' has a wrong offset!");

// ScriptStruct OPP.PlayerTalkSoundRefs
// 0x0140 (0x0140 - 0x0000)
struct FPlayerTalkSoundRefs final
{
public:
	class UAkAudioEvent*                          Help;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Help : 1;                                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Acknowledge;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Acknowledge : 1;                         // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Regroup;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Regroup : 1;                             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          CoopMoveStatus;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoopMoveStatus : 1;                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ItemNearby;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ItemNearby : 1;                          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Currency;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Currency : 1;                            // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Wait;                                              // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Wait : 1;                                // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Crawling;                                          // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Crawling : 1;                            // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Danger;                                            // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Danger : 1;                              // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActiveSkillCooldown;                               // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActiveSkillCooldown : 1;                 // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActiveSkillEmpty;                                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActiveSkillEmpty : 1;                    // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActiveSkillReady;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActiveSkillReady : 1;                    // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ActiveSkillNoneEquipped;                           // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActiveSkillNoneEquipped : 1;             // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ThankYou;                                          // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ThankYou : 1;                            // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          OnMyWay;                                           // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OnMyWay : 1;                             // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Hello;                                             // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Hello : 1;                               // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Trade;                                             // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Trade : 1;                               // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          DefaultPingVO;                                     // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultPingVO : 1;                       // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PuzzleRoomStressBreathStart;                       // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PuzzleRoomStressBreathStart : 1;         // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PuzzleRoomStressBreathStop;                        // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PuzzleRoomStressBreathStop : 1;          // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerTalkSoundRefs) == 0x000008, "Wrong alignment on FPlayerTalkSoundRefs");
static_assert(sizeof(FPlayerTalkSoundRefs) == 0x000140, "Wrong size on FPlayerTalkSoundRefs");
static_assert(offsetof(FPlayerTalkSoundRefs, Help) == 0x000000, "Member 'FPlayerTalkSoundRefs::Help' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Acknowledge) == 0x000010, "Member 'FPlayerTalkSoundRefs::Acknowledge' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Regroup) == 0x000020, "Member 'FPlayerTalkSoundRefs::Regroup' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, CoopMoveStatus) == 0x000030, "Member 'FPlayerTalkSoundRefs::CoopMoveStatus' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ItemNearby) == 0x000040, "Member 'FPlayerTalkSoundRefs::ItemNearby' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Currency) == 0x000050, "Member 'FPlayerTalkSoundRefs::Currency' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Wait) == 0x000060, "Member 'FPlayerTalkSoundRefs::Wait' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Crawling) == 0x000070, "Member 'FPlayerTalkSoundRefs::Crawling' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Danger) == 0x000080, "Member 'FPlayerTalkSoundRefs::Danger' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ActiveSkillCooldown) == 0x000090, "Member 'FPlayerTalkSoundRefs::ActiveSkillCooldown' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ActiveSkillEmpty) == 0x0000A0, "Member 'FPlayerTalkSoundRefs::ActiveSkillEmpty' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ActiveSkillReady) == 0x0000B0, "Member 'FPlayerTalkSoundRefs::ActiveSkillReady' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ActiveSkillNoneEquipped) == 0x0000C0, "Member 'FPlayerTalkSoundRefs::ActiveSkillNoneEquipped' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, ThankYou) == 0x0000D0, "Member 'FPlayerTalkSoundRefs::ThankYou' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, OnMyWay) == 0x0000E0, "Member 'FPlayerTalkSoundRefs::OnMyWay' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Hello) == 0x0000F0, "Member 'FPlayerTalkSoundRefs::Hello' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, Trade) == 0x000100, "Member 'FPlayerTalkSoundRefs::Trade' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, DefaultPingVO) == 0x000110, "Member 'FPlayerTalkSoundRefs::DefaultPingVO' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, PuzzleRoomStressBreathStart) == 0x000120, "Member 'FPlayerTalkSoundRefs::PuzzleRoomStressBreathStart' has a wrong offset!");
static_assert(offsetof(FPlayerTalkSoundRefs, PuzzleRoomStressBreathStop) == 0x000130, "Member 'FPlayerTalkSoundRefs::PuzzleRoomStressBreathStop' has a wrong offset!");

// ScriptStruct OPP.NPCSoundRefs
// 0x00B0 (0x00B0 - 0x0000)
struct FNPCSoundRefs final
{
public:
	class UAkAudioEvent*                          PusherReadyToSpawnFoley;                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PusherReadyToSpawnFoley : 1;             // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PusherReadyToSpawnVO;                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PusherReadyToSpawnVO : 1;                // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PouncerGnPStart;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPStart : 1;                     // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PouncerGnPStop;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPStop : 1;                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          SleeperDisturbedStart;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SleeperDisturbedStart : 1;               // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          SleeperDisturbedStop;                              // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SleeperDisturbedStop : 1;                // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          VOInterruptOno;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VOInterruptOno : 1;                      // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ShotgunImpact;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShotgunImpact : 1;                       // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ShotgunDamageOn;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShotgunDamageOn : 1;                     // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ShotgunProximity;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShotgunProximity : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ShotgunDamageOff;                                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShotgunDamageOff : 1;                    // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCSoundRefs) == 0x000008, "Wrong alignment on FNPCSoundRefs");
static_assert(sizeof(FNPCSoundRefs) == 0x0000B0, "Wrong size on FNPCSoundRefs");
static_assert(offsetof(FNPCSoundRefs, PusherReadyToSpawnFoley) == 0x000000, "Member 'FNPCSoundRefs::PusherReadyToSpawnFoley' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, PusherReadyToSpawnVO) == 0x000010, "Member 'FNPCSoundRefs::PusherReadyToSpawnVO' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, PouncerGnPStart) == 0x000020, "Member 'FNPCSoundRefs::PouncerGnPStart' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, PouncerGnPStop) == 0x000030, "Member 'FNPCSoundRefs::PouncerGnPStop' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, SleeperDisturbedStart) == 0x000040, "Member 'FNPCSoundRefs::SleeperDisturbedStart' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, SleeperDisturbedStop) == 0x000050, "Member 'FNPCSoundRefs::SleeperDisturbedStop' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, VOInterruptOno) == 0x000060, "Member 'FNPCSoundRefs::VOInterruptOno' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, ShotgunImpact) == 0x000070, "Member 'FNPCSoundRefs::ShotgunImpact' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, ShotgunDamageOn) == 0x000080, "Member 'FNPCSoundRefs::ShotgunDamageOn' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, ShotgunProximity) == 0x000090, "Member 'FNPCSoundRefs::ShotgunProximity' has a wrong offset!");
static_assert(offsetof(FNPCSoundRefs, ShotgunDamageOff) == 0x0000A0, "Member 'FNPCSoundRefs::ShotgunDamageOff' has a wrong offset!");

// ScriptStruct OPP.MusicSoundRefs
// 0x0020 (0x0020 - 0x0000)
struct FMusicSoundRefs final
{
public:
	class UAkAudioEvent*                          TrapRoomStart;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TrapRoomStart : 1;                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TrapRoomStop;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TrapRoomStop : 1;                        // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMusicSoundRefs) == 0x000008, "Wrong alignment on FMusicSoundRefs");
static_assert(sizeof(FMusicSoundRefs) == 0x000020, "Wrong size on FMusicSoundRefs");
static_assert(offsetof(FMusicSoundRefs, TrapRoomStart) == 0x000000, "Member 'FMusicSoundRefs::TrapRoomStart' has a wrong offset!");
static_assert(offsetof(FMusicSoundRefs, TrapRoomStop) == 0x000010, "Member 'FMusicSoundRefs::TrapRoomStop' has a wrong offset!");

// ScriptStruct OPP.RBSoundReferencesData
// 0x0530 (0x0530 - 0x0000)
struct FRBSoundReferencesData final
{
public:
	struct FFoleysSoundRefs                       Foleys;                                            // 0x0000(0x00B0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocalSoundRefs                        Local;                                             // 0x00B0(0x0090)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerStateSoundRefs                  PlayerState;                                       // 0x0140(0x0190)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSystemsSoundRefs                      Systems;                                           // 0x02D0(0x0050)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerTalkSoundRefs                   Talk;                                              // 0x0320(0x0140)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCSoundRefs                          NPC;                                               // 0x0460(0x00B0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMusicSoundRefs                        Music;                                             // 0x0510(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBSoundReferencesData) == 0x000008, "Wrong alignment on FRBSoundReferencesData");
static_assert(sizeof(FRBSoundReferencesData) == 0x000530, "Wrong size on FRBSoundReferencesData");
static_assert(offsetof(FRBSoundReferencesData, Foleys) == 0x000000, "Member 'FRBSoundReferencesData::Foleys' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, Local) == 0x0000B0, "Member 'FRBSoundReferencesData::Local' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, PlayerState) == 0x000140, "Member 'FRBSoundReferencesData::PlayerState' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, Systems) == 0x0002D0, "Member 'FRBSoundReferencesData::Systems' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, Talk) == 0x000320, "Member 'FRBSoundReferencesData::Talk' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, NPC) == 0x000460, "Member 'FRBSoundReferencesData::NPC' has a wrong offset!");
static_assert(offsetof(FRBSoundReferencesData, Music) == 0x000510, "Member 'FRBSoundReferencesData::Music' has a wrong offset!");

// ScriptStruct OPP.AIMonsterClosetData
// 0x0018 (0x0018 - 0x0000)
struct FAIMonsterClosetData final
{
public:
	class ARBMonsterCloset*                       ClosetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIMonsterClosetData) == 0x000008, "Wrong alignment on FAIMonsterClosetData");
static_assert(sizeof(FAIMonsterClosetData) == 0x000018, "Wrong size on FAIMonsterClosetData");
static_assert(offsetof(FAIMonsterClosetData, ClosetActor) == 0x000000, "Member 'FAIMonsterClosetData::ClosetActor' has a wrong offset!");

// ScriptStruct OPP.SpawnedAIQuestItemIntemInfo
// 0x0040 (0x0040 - 0x0000)
struct FSpawnedAIQuestItemIntemInfo final
{
public:
	class ARBPickup*                              SpawnedItem;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnedAIQuestItemIntemInfo) == 0x000010, "Wrong alignment on FSpawnedAIQuestItemIntemInfo");
static_assert(sizeof(FSpawnedAIQuestItemIntemInfo) == 0x000040, "Wrong size on FSpawnedAIQuestItemIntemInfo");
static_assert(offsetof(FSpawnedAIQuestItemIntemInfo, SpawnedItem) == 0x000000, "Member 'FSpawnedAIQuestItemIntemInfo::SpawnedItem' has a wrong offset!");
static_assert(offsetof(FSpawnedAIQuestItemIntemInfo, SpawnTransform) == 0x000010, "Member 'FSpawnedAIQuestItemIntemInfo::SpawnTransform' has a wrong offset!");

// ScriptStruct OPP.PsychosisFXData
// 0x0014 (0x0014 - 0x0000)
struct FPsychosisFXData final
{
public:
	float                                         Veins;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Colors;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deform;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shake;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkTexture;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychosisFXData) == 0x000004, "Wrong alignment on FPsychosisFXData");
static_assert(sizeof(FPsychosisFXData) == 0x000014, "Wrong size on FPsychosisFXData");
static_assert(offsetof(FPsychosisFXData, Veins) == 0x000000, "Member 'FPsychosisFXData::Veins' has a wrong offset!");
static_assert(offsetof(FPsychosisFXData, Colors) == 0x000004, "Member 'FPsychosisFXData::Colors' has a wrong offset!");
static_assert(offsetof(FPsychosisFXData, Deform) == 0x000008, "Member 'FPsychosisFXData::Deform' has a wrong offset!");
static_assert(offsetof(FPsychosisFXData, Shake) == 0x00000C, "Member 'FPsychosisFXData::Shake' has a wrong offset!");
static_assert(offsetof(FPsychosisFXData, DarkTexture) == 0x000010, "Member 'FPsychosisFXData::DarkTexture' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningManagerRewardItemInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FItemSpawningManagerRewardItemInfo final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemSpawningManagerRewardItemInfo) == 0x000004, "Wrong alignment on FItemSpawningManagerRewardItemInfo");
static_assert(sizeof(FItemSpawningManagerRewardItemInfo) == 0x000010, "Wrong size on FItemSpawningManagerRewardItemInfo");
static_assert(offsetof(FItemSpawningManagerRewardItemInfo, ItemType) == 0x000000, "Member 'FItemSpawningManagerRewardItemInfo::ItemType' has a wrong offset!");

// ScriptStruct OPP.RBGeneratedRewardData
// 0x0028 (0x0028 - 0x0000)
struct FRBGeneratedRewardData final
{
public:
	int32                                         Xp;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCurrencyEntry>                 Currencies;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           Items;                                             // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBGeneratedRewardData) == 0x000008, "Wrong alignment on FRBGeneratedRewardData");
static_assert(sizeof(FRBGeneratedRewardData) == 0x000028, "Wrong size on FRBGeneratedRewardData");
static_assert(offsetof(FRBGeneratedRewardData, Xp) == 0x000000, "Member 'FRBGeneratedRewardData::Xp' has a wrong offset!");
static_assert(offsetof(FRBGeneratedRewardData, Currencies) == 0x000008, "Member 'FRBGeneratedRewardData::Currencies' has a wrong offset!");
static_assert(offsetof(FRBGeneratedRewardData, Items) == 0x000018, "Member 'FRBGeneratedRewardData::Items' has a wrong offset!");

// ScriptStruct OPP.NPCWaypointAnimData
// 0x0008 (0x0008 - 0x0000)
struct FNPCWaypointAnimData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCWaypointAnimData) == 0x000008, "Wrong alignment on FNPCWaypointAnimData");
static_assert(sizeof(FNPCWaypointAnimData) == 0x000008, "Wrong size on FNPCWaypointAnimData");
static_assert(offsetof(FNPCWaypointAnimData, AnimSequence) == 0x000000, "Member 'FNPCWaypointAnimData::AnimSequence' has a wrong offset!");

// ScriptStruct OPP.HidespotCameraParams
// 0x0010 (0x0010 - 0x0000)
struct FHidespotCameraParams final
{
public:
	struct FVector2D                              CameraYawLimit;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraPitchLimit;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHidespotCameraParams) == 0x000004, "Wrong alignment on FHidespotCameraParams");
static_assert(sizeof(FHidespotCameraParams) == 0x000010, "Wrong size on FHidespotCameraParams");
static_assert(offsetof(FHidespotCameraParams, CameraYawLimit) == 0x000000, "Member 'FHidespotCameraParams::CameraYawLimit' has a wrong offset!");
static_assert(offsetof(FHidespotCameraParams, CameraPitchLimit) == 0x000008, "Member 'FHidespotCameraParams::CameraPitchLimit' has a wrong offset!");

// ScriptStruct OPP.CustomDamageInfoData
// 0x00D8 (0x00D8 - 0x0000)
struct FCustomDamageInfoData final
{
public:
	EDamageType                                   Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     DmgAmount;                                         // 0x0008(0x00C8)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKnockdown;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKill;                                          // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomDamageInfoData) == 0x000008, "Wrong alignment on FCustomDamageInfoData");
static_assert(sizeof(FCustomDamageInfoData) == 0x0000D8, "Wrong size on FCustomDamageInfoData");
static_assert(offsetof(FCustomDamageInfoData, Type) == 0x000000, "Member 'FCustomDamageInfoData::Type' has a wrong offset!");
static_assert(offsetof(FCustomDamageInfoData, DmgAmount) == 0x000008, "Member 'FCustomDamageInfoData::DmgAmount' has a wrong offset!");
static_assert(offsetof(FCustomDamageInfoData, bCanKnockdown) == 0x0000D0, "Member 'FCustomDamageInfoData::bCanKnockdown' has a wrong offset!");
static_assert(offsetof(FCustomDamageInfoData, bCanKill) == 0x0000D1, "Member 'FCustomDamageInfoData::bCanKill' has a wrong offset!");

// ScriptStruct OPP.ClimbOntoAnimRefs
// 0x00E0 (0x00E0 - 0x0000)
struct FClimbOntoAnimRefs final
{
public:
	struct FRBAnimRef                             ClimbOnto_50to75;                                  // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_50to75 : 1;                    // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOnto_75to150;                                 // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_75to150 : 1;                   // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOnto_150to200;                                // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_150to200 : 1;                  // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbOnto_200to300;                                // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_200to300 : 1;                  // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClimbOntoAnimRefs) == 0x000008, "Wrong alignment on FClimbOntoAnimRefs");
static_assert(sizeof(FClimbOntoAnimRefs) == 0x0000E0, "Wrong size on FClimbOntoAnimRefs");
static_assert(offsetof(FClimbOntoAnimRefs, ClimbOnto_50to75) == 0x000000, "Member 'FClimbOntoAnimRefs::ClimbOnto_50to75' has a wrong offset!");
static_assert(offsetof(FClimbOntoAnimRefs, ClimbOnto_75to150) == 0x000038, "Member 'FClimbOntoAnimRefs::ClimbOnto_75to150' has a wrong offset!");
static_assert(offsetof(FClimbOntoAnimRefs, ClimbOnto_150to200) == 0x000070, "Member 'FClimbOntoAnimRefs::ClimbOnto_150to200' has a wrong offset!");
static_assert(offsetof(FClimbOntoAnimRefs, ClimbOnto_200to300) == 0x0000A8, "Member 'FClimbOntoAnimRefs::ClimbOnto_200to300' has a wrong offset!");

// ScriptStruct OPP.ClimbOntoBGAnimRefs
// 0x0020 (0x0020 - 0x0000)
struct FClimbOntoBGAnimRefs final
{
public:
	class UBlendSpaceBase*                        ClimbOnto_50to100;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_50to100 : 1;                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        ClimbOnto_100to150;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbOnto_100to150 : 1;                  // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClimbOntoBGAnimRefs) == 0x000008, "Wrong alignment on FClimbOntoBGAnimRefs");
static_assert(sizeof(FClimbOntoBGAnimRefs) == 0x000020, "Wrong size on FClimbOntoBGAnimRefs");
static_assert(offsetof(FClimbOntoBGAnimRefs, ClimbOnto_50to100) == 0x000000, "Member 'FClimbOntoBGAnimRefs::ClimbOnto_50to100' has a wrong offset!");
static_assert(offsetof(FClimbOntoBGAnimRefs, ClimbOnto_100to150) == 0x000010, "Member 'FClimbOntoBGAnimRefs::ClimbOnto_100to150' has a wrong offset!");

// ScriptStruct OPP.ClimbDownAnimRefs
// 0x00A8 (0x00A8 - 0x0000)
struct FClimbDownAnimRefs final
{
public:
	struct FRBAnimRef                             ClimbDown_50to100;                                 // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbDown_50to100 : 1;                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbDown_100to150;                                // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbDown_100to150 : 1;                  // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ClimbDown_ToFalling;                               // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClimbDown_ToFalling : 1;                 // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClimbDownAnimRefs) == 0x000008, "Wrong alignment on FClimbDownAnimRefs");
static_assert(sizeof(FClimbDownAnimRefs) == 0x0000A8, "Wrong size on FClimbDownAnimRefs");
static_assert(offsetof(FClimbDownAnimRefs, ClimbDown_50to100) == 0x000000, "Member 'FClimbDownAnimRefs::ClimbDown_50to100' has a wrong offset!");
static_assert(offsetof(FClimbDownAnimRefs, ClimbDown_100to150) == 0x000038, "Member 'FClimbDownAnimRefs::ClimbDown_100to150' has a wrong offset!");
static_assert(offsetof(FClimbDownAnimRefs, ClimbDown_ToFalling) == 0x000070, "Member 'FClimbDownAnimRefs::ClimbDown_ToFalling' has a wrong offset!");

// ScriptStruct OPP.JumpOverBGAnimRefs
// 0x0010 (0x0010 - 0x0000)
struct FJumpOverBGAnimRefs final
{
public:
	class UBlendSpaceBase*                        JumpOver_25to100Deep;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpOver_25to100Deep : 1;                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpOverBGAnimRefs) == 0x000008, "Wrong alignment on FJumpOverBGAnimRefs");
static_assert(sizeof(FJumpOverBGAnimRefs) == 0x000010, "Wrong size on FJumpOverBGAnimRefs");
static_assert(offsetof(FJumpOverBGAnimRefs, JumpOver_25to100Deep) == 0x000000, "Member 'FJumpOverBGAnimRefs::JumpOver_25to100Deep' has a wrong offset!");

// ScriptStruct OPP.LandOntoLedgeAnimRefs
// 0x0030 (0x0030 - 0x0000)
struct FLandOntoLedgeAnimRefs final
{
public:
	class UAnimSequence*                          LandOntoLedge25;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LandOntoLedge25 : 1;                     // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LandOntoLedge50;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LandOntoLedge50 : 1;                     // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LandOntoLedge100;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LandOntoLedge100 : 1;                    // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLandOntoLedgeAnimRefs) == 0x000008, "Wrong alignment on FLandOntoLedgeAnimRefs");
static_assert(sizeof(FLandOntoLedgeAnimRefs) == 0x000030, "Wrong size on FLandOntoLedgeAnimRefs");
static_assert(offsetof(FLandOntoLedgeAnimRefs, LandOntoLedge25) == 0x000000, "Member 'FLandOntoLedgeAnimRefs::LandOntoLedge25' has a wrong offset!");
static_assert(offsetof(FLandOntoLedgeAnimRefs, LandOntoLedge50) == 0x000010, "Member 'FLandOntoLedgeAnimRefs::LandOntoLedge50' has a wrong offset!");
static_assert(offsetof(FLandOntoLedgeAnimRefs, LandOntoLedge100) == 0x000020, "Member 'FLandOntoLedgeAnimRefs::LandOntoLedge100' has a wrong offset!");

// ScriptStruct OPP.LocomotionAnimRefs
// 0x09C0 (0x09C0 - 0x0000)
struct FLocomotionAnimRefs final
{
public:
	class UAnimSequence*                          DeadPose;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DeadPose : 1;                            // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbOntoAnimRefs                     ClimbOntoWalk;                                     // 0x0010(0x00E0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbOntoAnimRefs                     ClimbOntoRun;                                      // 0x00F0(0x00E0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbOntoBGAnimRefs                   ClimbOntoBigGrunt;                                 // 0x01D0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbDownAnimRefs                     ClimbDownStanding;                                 // 0x01F0(0x00A8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbDownAnimRefs                     ClimbDownCrouching;                                // 0x0298(0x00A8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJumpOverAnimRefs                      JumpOver;                                          // 0x0340(0x0590)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJumpOverBGAnimRefs                    JumpOverBigGrunt;                                  // 0x08D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        DodgeBS;                                           // 0x08E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DodgeBS : 1;                             // 0x08E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8E9[0x7];                                      // 0x08E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        PushFromLedgeAnimatedBlendSpace;                   // 0x08F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PushFromLedgeAnimatedBlendSpace : 1;     // 0x08F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8F9[0x7];                                      // 0x08F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PushFromLedgeToFallAnimated;                       // 0x0900(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PushFromLedgeToFallAnimated : 1;         // 0x0908(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLandOntoLedgeAnimRefs                 LandOntoLedgeWall;                                 // 0x0910(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LandOntoLedgeWall : 1;                   // 0x0940(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_941[0x7];                                      // 0x0941(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLandOntoLedgeAnimRefs                 LandOntoLedgeNoWall;                               // 0x0948(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LandOntoLedgeNoWall : 1;                 // 0x0978(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_979[0x7];                                      // 0x0979(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NormalLand;                                        // 0x0980(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NormalLand : 1;                          // 0x0988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_989[0x7];                                      // 0x0989(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          MediumLand;                                        // 0x0990(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MediumLand : 1;                          // 0x0998(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_999[0x7];                                      // 0x0999(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ExhaustedLand;                                     // 0x09A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExhaustedLand : 1;                       // 0x09A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9A9[0x7];                                      // 0x09A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ExhaustedLandFromJumpOver;                         // 0x09B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExhaustedLandFromJumpOver : 1;           // 0x09B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9B9[0x7];                                      // 0x09B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionAnimRefs) == 0x000008, "Wrong alignment on FLocomotionAnimRefs");
static_assert(sizeof(FLocomotionAnimRefs) == 0x0009C0, "Wrong size on FLocomotionAnimRefs");
static_assert(offsetof(FLocomotionAnimRefs, DeadPose) == 0x000000, "Member 'FLocomotionAnimRefs::DeadPose' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ClimbOntoWalk) == 0x000010, "Member 'FLocomotionAnimRefs::ClimbOntoWalk' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ClimbOntoRun) == 0x0000F0, "Member 'FLocomotionAnimRefs::ClimbOntoRun' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ClimbOntoBigGrunt) == 0x0001D0, "Member 'FLocomotionAnimRefs::ClimbOntoBigGrunt' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ClimbDownStanding) == 0x0001F0, "Member 'FLocomotionAnimRefs::ClimbDownStanding' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ClimbDownCrouching) == 0x000298, "Member 'FLocomotionAnimRefs::ClimbDownCrouching' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, JumpOver) == 0x000340, "Member 'FLocomotionAnimRefs::JumpOver' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, JumpOverBigGrunt) == 0x0008D0, "Member 'FLocomotionAnimRefs::JumpOverBigGrunt' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, DodgeBS) == 0x0008E0, "Member 'FLocomotionAnimRefs::DodgeBS' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, PushFromLedgeAnimatedBlendSpace) == 0x0008F0, "Member 'FLocomotionAnimRefs::PushFromLedgeAnimatedBlendSpace' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, PushFromLedgeToFallAnimated) == 0x000900, "Member 'FLocomotionAnimRefs::PushFromLedgeToFallAnimated' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, LandOntoLedgeWall) == 0x000910, "Member 'FLocomotionAnimRefs::LandOntoLedgeWall' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, LandOntoLedgeNoWall) == 0x000948, "Member 'FLocomotionAnimRefs::LandOntoLedgeNoWall' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, NormalLand) == 0x000980, "Member 'FLocomotionAnimRefs::NormalLand' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, MediumLand) == 0x000990, "Member 'FLocomotionAnimRefs::MediumLand' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ExhaustedLand) == 0x0009A0, "Member 'FLocomotionAnimRefs::ExhaustedLand' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimRefs, ExhaustedLandFromJumpOver) == 0x0009B0, "Member 'FLocomotionAnimRefs::ExhaustedLandFromJumpOver' has a wrong offset!");

// ScriptStruct OPP.FatalityAnimSet
// 0x0180 (0x0180 - 0x0000)
struct FFatalityAnimSet final
{
public:
	TSoftObjectPtr<class UAnimSequence>           FrontAttackerRef;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FrontVictimRef;                                    // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           LeftAttackerRef;                                   // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           LeftVictimRef;                                     // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           RightAttackerRef;                                  // 0x00A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           RightVictimRef;                                    // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BackAttackerRef;                                   // 0x00F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BackVictimRef;                                     // 0x0118(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedFrontAttacker;                         // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedFrontVictim;                           // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedLeftAttacker;                          // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedLeftVictim;                            // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedRightAttacker;                         // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedRightVictim;                           // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedBackAttacker;                          // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AlwaysLoadedBackVictim;                            // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFatalityAnimSet) == 0x000008, "Wrong alignment on FFatalityAnimSet");
static_assert(sizeof(FFatalityAnimSet) == 0x000180, "Wrong size on FFatalityAnimSet");
static_assert(offsetof(FFatalityAnimSet, FrontAttackerRef) == 0x000000, "Member 'FFatalityAnimSet::FrontAttackerRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, FrontVictimRef) == 0x000028, "Member 'FFatalityAnimSet::FrontVictimRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, LeftAttackerRef) == 0x000050, "Member 'FFatalityAnimSet::LeftAttackerRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, LeftVictimRef) == 0x000078, "Member 'FFatalityAnimSet::LeftVictimRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, RightAttackerRef) == 0x0000A0, "Member 'FFatalityAnimSet::RightAttackerRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, RightVictimRef) == 0x0000C8, "Member 'FFatalityAnimSet::RightVictimRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, BackAttackerRef) == 0x0000F0, "Member 'FFatalityAnimSet::BackAttackerRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, BackVictimRef) == 0x000118, "Member 'FFatalityAnimSet::BackVictimRef' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedFrontAttacker) == 0x000140, "Member 'FFatalityAnimSet::AlwaysLoadedFrontAttacker' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedFrontVictim) == 0x000148, "Member 'FFatalityAnimSet::AlwaysLoadedFrontVictim' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedLeftAttacker) == 0x000150, "Member 'FFatalityAnimSet::AlwaysLoadedLeftAttacker' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedLeftVictim) == 0x000158, "Member 'FFatalityAnimSet::AlwaysLoadedLeftVictim' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedRightAttacker) == 0x000160, "Member 'FFatalityAnimSet::AlwaysLoadedRightAttacker' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedRightVictim) == 0x000168, "Member 'FFatalityAnimSet::AlwaysLoadedRightVictim' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedBackAttacker) == 0x000170, "Member 'FFatalityAnimSet::AlwaysLoadedBackAttacker' has a wrong offset!");
static_assert(offsetof(FFatalityAnimSet, AlwaysLoadedBackVictim) == 0x000178, "Member 'FFatalityAnimSet::AlwaysLoadedBackVictim' has a wrong offset!");

// ScriptStruct OPP.CombatAnimRefs
// 0x0270 (0x0270 - 0x0000)
struct FCombatAnimRefs final
{
public:
	class UAnimSequence*                          HitReactionTwitch;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionTwitch : 1;                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        StaggerBlendSpace;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StaggerBlendSpace : 1;                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        StumbleBlendSpace;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StumbleBlendSpace : 1;                   // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HitReactionBigStumbleForward;                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionBigStumbleForward : 1;        // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HitReactionBigStumbleLeft;                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionBigStumbleLeft : 1;           // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HitReactionBigStumbleRight;                        // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionBigStumbleRight : 1;          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HitReactionBigStumbleBack;                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionBigStumbleBack : 1;           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HitReactionKnockdown;                              // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HitReactionKnockdown : 1;                // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ReactionNearDeathToKnockdown;                      // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ReactionNearDeathToKnockdown : 1;        // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  SelfHelpUpInSas;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SelfHelpUpInSas : 1;                     // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          KnockDownStandUp;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_KnockDownStandUp : 1;                    // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SelfRevive;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SelfRevive : 1;                          // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PlayerInterruptingFatalityOnThisNPC;               // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerInterruptingFatalityOnThisNPC : 1; // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PlayerShovingThisNPC;                              // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerShovingThisNPC : 1;                // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PlayerInterruptingGroundAndPoundOnThisNPC;         // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerInterruptingGroundAndPoundOnThisNPC : 1; // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PusherAttackAttacker;                              // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PusherAttackAttacker : 1;                // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PusherAttackVictim;                                // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PusherAttackVictim : 1;                  // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PairedAttackAttacker;                              // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackAttacker : 1;                // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PairedAttackVictim;                                // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackVictim : 1;                  // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFatalityAnimSet>               StandardFatalities;                                // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StandardFatalities : 1;                  // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFatalityAnimSet>               LastManStandingFatalities;                         // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LastManStandingFatalities : 1;           // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          KnockdownToDeath;                                  // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_KnockdownToDeath : 1;                    // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBAnimRef>                     CoughUpperBodyAnimations;                          // 0x0178(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoughUpperBodyAnimations : 1;            // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBAnimRef>                     CoughCrouchedUpperBodyAnimations;                  // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoughCrouchedUpperBodyAnimations : 1;    // 0x01A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBAnimRef>                     CoughFullPsychosisUpperBodyAnimations;             // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoughFullPsychosisUpperBodyAnimations : 1; // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBasicDirection, struct FRBAnimRef>      CoopStabStabber;                                   // 0x01C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoopStabStabber : 1;                     // 0x0210(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBasicDirection, struct FRBAnimRef>      CoopStabVictim;                                    // 0x0218(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoopStabVictim : 1;                      // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombatAnimRefs) == 0x000008, "Wrong alignment on FCombatAnimRefs");
static_assert(sizeof(FCombatAnimRefs) == 0x000270, "Wrong size on FCombatAnimRefs");
static_assert(offsetof(FCombatAnimRefs, HitReactionTwitch) == 0x000000, "Member 'FCombatAnimRefs::HitReactionTwitch' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, StaggerBlendSpace) == 0x000010, "Member 'FCombatAnimRefs::StaggerBlendSpace' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, StumbleBlendSpace) == 0x000020, "Member 'FCombatAnimRefs::StumbleBlendSpace' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, HitReactionBigStumbleForward) == 0x000030, "Member 'FCombatAnimRefs::HitReactionBigStumbleForward' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, HitReactionBigStumbleLeft) == 0x000040, "Member 'FCombatAnimRefs::HitReactionBigStumbleLeft' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, HitReactionBigStumbleRight) == 0x000050, "Member 'FCombatAnimRefs::HitReactionBigStumbleRight' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, HitReactionBigStumbleBack) == 0x000060, "Member 'FCombatAnimRefs::HitReactionBigStumbleBack' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, HitReactionKnockdown) == 0x000070, "Member 'FCombatAnimRefs::HitReactionKnockdown' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, ReactionNearDeathToKnockdown) == 0x000080, "Member 'FCombatAnimRefs::ReactionNearDeathToKnockdown' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, SelfHelpUpInSas) == 0x000090, "Member 'FCombatAnimRefs::SelfHelpUpInSas' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, KnockDownStandUp) == 0x0000A8, "Member 'FCombatAnimRefs::KnockDownStandUp' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, SelfRevive) == 0x0000B8, "Member 'FCombatAnimRefs::SelfRevive' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PlayerInterruptingFatalityOnThisNPC) == 0x0000C8, "Member 'FCombatAnimRefs::PlayerInterruptingFatalityOnThisNPC' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PlayerShovingThisNPC) == 0x0000D8, "Member 'FCombatAnimRefs::PlayerShovingThisNPC' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PlayerInterruptingGroundAndPoundOnThisNPC) == 0x0000E8, "Member 'FCombatAnimRefs::PlayerInterruptingGroundAndPoundOnThisNPC' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PusherAttackAttacker) == 0x0000F8, "Member 'FCombatAnimRefs::PusherAttackAttacker' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PusherAttackVictim) == 0x000108, "Member 'FCombatAnimRefs::PusherAttackVictim' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PairedAttackAttacker) == 0x000118, "Member 'FCombatAnimRefs::PairedAttackAttacker' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, PairedAttackVictim) == 0x000128, "Member 'FCombatAnimRefs::PairedAttackVictim' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, StandardFatalities) == 0x000138, "Member 'FCombatAnimRefs::StandardFatalities' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, LastManStandingFatalities) == 0x000150, "Member 'FCombatAnimRefs::LastManStandingFatalities' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, KnockdownToDeath) == 0x000168, "Member 'FCombatAnimRefs::KnockdownToDeath' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, CoughUpperBodyAnimations) == 0x000178, "Member 'FCombatAnimRefs::CoughUpperBodyAnimations' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, CoughCrouchedUpperBodyAnimations) == 0x000190, "Member 'FCombatAnimRefs::CoughCrouchedUpperBodyAnimations' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, CoughFullPsychosisUpperBodyAnimations) == 0x0001A8, "Member 'FCombatAnimRefs::CoughFullPsychosisUpperBodyAnimations' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, CoopStabStabber) == 0x0001C0, "Member 'FCombatAnimRefs::CoopStabStabber' has a wrong offset!");
static_assert(offsetof(FCombatAnimRefs, CoopStabVictim) == 0x000218, "Member 'FCombatAnimRefs::CoopStabVictim' has a wrong offset!");

// ScriptStruct OPP.NPCSabotageAnimRefs
// 0x0020 (0x0020 - 0x0000)
struct FNPCSabotageAnimRefs final
{
public:
	class UAnimSequence*                          NPC_BreakGenerator;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_BreakGenerator : 1;                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_BreakDistractor;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_BreakDistractor : 1;                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCSabotageAnimRefs) == 0x000008, "Wrong alignment on FNPCSabotageAnimRefs");
static_assert(sizeof(FNPCSabotageAnimRefs) == 0x000020, "Wrong size on FNPCSabotageAnimRefs");
static_assert(offsetof(FNPCSabotageAnimRefs, NPC_BreakGenerator) == 0x000000, "Member 'FNPCSabotageAnimRefs::NPC_BreakGenerator' has a wrong offset!");
static_assert(offsetof(FNPCSabotageAnimRefs, NPC_BreakDistractor) == 0x000010, "Member 'FNPCSabotageAnimRefs::NPC_BreakDistractor' has a wrong offset!");

// ScriptStruct OPP.RBGenericConditionSet
// 0x0010 (0x0010 - 0x0000)
struct FRBGenericConditionSet
{
public:
	TArray<class URBGenericCondition*>            Conditions;                                        // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FRBGenericConditionSet) == 0x000008, "Wrong alignment on FRBGenericConditionSet");
static_assert(sizeof(FRBGenericConditionSet) == 0x000010, "Wrong size on FRBGenericConditionSet");
static_assert(offsetof(FRBGenericConditionSet, Conditions) == 0x000000, "Member 'FRBGenericConditionSet::Conditions' has a wrong offset!");

// ScriptStruct OPP.ConditionalAnimSequence
// 0x0018 (0x0018 - 0x0000)
struct FConditionalAnimSequence
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBGenericConditionSet                 Conditions;                                        // 0x0008(0x0010)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalAnimSequence) == 0x000008, "Wrong alignment on FConditionalAnimSequence");
static_assert(sizeof(FConditionalAnimSequence) == 0x000018, "Wrong size on FConditionalAnimSequence");
static_assert(offsetof(FConditionalAnimSequence, AnimSequence) == 0x000000, "Member 'FConditionalAnimSequence::AnimSequence' has a wrong offset!");
static_assert(offsetof(FConditionalAnimSequence, Conditions) == 0x000008, "Member 'FConditionalAnimSequence::Conditions' has a wrong offset!");

// ScriptStruct OPP.ConditionalAnimSequences
// 0x0010 (0x0010 - 0x0000)
struct FConditionalAnimSequences final
{
public:
	TArray<struct FConditionalAnimSequence>       Sequences;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalAnimSequences) == 0x000008, "Wrong alignment on FConditionalAnimSequences");
static_assert(sizeof(FConditionalAnimSequences) == 0x000010, "Wrong size on FConditionalAnimSequences");
static_assert(offsetof(FConditionalAnimSequences, Sequences) == 0x000000, "Member 'FConditionalAnimSequences::Sequences' has a wrong offset!");

// ScriptStruct OPP.NPCActionsAnimRefs
// 0x0288 (0x0288 - 0x0000)
struct FNPCActionsAnimRefs final
{
public:
	struct FNPCSabotageAnimRefs                   NPC_SabotageAnimRefs;                              // 0x0000(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          NPC_Investigate_Long;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_Investigate_Long : 1;                // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_Investigate_Short;                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_Investigate_Short : 1;               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_GiveUpInvestigationAnims;                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GiveUpInvestigationAnims : 1;        // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_GiveUpAlertedAnims;                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GiveUpAlertedAnims : 1;              // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_GiveUpSuspiciousAnims;                         // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GiveUpSuspiciousAnims : 1;           // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConditionalAnimSequences              NPC_IdleBreakers;                                  // 0x0088(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_IdleBreakers : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_PlayerTauntAnims;                              // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_PlayerTauntAnims : 1;                // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_BerserkIdleBreakers;                           // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_BerserkIdleBreakers : 1;             // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        NPC_ReactToPlayer;                                 // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToPlayer : 1;                   // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToGrenade;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToGrenade : 1;                  // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_TrapReaction;                                  // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_TrapReaction : 1;                    // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_CheckSurroundings;                             // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_CheckSurroundings : 1;               // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        TurnOnSpotBS;                                      // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TurnOnSpotBS : 1;                        // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        KnockOutBS;                                        // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_KnockOutBS : 1;                          // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_GetUpFromKnockout_Short;                       // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GetUpFromKnockout_Short : 1;         // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_GetUpFromKnockout_Long;                        // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GetUpFromKnockout_Long : 1;          // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_HaarpReactions;                                // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_HaarpReactions : 1;                  // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_ReactToGrenadeStun;                            // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToGrenadeStun : 1;              // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_GrenadeStun;                                   // 0x0188(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GrenadeStun : 1;                     // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_RecoverFromGrenadeStun;                        // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_RecoverFromGrenadeStun : 1;          // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToBlindPaint_Left;                        // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToBlindPaint_Left : 1;          // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToBlindPaint_Right;                       // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToBlindPaint_Right : 1;         // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToBlindPaint_Forward;                     // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToBlindPaint_Forward : 1;       // 0x01E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToHealSlowdown;                           // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToHealSlowdown : 1;             // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToJammerUnaware;                          // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToJammerUnaware : 1;            // 0x0200(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_ReactToJammerAlert;                            // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_ReactToJammerAlert : 1;              // 0x0210(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_StalkerTargetBulbExplodeReaction;              // 0x0218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_StalkerTargetBulbExplodeReaction : 1; // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_RecoverFromBlindPaint;                         // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_RecoverFromBlindPaint : 1;           // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_FlinchReactions;                               // 0x0240(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_FlinchReactions : 1;                 // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_GoryDeath;                                     // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_GoryDeath : 1;                       // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_SlamDoorLeft;                                  // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_SlamDoorLeft : 1;                    // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_SlamDoorRight;                                 // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_SlamDoorRight : 1;                   // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCActionsAnimRefs) == 0x000008, "Wrong alignment on FNPCActionsAnimRefs");
static_assert(sizeof(FNPCActionsAnimRefs) == 0x000288, "Wrong size on FNPCActionsAnimRefs");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_SabotageAnimRefs) == 0x000000, "Member 'FNPCActionsAnimRefs::NPC_SabotageAnimRefs' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_Investigate_Long) == 0x000020, "Member 'FNPCActionsAnimRefs::NPC_Investigate_Long' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_Investigate_Short) == 0x000030, "Member 'FNPCActionsAnimRefs::NPC_Investigate_Short' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GiveUpInvestigationAnims) == 0x000040, "Member 'FNPCActionsAnimRefs::NPC_GiveUpInvestigationAnims' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GiveUpAlertedAnims) == 0x000058, "Member 'FNPCActionsAnimRefs::NPC_GiveUpAlertedAnims' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GiveUpSuspiciousAnims) == 0x000070, "Member 'FNPCActionsAnimRefs::NPC_GiveUpSuspiciousAnims' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_IdleBreakers) == 0x000088, "Member 'FNPCActionsAnimRefs::NPC_IdleBreakers' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_PlayerTauntAnims) == 0x0000A0, "Member 'FNPCActionsAnimRefs::NPC_PlayerTauntAnims' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_BerserkIdleBreakers) == 0x0000B8, "Member 'FNPCActionsAnimRefs::NPC_BerserkIdleBreakers' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToPlayer) == 0x0000D0, "Member 'FNPCActionsAnimRefs::NPC_ReactToPlayer' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToGrenade) == 0x0000E0, "Member 'FNPCActionsAnimRefs::NPC_ReactToGrenade' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_TrapReaction) == 0x0000F0, "Member 'FNPCActionsAnimRefs::NPC_TrapReaction' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_CheckSurroundings) == 0x000100, "Member 'FNPCActionsAnimRefs::NPC_CheckSurroundings' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, TurnOnSpotBS) == 0x000118, "Member 'FNPCActionsAnimRefs::TurnOnSpotBS' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, KnockOutBS) == 0x000128, "Member 'FNPCActionsAnimRefs::KnockOutBS' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GetUpFromKnockout_Short) == 0x000138, "Member 'FNPCActionsAnimRefs::NPC_GetUpFromKnockout_Short' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GetUpFromKnockout_Long) == 0x000148, "Member 'FNPCActionsAnimRefs::NPC_GetUpFromKnockout_Long' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_HaarpReactions) == 0x000158, "Member 'FNPCActionsAnimRefs::NPC_HaarpReactions' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToGrenadeStun) == 0x000170, "Member 'FNPCActionsAnimRefs::NPC_ReactToGrenadeStun' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GrenadeStun) == 0x000188, "Member 'FNPCActionsAnimRefs::NPC_GrenadeStun' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_RecoverFromGrenadeStun) == 0x0001A0, "Member 'FNPCActionsAnimRefs::NPC_RecoverFromGrenadeStun' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToBlindPaint_Left) == 0x0001B8, "Member 'FNPCActionsAnimRefs::NPC_ReactToBlindPaint_Left' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToBlindPaint_Right) == 0x0001C8, "Member 'FNPCActionsAnimRefs::NPC_ReactToBlindPaint_Right' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToBlindPaint_Forward) == 0x0001D8, "Member 'FNPCActionsAnimRefs::NPC_ReactToBlindPaint_Forward' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToHealSlowdown) == 0x0001E8, "Member 'FNPCActionsAnimRefs::NPC_ReactToHealSlowdown' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToJammerUnaware) == 0x0001F8, "Member 'FNPCActionsAnimRefs::NPC_ReactToJammerUnaware' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_ReactToJammerAlert) == 0x000208, "Member 'FNPCActionsAnimRefs::NPC_ReactToJammerAlert' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_StalkerTargetBulbExplodeReaction) == 0x000218, "Member 'FNPCActionsAnimRefs::NPC_StalkerTargetBulbExplodeReaction' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_RecoverFromBlindPaint) == 0x000228, "Member 'FNPCActionsAnimRefs::NPC_RecoverFromBlindPaint' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_FlinchReactions) == 0x000240, "Member 'FNPCActionsAnimRefs::NPC_FlinchReactions' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_GoryDeath) == 0x000258, "Member 'FNPCActionsAnimRefs::NPC_GoryDeath' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_SlamDoorLeft) == 0x000268, "Member 'FNPCActionsAnimRefs::NPC_SlamDoorLeft' has a wrong offset!");
static_assert(offsetof(FNPCActionsAnimRefs, NPC_SlamDoorRight) == 0x000278, "Member 'FNPCActionsAnimRefs::NPC_SlamDoorRight' has a wrong offset!");

// ScriptStruct OPP.InteractionsAnimRefs
// 0x01C8 (0x01C8 - 0x0000)
struct FInteractionsAnimRefs final
{
public:
	class UBlendSpaceBase*                        GenericPickUpBlendSpace;                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericPickUpBlendSpace : 1;             // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        GenericCrouchedPickUpBlendSpace;                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericCrouchedPickUpBlendSpace : 1;     // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        GenericCrouched1PPickUpBlendSpace;                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericCrouched1PPickUpBlendSpace : 1;   // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        GenericPickUpFromTopBlendSpace;                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericPickUpFromTopBlendSpace : 1;      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        GenericCrouchedPickUpFromTopBlendSpace;            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericCrouchedPickUpFromTopBlendSpace : 1; // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        GenericCrouched1PPickUpFromTopBlendSpace;          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericCrouched1PPickUpFromTopBlendSpace : 1; // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          GenericDropItem;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericDropItem : 1;                     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          GenericCrouchedDropItem;                           // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericCrouchedDropItem : 1;             // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ThrowSmallWeapon;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ThrowSmallWeapon : 1;                    // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ActivateDynamicObstacleLeft;                       // 0x0090(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActivateDynamicObstacleLeft : 1;         // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ActivateDynamicObstacleRight;                      // 0x00C8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActivateDynamicObstacleRight : 1;        // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BashDynamicObstacle;                               // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BashDynamicObstacle : 1;                 // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BashWindow;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BashWindow : 1;                          // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             WalkJumpTroughWindowToLand;                        // 0x0120(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_WalkJumpTroughWindowToLand : 1;          // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             RunJumpTroughWindowToLand;                         // 0x0158(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RunJumpTroughWindowToLand : 1;           // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             JumpTroughWindowToFall;                            // 0x0190(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_JumpTroughWindowToFall : 1;              // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionsAnimRefs) == 0x000008, "Wrong alignment on FInteractionsAnimRefs");
static_assert(sizeof(FInteractionsAnimRefs) == 0x0001C8, "Wrong size on FInteractionsAnimRefs");
static_assert(offsetof(FInteractionsAnimRefs, GenericPickUpBlendSpace) == 0x000000, "Member 'FInteractionsAnimRefs::GenericPickUpBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericCrouchedPickUpBlendSpace) == 0x000010, "Member 'FInteractionsAnimRefs::GenericCrouchedPickUpBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericCrouched1PPickUpBlendSpace) == 0x000020, "Member 'FInteractionsAnimRefs::GenericCrouched1PPickUpBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericPickUpFromTopBlendSpace) == 0x000030, "Member 'FInteractionsAnimRefs::GenericPickUpFromTopBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericCrouchedPickUpFromTopBlendSpace) == 0x000040, "Member 'FInteractionsAnimRefs::GenericCrouchedPickUpFromTopBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericCrouched1PPickUpFromTopBlendSpace) == 0x000050, "Member 'FInteractionsAnimRefs::GenericCrouched1PPickUpFromTopBlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericDropItem) == 0x000060, "Member 'FInteractionsAnimRefs::GenericDropItem' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, GenericCrouchedDropItem) == 0x000070, "Member 'FInteractionsAnimRefs::GenericCrouchedDropItem' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, ThrowSmallWeapon) == 0x000080, "Member 'FInteractionsAnimRefs::ThrowSmallWeapon' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, ActivateDynamicObstacleLeft) == 0x000090, "Member 'FInteractionsAnimRefs::ActivateDynamicObstacleLeft' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, ActivateDynamicObstacleRight) == 0x0000C8, "Member 'FInteractionsAnimRefs::ActivateDynamicObstacleRight' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, BashDynamicObstacle) == 0x000100, "Member 'FInteractionsAnimRefs::BashDynamicObstacle' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, BashWindow) == 0x000110, "Member 'FInteractionsAnimRefs::BashWindow' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, WalkJumpTroughWindowToLand) == 0x000120, "Member 'FInteractionsAnimRefs::WalkJumpTroughWindowToLand' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, RunJumpTroughWindowToLand) == 0x000158, "Member 'FInteractionsAnimRefs::RunJumpTroughWindowToLand' has a wrong offset!");
static_assert(offsetof(FInteractionsAnimRefs, JumpTroughWindowToFall) == 0x000190, "Member 'FInteractionsAnimRefs::JumpTroughWindowToFall' has a wrong offset!");

// ScriptStruct OPP.PouncerGnPAnimRefs
// 0x02A0 (0x02A0 - 0x0000)
struct FPouncerGnPAnimRefs final
{
public:
	class UAnimSequence*                          EnterPouncerGnPAttacker_FreeStanding;              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_FreeStanding : 1; // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_FreeStanding;              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_FreeStanding : 1; // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_StandingLeft;              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_StandingLeft : 1; // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_StandingLeft;              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_StandingLeft : 1; // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_StandingRight;             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_StandingRight : 1; // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_StandingRight;             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_StandingRight : 1; // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_ProneLeft;                 // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_ProneLeft : 1;   // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_ProneLeft;                 // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_ProneLeft : 1;   // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_ProneRight;                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_ProneRight : 1;  // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_ProneRight;                // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_ProneRight : 1;  // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_Crouched;                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_Crouched : 1;    // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_Crouched;                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_Crouched : 1;    // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_InsideHorizontal;          // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_InsideHorizontal : 1; // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_InsideHorizontal;          // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_InsideHorizontal : 1; // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_InsideVertical;            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_InsideVertical : 1; // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_InsideVertical;            // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_InsideVertical : 1; // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EnterPouncerGnPAttacker_CarTrunk;                  // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPAttacker_CarTrunk : 1;    // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        EnterPouncerGnPVictimBS_CarTrunk;                  // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterPouncerGnPVictimBS_CarTrunk : 1;    // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SignalTackle;                                      // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SignalTackle : 1;                        // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          TackleFail;                                        // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TackleFail : 1;                          // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPFinishAttacker;                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPFinishAttacker : 1;            // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPFinishVictimKnockdown;                   // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPFinishVictimKnockdown : 1;     // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPFinishVictimDead;                        // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPFinishVictimDead : 1;          // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPGiveUpAttacker;                          // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPGiveUpAttacker : 1;            // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPGiveUpVictim;                            // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPGiveUpVictim : 1;              // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptInterrupter;                    // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptInterrupter : 1;      // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptFwdPouncer;                     // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptFwdPouncer : 1;       // 0x01A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptFwdPinnedPlayer;                // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptFwdPinnedPlayer : 1;  // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptLeftPouncer;                    // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptLeftPouncer : 1;      // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptLeftPinnedPlayer;               // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptLeftPinnedPlayer : 1; // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptRightPouncer;                   // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptRightPouncer : 1;     // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptRightPinnedPlayer;              // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptRightPinnedPlayer : 1; // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptBackPouncer;                    // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptBackPouncer : 1;      // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPInterruptBackPinnedPlayer;               // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPInterruptBackPinnedPlayer : 1; // 0x0218(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeFistLeftPlayer;                    // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeFistLeftPlayer : 1;      // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeBottleLeftPlayer;                  // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeBottleLeftPlayer : 1;    // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeBrickLeftPlayer;                   // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeBrickLeftPlayer : 1;     // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeLeftPouncer;                       // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeLeftPouncer : 1;         // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeFistRightPlayer;                   // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeFistRightPlayer : 1;     // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeBottleRightPlayer;                 // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeBottleRightPlayer : 1;   // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeBrickRightPlayer;                  // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeBrickRightPlayer : 1;    // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PouncerGnPEscapeRightPouncer;                      // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PouncerGnPEscapeRightPouncer : 1;        // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPouncerGnPAnimRefs) == 0x000008, "Wrong alignment on FPouncerGnPAnimRefs");
static_assert(sizeof(FPouncerGnPAnimRefs) == 0x0002A0, "Wrong size on FPouncerGnPAnimRefs");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_FreeStanding) == 0x000000, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_FreeStanding' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_FreeStanding) == 0x000010, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_FreeStanding' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_StandingLeft) == 0x000020, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_StandingLeft' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_StandingLeft) == 0x000030, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_StandingLeft' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_StandingRight) == 0x000040, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_StandingRight' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_StandingRight) == 0x000050, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_StandingRight' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_ProneLeft) == 0x000060, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_ProneLeft' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_ProneLeft) == 0x000070, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_ProneLeft' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_ProneRight) == 0x000080, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_ProneRight' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_ProneRight) == 0x000090, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_ProneRight' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_Crouched) == 0x0000A0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_Crouched' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_Crouched) == 0x0000B0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_Crouched' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_InsideHorizontal) == 0x0000C0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_InsideHorizontal' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_InsideHorizontal) == 0x0000D0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_InsideHorizontal' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_InsideVertical) == 0x0000E0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_InsideVertical' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_InsideVertical) == 0x0000F0, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_InsideVertical' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPAttacker_CarTrunk) == 0x000100, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPAttacker_CarTrunk' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, EnterPouncerGnPVictimBS_CarTrunk) == 0x000110, "Member 'FPouncerGnPAnimRefs::EnterPouncerGnPVictimBS_CarTrunk' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, SignalTackle) == 0x000120, "Member 'FPouncerGnPAnimRefs::SignalTackle' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, TackleFail) == 0x000130, "Member 'FPouncerGnPAnimRefs::TackleFail' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPFinishAttacker) == 0x000140, "Member 'FPouncerGnPAnimRefs::PouncerGnPFinishAttacker' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPFinishVictimKnockdown) == 0x000150, "Member 'FPouncerGnPAnimRefs::PouncerGnPFinishVictimKnockdown' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPFinishVictimDead) == 0x000160, "Member 'FPouncerGnPAnimRefs::PouncerGnPFinishVictimDead' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPGiveUpAttacker) == 0x000170, "Member 'FPouncerGnPAnimRefs::PouncerGnPGiveUpAttacker' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPGiveUpVictim) == 0x000180, "Member 'FPouncerGnPAnimRefs::PouncerGnPGiveUpVictim' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptInterrupter) == 0x000190, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptInterrupter' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptFwdPouncer) == 0x0001A0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptFwdPouncer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptFwdPinnedPlayer) == 0x0001B0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptFwdPinnedPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptLeftPouncer) == 0x0001C0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptLeftPouncer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptLeftPinnedPlayer) == 0x0001D0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptLeftPinnedPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptRightPouncer) == 0x0001E0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptRightPouncer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptRightPinnedPlayer) == 0x0001F0, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptRightPinnedPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptBackPouncer) == 0x000200, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptBackPouncer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPInterruptBackPinnedPlayer) == 0x000210, "Member 'FPouncerGnPAnimRefs::PouncerGnPInterruptBackPinnedPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeFistLeftPlayer) == 0x000220, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeFistLeftPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeBottleLeftPlayer) == 0x000230, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeBottleLeftPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeBrickLeftPlayer) == 0x000240, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeBrickLeftPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeLeftPouncer) == 0x000250, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeLeftPouncer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeFistRightPlayer) == 0x000260, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeFistRightPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeBottleRightPlayer) == 0x000270, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeBottleRightPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeBrickRightPlayer) == 0x000280, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeBrickRightPlayer' has a wrong offset!");
static_assert(offsetof(FPouncerGnPAnimRefs, PouncerGnPEscapeRightPouncer) == 0x000290, "Member 'FPouncerGnPAnimRefs::PouncerGnPEscapeRightPouncer' has a wrong offset!");

// ScriptStruct OPP.DoorInteractionsAnimRefs
// 0x0350 (0x0350 - 0x0000)
struct FDoorInteractionsAnimRefs final
{
public:
	class UAnimSequenceBase*                      OpenLeft;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenLeft : 1;                            // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      OpenLeftJumpScare;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenLeftJumpScare : 1;                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      OpenLeftFailed;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenLeftFailed : 1;                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      OpenRight;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenRight : 1;                           // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      OpenRightJumpScare;                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenRightJumpScare : 1;                  // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      OpenRightFailed;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OpenRightFailed : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideLeft;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideLeft : 1;                     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideLeftChase;                              // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideLeftChase : 1;                // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideLeftRunning;                            // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideLeftRunning : 1;              // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideRight;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideRight : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideRightChase;                             // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideRightChase : 1;               // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseInsideRightRunning;                           // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseInsideRightRunning : 1;             // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideLeft;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideLeft : 1;                    // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideLeftChase;                             // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideLeftChase : 1;               // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideLeftRunning;                           // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideLeftRunning : 1;             // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideRight;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideRight : 1;                   // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideRightChase;                            // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideRightChase : 1;              // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CloseOutsideRightRunning;                          // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseOutsideRightRunning : 1;            // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenLeft;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenLeft : 1;                    // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenLeftJumpScare;                         // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenLeftJumpScare : 1;           // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenLeftFailed;                            // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenLeftFailed : 1;              // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenRight;                                 // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenRight : 1;                   // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenRightJumpScare;                        // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenRightJumpScare : 1;          // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedOpenRightFailed;                           // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedOpenRightFailed : 1;             // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseInsideLeft;                           // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseInsideLeft : 1;             // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseInsideLeftChase;                      // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseInsideLeftChase : 1;        // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseInsideRight;                          // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseInsideRight : 1;            // 0x01A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseInsideRightChase;                     // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseInsideRightChase : 1;       // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseOutsideLeft;                          // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseOutsideLeft : 1;            // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseOutsideLeftChase;                     // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseOutsideLeftChase : 1;       // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseOutsideRight;                         // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseOutsideRight : 1;           // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CrouchedCloseOutsideRightChase;                    // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchedCloseOutsideRightChase : 1;      // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenInLeft;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenInLeft : 1;                      // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenInRight;                                   // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenInRight : 1;                     // 0x0218(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenLeft;                                      // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenLeft : 1;                        // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenRight;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenRight : 1;                       // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenOutForwardLeft;                            // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenOutForwardLeft : 1;              // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenOutForwardRight;                           // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenOutForwardRight : 1;             // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenOutBackwardLeft;                           // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenOutBackwardLeft : 1;             // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenOutBackwardRight;                          // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenOutBackwardRight : 1;            // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SlowOpenOutByInterruption;                         // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowOpenOutByInterruption : 1;           // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Open_Left;                               // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Open_Left : 1;                 // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Open_Left_JumpScare;                     // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Open_Left_JumpScare : 1;       // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Try_Left;                                // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Try_Left : 1;                  // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Open_Right;                              // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Open_Right : 1;                // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Open_Right_JumpScare;                    // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Open_Right_JumpScare : 1;      // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Kick_Try_Right;                               // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Kick_Try_Right : 1;                 // 0x02E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Open_Left;                           // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Open_Left : 1;             // 0x02F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Open_Left_JumpScare;                 // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Open_Left_JumpScare : 1;   // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Try_Left;                            // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Try_Left : 1;              // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Open_Right;                          // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Open_Right : 1;            // 0x0328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Open_Right_JumpScare;                // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Open_Right_JumpScare : 1;  // 0x0338(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Bash_Shoulder_Try_Right;                           // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Shoulder_Try_Right : 1;             // 0x0348(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDoorInteractionsAnimRefs) == 0x000008, "Wrong alignment on FDoorInteractionsAnimRefs");
static_assert(sizeof(FDoorInteractionsAnimRefs) == 0x000350, "Wrong size on FDoorInteractionsAnimRefs");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenLeft) == 0x000000, "Member 'FDoorInteractionsAnimRefs::OpenLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenLeftJumpScare) == 0x000010, "Member 'FDoorInteractionsAnimRefs::OpenLeftJumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenLeftFailed) == 0x000020, "Member 'FDoorInteractionsAnimRefs::OpenLeftFailed' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenRight) == 0x000030, "Member 'FDoorInteractionsAnimRefs::OpenRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenRightJumpScare) == 0x000040, "Member 'FDoorInteractionsAnimRefs::OpenRightJumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, OpenRightFailed) == 0x000050, "Member 'FDoorInteractionsAnimRefs::OpenRightFailed' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideLeft) == 0x000060, "Member 'FDoorInteractionsAnimRefs::CloseInsideLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideLeftChase) == 0x000070, "Member 'FDoorInteractionsAnimRefs::CloseInsideLeftChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideLeftRunning) == 0x000080, "Member 'FDoorInteractionsAnimRefs::CloseInsideLeftRunning' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideRight) == 0x000090, "Member 'FDoorInteractionsAnimRefs::CloseInsideRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideRightChase) == 0x0000A0, "Member 'FDoorInteractionsAnimRefs::CloseInsideRightChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseInsideRightRunning) == 0x0000B0, "Member 'FDoorInteractionsAnimRefs::CloseInsideRightRunning' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideLeft) == 0x0000C0, "Member 'FDoorInteractionsAnimRefs::CloseOutsideLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideLeftChase) == 0x0000D0, "Member 'FDoorInteractionsAnimRefs::CloseOutsideLeftChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideLeftRunning) == 0x0000E0, "Member 'FDoorInteractionsAnimRefs::CloseOutsideLeftRunning' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideRight) == 0x0000F0, "Member 'FDoorInteractionsAnimRefs::CloseOutsideRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideRightChase) == 0x000100, "Member 'FDoorInteractionsAnimRefs::CloseOutsideRightChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CloseOutsideRightRunning) == 0x000110, "Member 'FDoorInteractionsAnimRefs::CloseOutsideRightRunning' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenLeft) == 0x000120, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenLeftJumpScare) == 0x000130, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenLeftJumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenLeftFailed) == 0x000140, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenLeftFailed' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenRight) == 0x000150, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenRightJumpScare) == 0x000160, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenRightJumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedOpenRightFailed) == 0x000170, "Member 'FDoorInteractionsAnimRefs::CrouchedOpenRightFailed' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseInsideLeft) == 0x000180, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseInsideLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseInsideLeftChase) == 0x000190, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseInsideLeftChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseInsideRight) == 0x0001A0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseInsideRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseInsideRightChase) == 0x0001B0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseInsideRightChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseOutsideLeft) == 0x0001C0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseOutsideLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseOutsideLeftChase) == 0x0001D0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseOutsideLeftChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseOutsideRight) == 0x0001E0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseOutsideRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, CrouchedCloseOutsideRightChase) == 0x0001F0, "Member 'FDoorInteractionsAnimRefs::CrouchedCloseOutsideRightChase' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenInLeft) == 0x000200, "Member 'FDoorInteractionsAnimRefs::SlowOpenInLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenInRight) == 0x000210, "Member 'FDoorInteractionsAnimRefs::SlowOpenInRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenLeft) == 0x000220, "Member 'FDoorInteractionsAnimRefs::SlowOpenLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenRight) == 0x000230, "Member 'FDoorInteractionsAnimRefs::SlowOpenRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenOutForwardLeft) == 0x000240, "Member 'FDoorInteractionsAnimRefs::SlowOpenOutForwardLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenOutForwardRight) == 0x000250, "Member 'FDoorInteractionsAnimRefs::SlowOpenOutForwardRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenOutBackwardLeft) == 0x000260, "Member 'FDoorInteractionsAnimRefs::SlowOpenOutBackwardLeft' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenOutBackwardRight) == 0x000270, "Member 'FDoorInteractionsAnimRefs::SlowOpenOutBackwardRight' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, SlowOpenOutByInterruption) == 0x000280, "Member 'FDoorInteractionsAnimRefs::SlowOpenOutByInterruption' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Open_Left) == 0x000290, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Open_Left' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Open_Left_JumpScare) == 0x0002A0, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Open_Left_JumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Try_Left) == 0x0002B0, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Try_Left' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Open_Right) == 0x0002C0, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Open_Right' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Open_Right_JumpScare) == 0x0002D0, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Open_Right_JumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Kick_Try_Right) == 0x0002E0, "Member 'FDoorInteractionsAnimRefs::Bash_Kick_Try_Right' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Open_Left) == 0x0002F0, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Open_Left' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Open_Left_JumpScare) == 0x000300, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Open_Left_JumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Try_Left) == 0x000310, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Try_Left' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Open_Right) == 0x000320, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Open_Right' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Open_Right_JumpScare) == 0x000330, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Open_Right_JumpScare' has a wrong offset!");
static_assert(offsetof(FDoorInteractionsAnimRefs, Bash_Shoulder_Try_Right) == 0x000340, "Member 'FDoorInteractionsAnimRefs::Bash_Shoulder_Try_Right' has a wrong offset!");

// ScriptStruct OPP.CoopTrapAnimRefs
// 0x01F8 (0x01F8 - 0x0000)
struct FCoopTrapAnimRefs final
{
public:
	struct FRBAnimRef                             VictimEnter;                                       // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VictimEnter : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             VictimLoop;                                        // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VictimLoop : 1;                          // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             VictimExit;                                        // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VictimExit : 1;                          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             VictimFailKnockdown;                               // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VictimFailKnockdown : 1;                 // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             VictimFailDeath;                                   // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_VictimFailDeath : 1;                     // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HelperEnterLeft;                                   // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HelperEnterLeft : 1;                     // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HelperEnterRight;                                  // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HelperEnterRight : 1;                    // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HelperLoop;                                        // 0x0188(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HelperLoop : 1;                          // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HelperExit;                                        // 0x01C0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HelperExit : 1;                          // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoopTrapAnimRefs) == 0x000008, "Wrong alignment on FCoopTrapAnimRefs");
static_assert(sizeof(FCoopTrapAnimRefs) == 0x0001F8, "Wrong size on FCoopTrapAnimRefs");
static_assert(offsetof(FCoopTrapAnimRefs, VictimEnter) == 0x000000, "Member 'FCoopTrapAnimRefs::VictimEnter' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, VictimLoop) == 0x000038, "Member 'FCoopTrapAnimRefs::VictimLoop' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, VictimExit) == 0x000070, "Member 'FCoopTrapAnimRefs::VictimExit' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, VictimFailKnockdown) == 0x0000A8, "Member 'FCoopTrapAnimRefs::VictimFailKnockdown' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, VictimFailDeath) == 0x0000E0, "Member 'FCoopTrapAnimRefs::VictimFailDeath' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, HelperEnterLeft) == 0x000118, "Member 'FCoopTrapAnimRefs::HelperEnterLeft' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, HelperEnterRight) == 0x000150, "Member 'FCoopTrapAnimRefs::HelperEnterRight' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, HelperLoop) == 0x000188, "Member 'FCoopTrapAnimRefs::HelperLoop' has a wrong offset!");
static_assert(offsetof(FCoopTrapAnimRefs, HelperExit) == 0x0001C0, "Member 'FCoopTrapAnimRefs::HelperExit' has a wrong offset!");

// ScriptStruct OPP.NPCAttackAnimRefs
// 0x0080 (0x0080 - 0x0000)
struct FNPCAttackAnimRefs final
{
public:
	TArray<class UAnimSequence*>                  NPC_AttackQuick;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_AttackQuick : 1;                     // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  NPC_AttackLow;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_AttackLow : 1;                       // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_PushOtherPawn;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_PushOtherPawn : 1;                   // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          GooseberrySwipe;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GooseberrySwipe : 1;                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          GooseberryLunge;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GooseberryLunge : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NPC_Lunge;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPC_Lunge : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Imposter_Charge;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Imposter_Charge : 1;                     // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAttackAnimRefs) == 0x000008, "Wrong alignment on FNPCAttackAnimRefs");
static_assert(sizeof(FNPCAttackAnimRefs) == 0x000080, "Wrong size on FNPCAttackAnimRefs");
static_assert(offsetof(FNPCAttackAnimRefs, NPC_AttackQuick) == 0x000000, "Member 'FNPCAttackAnimRefs::NPC_AttackQuick' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, NPC_AttackLow) == 0x000018, "Member 'FNPCAttackAnimRefs::NPC_AttackLow' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, NPC_PushOtherPawn) == 0x000030, "Member 'FNPCAttackAnimRefs::NPC_PushOtherPawn' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, GooseberrySwipe) == 0x000040, "Member 'FNPCAttackAnimRefs::GooseberrySwipe' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, GooseberryLunge) == 0x000050, "Member 'FNPCAttackAnimRefs::GooseberryLunge' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, NPC_Lunge) == 0x000060, "Member 'FNPCAttackAnimRefs::NPC_Lunge' has a wrong offset!");
static_assert(offsetof(FNPCAttackAnimRefs, Imposter_Charge) == 0x000070, "Member 'FNPCAttackAnimRefs::Imposter_Charge' has a wrong offset!");

// ScriptStruct OPP.PlayerHelpUpAnimSet
// 0x01C0 (0x01C0 - 0x0000)
struct FPlayerHelpUpAnimSet final
{
public:
	struct FRBAnimRef                             Entry_Follower;                                    // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Entry_Follower : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Entry_Leader;                                      // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Entry_Leader : 1;                        // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Try_Follower;                                      // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Try_Follower : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Try_Leader;                                        // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Try_Leader : 1;                          // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Leave_Leader;                                      // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Leave_Leader : 1;                        // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Success_Follower;                                  // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Success_Follower : 1;                    // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Success_Leader;                                    // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Success_Leader : 1;                      // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Fail_Follower;                                     // 0x0188(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Fail_Follower : 1;                       // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHelpUpAnimSet) == 0x000008, "Wrong alignment on FPlayerHelpUpAnimSet");
static_assert(sizeof(FPlayerHelpUpAnimSet) == 0x0001C0, "Wrong size on FPlayerHelpUpAnimSet");
static_assert(offsetof(FPlayerHelpUpAnimSet, Entry_Follower) == 0x000000, "Member 'FPlayerHelpUpAnimSet::Entry_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Entry_Leader) == 0x000038, "Member 'FPlayerHelpUpAnimSet::Entry_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Try_Follower) == 0x000070, "Member 'FPlayerHelpUpAnimSet::Try_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Try_Leader) == 0x0000A8, "Member 'FPlayerHelpUpAnimSet::Try_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Leave_Leader) == 0x0000E0, "Member 'FPlayerHelpUpAnimSet::Leave_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Success_Follower) == 0x000118, "Member 'FPlayerHelpUpAnimSet::Success_Follower' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Success_Leader) == 0x000150, "Member 'FPlayerHelpUpAnimSet::Success_Leader' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimSet, Fail_Follower) == 0x000188, "Member 'FPlayerHelpUpAnimSet::Fail_Follower' has a wrong offset!");

// ScriptStruct OPP.PlayerHelpUpAnimRefs
// 0x0720 (0x0720 - 0x0000)
struct FPlayerHelpUpAnimRefs final
{
public:
	struct FPlayerHelpUpAnimSet                   Forward;                                           // 0x0000(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Forward : 1;                             // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHelpUpAnimSet                   Backward;                                          // 0x01C8(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Backward : 1;                            // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHelpUpAnimSet                   Right;                                             // 0x0390(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Right : 1;                               // 0x0550(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHelpUpAnimSet                   Left;                                              // 0x0558(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Left : 1;                                // 0x0718(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_719[0x7];                                      // 0x0719(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHelpUpAnimRefs) == 0x000008, "Wrong alignment on FPlayerHelpUpAnimRefs");
static_assert(sizeof(FPlayerHelpUpAnimRefs) == 0x000720, "Wrong size on FPlayerHelpUpAnimRefs");
static_assert(offsetof(FPlayerHelpUpAnimRefs, Forward) == 0x000000, "Member 'FPlayerHelpUpAnimRefs::Forward' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimRefs, Backward) == 0x0001C8, "Member 'FPlayerHelpUpAnimRefs::Backward' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimRefs, Right) == 0x000390, "Member 'FPlayerHelpUpAnimRefs::Right' has a wrong offset!");
static_assert(offsetof(FPlayerHelpUpAnimRefs, Left) == 0x000558, "Member 'FPlayerHelpUpAnimRefs::Left' has a wrong offset!");

// ScriptStruct OPP.CoopMoveAnimRefs
// 0x12A8 (0x12A8 - 0x0000)
struct FCoopMoveAnimRefs final
{
public:
	struct FRBAnimRef                             HighJump_Catch_StepIn_Leader;                      // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Catch_StepIn_Leader : 1;        // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Catch_StepOut_Leader;                     // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Catch_StepOut_Leader : 1;       // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Catch_FromJump_Leader;                    // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Catch_FromJump_Leader : 1;      // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Catch_FromToss_Leader;                    // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Catch_FromToss_Leader : 1;      // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Toss_StepIn_Front_Leader;                 // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Toss_StepIn_Front_Leader : 1;   // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Toss_StepIn_Back_Leader;                  // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Toss_StepIn_Back_Leader : 1;    // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Toss_Leader;                              // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Toss_Leader : 1;                // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Catch_Follower;                           // 0x0188(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Catch_Follower : 1;             // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_Toss_Follower;                            // 0x01C0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_Toss_Follower : 1;              // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             HighJump_TossCatch_Follower;                       // 0x01F8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighJump_TossCatch_Follower : 1;         // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             CoopClimbOver_Toss_Follower;                       // 0x0230(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CoopClimbOver_Toss_Follower : 1;         // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_Follower_Wall;                       // 0x0268(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_Follower_Wall : 1;         // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_Follower_NoWall;                     // 0x02A0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_Follower_NoWall : 1;       // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_Follower_Catch;                      // 0x02D8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_Follower_Catch : 1;        // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_StepIn_Left_Leader;                  // 0x0310(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_StepIn_Left_Leader : 1;    // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_StepIn_Right_Leader;                 // 0x0348(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_StepIn_Right_Leader : 1;   // 0x0378(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_Left_Leader;                         // 0x0380(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_Left_Leader : 1;           // 0x03B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Toss_Right_Leader;                        // 0x03B8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Toss_Right_Leader : 1;          // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Jump_Follower;                            // 0x03F0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Jump_Follower : 1;              // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Catch_StepIn_Leader;                      // 0x0428(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Catch_StepIn_Leader : 1;        // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Catch_Leader_FromJump;                    // 0x0460(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Catch_Leader_FromJump : 1;      // 0x0490(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             LongJump_Catch_Leader_FromToss;                    // 0x0498(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongJump_Catch_Leader_FromToss : 1;      // 0x04C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Bash_Enter_Left;                                   // 0x04D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Enter_Left : 1;                     // 0x04D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Bash_Action_Left;                                  // 0x04E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Action_Left : 1;                    // 0x04E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Bash_Enter_Right;                                  // 0x04F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Enter_Right : 1;                    // 0x04F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Bash_Action_Right;                                 // 0x0500(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Bash_Action_Right : 1;                   // 0x0508(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHelpUpAnimRefs                  PlayerHelpUp;                                      // 0x0510(0x0720)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerReviveAnimRefs                  PlayerRevive;                                      // 0x0C30(0x0640)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRBAnimRef                             Trade_Give_Item;                                   // 0x1270(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Trade_Give_Item : 1;                     // 0x12A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12A1[0x7];                                     // 0x12A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoopMoveAnimRefs) == 0x000008, "Wrong alignment on FCoopMoveAnimRefs");
static_assert(sizeof(FCoopMoveAnimRefs) == 0x0012A8, "Wrong size on FCoopMoveAnimRefs");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Catch_StepIn_Leader) == 0x000000, "Member 'FCoopMoveAnimRefs::HighJump_Catch_StepIn_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Catch_StepOut_Leader) == 0x000038, "Member 'FCoopMoveAnimRefs::HighJump_Catch_StepOut_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Catch_FromJump_Leader) == 0x000070, "Member 'FCoopMoveAnimRefs::HighJump_Catch_FromJump_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Catch_FromToss_Leader) == 0x0000A8, "Member 'FCoopMoveAnimRefs::HighJump_Catch_FromToss_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Toss_StepIn_Front_Leader) == 0x0000E0, "Member 'FCoopMoveAnimRefs::HighJump_Toss_StepIn_Front_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Toss_StepIn_Back_Leader) == 0x000118, "Member 'FCoopMoveAnimRefs::HighJump_Toss_StepIn_Back_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Toss_Leader) == 0x000150, "Member 'FCoopMoveAnimRefs::HighJump_Toss_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Catch_Follower) == 0x000188, "Member 'FCoopMoveAnimRefs::HighJump_Catch_Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_Toss_Follower) == 0x0001C0, "Member 'FCoopMoveAnimRefs::HighJump_Toss_Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, HighJump_TossCatch_Follower) == 0x0001F8, "Member 'FCoopMoveAnimRefs::HighJump_TossCatch_Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, CoopClimbOver_Toss_Follower) == 0x000230, "Member 'FCoopMoveAnimRefs::CoopClimbOver_Toss_Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_Follower_Wall) == 0x000268, "Member 'FCoopMoveAnimRefs::LongJump_Toss_Follower_Wall' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_Follower_NoWall) == 0x0002A0, "Member 'FCoopMoveAnimRefs::LongJump_Toss_Follower_NoWall' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_Follower_Catch) == 0x0002D8, "Member 'FCoopMoveAnimRefs::LongJump_Toss_Follower_Catch' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_StepIn_Left_Leader) == 0x000310, "Member 'FCoopMoveAnimRefs::LongJump_Toss_StepIn_Left_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_StepIn_Right_Leader) == 0x000348, "Member 'FCoopMoveAnimRefs::LongJump_Toss_StepIn_Right_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_Left_Leader) == 0x000380, "Member 'FCoopMoveAnimRefs::LongJump_Toss_Left_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Toss_Right_Leader) == 0x0003B8, "Member 'FCoopMoveAnimRefs::LongJump_Toss_Right_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Jump_Follower) == 0x0003F0, "Member 'FCoopMoveAnimRefs::LongJump_Jump_Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Catch_StepIn_Leader) == 0x000428, "Member 'FCoopMoveAnimRefs::LongJump_Catch_StepIn_Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Catch_Leader_FromJump) == 0x000460, "Member 'FCoopMoveAnimRefs::LongJump_Catch_Leader_FromJump' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, LongJump_Catch_Leader_FromToss) == 0x000498, "Member 'FCoopMoveAnimRefs::LongJump_Catch_Leader_FromToss' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, Bash_Enter_Left) == 0x0004D0, "Member 'FCoopMoveAnimRefs::Bash_Enter_Left' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, Bash_Action_Left) == 0x0004E0, "Member 'FCoopMoveAnimRefs::Bash_Action_Left' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, Bash_Enter_Right) == 0x0004F0, "Member 'FCoopMoveAnimRefs::Bash_Enter_Right' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, Bash_Action_Right) == 0x000500, "Member 'FCoopMoveAnimRefs::Bash_Action_Right' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, PlayerHelpUp) == 0x000510, "Member 'FCoopMoveAnimRefs::PlayerHelpUp' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, PlayerRevive) == 0x000C30, "Member 'FCoopMoveAnimRefs::PlayerRevive' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimRefs, Trade_Give_Item) == 0x001270, "Member 'FCoopMoveAnimRefs::Trade_Give_Item' has a wrong offset!");

// ScriptStruct OPP.PlayerHitReactionSetAnimRefs
// 0x01C0 (0x01C0 - 0x0000)
struct FPlayerHitReactionSetAnimRefs final
{
public:
	struct FRBAnimRef                             Start_Forward;                                     // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Start_Forward : 1;                       // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Start_Right;                                       // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Start_Right : 1;                         // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Start_Back;                                        // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Start_Back : 1;                          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             Start_Left;                                        // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Start_Left : 1;                          // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             End_Forward;                                       // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_End_Forward : 1;                         // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             End_Right;                                         // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_End_Right : 1;                           // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             End_Back;                                          // 0x0150(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_End_Back : 1;                            // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             End_Left;                                          // 0x0188(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_End_Left : 1;                            // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitReactionSetAnimRefs) == 0x000008, "Wrong alignment on FPlayerHitReactionSetAnimRefs");
static_assert(sizeof(FPlayerHitReactionSetAnimRefs) == 0x0001C0, "Wrong size on FPlayerHitReactionSetAnimRefs");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, Start_Forward) == 0x000000, "Member 'FPlayerHitReactionSetAnimRefs::Start_Forward' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, Start_Right) == 0x000038, "Member 'FPlayerHitReactionSetAnimRefs::Start_Right' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, Start_Back) == 0x000070, "Member 'FPlayerHitReactionSetAnimRefs::Start_Back' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, Start_Left) == 0x0000A8, "Member 'FPlayerHitReactionSetAnimRefs::Start_Left' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, End_Forward) == 0x0000E0, "Member 'FPlayerHitReactionSetAnimRefs::End_Forward' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, End_Right) == 0x000118, "Member 'FPlayerHitReactionSetAnimRefs::End_Right' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, End_Back) == 0x000150, "Member 'FPlayerHitReactionSetAnimRefs::End_Back' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionSetAnimRefs, End_Left) == 0x000188, "Member 'FPlayerHitReactionSetAnimRefs::End_Left' has a wrong offset!");

// ScriptStruct OPP.PlayerHitReactionsAnimRefs
// 0x08E8 (0x08E8 - 0x0000)
struct FPlayerHitReactionsAnimRefs final
{
public:
	struct FPlayerHitReactionSetAnimRefs          Light;                                             // 0x0000(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Light : 1;                               // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHitReactionSetAnimRefs          Medium;                                            // 0x01C8(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Medium : 1;                              // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHitReactionSetAnimRefs          Heavy;                                             // 0x0390(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Heavy : 1;                               // 0x0550(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHitReactionSetAnimRefs          KnockedDown;                                       // 0x0558(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_KnockedDown : 1;                         // 0x0718(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_719[0x7];                                      // 0x0719(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerHitReactionSetAnimRefs          Dead;                                              // 0x0720(0x01C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Dead : 1;                                // 0x08E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8E1[0x7];                                      // 0x08E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitReactionsAnimRefs) == 0x000008, "Wrong alignment on FPlayerHitReactionsAnimRefs");
static_assert(sizeof(FPlayerHitReactionsAnimRefs) == 0x0008E8, "Wrong size on FPlayerHitReactionsAnimRefs");
static_assert(offsetof(FPlayerHitReactionsAnimRefs, Light) == 0x000000, "Member 'FPlayerHitReactionsAnimRefs::Light' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionsAnimRefs, Medium) == 0x0001C8, "Member 'FPlayerHitReactionsAnimRefs::Medium' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionsAnimRefs, Heavy) == 0x000390, "Member 'FPlayerHitReactionsAnimRefs::Heavy' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionsAnimRefs, KnockedDown) == 0x000558, "Member 'FPlayerHitReactionsAnimRefs::KnockedDown' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionsAnimRefs, Dead) == 0x000720, "Member 'FPlayerHitReactionsAnimRefs::Dead' has a wrong offset!");

// ScriptStruct OPP.NightVisionAnimRefs
// 0x0150 (0x0150 - 0x0000)
struct FNightVisionAnimRefs final
{
public:
	struct FRBAnimRef                             GoggleTurnOn;                                      // 0x0000(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GoggleTurnOn : 1;                        // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             GoggleTurnOff;                                     // 0x0038(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GoggleTurnOff : 1;                       // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ArmTurnOn;                                         // 0x0070(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ArmTurnOn : 1;                           // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ArmTurnOff;                                        // 0x00A8(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ArmTurnOff : 1;                          // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ArmTurnOnCrouched;                                 // 0x00E0(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ArmTurnOnCrouched : 1;                   // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAnimRef                             ArmTurnOffCrouched;                                // 0x0118(0x0030)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ArmTurnOffCrouched : 1;                  // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNightVisionAnimRefs) == 0x000008, "Wrong alignment on FNightVisionAnimRefs");
static_assert(sizeof(FNightVisionAnimRefs) == 0x000150, "Wrong size on FNightVisionAnimRefs");
static_assert(offsetof(FNightVisionAnimRefs, GoggleTurnOn) == 0x000000, "Member 'FNightVisionAnimRefs::GoggleTurnOn' has a wrong offset!");
static_assert(offsetof(FNightVisionAnimRefs, GoggleTurnOff) == 0x000038, "Member 'FNightVisionAnimRefs::GoggleTurnOff' has a wrong offset!");
static_assert(offsetof(FNightVisionAnimRefs, ArmTurnOn) == 0x000070, "Member 'FNightVisionAnimRefs::ArmTurnOn' has a wrong offset!");
static_assert(offsetof(FNightVisionAnimRefs, ArmTurnOff) == 0x0000A8, "Member 'FNightVisionAnimRefs::ArmTurnOff' has a wrong offset!");
static_assert(offsetof(FNightVisionAnimRefs, ArmTurnOnCrouched) == 0x0000E0, "Member 'FNightVisionAnimRefs::ArmTurnOnCrouched' has a wrong offset!");
static_assert(offsetof(FNightVisionAnimRefs, ArmTurnOffCrouched) == 0x000118, "Member 'FNightVisionAnimRefs::ArmTurnOffCrouched' has a wrong offset!");

// ScriptStruct OPP.RBAnimReferencesData
// 0x35C8 (0x35C8 - 0x0000)
struct FRBAnimReferencesData final
{
public:
	struct FLocomotionAnimRefs                    Locomotion;                                        // 0x0000(0x09C0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCombatAnimRefs                        Combat;                                            // 0x09C0(0x0270)(Edit, NativeAccessSpecifierPublic)
	struct FInteractionsAnimRefs                  Interactions;                                      // 0x0C30(0x01C8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorInteractionsAnimRefs              DoorInteractions;                                  // 0x0DF8(0x0350)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCAttackAnimRefs                     NPCAttacks;                                        // 0x1148(0x0080)(Edit, NativeAccessSpecifierPublic)
	struct FNPCActionsAnimRefs                    NPCActions;                                        // 0x11C8(0x0288)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FPouncerGnPAnimRefs                    PouncerGnP;                                        // 0x1450(0x02A0)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoopTrapAnimRefs                      CoopTrap;                                          // 0x16F0(0x01F8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoopMoveAnimRefs                      CoopMove;                                          // 0x18E8(0x12A8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerHitReactionsAnimRefs            PlayerHitReaction;                                 // 0x2B90(0x08E8)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNightVisionAnimRefs                   NightVision;                                       // 0x3478(0x0150)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBAnimReferencesData) == 0x000008, "Wrong alignment on FRBAnimReferencesData");
static_assert(sizeof(FRBAnimReferencesData) == 0x0035C8, "Wrong size on FRBAnimReferencesData");
static_assert(offsetof(FRBAnimReferencesData, Locomotion) == 0x000000, "Member 'FRBAnimReferencesData::Locomotion' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, Combat) == 0x0009C0, "Member 'FRBAnimReferencesData::Combat' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, Interactions) == 0x000C30, "Member 'FRBAnimReferencesData::Interactions' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, DoorInteractions) == 0x000DF8, "Member 'FRBAnimReferencesData::DoorInteractions' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, NPCAttacks) == 0x001148, "Member 'FRBAnimReferencesData::NPCAttacks' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, NPCActions) == 0x0011C8, "Member 'FRBAnimReferencesData::NPCActions' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, PouncerGnP) == 0x001450, "Member 'FRBAnimReferencesData::PouncerGnP' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, CoopTrap) == 0x0016F0, "Member 'FRBAnimReferencesData::CoopTrap' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, CoopMove) == 0x0018E8, "Member 'FRBAnimReferencesData::CoopMove' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, PlayerHitReaction) == 0x002B90, "Member 'FRBAnimReferencesData::PlayerHitReaction' has a wrong offset!");
static_assert(offsetof(FRBAnimReferencesData, NightVision) == 0x003478, "Member 'FRBAnimReferencesData::NightVision' has a wrong offset!");

// ScriptStruct OPP.HallucinationTrapsRuntimeData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FHallucinationTrapsRuntimeData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHallucinationTrapsRuntimeData) == 0x000004, "Wrong alignment on FHallucinationTrapsRuntimeData");
static_assert(sizeof(FHallucinationTrapsRuntimeData) == 0x000008, "Wrong size on FHallucinationTrapsRuntimeData");

// ScriptStruct OPP.PickupObjectiveConfig
// 0x000C (0x000C - 0x0000)
struct FPickupObjectiveConfig final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckIfReachable;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSpacialReasoningForDistance;                    // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSearchDistance;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSearchDistance;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupObjectiveConfig) == 0x000004, "Wrong alignment on FPickupObjectiveConfig");
static_assert(sizeof(FPickupObjectiveConfig) == 0x00000C, "Wrong size on FPickupObjectiveConfig");
static_assert(offsetof(FPickupObjectiveConfig, ItemType) == 0x000000, "Member 'FPickupObjectiveConfig::ItemType' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveConfig, CheckIfReachable) == 0x000001, "Member 'FPickupObjectiveConfig::CheckIfReachable' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveConfig, UseSpacialReasoningForDistance) == 0x000002, "Member 'FPickupObjectiveConfig::UseSpacialReasoningForDistance' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveConfig, MaxSearchDistance) == 0x000004, "Member 'FPickupObjectiveConfig::MaxSearchDistance' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveConfig, MinSearchDistance) == 0x000008, "Member 'FPickupObjectiveConfig::MinSearchDistance' has a wrong offset!");

// ScriptStruct OPP.NewsItem
// 0x00E8 (0x00E8 - 0x0000)
struct FNewsItem final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENewsItemLocation                             Location;                                          // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CategoryTitle;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImageUrl;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      ImageTexture;                                      // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENewsItemCTAType                              CTAType;                                           // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENewsItemCTAMenuType                          CTAMenuType;                                       // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CTADetails;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExternalUrl;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FeatureSwitch;                                     // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BorderColor;                                       // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderBackgroundColor;                             // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderTextColor;                                   // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CategoryTextColor;                                 // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CategoryBackgroundColor;                           // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewsItem) == 0x000008, "Wrong alignment on FNewsItem");
static_assert(sizeof(FNewsItem) == 0x0000E8, "Wrong size on FNewsItem");
static_assert(offsetof(FNewsItem, ID) == 0x000000, "Member 'FNewsItem::ID' has a wrong offset!");
static_assert(offsetof(FNewsItem, Location) == 0x000008, "Member 'FNewsItem::Location' has a wrong offset!");
static_assert(offsetof(FNewsItem, CategoryTitle) == 0x000010, "Member 'FNewsItem::CategoryTitle' has a wrong offset!");
static_assert(offsetof(FNewsItem, Title) == 0x000020, "Member 'FNewsItem::Title' has a wrong offset!");
static_assert(offsetof(FNewsItem, Description) == 0x000030, "Member 'FNewsItem::Description' has a wrong offset!");
static_assert(offsetof(FNewsItem, ImageUrl) == 0x000040, "Member 'FNewsItem::ImageUrl' has a wrong offset!");
static_assert(offsetof(FNewsItem, ImageTexture) == 0x000050, "Member 'FNewsItem::ImageTexture' has a wrong offset!");
static_assert(offsetof(FNewsItem, CTAType) == 0x000058, "Member 'FNewsItem::CTAType' has a wrong offset!");
static_assert(offsetof(FNewsItem, CTAMenuType) == 0x000059, "Member 'FNewsItem::CTAMenuType' has a wrong offset!");
static_assert(offsetof(FNewsItem, CTADetails) == 0x000060, "Member 'FNewsItem::CTADetails' has a wrong offset!");
static_assert(offsetof(FNewsItem, ExternalUrl) == 0x000070, "Member 'FNewsItem::ExternalUrl' has a wrong offset!");
static_assert(offsetof(FNewsItem, Priority) == 0x000080, "Member 'FNewsItem::Priority' has a wrong offset!");
static_assert(offsetof(FNewsItem, FeatureSwitch) == 0x000088, "Member 'FNewsItem::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FNewsItem, BorderColor) == 0x000098, "Member 'FNewsItem::BorderColor' has a wrong offset!");
static_assert(offsetof(FNewsItem, HeaderBackgroundColor) == 0x0000A8, "Member 'FNewsItem::HeaderBackgroundColor' has a wrong offset!");
static_assert(offsetof(FNewsItem, HeaderTextColor) == 0x0000B8, "Member 'FNewsItem::HeaderTextColor' has a wrong offset!");
static_assert(offsetof(FNewsItem, CategoryTextColor) == 0x0000C8, "Member 'FNewsItem::CategoryTextColor' has a wrong offset!");
static_assert(offsetof(FNewsItem, CategoryBackgroundColor) == 0x0000D8, "Member 'FNewsItem::CategoryBackgroundColor' has a wrong offset!");

// ScriptStruct OPP.PlayerDebugInfo
// 0x0030 (0x0030 - 0x0000)
struct FPlayerDebugInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHotPotato;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     ServerPhysHitResults;                              // 0x0010(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         HealthRegenTimeLeft;                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUpdatedTime;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDebugInfo) == 0x000008, "Wrong alignment on FPlayerDebugInfo");
static_assert(sizeof(FPlayerDebugInfo) == 0x000030, "Wrong size on FPlayerDebugInfo");
static_assert(offsetof(FPlayerDebugInfo, Player) == 0x000000, "Member 'FPlayerDebugInfo::Player' has a wrong offset!");
static_assert(offsetof(FPlayerDebugInfo, bHasHotPotato) == 0x000008, "Member 'FPlayerDebugInfo::bHasHotPotato' has a wrong offset!");
static_assert(offsetof(FPlayerDebugInfo, ServerPhysHitResults) == 0x000010, "Member 'FPlayerDebugInfo::ServerPhysHitResults' has a wrong offset!");
static_assert(offsetof(FPlayerDebugInfo, HealthRegenTimeLeft) == 0x000020, "Member 'FPlayerDebugInfo::HealthRegenTimeLeft' has a wrong offset!");
static_assert(offsetof(FPlayerDebugInfo, LastUpdatedTime) == 0x000024, "Member 'FPlayerDebugInfo::LastUpdatedTime' has a wrong offset!");

// ScriptStruct OPP.HallucinationEffectData
// 0x01A8 (0x01A8 - 0x0000)
struct FHallucinationEffectData final
{
public:
	EHallucinationType                            HallucinationType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     ActivationDelay;                                   // 0x0008(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     ActivationDelayMax;                                // 0x00D0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnlyOnce;                                     // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipActivationDelayOnIncrease;                    // 0x0199(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URBHallucinationConfig*                 HallucinationConfig;                               // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHallucinationEffectData) == 0x000008, "Wrong alignment on FHallucinationEffectData");
static_assert(sizeof(FHallucinationEffectData) == 0x0001A8, "Wrong size on FHallucinationEffectData");
static_assert(offsetof(FHallucinationEffectData, HallucinationType) == 0x000000, "Member 'FHallucinationEffectData::HallucinationType' has a wrong offset!");
static_assert(offsetof(FHallucinationEffectData, ActivationDelay) == 0x000008, "Member 'FHallucinationEffectData::ActivationDelay' has a wrong offset!");
static_assert(offsetof(FHallucinationEffectData, ActivationDelayMax) == 0x0000D0, "Member 'FHallucinationEffectData::ActivationDelayMax' has a wrong offset!");
static_assert(offsetof(FHallucinationEffectData, bPlayOnlyOnce) == 0x000198, "Member 'FHallucinationEffectData::bPlayOnlyOnce' has a wrong offset!");
static_assert(offsetof(FHallucinationEffectData, bSkipActivationDelayOnIncrease) == 0x000199, "Member 'FHallucinationEffectData::bSkipActivationDelayOnIncrease' has a wrong offset!");
static_assert(offsetof(FHallucinationEffectData, HallucinationConfig) == 0x0001A0, "Member 'FHallucinationEffectData::HallucinationConfig' has a wrong offset!");

// ScriptStruct OPP.WaterValveSectionRuntimeData
// 0x0058 (0x0058 - 0x0000)
struct FWaterValveSectionRuntimeData final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableForThisDifficulty;                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaterFlowing;                                     // 0x000A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x000B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PumpActor;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ObjectiveValveActors;                              // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class URBValvePanelComponent*>         ObjectiveValvePanels;                              // 0x0028(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CompletedObjectiveValveActors;                     // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DiscoveredObjectiveValveActors;                    // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterValveSectionRuntimeData) == 0x000008, "Wrong alignment on FWaterValveSectionRuntimeData");
static_assert(sizeof(FWaterValveSectionRuntimeData) == 0x000058, "Wrong size on FWaterValveSectionRuntimeData");
static_assert(offsetof(FWaterValveSectionRuntimeData, SectionName) == 0x000000, "Member 'FWaterValveSectionRuntimeData::SectionName' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, bAvailableForThisDifficulty) == 0x000008, "Member 'FWaterValveSectionRuntimeData::bAvailableForThisDifficulty' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, bActive) == 0x000009, "Member 'FWaterValveSectionRuntimeData::bActive' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, bWaterFlowing) == 0x00000A, "Member 'FWaterValveSectionRuntimeData::bWaterFlowing' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, bCompleted) == 0x00000B, "Member 'FWaterValveSectionRuntimeData::bCompleted' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, PumpActor) == 0x000010, "Member 'FWaterValveSectionRuntimeData::PumpActor' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, ObjectiveValveActors) == 0x000018, "Member 'FWaterValveSectionRuntimeData::ObjectiveValveActors' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, ObjectiveValvePanels) == 0x000028, "Member 'FWaterValveSectionRuntimeData::ObjectiveValvePanels' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, CompletedObjectiveValveActors) == 0x000038, "Member 'FWaterValveSectionRuntimeData::CompletedObjectiveValveActors' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionRuntimeData, DiscoveredObjectiveValveActors) == 0x000048, "Member 'FWaterValveSectionRuntimeData::DiscoveredObjectiveValveActors' has a wrong offset!");

// ScriptStruct OPP.AIPatrolConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FAIPatrolConfig final
{
public:
	float                                         RandomContrib;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RandomContrib : 1;                       // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdealDistanceFromBot;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IdealDistanceFromBot : 1;                // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdealDistanceFromBotContrib;                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IdealDistanceFromBotContrib : 1;         // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseToOtherBotDistance;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseToOtherBotDistance : 1;             // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseToOtherBotContrib;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseToOtherBotContrib : 1;              // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearPlayerDistance;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NearPlayerDistance : 1;                  // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearPlayerContrib;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NearPlayerContrib : 1;                   // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearChasedPlayerDistance;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NearChasedPlayerDistance : 1;            // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearChasedPlayerContrib;                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NearChasedPlayerContrib : 1;             // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnvisitedContrib;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnvisitedContrib : 1;                    // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentlyVisitedDelay;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RecentlyVisitedDelay : 1;                // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentlyVisitedContrib;                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RecentlyVisitedContrib : 1;              // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentlyVisitedByAnyDelay;                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RecentlyVisitedByAnyDelay : 1;           // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentlyVisitedByAnyContrib;                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RecentlyVisitedByAnyContrib : 1;         // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DifferentHeightThreshold;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DifferentHeightThreshold : 1;            // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DifferentHeightToBotContrib;                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DifferentHeightToBotContrib : 1;         // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomeSeekingNormalDist;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HomeSeekingNormalDist : 1;               // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomeSeekingContrib;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HomeSeekingContrib : 1;                  // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadingOdds;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpreadingOdds : 1;                       // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadingContrib;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpreadingContrib : 1;                    // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionToAvoidContrib;                           // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DirectionToAvoidContrib : 1;             // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultWaypointMinWaitTime;                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultWaypointMinWaitTime : 1;          // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultWaypointMaxWaitTime;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultWaypointMaxWaitTime : 1;          // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRepathIfGoingThroughActiveChase;                  // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRepathIfGoingThroughActiveChase : 1;    // 0x00B6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPatrolConfig) == 0x000004, "Wrong alignment on FAIPatrolConfig");
static_assert(sizeof(FAIPatrolConfig) == 0x0000B8, "Wrong size on FAIPatrolConfig");
static_assert(offsetof(FAIPatrolConfig, RandomContrib) == 0x000000, "Member 'FAIPatrolConfig::RandomContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, IdealDistanceFromBot) == 0x000008, "Member 'FAIPatrolConfig::IdealDistanceFromBot' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, IdealDistanceFromBotContrib) == 0x000010, "Member 'FAIPatrolConfig::IdealDistanceFromBotContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, CloseToOtherBotDistance) == 0x000018, "Member 'FAIPatrolConfig::CloseToOtherBotDistance' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, CloseToOtherBotContrib) == 0x000020, "Member 'FAIPatrolConfig::CloseToOtherBotContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, NearPlayerDistance) == 0x000028, "Member 'FAIPatrolConfig::NearPlayerDistance' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, NearPlayerContrib) == 0x000030, "Member 'FAIPatrolConfig::NearPlayerContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, NearChasedPlayerDistance) == 0x000038, "Member 'FAIPatrolConfig::NearChasedPlayerDistance' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, NearChasedPlayerContrib) == 0x000040, "Member 'FAIPatrolConfig::NearChasedPlayerContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, UnvisitedContrib) == 0x000048, "Member 'FAIPatrolConfig::UnvisitedContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, RecentlyVisitedDelay) == 0x000050, "Member 'FAIPatrolConfig::RecentlyVisitedDelay' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, RecentlyVisitedContrib) == 0x000058, "Member 'FAIPatrolConfig::RecentlyVisitedContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, RecentlyVisitedByAnyDelay) == 0x000060, "Member 'FAIPatrolConfig::RecentlyVisitedByAnyDelay' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, RecentlyVisitedByAnyContrib) == 0x000068, "Member 'FAIPatrolConfig::RecentlyVisitedByAnyContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, DifferentHeightThreshold) == 0x000070, "Member 'FAIPatrolConfig::DifferentHeightThreshold' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, DifferentHeightToBotContrib) == 0x000078, "Member 'FAIPatrolConfig::DifferentHeightToBotContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, HomeSeekingNormalDist) == 0x000080, "Member 'FAIPatrolConfig::HomeSeekingNormalDist' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, HomeSeekingContrib) == 0x000088, "Member 'FAIPatrolConfig::HomeSeekingContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, SpreadingOdds) == 0x000090, "Member 'FAIPatrolConfig::SpreadingOdds' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, SpreadingContrib) == 0x000098, "Member 'FAIPatrolConfig::SpreadingContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, DirectionToAvoidContrib) == 0x0000A0, "Member 'FAIPatrolConfig::DirectionToAvoidContrib' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, DefaultWaypointMinWaitTime) == 0x0000A8, "Member 'FAIPatrolConfig::DefaultWaypointMinWaitTime' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, DefaultWaypointMaxWaitTime) == 0x0000B0, "Member 'FAIPatrolConfig::DefaultWaypointMaxWaitTime' has a wrong offset!");
static_assert(offsetof(FAIPatrolConfig, bRepathIfGoingThroughActiveChase) == 0x0000B5, "Member 'FAIPatrolConfig::bRepathIfGoingThroughActiveChase' has a wrong offset!");

// ScriptStruct OPP.GameSyncValues
// 0x0010 (0x0010 - 0x0000)
struct FGameSyncValues final
{
public:
	TArray<class FName>                           GameSyncValues;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameSyncValues) == 0x000008, "Wrong alignment on FGameSyncValues");
static_assert(sizeof(FGameSyncValues) == 0x000010, "Wrong size on FGameSyncValues");
static_assert(offsetof(FGameSyncValues, GameSyncValues) == 0x000000, "Member 'FGameSyncValues::GameSyncValues' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnalysisSightData
// 0x0038 (0x0038 - 0x0000)
struct FInvestigationAnalysisSightData final
{
public:
	float                                         RelAngle;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightClearance;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInterestPoint;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URBNPCInterestPointComponent> InterestPointComp;                                 // 0x0010(0x0028)(Edit, ExportObject, EditConst, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationAnalysisSightData) == 0x000008, "Wrong alignment on FInvestigationAnalysisSightData");
static_assert(sizeof(FInvestigationAnalysisSightData) == 0x000038, "Wrong size on FInvestigationAnalysisSightData");
static_assert(offsetof(FInvestigationAnalysisSightData, RelAngle) == 0x000000, "Member 'FInvestigationAnalysisSightData::RelAngle' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSightData, SightClearance) == 0x000004, "Member 'FInvestigationAnalysisSightData::SightClearance' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSightData, bHasInterestPoint) == 0x000008, "Member 'FInvestigationAnalysisSightData::bHasInterestPoint' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSightData, InterestPointComp) == 0x000010, "Member 'FInvestigationAnalysisSightData::InterestPointComp' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnalysisProjectedData
// 0x0018 (0x0018 - 0x0000)
struct FInvestigationAnalysisProjectedData final
{
public:
	float                                         DistForward;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeHeight;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInvestigationAnalysisSightData> SightData;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationAnalysisProjectedData) == 0x000008, "Wrong alignment on FInvestigationAnalysisProjectedData");
static_assert(sizeof(FInvestigationAnalysisProjectedData) == 0x000018, "Wrong size on FInvestigationAnalysisProjectedData");
static_assert(offsetof(FInvestigationAnalysisProjectedData, DistForward) == 0x000000, "Member 'FInvestigationAnalysisProjectedData::DistForward' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisProjectedData, RelativeHeight) == 0x000004, "Member 'FInvestigationAnalysisProjectedData::RelativeHeight' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisProjectedData, SightData) == 0x000008, "Member 'FInvestigationAnalysisProjectedData::SightData' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnalysisAngleData
// 0x0018 (0x0018 - 0x0000)
struct FInvestigationAnalysisAngleData final
{
public:
	float                                         AngleWS;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavmeshClearance;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInvestigationAnalysisProjectedData> ProjectedData;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationAnalysisAngleData) == 0x000008, "Wrong alignment on FInvestigationAnalysisAngleData");
static_assert(sizeof(FInvestigationAnalysisAngleData) == 0x000018, "Wrong size on FInvestigationAnalysisAngleData");
static_assert(offsetof(FInvestigationAnalysisAngleData, AngleWS) == 0x000000, "Member 'FInvestigationAnalysisAngleData::AngleWS' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisAngleData, NavmeshClearance) == 0x000004, "Member 'FInvestigationAnalysisAngleData::NavmeshClearance' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisAngleData, ProjectedData) == 0x000008, "Member 'FInvestigationAnalysisAngleData::ProjectedData' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnalysis
// 0x0018 (0x0018 - 0x0000)
struct FInvestigationAnalysis final
{
public:
	bool                                          bValidAnalysis;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInvestigationAnalysisAngleData> AngleData;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationAnalysis) == 0x000008, "Wrong alignment on FInvestigationAnalysis");
static_assert(sizeof(FInvestigationAnalysis) == 0x000018, "Wrong size on FInvestigationAnalysis");
static_assert(offsetof(FInvestigationAnalysis, bValidAnalysis) == 0x000000, "Member 'FInvestigationAnalysis::bValidAnalysis' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysis, AngleData) == 0x000008, "Member 'FInvestigationAnalysis::AngleData' has a wrong offset!");

// ScriptStruct OPP.AreaOfEffectDamage
// 0x0058 (0x0058 - 0x0000)
struct FAreaOfEffectDamage final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBPawn*>                        Targets;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBPawn*>                        Victims;                                           // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaOfEffectDamage) == 0x000008, "Wrong alignment on FAreaOfEffectDamage");
static_assert(sizeof(FAreaOfEffectDamage) == 0x000058, "Wrong size on FAreaOfEffectDamage");
static_assert(offsetof(FAreaOfEffectDamage, Targets) == 0x000038, "Member 'FAreaOfEffectDamage::Targets' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectDamage, Victims) == 0x000048, "Member 'FAreaOfEffectDamage::Victims' has a wrong offset!");

// ScriptStruct OPP.InteractionData
// 0x0050 (0x0050 - 0x0000)
struct FInteractionData final
{
public:
	TArray<class UAnimSequenceBase*>              AnimSequenceBucket;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              ThirdPersonSpecificAnimSequenceBucket;             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAnimSequenceUpperBody;                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimSequenceUpperBodyAllowsRotation;              // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimSequencePlayRate;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimSequenceLoopCount;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustmentType                               AdjustmentType;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnimLocation;                                      // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnimForward;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToGround;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockIntoOperatingLocomotion;                      // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  StartSpecialMove;                                  // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  FinishSpecialMove;                                 // 0x004B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterruptible;                                  // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnimAfterAdjustPosition;                      // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionData) == 0x000008, "Wrong alignment on FInteractionData");
static_assert(sizeof(FInteractionData) == 0x000050, "Wrong size on FInteractionData");
static_assert(offsetof(FInteractionData, AnimSequenceBucket) == 0x000000, "Member 'FInteractionData::AnimSequenceBucket' has a wrong offset!");
static_assert(offsetof(FInteractionData, ThirdPersonSpecificAnimSequenceBucket) == 0x000010, "Member 'FInteractionData::ThirdPersonSpecificAnimSequenceBucket' has a wrong offset!");
static_assert(offsetof(FInteractionData, bAnimSequenceUpperBody) == 0x000020, "Member 'FInteractionData::bAnimSequenceUpperBody' has a wrong offset!");
static_assert(offsetof(FInteractionData, bAnimSequenceUpperBodyAllowsRotation) == 0x000021, "Member 'FInteractionData::bAnimSequenceUpperBodyAllowsRotation' has a wrong offset!");
static_assert(offsetof(FInteractionData, AnimSequencePlayRate) == 0x000024, "Member 'FInteractionData::AnimSequencePlayRate' has a wrong offset!");
static_assert(offsetof(FInteractionData, AnimSequenceLoopCount) == 0x000028, "Member 'FInteractionData::AnimSequenceLoopCount' has a wrong offset!");
static_assert(offsetof(FInteractionData, AdjustmentType) == 0x00002C, "Member 'FInteractionData::AdjustmentType' has a wrong offset!");
static_assert(offsetof(FInteractionData, AnimLocation) == 0x000030, "Member 'FInteractionData::AnimLocation' has a wrong offset!");
static_assert(offsetof(FInteractionData, AnimForward) == 0x00003C, "Member 'FInteractionData::AnimForward' has a wrong offset!");
static_assert(offsetof(FInteractionData, bAlignToGround) == 0x000048, "Member 'FInteractionData::bAlignToGround' has a wrong offset!");
static_assert(offsetof(FInteractionData, bLockIntoOperatingLocomotion) == 0x000049, "Member 'FInteractionData::bLockIntoOperatingLocomotion' has a wrong offset!");
static_assert(offsetof(FInteractionData, StartSpecialMove) == 0x00004A, "Member 'FInteractionData::StartSpecialMove' has a wrong offset!");
static_assert(offsetof(FInteractionData, FinishSpecialMove) == 0x00004B, "Member 'FInteractionData::FinishSpecialMove' has a wrong offset!");
static_assert(offsetof(FInteractionData, bIsInterruptible) == 0x00004C, "Member 'FInteractionData::bIsInterruptible' has a wrong offset!");
static_assert(offsetof(FInteractionData, bPlayAnimAfterAdjustPosition) == 0x00004D, "Member 'FInteractionData::bPlayAnimAfterAdjustPosition' has a wrong offset!");

// ScriptStruct OPP.ProceduralRotationAnimData
// 0x003C (0x003C - 0x0000)
struct FProceduralRotationAnimData final
{
public:
	float                                         HeadingDelta;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralAnimInterpType                     InterpType;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScheduledPawnTime;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScheduledServerTime;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantSpeedContrib;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeLeft;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForNotify;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeDataAfterNotify;                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RecomputeDesiredOrientation;                       // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIndependentRotationControl;                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndependentRotationDuration;                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralRotationAnimData) == 0x000004, "Wrong alignment on FProceduralRotationAnimData");
static_assert(sizeof(FProceduralRotationAnimData) == 0x00003C, "Wrong size on FProceduralRotationAnimData");
static_assert(offsetof(FProceduralRotationAnimData, HeadingDelta) == 0x000000, "Member 'FProceduralRotationAnimData::HeadingDelta' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, InterpType) == 0x000004, "Member 'FProceduralRotationAnimData::InterpType' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, ScheduledPawnTime) == 0x000008, "Member 'FProceduralRotationAnimData::ScheduledPawnTime' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, ScheduledServerTime) == 0x00000C, "Member 'FProceduralRotationAnimData::ScheduledServerTime' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, ConstantSpeedContrib) == 0x000010, "Member 'FProceduralRotationAnimData::ConstantSpeedContrib' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, DelayTimeLeft) == 0x000014, "Member 'FProceduralRotationAnimData::DelayTimeLeft' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, TotalTime) == 0x000018, "Member 'FProceduralRotationAnimData::TotalTime' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, ElapsedTime) == 0x00001C, "Member 'FProceduralRotationAnimData::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, bWaitForNotify) == 0x000020, "Member 'FProceduralRotationAnimData::bWaitForNotify' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, bRecomputeDataAfterNotify) == 0x000021, "Member 'FProceduralRotationAnimData::bRecomputeDataAfterNotify' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, RecomputeDesiredOrientation) == 0x000024, "Member 'FProceduralRotationAnimData::RecomputeDesiredOrientation' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, bIndependentRotationControl) == 0x000030, "Member 'FProceduralRotationAnimData::bIndependentRotationControl' has a wrong offset!");
static_assert(offsetof(FProceduralRotationAnimData, IndependentRotationDuration) == 0x000034, "Member 'FProceduralRotationAnimData::IndependentRotationDuration' has a wrong offset!");

// ScriptStruct OPP.AIAudioConfig
// 0x007C (0x007C - 0x0000)
struct FAIAudioConfig final
{
public:
	bool                                          bRelevantForThreatLevel;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRelevantForThreatLevel : 1;             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThreatInAmbient;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThreatInAmbient : 1;                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseThreatDistAmbient;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseThreatDistAmbient : 1;              // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarThreatDistAmbient;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarThreatDistAmbient : 1;                // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThreatInUnaware;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThreatInUnaware : 1;                  // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseThreatDistUnaware;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseThreatDistUnaware : 1;              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarThreatDistUnaware;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarThreatDistUnaware : 1;                // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThreatInSuspicious;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThreatInSuspicious : 1;               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseThreatDistSuspicious;                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseThreatDistSuspicious : 1;           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarThreatDistSuspicious;                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarThreatDistSuspicious : 1;             // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThreatInInvestigate;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThreatInInvestigate : 1;              // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseThreatDistInvestigate;                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseThreatDistInvestigate : 1;          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarThreatDistInvestigate;                          // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarThreatDistInvestigate : 1;            // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThreatInChase;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThreatInChase : 1;                    // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseThreatDistChase;                              // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseThreatDistChase : 1;                // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarThreatDistChase;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarThreatDistChase : 1;                  // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAudioConfig) == 0x000004, "Wrong alignment on FAIAudioConfig");
static_assert(sizeof(FAIAudioConfig) == 0x00007C, "Wrong size on FAIAudioConfig");
static_assert(offsetof(FAIAudioConfig, bRelevantForThreatLevel) == 0x000000, "Member 'FAIAudioConfig::bRelevantForThreatLevel' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, MaxThreatInAmbient) == 0x000004, "Member 'FAIAudioConfig::MaxThreatInAmbient' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, CloseThreatDistAmbient) == 0x00000C, "Member 'FAIAudioConfig::CloseThreatDistAmbient' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, FarThreatDistAmbient) == 0x000014, "Member 'FAIAudioConfig::FarThreatDistAmbient' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, MaxThreatInUnaware) == 0x00001C, "Member 'FAIAudioConfig::MaxThreatInUnaware' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, CloseThreatDistUnaware) == 0x000024, "Member 'FAIAudioConfig::CloseThreatDistUnaware' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, FarThreatDistUnaware) == 0x00002C, "Member 'FAIAudioConfig::FarThreatDistUnaware' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, MaxThreatInSuspicious) == 0x000034, "Member 'FAIAudioConfig::MaxThreatInSuspicious' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, CloseThreatDistSuspicious) == 0x00003C, "Member 'FAIAudioConfig::CloseThreatDistSuspicious' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, FarThreatDistSuspicious) == 0x000044, "Member 'FAIAudioConfig::FarThreatDistSuspicious' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, MaxThreatInInvestigate) == 0x00004C, "Member 'FAIAudioConfig::MaxThreatInInvestigate' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, CloseThreatDistInvestigate) == 0x000054, "Member 'FAIAudioConfig::CloseThreatDistInvestigate' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, FarThreatDistInvestigate) == 0x00005C, "Member 'FAIAudioConfig::FarThreatDistInvestigate' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, MaxThreatInChase) == 0x000064, "Member 'FAIAudioConfig::MaxThreatInChase' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, CloseThreatDistChase) == 0x00006C, "Member 'FAIAudioConfig::CloseThreatDistChase' has a wrong offset!");
static_assert(offsetof(FAIAudioConfig, FarThreatDistChase) == 0x000074, "Member 'FAIAudioConfig::FarThreatDistChase' has a wrong offset!");

// ScriptStruct OPP.AIVisionCone
// 0x0030 (0x0030 - 0x0000)
struct FAIVisionCone final
{
public:
	float                                         MaxForwardDistance;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxForwardDistance : 1;                  // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPeripheralDistance;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPeripheralDistance : 1;               // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerHorzAngle;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InnerHorzAngle : 1;                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterHorzAngle;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OuterHorzAngle : 1;                      // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerVertAngle;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InnerVertAngle : 1;                      // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterVertAngle;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OuterVertAngle : 1;                      // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIVisionCone) == 0x000004, "Wrong alignment on FAIVisionCone");
static_assert(sizeof(FAIVisionCone) == 0x000030, "Wrong size on FAIVisionCone");
static_assert(offsetof(FAIVisionCone, MaxForwardDistance) == 0x000000, "Member 'FAIVisionCone::MaxForwardDistance' has a wrong offset!");
static_assert(offsetof(FAIVisionCone, MaxPeripheralDistance) == 0x000008, "Member 'FAIVisionCone::MaxPeripheralDistance' has a wrong offset!");
static_assert(offsetof(FAIVisionCone, InnerHorzAngle) == 0x000010, "Member 'FAIVisionCone::InnerHorzAngle' has a wrong offset!");
static_assert(offsetof(FAIVisionCone, OuterHorzAngle) == 0x000018, "Member 'FAIVisionCone::OuterHorzAngle' has a wrong offset!");
static_assert(offsetof(FAIVisionCone, InnerVertAngle) == 0x000020, "Member 'FAIVisionCone::InnerVertAngle' has a wrong offset!");
static_assert(offsetof(FAIVisionCone, OuterVertAngle) == 0x000028, "Member 'FAIVisionCone::OuterVertAngle' has a wrong offset!");

// ScriptStruct OPP.AIVisionDebugData
// 0x00D0 (0x00D0 - 0x0000)
struct FAIVisionDebugData final
{
public:
	struct FAIVisionCone                          PartialVisibilityCone;                             // 0x0000(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIVisionCone                          FullVisibilityCone;                                // 0x0030(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIVisionCone                          DarknessPartialVisibilityCone;                     // 0x0060(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIVisionCone                          DarknessFullVisibilityCone;                        // 0x0090(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         CloseDistance_FullVisibility;                      // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseDistance_PartialVisibility;                   // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarknessCloseDistance_FullVisibility;              // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarknessCloseDistance_PartialVisibility;           // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIVisionDebugData) == 0x000004, "Wrong alignment on FAIVisionDebugData");
static_assert(sizeof(FAIVisionDebugData) == 0x0000D0, "Wrong size on FAIVisionDebugData");
static_assert(offsetof(FAIVisionDebugData, PartialVisibilityCone) == 0x000000, "Member 'FAIVisionDebugData::PartialVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, FullVisibilityCone) == 0x000030, "Member 'FAIVisionDebugData::FullVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, DarknessPartialVisibilityCone) == 0x000060, "Member 'FAIVisionDebugData::DarknessPartialVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, DarknessFullVisibilityCone) == 0x000090, "Member 'FAIVisionDebugData::DarknessFullVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, CloseDistance_FullVisibility) == 0x0000C0, "Member 'FAIVisionDebugData::CloseDistance_FullVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, CloseDistance_PartialVisibility) == 0x0000C4, "Member 'FAIVisionDebugData::CloseDistance_PartialVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, DarknessCloseDistance_FullVisibility) == 0x0000C8, "Member 'FAIVisionDebugData::DarknessCloseDistance_FullVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionDebugData, DarknessCloseDistance_PartialVisibility) == 0x0000CC, "Member 'FAIVisionDebugData::DarknessCloseDistance_PartialVisibility' has a wrong offset!");

// ScriptStruct OPP.RBBattlePassPageItemData
// 0x0020 (0x0020 - 0x0000)
struct FRBBattlePassPageItemData final
{
public:
	class FName                                   BattlePassId;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageIndex;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrencyCost;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBattlePassPageItemData) == 0x000004, "Wrong alignment on FRBBattlePassPageItemData");
static_assert(sizeof(FRBBattlePassPageItemData) == 0x000020, "Wrong size on FRBBattlePassPageItemData");
static_assert(offsetof(FRBBattlePassPageItemData, BattlePassId) == 0x000000, "Member 'FRBBattlePassPageItemData::BattlePassId' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageItemData, PageIndex) == 0x000008, "Member 'FRBBattlePassPageItemData::PageIndex' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageItemData, Index) == 0x00000C, "Member 'FRBBattlePassPageItemData::Index' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageItemData, CurrencyType) == 0x000010, "Member 'FRBBattlePassPageItemData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageItemData, CurrencyCost) == 0x000014, "Member 'FRBBattlePassPageItemData::CurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageItemData, ItemId) == 0x000018, "Member 'FRBBattlePassPageItemData::ItemId' has a wrong offset!");

// ScriptStruct OPP.RBBattlePassPageData
// 0x0020 (0x0020 - 0x0000)
struct FRBBattlePassPageData final
{
public:
	class FName                                   BattlePassId;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBBattlePassPageItemData>      Items;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBattlePassPageData) == 0x000008, "Wrong alignment on FRBBattlePassPageData");
static_assert(sizeof(FRBBattlePassPageData) == 0x000020, "Wrong size on FRBBattlePassPageData");
static_assert(offsetof(FRBBattlePassPageData, BattlePassId) == 0x000000, "Member 'FRBBattlePassPageData::BattlePassId' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageData, Index) == 0x000008, "Member 'FRBBattlePassPageData::Index' has a wrong offset!");
static_assert(offsetof(FRBBattlePassPageData, Items) == 0x000010, "Member 'FRBBattlePassPageData::Items' has a wrong offset!");

// ScriptStruct OPP.CurencySettings
// 0x0060 (0x0060 - 0x0000)
struct FCurencySettings final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Cap;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RewardIcon;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurencySettings) == 0x000008, "Wrong alignment on FCurencySettings");
static_assert(sizeof(FCurencySettings) == 0x000060, "Wrong size on FCurencySettings");
static_assert(offsetof(FCurencySettings, Name) == 0x000000, "Member 'FCurencySettings::Name' has a wrong offset!");
static_assert(offsetof(FCurencySettings, Description) == 0x000018, "Member 'FCurencySettings::Description' has a wrong offset!");
static_assert(offsetof(FCurencySettings, Cap) == 0x000030, "Member 'FCurencySettings::Cap' has a wrong offset!");
static_assert(offsetof(FCurencySettings, Icon) == 0x000038, "Member 'FCurencySettings::Icon' has a wrong offset!");
static_assert(offsetof(FCurencySettings, RewardIcon) == 0x000040, "Member 'FCurencySettings::RewardIcon' has a wrong offset!");
static_assert(offsetof(FCurencySettings, Tint) == 0x000048, "Member 'FCurencySettings::Tint' has a wrong offset!");
static_assert(offsetof(FCurencySettings, Order) == 0x000058, "Member 'FCurencySettings::Order' has a wrong offset!");

// ScriptStruct OPP.RTPCInfo
// 0x000C (0x000C - 0x0000)
struct FRTPCInfo final
{
public:
	float                                         InitialValue;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRTPCInfo) == 0x000004, "Wrong alignment on FRTPCInfo");
static_assert(sizeof(FRTPCInfo) == 0x00000C, "Wrong size on FRTPCInfo");
static_assert(offsetof(FRTPCInfo, InitialValue) == 0x000000, "Member 'FRTPCInfo::InitialValue' has a wrong offset!");
static_assert(offsetof(FRTPCInfo, Min) == 0x000004, "Member 'FRTPCInfo::Min' has a wrong offset!");
static_assert(offsetof(FRTPCInfo, Max) == 0x000008, "Member 'FRTPCInfo::Max' has a wrong offset!");

// ScriptStruct OPP.ObstacleVariatorComponentList
// 0x0010 (0x0010 - 0x0000)
struct FObstacleVariatorComponentList final
{
public:
	TArray<class URBObstacleVariatorComponent*>   List;                                              // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObstacleVariatorComponentList) == 0x000008, "Wrong alignment on FObstacleVariatorComponentList");
static_assert(sizeof(FObstacleVariatorComponentList) == 0x000010, "Wrong size on FObstacleVariatorComponentList");
static_assert(offsetof(FObstacleVariatorComponentList, List) == 0x000000, "Member 'FObstacleVariatorComponentList::List' has a wrong offset!");

// ScriptStruct OPP.ObstacleRandomizationRuntimeData
// 0x00C0 (0x00C0 - 0x0000)
struct FObstacleRandomizationRuntimeData final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObstacleVariatorComponentList> Obstacles;                                         // 0x00A0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ARBTrapGroup*>                   TrapGroups;                                        // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObstacleRandomizationRuntimeData) == 0x000008, "Wrong alignment on FObstacleRandomizationRuntimeData");
static_assert(sizeof(FObstacleRandomizationRuntimeData) == 0x0000C0, "Wrong size on FObstacleRandomizationRuntimeData");
static_assert(offsetof(FObstacleRandomizationRuntimeData, Obstacles) == 0x0000A0, "Member 'FObstacleRandomizationRuntimeData::Obstacles' has a wrong offset!");
static_assert(offsetof(FObstacleRandomizationRuntimeData, TrapGroups) == 0x0000B0, "Member 'FObstacleRandomizationRuntimeData::TrapGroups' has a wrong offset!");

// ScriptStruct OPP.AIClosetConfig
// 0x0028 (0x0028 - 0x0000)
struct FAIClosetConfig final
{
public:
	float                                         DistanceScoreContribution;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceScoreContribution : 1;           // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceForPoints;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceForPoints : 1;                // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceForPathedPoints;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceForPathedPoints : 1;          // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomScoreContribution;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RandomScoreContribution : 1;             // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnLocationScoreContribution;                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpawnLocationScoreContribution : 1;      // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIClosetConfig) == 0x000004, "Wrong alignment on FAIClosetConfig");
static_assert(sizeof(FAIClosetConfig) == 0x000028, "Wrong size on FAIClosetConfig");
static_assert(offsetof(FAIClosetConfig, DistanceScoreContribution) == 0x000000, "Member 'FAIClosetConfig::DistanceScoreContribution' has a wrong offset!");
static_assert(offsetof(FAIClosetConfig, MaxDistanceForPoints) == 0x000008, "Member 'FAIClosetConfig::MaxDistanceForPoints' has a wrong offset!");
static_assert(offsetof(FAIClosetConfig, MaxDistanceForPathedPoints) == 0x000010, "Member 'FAIClosetConfig::MaxDistanceForPathedPoints' has a wrong offset!");
static_assert(offsetof(FAIClosetConfig, RandomScoreContribution) == 0x000018, "Member 'FAIClosetConfig::RandomScoreContribution' has a wrong offset!");
static_assert(offsetof(FAIClosetConfig, SpawnLocationScoreContribution) == 0x000020, "Member 'FAIClosetConfig::SpawnLocationScoreContribution' has a wrong offset!");

// ScriptStruct OPP.NPCStorylineEntry
// 0x0010 (0x0010 - 0x0000)
struct FNPCStorylineEntry final
{
public:
	int32                                         TrialsPlayedRequirement;                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StorylineVO;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCStorylineEntry) == 0x000008, "Wrong alignment on FNPCStorylineEntry");
static_assert(sizeof(FNPCStorylineEntry) == 0x000010, "Wrong size on FNPCStorylineEntry");
static_assert(offsetof(FNPCStorylineEntry, TrialsPlayedRequirement) == 0x000000, "Member 'FNPCStorylineEntry::TrialsPlayedRequirement' has a wrong offset!");
static_assert(offsetof(FNPCStorylineEntry, StorylineVO) == 0x000008, "Member 'FNPCStorylineEntry::StorylineVO' has a wrong offset!");

// ScriptStruct OPP.NPCStorylinePath
// 0x0018 (0x0018 - 0x0000)
struct FNPCStorylinePath final
{
public:
	TArray<struct FNPCStorylineEntry>             Storylines;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExclusivePath;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCStorylinePath) == 0x000008, "Wrong alignment on FNPCStorylinePath");
static_assert(sizeof(FNPCStorylinePath) == 0x000018, "Wrong size on FNPCStorylinePath");
static_assert(offsetof(FNPCStorylinePath, Storylines) == 0x000000, "Member 'FNPCStorylinePath::Storylines' has a wrong offset!");
static_assert(offsetof(FNPCStorylinePath, bExclusivePath) == 0x000010, "Member 'FNPCStorylinePath::bExclusivePath' has a wrong offset!");

// ScriptStruct OPP.NPCStorylinesPaths
// 0x0050 (0x0050 - 0x0000)
struct FNPCStorylinesPaths final
{
public:
	TMap<class FString, struct FNPCStorylinePath> StoryLinePaths;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCStorylinesPaths) == 0x000008, "Wrong alignment on FNPCStorylinesPaths");
static_assert(sizeof(FNPCStorylinesPaths) == 0x000050, "Wrong size on FNPCStorylinesPaths");
static_assert(offsetof(FNPCStorylinesPaths, StoryLinePaths) == 0x000000, "Member 'FNPCStorylinesPaths::StoryLinePaths' has a wrong offset!");

// ScriptStruct OPP.TriggerableActionData
// 0x0030 (0x0030 - 0x0000)
struct FTriggerableActionData final
{
public:
	ETriggerableActionType                        Action;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  Actor;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerableActionData) == 0x000008, "Wrong alignment on FTriggerableActionData");
static_assert(sizeof(FTriggerableActionData) == 0x000030, "Wrong size on FTriggerableActionData");
static_assert(offsetof(FTriggerableActionData, Action) == 0x000000, "Member 'FTriggerableActionData::Action' has a wrong offset!");
static_assert(offsetof(FTriggerableActionData, Actor) == 0x000008, "Member 'FTriggerableActionData::Actor' has a wrong offset!");

// ScriptStruct OPP.ContainerForcedContentItemSettings
// 0x00D0 (0x00D0 - 0x0000)
struct FContainerForcedContentItemSettings final
{
public:
	TSubclassOf<class ARBPickup>                  ItemClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     SpawnChancePercent;                                // 0x0008(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerForcedContentItemSettings) == 0x000008, "Wrong alignment on FContainerForcedContentItemSettings");
static_assert(sizeof(FContainerForcedContentItemSettings) == 0x0000D0, "Wrong size on FContainerForcedContentItemSettings");
static_assert(offsetof(FContainerForcedContentItemSettings, ItemClass) == 0x000000, "Member 'FContainerForcedContentItemSettings::ItemClass' has a wrong offset!");
static_assert(offsetof(FContainerForcedContentItemSettings, SpawnChancePercent) == 0x000008, "Member 'FContainerForcedContentItemSettings::SpawnChancePercent' has a wrong offset!");

// ScriptStruct OPP.VoiceChatVolumeMapping
// 0x0014 (0x0014 - 0x0000)
struct FVoiceChatVolumeMapping final
{
public:
	struct FProfileId                             ProfileId;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoiceChatVolumeMapping) == 0x000004, "Wrong alignment on FVoiceChatVolumeMapping");
static_assert(sizeof(FVoiceChatVolumeMapping) == 0x000014, "Wrong size on FVoiceChatVolumeMapping");
static_assert(offsetof(FVoiceChatVolumeMapping, ProfileId) == 0x000000, "Member 'FVoiceChatVolumeMapping::ProfileId' has a wrong offset!");
static_assert(offsetof(FVoiceChatVolumeMapping, Volume) == 0x000010, "Member 'FVoiceChatVolumeMapping::Volume' has a wrong offset!");

// ScriptStruct OPP.DevDecalData
// 0x0038 (0x0038 - 0x0000)
struct FDevDecalData final
{
public:
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultDecalSize;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDecalDepth;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRotation;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevDecalData) == 0x000008, "Wrong alignment on FDevDecalData");
static_assert(sizeof(FDevDecalData) == 0x000038, "Wrong size on FDevDecalData");
static_assert(offsetof(FDevDecalData, Material) == 0x000000, "Member 'FDevDecalData::Material' has a wrong offset!");
static_assert(offsetof(FDevDecalData, DefaultDecalSize) == 0x000028, "Member 'FDevDecalData::DefaultDecalSize' has a wrong offset!");
static_assert(offsetof(FDevDecalData, DefaultDecalDepth) == 0x000030, "Member 'FDevDecalData::DefaultDecalDepth' has a wrong offset!");
static_assert(offsetof(FDevDecalData, DefaultRotation) == 0x000034, "Member 'FDevDecalData::DefaultRotation' has a wrong offset!");

// ScriptStruct OPP.BackgroundCharacterLocomotionSet
// 0x00A8 (0x00A8 - 0x0000)
struct FBackgroundCharacterLocomotionSet final
{
public:
	class UAnimationAsset*                        ForwardLoop;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        StartForward;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        StartLeft90;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        StartRight90;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        StartLeft180;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        StartRight180;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBackgroundCharacterStopData           StopForward;                                       // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBackgroundCharacterStopData           StopLeft90;                                        // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBackgroundCharacterStopData           StopRight90;                                       // 0x0060(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBackgroundCharacterStopData           StopLeft180;                                       // 0x0078(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBackgroundCharacterStopData           StopRight180;                                      // 0x0090(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBackgroundCharacterLocomotionSet) == 0x000008, "Wrong alignment on FBackgroundCharacterLocomotionSet");
static_assert(sizeof(FBackgroundCharacterLocomotionSet) == 0x0000A8, "Wrong size on FBackgroundCharacterLocomotionSet");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, ForwardLoop) == 0x000000, "Member 'FBackgroundCharacterLocomotionSet::ForwardLoop' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StartForward) == 0x000008, "Member 'FBackgroundCharacterLocomotionSet::StartForward' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StartLeft90) == 0x000010, "Member 'FBackgroundCharacterLocomotionSet::StartLeft90' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StartRight90) == 0x000018, "Member 'FBackgroundCharacterLocomotionSet::StartRight90' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StartLeft180) == 0x000020, "Member 'FBackgroundCharacterLocomotionSet::StartLeft180' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StartRight180) == 0x000028, "Member 'FBackgroundCharacterLocomotionSet::StartRight180' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StopForward) == 0x000030, "Member 'FBackgroundCharacterLocomotionSet::StopForward' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StopLeft90) == 0x000048, "Member 'FBackgroundCharacterLocomotionSet::StopLeft90' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StopRight90) == 0x000060, "Member 'FBackgroundCharacterLocomotionSet::StopRight90' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StopLeft180) == 0x000078, "Member 'FBackgroundCharacterLocomotionSet::StopLeft180' has a wrong offset!");
static_assert(offsetof(FBackgroundCharacterLocomotionSet, StopRight180) == 0x000090, "Member 'FBackgroundCharacterLocomotionSet::StopRight180' has a wrong offset!");

// ScriptStruct OPP.NPCConditionalDoorInteractionAnimData
// 0x0018 (0x0058 - 0x0040)
struct FNPCConditionalDoorInteractionAnimData final : public FNPCDoorInteractionAnimData
{
public:
	EDoorPassDirection                            Direction;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorPassType                                 Type;                                              // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBGenericConditionSet                 Conditions;                                        // 0x0048(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCConditionalDoorInteractionAnimData) == 0x000008, "Wrong alignment on FNPCConditionalDoorInteractionAnimData");
static_assert(sizeof(FNPCConditionalDoorInteractionAnimData) == 0x000058, "Wrong size on FNPCConditionalDoorInteractionAnimData");
static_assert(offsetof(FNPCConditionalDoorInteractionAnimData, Direction) == 0x000040, "Member 'FNPCConditionalDoorInteractionAnimData::Direction' has a wrong offset!");
static_assert(offsetof(FNPCConditionalDoorInteractionAnimData, Type) == 0x000041, "Member 'FNPCConditionalDoorInteractionAnimData::Type' has a wrong offset!");
static_assert(offsetof(FNPCConditionalDoorInteractionAnimData, Conditions) == 0x000048, "Member 'FNPCConditionalDoorInteractionAnimData::Conditions' has a wrong offset!");

// ScriptStruct OPP.HallucinationBracketEffectRuntimeData
// 0x01B8 (0x01B8 - 0x0000)
struct FHallucinationBracketEffectRuntimeData final
{
public:
	struct FHallucinationEffectData               EffectDataCache;                                   // 0x0000(0x01A8)(NativeAccessSpecifierPublic)
	EHallucinationType                            HallucinationType;                                 // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextActivationTime;                                // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastActivationTime;                                // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberActivated;                                   // 0x01B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHallucinationBracketEffectRuntimeData) == 0x000008, "Wrong alignment on FHallucinationBracketEffectRuntimeData");
static_assert(sizeof(FHallucinationBracketEffectRuntimeData) == 0x0001B8, "Wrong size on FHallucinationBracketEffectRuntimeData");
static_assert(offsetof(FHallucinationBracketEffectRuntimeData, EffectDataCache) == 0x000000, "Member 'FHallucinationBracketEffectRuntimeData::EffectDataCache' has a wrong offset!");
static_assert(offsetof(FHallucinationBracketEffectRuntimeData, HallucinationType) == 0x0001A8, "Member 'FHallucinationBracketEffectRuntimeData::HallucinationType' has a wrong offset!");
static_assert(offsetof(FHallucinationBracketEffectRuntimeData, NextActivationTime) == 0x0001AC, "Member 'FHallucinationBracketEffectRuntimeData::NextActivationTime' has a wrong offset!");
static_assert(offsetof(FHallucinationBracketEffectRuntimeData, LastActivationTime) == 0x0001B0, "Member 'FHallucinationBracketEffectRuntimeData::LastActivationTime' has a wrong offset!");
static_assert(offsetof(FHallucinationBracketEffectRuntimeData, NumberActivated) == 0x0001B4, "Member 'FHallucinationBracketEffectRuntimeData::NumberActivated' has a wrong offset!");

// ScriptStruct OPP.HallucinationPlayerRuntimeData
// 0x0030 (0x0030 - 0x0000)
struct FHallucinationPlayerRuntimeData final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastIncreasedPsychosisTime;                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEnteredStateTime;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentBracket;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomCooldownForNextHiddenSpectre;                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHallucinationBracketEffectRuntimeData> EffectRuntimeData;                                 // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasExitedStartSAS;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHallucinationPlayerRuntimeData) == 0x000008, "Wrong alignment on FHallucinationPlayerRuntimeData");
static_assert(sizeof(FHallucinationPlayerRuntimeData) == 0x000030, "Wrong size on FHallucinationPlayerRuntimeData");
static_assert(offsetof(FHallucinationPlayerRuntimeData, Player) == 0x000000, "Member 'FHallucinationPlayerRuntimeData::Player' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, LastIncreasedPsychosisTime) == 0x000008, "Member 'FHallucinationPlayerRuntimeData::LastIncreasedPsychosisTime' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, LastEnteredStateTime) == 0x00000C, "Member 'FHallucinationPlayerRuntimeData::LastEnteredStateTime' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, CurrentBracket) == 0x000010, "Member 'FHallucinationPlayerRuntimeData::CurrentBracket' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, RandomCooldownForNextHiddenSpectre) == 0x000014, "Member 'FHallucinationPlayerRuntimeData::RandomCooldownForNextHiddenSpectre' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, EffectRuntimeData) == 0x000018, "Member 'FHallucinationPlayerRuntimeData::EffectRuntimeData' has a wrong offset!");
static_assert(offsetof(FHallucinationPlayerRuntimeData, bHasExitedStartSAS) == 0x000028, "Member 'FHallucinationPlayerRuntimeData::bHasExitedStartSAS' has a wrong offset!");

// ScriptStruct OPP.RBProgramInfoRow
// 0x01D0 (0x01D8 - 0x0008)
struct FRBProgramInfoRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramType                                  Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerFacing;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Order;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Source;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Poster;                                            // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTrialPoster;                                   // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TutorialId;                                        // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TutorialText;                                      // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TutorialImage;                                     // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvailableTutorialId;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AvailableTutorialTitle;                            // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AvailableTutorialText;                             // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPlayerLevelForVisibility;                  // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LockedText;                                        // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EventTypeText;                                     // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           NameColor;                                         // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NameBackgroundColor;                               // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventTypeTextColor;                                // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventTypeBackgroundColor;                          // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TrialIds;                                          // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUnlockTrialsLinearly;                             // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EasyVariatorIds;                                   // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           NormalVariatorIds;                                 // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HardVariatorIds;                                   // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           InsaneVariatorIds;                                 // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBProgramInfoRow) == 0x000008, "Wrong alignment on FRBProgramInfoRow");
static_assert(sizeof(FRBProgramInfoRow) == 0x0001D8, "Wrong size on FRBProgramInfoRow");
static_assert(offsetof(FRBProgramInfoRow, ID) == 0x000008, "Member 'FRBProgramInfoRow::ID' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, Type) == 0x000010, "Member 'FRBProgramInfoRow::Type' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, bIsPlayerFacing) == 0x000011, "Member 'FRBProgramInfoRow::bIsPlayerFacing' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, Order) == 0x000014, "Member 'FRBProgramInfoRow::Order' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, Name) == 0x000018, "Member 'FRBProgramInfoRow::Name' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, Source) == 0x000030, "Member 'FRBProgramInfoRow::Source' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, Poster) == 0x000048, "Member 'FRBProgramInfoRow::Poster' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, bUseTrialPoster) == 0x000070, "Member 'FRBProgramInfoRow::bUseTrialPoster' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, TutorialId) == 0x000074, "Member 'FRBProgramInfoRow::TutorialId' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, TutorialText) == 0x000080, "Member 'FRBProgramInfoRow::TutorialText' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, TutorialImage) == 0x000098, "Member 'FRBProgramInfoRow::TutorialImage' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, AvailableTutorialId) == 0x0000C0, "Member 'FRBProgramInfoRow::AvailableTutorialId' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, AvailableTutorialTitle) == 0x0000C8, "Member 'FRBProgramInfoRow::AvailableTutorialTitle' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, AvailableTutorialText) == 0x0000E0, "Member 'FRBProgramInfoRow::AvailableTutorialText' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, FeatureSwitch) == 0x0000F8, "Member 'FRBProgramInfoRow::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, RequiredPlayerLevelForVisibility) == 0x000108, "Member 'FRBProgramInfoRow::RequiredPlayerLevelForVisibility' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, LockedText) == 0x000110, "Member 'FRBProgramInfoRow::LockedText' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, EventTypeText) == 0x000128, "Member 'FRBProgramInfoRow::EventTypeText' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, NameColor) == 0x000140, "Member 'FRBProgramInfoRow::NameColor' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, NameBackgroundColor) == 0x000150, "Member 'FRBProgramInfoRow::NameBackgroundColor' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, EventTypeTextColor) == 0x000160, "Member 'FRBProgramInfoRow::EventTypeTextColor' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, EventTypeBackgroundColor) == 0x000170, "Member 'FRBProgramInfoRow::EventTypeBackgroundColor' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, TrialIds) == 0x000180, "Member 'FRBProgramInfoRow::TrialIds' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, bUnlockTrialsLinearly) == 0x000190, "Member 'FRBProgramInfoRow::bUnlockTrialsLinearly' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, EasyVariatorIds) == 0x000198, "Member 'FRBProgramInfoRow::EasyVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, NormalVariatorIds) == 0x0001A8, "Member 'FRBProgramInfoRow::NormalVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, HardVariatorIds) == 0x0001B8, "Member 'FRBProgramInfoRow::HardVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBProgramInfoRow, InsaneVariatorIds) == 0x0001C8, "Member 'FRBProgramInfoRow::InsaneVariatorIds' has a wrong offset!");

// ScriptStruct OPP.NPCTurnOnSpotData
// 0x0004 (0x0004 - 0x0000)
struct FNPCTurnOnSpotData final
{
public:
	float                                         TargetHeading;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCTurnOnSpotData) == 0x000004, "Wrong alignment on FNPCTurnOnSpotData");
static_assert(sizeof(FNPCTurnOnSpotData) == 0x000004, "Wrong size on FNPCTurnOnSpotData");
static_assert(offsetof(FNPCTurnOnSpotData, TargetHeading) == 0x000000, "Member 'FNPCTurnOnSpotData::TargetHeading' has a wrong offset!");

// ScriptStruct OPP.CameraWaveData
// 0x000C (0x000C - 0x0000)
struct FCameraWaveData final
{
public:
	float                                         Amplitude;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPhase;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraWaveData) == 0x000004, "Wrong alignment on FCameraWaveData");
static_assert(sizeof(FCameraWaveData) == 0x00000C, "Wrong size on FCameraWaveData");
static_assert(offsetof(FCameraWaveData, Amplitude) == 0x000000, "Member 'FCameraWaveData::Amplitude' has a wrong offset!");
static_assert(offsetof(FCameraWaveData, Frequency) == 0x000004, "Member 'FCameraWaveData::Frequency' has a wrong offset!");
static_assert(offsetof(FCameraWaveData, StartPhase) == 0x000008, "Member 'FCameraWaveData::StartPhase' has a wrong offset!");

// ScriptStruct OPP.CameraShakeData
// 0x0098 (0x0098 - 0x0000)
struct FCameraShakeData final
{
public:
	float                                         Intensity;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShakeDistance;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceExponent;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPositionless;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitZDistance;                                   // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinZDistance;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZDistance;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        YawWaveA;                                          // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        YawWaveB;                                          // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        PitchWaveA;                                        // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        PitchWaveB;                                        // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        RollWaveA;                                         // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraWaveData                        RollWaveB;                                         // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EForceFeedbackDataType                        AssociatedForceFeedback;                           // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x23];                                      // 0x006D(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Owner;                                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraShakeData) == 0x000008, "Wrong alignment on FCameraShakeData");
static_assert(sizeof(FCameraShakeData) == 0x000098, "Wrong size on FCameraShakeData");
static_assert(offsetof(FCameraShakeData, Intensity) == 0x000000, "Member 'FCameraShakeData::Intensity' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, Duration) == 0x000004, "Member 'FCameraShakeData::Duration' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, FadeInTime) == 0x000008, "Member 'FCameraShakeData::FadeInTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, FadeOutTime) == 0x00000C, "Member 'FCameraShakeData::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, MaxShakeDistance) == 0x000010, "Member 'FCameraShakeData::MaxShakeDistance' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, DistanceExponent) == 0x000014, "Member 'FCameraShakeData::DistanceExponent' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, bPositionless) == 0x000018, "Member 'FCameraShakeData::bPositionless' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, bLimitZDistance) == 0x000019, "Member 'FCameraShakeData::bLimitZDistance' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, MinZDistance) == 0x00001C, "Member 'FCameraShakeData::MinZDistance' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, MaxZDistance) == 0x000020, "Member 'FCameraShakeData::MaxZDistance' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, YawWaveA) == 0x000024, "Member 'FCameraShakeData::YawWaveA' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, YawWaveB) == 0x000030, "Member 'FCameraShakeData::YawWaveB' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, PitchWaveA) == 0x00003C, "Member 'FCameraShakeData::PitchWaveA' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, PitchWaveB) == 0x000048, "Member 'FCameraShakeData::PitchWaveB' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, RollWaveA) == 0x000054, "Member 'FCameraShakeData::RollWaveA' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, RollWaveB) == 0x000060, "Member 'FCameraShakeData::RollWaveB' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, AssociatedForceFeedback) == 0x00006C, "Member 'FCameraShakeData::AssociatedForceFeedback' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, Owner) == 0x000090, "Member 'FCameraShakeData::Owner' has a wrong offset!");

// ScriptStruct OPP.SectionSpawningOverrideRuntimeInfo
// 0x0038 (0x0038 - 0x0000)
struct FSectionSpawningOverrideRuntimeInfo final
{
public:
	class ARBRoomGroup*                           Section;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsRemaining;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsSpawned;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   Containers;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   AllSectionContainers;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasInitContainers;                                // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSectionSpawningOverrideRuntimeInfo) == 0x000008, "Wrong alignment on FSectionSpawningOverrideRuntimeInfo");
static_assert(sizeof(FSectionSpawningOverrideRuntimeInfo) == 0x000038, "Wrong size on FSectionSpawningOverrideRuntimeInfo");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, Section) == 0x000000, "Member 'FSectionSpawningOverrideRuntimeInfo::Section' has a wrong offset!");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, NumberOfItemsRemaining) == 0x000008, "Member 'FSectionSpawningOverrideRuntimeInfo::NumberOfItemsRemaining' has a wrong offset!");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, NumberOfItemsSpawned) == 0x00000C, "Member 'FSectionSpawningOverrideRuntimeInfo::NumberOfItemsSpawned' has a wrong offset!");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, Containers) == 0x000010, "Member 'FSectionSpawningOverrideRuntimeInfo::Containers' has a wrong offset!");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, AllSectionContainers) == 0x000020, "Member 'FSectionSpawningOverrideRuntimeInfo::AllSectionContainers' has a wrong offset!");
static_assert(offsetof(FSectionSpawningOverrideRuntimeInfo, bHasInitContainers) == 0x000030, "Member 'FSectionSpawningOverrideRuntimeInfo::bHasInitContainers' has a wrong offset!");

// ScriptStruct OPP.PlayerHitReactionParams
// 0x0050 (0x0050 - 0x0000)
struct FPlayerHitReactionParams final
{
public:
	float                                         PawnTime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerHitReactionType                        ReactionType;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldYaw;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeYaw;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEffects;                                      // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPos;                                         // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDir;                                         // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageLocation;                                    // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                HitReactionTriggerer;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitReactionParams) == 0x000008, "Wrong alignment on FPlayerHitReactionParams");
static_assert(sizeof(FPlayerHitReactionParams) == 0x000050, "Wrong size on FPlayerHitReactionParams");
static_assert(offsetof(FPlayerHitReactionParams, PawnTime) == 0x000000, "Member 'FPlayerHitReactionParams::PawnTime' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, ServerTime) == 0x000004, "Member 'FPlayerHitReactionParams::ServerTime' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, ReactionType) == 0x000008, "Member 'FPlayerHitReactionParams::ReactionType' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, WorldYaw) == 0x00000C, "Member 'FPlayerHitReactionParams::WorldYaw' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, RelativeYaw) == 0x000010, "Member 'FPlayerHitReactionParams::RelativeYaw' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, bPlayEffects) == 0x000014, "Member 'FPlayerHitReactionParams::bPlayEffects' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, TargetPos) == 0x000018, "Member 'FPlayerHitReactionParams::TargetPos' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, TargetDir) == 0x000024, "Member 'FPlayerHitReactionParams::TargetDir' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, Damage) == 0x000030, "Member 'FPlayerHitReactionParams::Damage' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, DamageLocation) == 0x000034, "Member 'FPlayerHitReactionParams::DamageLocation' has a wrong offset!");
static_assert(offsetof(FPlayerHitReactionParams, HitReactionTriggerer) == 0x000040, "Member 'FPlayerHitReactionParams::HitReactionTriggerer' has a wrong offset!");

// ScriptStruct OPP.RBBadgeHudProgressDisplayDetails
// 0x0008 (0x0008 - 0x0000)
struct FRBBadgeHudProgressDisplayDetails final
{
public:
	class FName                                   BadgeId;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBadgeHudProgressDisplayDetails) == 0x000004, "Wrong alignment on FRBBadgeHudProgressDisplayDetails");
static_assert(sizeof(FRBBadgeHudProgressDisplayDetails) == 0x000008, "Wrong size on FRBBadgeHudProgressDisplayDetails");
static_assert(offsetof(FRBBadgeHudProgressDisplayDetails, BadgeId) == 0x000000, "Member 'FRBBadgeHudProgressDisplayDetails::BadgeId' has a wrong offset!");

// ScriptStruct OPP.PipeJunction
// 0x0030 (0x0030 - 0x0000)
struct FPipeJunction final
{
public:
	TSoftObjectPtr<class AActor>                  PipeJunction;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPipeJunctionType                             JunctionType;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeakingFront;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeakingBack;                                      // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPipeJunction) == 0x000008, "Wrong alignment on FPipeJunction");
static_assert(sizeof(FPipeJunction) == 0x000030, "Wrong size on FPipeJunction");
static_assert(offsetof(FPipeJunction, PipeJunction) == 0x000000, "Member 'FPipeJunction::PipeJunction' has a wrong offset!");
static_assert(offsetof(FPipeJunction, JunctionType) == 0x000028, "Member 'FPipeJunction::JunctionType' has a wrong offset!");
static_assert(offsetof(FPipeJunction, bLeakingFront) == 0x000029, "Member 'FPipeJunction::bLeakingFront' has a wrong offset!");
static_assert(offsetof(FPipeJunction, bLeakingBack) == 0x00002A, "Member 'FPipeJunction::bLeakingBack' has a wrong offset!");

// ScriptStruct OPP.PlayerShoveData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerShoveData final
{
public:
	class ARBPawn*                                Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShoveAnimation;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerShoveData) == 0x000008, "Wrong alignment on FPlayerShoveData");
static_assert(sizeof(FPlayerShoveData) == 0x000010, "Wrong size on FPlayerShoveData");
static_assert(offsetof(FPlayerShoveData, Target) == 0x000000, "Member 'FPlayerShoveData::Target' has a wrong offset!");
static_assert(offsetof(FPlayerShoveData, ShoveAnimation) == 0x000008, "Member 'FPlayerShoveData::ShoveAnimation' has a wrong offset!");

// ScriptStruct OPP.StageAudioEvents
// 0x0020 (0x0020 - 0x0000)
struct FStageAudioEvents final
{
public:
	TArray<class UAkAudioEvent*>                  StartEvents;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAkAudioEvent*>                  StopEvents;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageAudioEvents) == 0x000008, "Wrong alignment on FStageAudioEvents");
static_assert(sizeof(FStageAudioEvents) == 0x000020, "Wrong size on FStageAudioEvents");
static_assert(offsetof(FStageAudioEvents, StartEvents) == 0x000000, "Member 'FStageAudioEvents::StartEvents' has a wrong offset!");
static_assert(offsetof(FStageAudioEvents, StopEvents) == 0x000010, "Member 'FStageAudioEvents::StopEvents' has a wrong offset!");

// ScriptStruct OPP.IngameItemConfig
// 0x0028 (0x0028 - 0x0000)
struct FIngameItemConfig final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         ItemClassPath;                                     // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemInventoryPriority;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIngameItemConfig) == 0x000008, "Wrong alignment on FIngameItemConfig");
static_assert(sizeof(FIngameItemConfig) == 0x000028, "Wrong size on FIngameItemConfig");
static_assert(offsetof(FIngameItemConfig, ItemType) == 0x000000, "Member 'FIngameItemConfig::ItemType' has a wrong offset!");
static_assert(offsetof(FIngameItemConfig, ItemClassPath) == 0x000008, "Member 'FIngameItemConfig::ItemClassPath' has a wrong offset!");
static_assert(offsetof(FIngameItemConfig, ItemInventoryPriority) == 0x000020, "Member 'FIngameItemConfig::ItemInventoryPriority' has a wrong offset!");

// ScriptStruct OPP.PairedTwoPhaseAnimData
// 0x0038 (0x0038 - 0x0000)
struct FPairedTwoPhaseAnimData final
{
public:
	struct FPairedAnim                            EnterAnims;                                        // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            ExitAnims;                                         // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELocomotionMode                               PlayerFinishedLocomotionMode;                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPairedTwoPhaseAnimData) == 0x000008, "Wrong alignment on FPairedTwoPhaseAnimData");
static_assert(sizeof(FPairedTwoPhaseAnimData) == 0x000038, "Wrong size on FPairedTwoPhaseAnimData");
static_assert(offsetof(FPairedTwoPhaseAnimData, EnterAnims) == 0x000000, "Member 'FPairedTwoPhaseAnimData::EnterAnims' has a wrong offset!");
static_assert(offsetof(FPairedTwoPhaseAnimData, ExitAnims) == 0x000018, "Member 'FPairedTwoPhaseAnimData::ExitAnims' has a wrong offset!");
static_assert(offsetof(FPairedTwoPhaseAnimData, PlayerFinishedLocomotionMode) == 0x000030, "Member 'FPairedTwoPhaseAnimData::PlayerFinishedLocomotionMode' has a wrong offset!");

// ScriptStruct OPP.RBActiveSkillSettingsRow
// 0x0030 (0x0038 - 0x0008)
struct FRBActiveSkillSettingsRow final : public FTableRowBase
{
public:
	EActiveSkillType                              ActiveSkillType;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialNumberOfCharges;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownBetweenCharges;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerRadius;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerDelay;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeDuration;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Effect;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadius;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimeAssetEffectDurationMultiplier;                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration2;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistractionRange;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBActiveSkillSettingsRow) == 0x000008, "Wrong alignment on FRBActiveSkillSettingsRow");
static_assert(sizeof(FRBActiveSkillSettingsRow) == 0x000038, "Wrong size on FRBActiveSkillSettingsRow");
static_assert(offsetof(FRBActiveSkillSettingsRow, ActiveSkillType) == 0x000008, "Member 'FRBActiveSkillSettingsRow::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, InitialNumberOfCharges) == 0x00000C, "Member 'FRBActiveSkillSettingsRow::InitialNumberOfCharges' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, CooldownBetweenCharges) == 0x000010, "Member 'FRBActiveSkillSettingsRow::CooldownBetweenCharges' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, TriggerRadius) == 0x000014, "Member 'FRBActiveSkillSettingsRow::TriggerRadius' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, TriggerDelay) == 0x000018, "Member 'FRBActiveSkillSettingsRow::TriggerDelay' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, ChargeDuration) == 0x00001C, "Member 'FRBActiveSkillSettingsRow::ChargeDuration' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, Effect) == 0x000020, "Member 'FRBActiveSkillSettingsRow::Effect' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, EffectRadius) == 0x000024, "Member 'FRBActiveSkillSettingsRow::EffectRadius' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, EffectDuration) == 0x000028, "Member 'FRBActiveSkillSettingsRow::EffectDuration' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, PrimeAssetEffectDurationMultiplier) == 0x00002C, "Member 'FRBActiveSkillSettingsRow::PrimeAssetEffectDurationMultiplier' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, EffectDuration2) == 0x000030, "Member 'FRBActiveSkillSettingsRow::EffectDuration2' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettingsRow, DistractionRange) == 0x000034, "Member 'FRBActiveSkillSettingsRow::DistractionRange' has a wrong offset!");

// ScriptStruct OPP.RBUIEffectDisplayData
// 0x0030 (0x0030 - 0x0000)
struct FRBUIEffectDisplayData final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBUIEffectDisplayData) == 0x000008, "Wrong alignment on FRBUIEffectDisplayData");
static_assert(sizeof(FRBUIEffectDisplayData) == 0x000030, "Wrong size on FRBUIEffectDisplayData");
static_assert(offsetof(FRBUIEffectDisplayData, Description) == 0x000000, "Member 'FRBUIEffectDisplayData::Description' has a wrong offset!");
static_assert(offsetof(FRBUIEffectDisplayData, Icon) == 0x000018, "Member 'FRBUIEffectDisplayData::Icon' has a wrong offset!");
static_assert(offsetof(FRBUIEffectDisplayData, Color) == 0x000020, "Member 'FRBUIEffectDisplayData::Color' has a wrong offset!");

// ScriptStruct OPP.CoopMoveData
// 0x00A0 (0x00A0 - 0x0000)
struct FCoopMoveData final
{
public:
	ESpecialMove                                  MoveType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipGenericCoopMoveNotify;                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              Leader;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              Follower;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              ExtraPartner;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitiatorLocation;                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitiatorDirection;                                // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReceiverLocation;                                  // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReceiverDirection;                                 // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasicDirection                               BasicDirection;                                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBLedgeMarker*                         LedgeMarker;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PivotPointOnLedge;                                 // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraversalDir;                                      // 0x006C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LedgeHeight;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropHeight;                                        // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrouchBeforeMove;                              // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustCrouchAfterMove;                              // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0084(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoopMoveType                                 OfferMoveType;                                     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoopMoveOfferState                           OfferState;                                        // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CoopMoveActor;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCoopMoveData) == 0x000008, "Wrong alignment on FCoopMoveData");
static_assert(sizeof(FCoopMoveData) == 0x0000A0, "Wrong size on FCoopMoveData");
static_assert(offsetof(FCoopMoveData, MoveType) == 0x000000, "Member 'FCoopMoveData::MoveType' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, bSkipGenericCoopMoveNotify) == 0x000001, "Member 'FCoopMoveData::bSkipGenericCoopMoveNotify' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, Leader) == 0x000008, "Member 'FCoopMoveData::Leader' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, Follower) == 0x000010, "Member 'FCoopMoveData::Follower' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, ExtraPartner) == 0x000018, "Member 'FCoopMoveData::ExtraPartner' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, InitiatorLocation) == 0x000020, "Member 'FCoopMoveData::InitiatorLocation' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, InitiatorDirection) == 0x00002C, "Member 'FCoopMoveData::InitiatorDirection' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, ReceiverLocation) == 0x000038, "Member 'FCoopMoveData::ReceiverLocation' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, ReceiverDirection) == 0x000044, "Member 'FCoopMoveData::ReceiverDirection' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, BasicDirection) == 0x000050, "Member 'FCoopMoveData::BasicDirection' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, LedgeMarker) == 0x000058, "Member 'FCoopMoveData::LedgeMarker' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, PivotPointOnLedge) == 0x000060, "Member 'FCoopMoveData::PivotPointOnLedge' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, TraversalDir) == 0x00006C, "Member 'FCoopMoveData::TraversalDir' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, LedgeHeight) == 0x000078, "Member 'FCoopMoveData::LedgeHeight' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, DropHeight) == 0x00007C, "Member 'FCoopMoveData::DropHeight' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, bWasCrouchBeforeMove) == 0x000080, "Member 'FCoopMoveData::bWasCrouchBeforeMove' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, bMustCrouchAfterMove) == 0x000081, "Member 'FCoopMoveData::bMustCrouchAfterMove' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, TargetLocation) == 0x000084, "Member 'FCoopMoveData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, OfferMoveType) == 0x000090, "Member 'FCoopMoveData::OfferMoveType' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, OfferState) == 0x000091, "Member 'FCoopMoveData::OfferState' has a wrong offset!");
static_assert(offsetof(FCoopMoveData, CoopMoveActor) == 0x000098, "Member 'FCoopMoveData::CoopMoveActor' has a wrong offset!");

// ScriptStruct OPP.PlayerProximityConfig
// 0x0014 (0x0014 - 0x0000)
struct FPlayerProximityConfig final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnabled : 1;                            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProximityDistance;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ProximityDistance : 1;                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVOInterval;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinVOInterval : 1;                       // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerProximityConfig) == 0x000004, "Wrong alignment on FPlayerProximityConfig");
static_assert(sizeof(FPlayerProximityConfig) == 0x000014, "Wrong size on FPlayerProximityConfig");
static_assert(offsetof(FPlayerProximityConfig, bEnabled) == 0x000000, "Member 'FPlayerProximityConfig::bEnabled' has a wrong offset!");
static_assert(offsetof(FPlayerProximityConfig, ProximityDistance) == 0x000004, "Member 'FPlayerProximityConfig::ProximityDistance' has a wrong offset!");
static_assert(offsetof(FPlayerProximityConfig, MinVOInterval) == 0x00000C, "Member 'FPlayerProximityConfig::MinVOInterval' has a wrong offset!");

// ScriptStruct OPP.TraversalMoveData
// 0x0070 (0x0070 - 0x0000)
struct FTraversalMoveData final
{
public:
	ESpecialMove                                  TraversalMove;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TraversalMoveSubType;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TraversalActor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EndTraversalActor;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDirection;                                   // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExpectedEndPosition;                               // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJumpOverAnimType                             JumpOverAnimType;                                  // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClimbOntoAnimType                            ClimbOntoAnimType;                                 // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMode                               NextLocomotionMode;                                // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstacleHeight;                                    // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleWidth;                                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleDropHeight;                                // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleAngle;                                     // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunning;                                          // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrouchBeforeMove;                              // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustCrouchAfterMove;                              // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPawnRepulsionType                            PawnRepulsion;                                     // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstacleAnimBaseHeight;                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleAnimBaseWidth;                             // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraversalMoveData) == 0x000008, "Wrong alignment on FTraversalMoveData");
static_assert(sizeof(FTraversalMoveData) == 0x000070, "Wrong size on FTraversalMoveData");
static_assert(offsetof(FTraversalMoveData, TraversalMove) == 0x000000, "Member 'FTraversalMoveData::TraversalMove' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, TraversalMoveSubType) == 0x000001, "Member 'FTraversalMoveData::TraversalMoveSubType' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, TraversalActor) == 0x000008, "Member 'FTraversalMoveData::TraversalActor' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, EndTraversalActor) == 0x000010, "Member 'FTraversalMoveData::EndTraversalActor' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, TargetPosition) == 0x000018, "Member 'FTraversalMoveData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, TargetDirection) == 0x000024, "Member 'FTraversalMoveData::TargetDirection' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ExpectedEndPosition) == 0x000030, "Member 'FTraversalMoveData::ExpectedEndPosition' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, JumpOverAnimType) == 0x00003C, "Member 'FTraversalMoveData::JumpOverAnimType' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ClimbOntoAnimType) == 0x00003D, "Member 'FTraversalMoveData::ClimbOntoAnimType' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, NextLocomotionMode) == 0x00003E, "Member 'FTraversalMoveData::NextLocomotionMode' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleHeight) == 0x000040, "Member 'FTraversalMoveData::ObstacleHeight' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleWidth) == 0x000044, "Member 'FTraversalMoveData::ObstacleWidth' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleDropHeight) == 0x000048, "Member 'FTraversalMoveData::ObstacleDropHeight' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleAngle) == 0x00004C, "Member 'FTraversalMoveData::ObstacleAngle' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, bRunning) == 0x000050, "Member 'FTraversalMoveData::bRunning' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, bWasCrouchBeforeMove) == 0x000051, "Member 'FTraversalMoveData::bWasCrouchBeforeMove' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, bMustCrouchAfterMove) == 0x000052, "Member 'FTraversalMoveData::bMustCrouchAfterMove' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, Velocity) == 0x000054, "Member 'FTraversalMoveData::Velocity' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, PawnRepulsion) == 0x000058, "Member 'FTraversalMoveData::PawnRepulsion' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleAnimBaseHeight) == 0x00005C, "Member 'FTraversalMoveData::ObstacleAnimBaseHeight' has a wrong offset!");
static_assert(offsetof(FTraversalMoveData, ObstacleAnimBaseWidth) == 0x000060, "Member 'FTraversalMoveData::ObstacleAnimBaseWidth' has a wrong offset!");

// ScriptStruct OPP.AISneakData
// 0x0030 (0x0030 - 0x0000)
struct FAISneakData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              TargetPlayer;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISneakData) == 0x000008, "Wrong alignment on FAISneakData");
static_assert(sizeof(FAISneakData) == 0x000030, "Wrong size on FAISneakData");
static_assert(offsetof(FAISneakData, TargetPlayer) == 0x000028, "Member 'FAISneakData::TargetPlayer' has a wrong offset!");

// ScriptStruct OPP.ScheduledSpecialAnimData
// 0x0048 (0x0048 - 0x0000)
struct FScheduledSpecialAnimData final
{
public:
	float                                         PawnTime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptInteraction;                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollisionEnabled;                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnchor;                                           // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnchorLocation;                                    // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnchorForward;                                     // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Animation;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         blendInTime;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScriptedAnimationYawLimit;                         // 0x0034(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScriptedAnimationPitchLimit;                       // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledSpecialAnimData) == 0x000008, "Wrong alignment on FScheduledSpecialAnimData");
static_assert(sizeof(FScheduledSpecialAnimData) == 0x000048, "Wrong size on FScheduledSpecialAnimData");
static_assert(offsetof(FScheduledSpecialAnimData, PawnTime) == 0x000000, "Member 'FScheduledSpecialAnimData::PawnTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, ServerTime) == 0x000004, "Member 'FScheduledSpecialAnimData::ServerTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, bInterruptInteraction) == 0x000008, "Member 'FScheduledSpecialAnimData::bInterruptInteraction' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, bCollisionEnabled) == 0x000009, "Member 'FScheduledSpecialAnimData::bCollisionEnabled' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, bAnchor) == 0x00000A, "Member 'FScheduledSpecialAnimData::bAnchor' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, AnchorLocation) == 0x00000C, "Member 'FScheduledSpecialAnimData::AnchorLocation' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, AnchorForward) == 0x000018, "Member 'FScheduledSpecialAnimData::AnchorForward' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, Animation) == 0x000028, "Member 'FScheduledSpecialAnimData::Animation' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, blendInTime) == 0x000030, "Member 'FScheduledSpecialAnimData::blendInTime' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, ScriptedAnimationYawLimit) == 0x000034, "Member 'FScheduledSpecialAnimData::ScriptedAnimationYawLimit' has a wrong offset!");
static_assert(offsetof(FScheduledSpecialAnimData, ScriptedAnimationPitchLimit) == 0x00003C, "Member 'FScheduledSpecialAnimData::ScriptedAnimationPitchLimit' has a wrong offset!");

// ScriptStruct OPP.UnionTortureTargetData
// 0x0002 (0x0002 - 0x0000)
struct FUnionTortureTargetData final
{
public:
	EUnionTortureTarget                           Target;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnionTortureSymbol                           Symbol;                                            // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnionTortureTargetData) == 0x000001, "Wrong alignment on FUnionTortureTargetData");
static_assert(sizeof(FUnionTortureTargetData) == 0x000002, "Wrong size on FUnionTortureTargetData");
static_assert(offsetof(FUnionTortureTargetData, Target) == 0x000000, "Member 'FUnionTortureTargetData::Target' has a wrong offset!");
static_assert(offsetof(FUnionTortureTargetData, Symbol) == 0x000001, "Member 'FUnionTortureTargetData::Symbol' has a wrong offset!");

// ScriptStruct OPP.UnionTortureGameData
// 0x0018 (0x0018 - 0x0000)
struct FUnionTortureGameData final
{
public:
	TArray<struct FUnionTortureTargetData>        Targets;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumHits;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRounds;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnionTortureGameData) == 0x000008, "Wrong alignment on FUnionTortureGameData");
static_assert(sizeof(FUnionTortureGameData) == 0x000018, "Wrong size on FUnionTortureGameData");
static_assert(offsetof(FUnionTortureGameData, Targets) == 0x000000, "Member 'FUnionTortureGameData::Targets' has a wrong offset!");
static_assert(offsetof(FUnionTortureGameData, NumHits) == 0x000010, "Member 'FUnionTortureGameData::NumHits' has a wrong offset!");
static_assert(offsetof(FUnionTortureGameData, NumRounds) == 0x000014, "Member 'FUnionTortureGameData::NumRounds' has a wrong offset!");

// ScriptStruct OPP.PawnTimestamp
// 0x0010 (0x0010 - 0x0000)
struct FPawnTimestamp final
{
public:
	float                                         PawnTime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPawn*                                PawnOwner;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPawnTimestamp) == 0x000008, "Wrong alignment on FPawnTimestamp");
static_assert(sizeof(FPawnTimestamp) == 0x000010, "Wrong size on FPawnTimestamp");
static_assert(offsetof(FPawnTimestamp, PawnTime) == 0x000000, "Member 'FPawnTimestamp::PawnTime' has a wrong offset!");
static_assert(offsetof(FPawnTimestamp, ServerTime) == 0x000004, "Member 'FPawnTimestamp::ServerTime' has a wrong offset!");
static_assert(offsetof(FPawnTimestamp, PawnOwner) == 0x000008, "Member 'FPawnTimestamp::PawnOwner' has a wrong offset!");

// ScriptStruct OPP.ScheduledBool
// 0x0008 (0x0070 - 0x0068)
struct FScheduledBool final : public FScheduledProperty
{
public:
	bool                                          InitialValue;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastValue;                                         // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurrentValue;                                      // 0x006A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DesiredValue;                                      // 0x006B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledBool) == 0x000008, "Wrong alignment on FScheduledBool");
static_assert(sizeof(FScheduledBool) == 0x000070, "Wrong size on FScheduledBool");
static_assert(offsetof(FScheduledBool, InitialValue) == 0x000068, "Member 'FScheduledBool::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledBool, LastValue) == 0x000069, "Member 'FScheduledBool::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledBool, CurrentValue) == 0x00006A, "Member 'FScheduledBool::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledBool, DesiredValue) == 0x00006B, "Member 'FScheduledBool::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.PlayerMemory
// 0x0064 (0x0064 - 0x0000)
struct alignas(0x04) FPlayerMemory final
{
public:
	uint8                                         Pad_0[0x64];                                       // 0x0000(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMemory) == 0x000004, "Wrong alignment on FPlayerMemory");
static_assert(sizeof(FPlayerMemory) == 0x000064, "Wrong size on FPlayerMemory");

// ScriptStruct OPP.AISpeedConfig
// 0x0140 (0x0140 - 0x0000)
struct FAISpeedConfig final
{
public:
	float                                         BaseSpeed;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BaseSpeed : 1;                           // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChaseSpeed;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChaseSpeed : 1;                          // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigationSpeedAware;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InvestigationSpeedAware : 1;             // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigationSpeedUnaware;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InvestigationSpeedUnaware : 1;           // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RetirementSpeed;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RetirementSpeed : 1;                     // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerAvoidanceSpeed;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerAvoidanceSpeed : 1;                // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorAccelRate;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BehaviorAccelRate : 1;                   // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorDecelRate;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BehaviorDecelRate : 1;                   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInstantAccel;                                     // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bInstantAccel : 1;                       // 0x003E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInstantDecel;                                     // 0x003F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bInstantDecel : 1;                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DarknessFactor;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessFactor : 1;                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableSprint;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableSprint : 1;                       // 0x004A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSprintSpeedGain;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxSprintSpeedGain : 1;                  // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintAcceleration;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SprintAcceleration : 1;                  // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintDeceleration;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SprintDeceleration : 1;                  // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeedForSprint;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinSpeedForSprint : 1;                   // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStraightDistForSprintAccel;                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinStraightDistForSprintAccel : 1;       // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStraightDistForSprintKeep;                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinStraightDistForSprintKeep : 1;        // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableNPCStamina;                                 // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableNPCStamina : 1;                   // 0x007A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStaminaSpeedLoss;                               // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxStaminaSpeedLoss : 1;                 // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaLevelForStartSlowdown;                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StaminaLevelForStartSlowdown : 1;        // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeedForStaminaConsumption;                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinSpeedForStaminaConsumption : 1;       // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedForStaminaConsumption;                     // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxSpeedForStaminaConsumption : 1;       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStaminaComsumptionRate;                         // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxStaminaComsumptionRate : 1;           // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutsideLeashStaminaConsumption;                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_OutsideLeashStaminaConsumption : 1;      // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaRecoveryRate;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StaminaRecoveryRate : 1;                 // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBeforeStaminaRecovery;                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinTimeBeforeStaminaRecovery : 1;        // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FaceOffAdjustSpeedBoost;                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FaceOffAdjustSpeedBoost : 1;             // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackMercyFactor;                                 // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackMercyFactor : 1;                   // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackMercyDuration;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackMercyDuration : 1;                 // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroupChasingRestartSpeedDuration;                  // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GroupChasingRestartSpeedDuration : 1;    // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChaseNoVisibilityFactor;                           // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChaseNoVisibilityFactor : 1;             // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightlessChaseSlowdownDuration;                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SightlessChaseSlowdownDuration : 1;      // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNoVisibleRubberBandingSlowDown;                   // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bNoVisibleRubberBandingSlowDown : 1;     // 0x00EA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRubberBandingRequiresPlayerRun;                   // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRubberBandingRequiresPlayerRun : 1;     // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubberBandingDelay;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RubberBandingDelay : 1;                  // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubberBandingMinDist;                              // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RubberBandingMinDist : 1;                // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubberBandingMaxDist;                              // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RubberBandingMaxDist : 1;                // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubberBandingFactorMinDist;                        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RubberBandingFactorMinDist : 1;          // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubberBandingFactorMaxDist;                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RubberBandingFactorMaxDist : 1;          // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNoAdjustmentForSlopes;                            // 0x0115(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bNoAdjustmentForSlopes : 1;              // 0x0116(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_117[0x1];                                      // 0x0117(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedPenaltyForUpSlope;                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxSpeedPenaltyForUpSlope : 1;           // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedGainForDownSlope;                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxSpeedGainForDownSlope : 1;            // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedCapForLowHealth;                              // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpeedCapForLowHealth : 1;                // 0x012C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowHealthForSpeedCap;                              // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LowHealthForSpeedCap : 1;                // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthForSpeedCapStart;                            // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HealthForSpeedCapStart : 1;              // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISpeedConfig) == 0x000004, "Wrong alignment on FAISpeedConfig");
static_assert(sizeof(FAISpeedConfig) == 0x000140, "Wrong size on FAISpeedConfig");
static_assert(offsetof(FAISpeedConfig, BaseSpeed) == 0x000000, "Member 'FAISpeedConfig::BaseSpeed' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, ChaseSpeed) == 0x000008, "Member 'FAISpeedConfig::ChaseSpeed' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, InvestigationSpeedAware) == 0x000010, "Member 'FAISpeedConfig::InvestigationSpeedAware' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, InvestigationSpeedUnaware) == 0x000018, "Member 'FAISpeedConfig::InvestigationSpeedUnaware' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RetirementSpeed) == 0x000020, "Member 'FAISpeedConfig::RetirementSpeed' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, PlayerAvoidanceSpeed) == 0x000028, "Member 'FAISpeedConfig::PlayerAvoidanceSpeed' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, BehaviorAccelRate) == 0x000030, "Member 'FAISpeedConfig::BehaviorAccelRate' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, BehaviorDecelRate) == 0x000038, "Member 'FAISpeedConfig::BehaviorDecelRate' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bInstantAccel) == 0x00003D, "Member 'FAISpeedConfig::bInstantAccel' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bInstantDecel) == 0x00003F, "Member 'FAISpeedConfig::bInstantDecel' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, DarknessFactor) == 0x000044, "Member 'FAISpeedConfig::DarknessFactor' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bEnableSprint) == 0x000049, "Member 'FAISpeedConfig::bEnableSprint' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxSprintSpeedGain) == 0x00004C, "Member 'FAISpeedConfig::MaxSprintSpeedGain' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, SprintAcceleration) == 0x000054, "Member 'FAISpeedConfig::SprintAcceleration' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, SprintDeceleration) == 0x00005C, "Member 'FAISpeedConfig::SprintDeceleration' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MinSpeedForSprint) == 0x000064, "Member 'FAISpeedConfig::MinSpeedForSprint' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MinStraightDistForSprintAccel) == 0x00006C, "Member 'FAISpeedConfig::MinStraightDistForSprintAccel' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MinStraightDistForSprintKeep) == 0x000074, "Member 'FAISpeedConfig::MinStraightDistForSprintKeep' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bEnableNPCStamina) == 0x000079, "Member 'FAISpeedConfig::bEnableNPCStamina' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxStaminaSpeedLoss) == 0x00007C, "Member 'FAISpeedConfig::MaxStaminaSpeedLoss' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, StaminaLevelForStartSlowdown) == 0x000084, "Member 'FAISpeedConfig::StaminaLevelForStartSlowdown' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MinSpeedForStaminaConsumption) == 0x00008C, "Member 'FAISpeedConfig::MinSpeedForStaminaConsumption' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxSpeedForStaminaConsumption) == 0x000094, "Member 'FAISpeedConfig::MaxSpeedForStaminaConsumption' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxStaminaComsumptionRate) == 0x00009C, "Member 'FAISpeedConfig::MaxStaminaComsumptionRate' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, OutsideLeashStaminaConsumption) == 0x0000A4, "Member 'FAISpeedConfig::OutsideLeashStaminaConsumption' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, StaminaRecoveryRate) == 0x0000AC, "Member 'FAISpeedConfig::StaminaRecoveryRate' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MinTimeBeforeStaminaRecovery) == 0x0000B4, "Member 'FAISpeedConfig::MinTimeBeforeStaminaRecovery' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, FaceOffAdjustSpeedBoost) == 0x0000BC, "Member 'FAISpeedConfig::FaceOffAdjustSpeedBoost' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, AttackMercyFactor) == 0x0000C4, "Member 'FAISpeedConfig::AttackMercyFactor' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, AttackMercyDuration) == 0x0000CC, "Member 'FAISpeedConfig::AttackMercyDuration' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, GroupChasingRestartSpeedDuration) == 0x0000D4, "Member 'FAISpeedConfig::GroupChasingRestartSpeedDuration' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, ChaseNoVisibilityFactor) == 0x0000DC, "Member 'FAISpeedConfig::ChaseNoVisibilityFactor' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, SightlessChaseSlowdownDuration) == 0x0000E4, "Member 'FAISpeedConfig::SightlessChaseSlowdownDuration' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bNoVisibleRubberBandingSlowDown) == 0x0000E9, "Member 'FAISpeedConfig::bNoVisibleRubberBandingSlowDown' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bRubberBandingRequiresPlayerRun) == 0x0000EB, "Member 'FAISpeedConfig::bRubberBandingRequiresPlayerRun' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RubberBandingDelay) == 0x0000F0, "Member 'FAISpeedConfig::RubberBandingDelay' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RubberBandingMinDist) == 0x0000F8, "Member 'FAISpeedConfig::RubberBandingMinDist' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RubberBandingMaxDist) == 0x000100, "Member 'FAISpeedConfig::RubberBandingMaxDist' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RubberBandingFactorMinDist) == 0x000108, "Member 'FAISpeedConfig::RubberBandingFactorMinDist' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, RubberBandingFactorMaxDist) == 0x000110, "Member 'FAISpeedConfig::RubberBandingFactorMaxDist' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, bNoAdjustmentForSlopes) == 0x000115, "Member 'FAISpeedConfig::bNoAdjustmentForSlopes' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxSpeedPenaltyForUpSlope) == 0x000118, "Member 'FAISpeedConfig::MaxSpeedPenaltyForUpSlope' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, MaxSpeedGainForDownSlope) == 0x000120, "Member 'FAISpeedConfig::MaxSpeedGainForDownSlope' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, SpeedCapForLowHealth) == 0x000128, "Member 'FAISpeedConfig::SpeedCapForLowHealth' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, LowHealthForSpeedCap) == 0x000130, "Member 'FAISpeedConfig::LowHealthForSpeedCap' has a wrong offset!");
static_assert(offsetof(FAISpeedConfig, HealthForSpeedCapStart) == 0x000138, "Member 'FAISpeedConfig::HealthForSpeedCapStart' has a wrong offset!");

// ScriptStruct OPP.DoorInteractionAudioEvent
// 0x0010 (0x0010 - 0x0000)
struct FDoorInteractionAudioEvent final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Event;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorInteractionAudioEvent) == 0x000008, "Wrong alignment on FDoorInteractionAudioEvent");
static_assert(sizeof(FDoorInteractionAudioEvent) == 0x000010, "Wrong size on FDoorInteractionAudioEvent");
static_assert(offsetof(FDoorInteractionAudioEvent, Event) == 0x000008, "Member 'FDoorInteractionAudioEvent::Event' has a wrong offset!");

// ScriptStruct OPP.RBSocialMenuEntryDetails
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FRBSocialMenuEntryDetails final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBSocialMenuEntryDetails) == 0x000008, "Wrong alignment on FRBSocialMenuEntryDetails");
static_assert(sizeof(FRBSocialMenuEntryDetails) == 0x000060, "Wrong size on FRBSocialMenuEntryDetails");

// ScriptStruct OPP.PlayerAudioState
// 0x0030 (0x0030 - 0x0000)
struct FPlayerAudioState final
{
public:
	class FName                                   StateGroupName;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateOffName;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartEvent;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndServerTimestamp;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerAudioState) == 0x000008, "Wrong alignment on FPlayerAudioState");
static_assert(sizeof(FPlayerAudioState) == 0x000030, "Wrong size on FPlayerAudioState");
static_assert(offsetof(FPlayerAudioState, StateGroupName) == 0x000000, "Member 'FPlayerAudioState::StateGroupName' has a wrong offset!");
static_assert(offsetof(FPlayerAudioState, StateName) == 0x000008, "Member 'FPlayerAudioState::StateName' has a wrong offset!");
static_assert(offsetof(FPlayerAudioState, StateOffName) == 0x000010, "Member 'FPlayerAudioState::StateOffName' has a wrong offset!");
static_assert(offsetof(FPlayerAudioState, StartEvent) == 0x000018, "Member 'FPlayerAudioState::StartEvent' has a wrong offset!");
static_assert(offsetof(FPlayerAudioState, StopEvent) == 0x000020, "Member 'FPlayerAudioState::StopEvent' has a wrong offset!");
static_assert(offsetof(FPlayerAudioState, EndServerTimestamp) == 0x000028, "Member 'FPlayerAudioState::EndServerTimestamp' has a wrong offset!");

// ScriptStruct OPP.WWWObjectKey
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FWWWObjectKey final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWObjectKey) == 0x000008, "Wrong alignment on FWWWObjectKey");
static_assert(sizeof(FWWWObjectKey) == 0x000008, "Wrong size on FWWWObjectKey");

// ScriptStruct OPP.NPCStorylineFallbackPoolEntry
// 0x0010 (0x0010 - 0x0000)
struct FNPCStorylineFallbackPoolEntry final
{
public:
	int32                                         TrialsPlayedRequirementMin;                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrialsPlayedRequirementMax;                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StorylineVO;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCStorylineFallbackPoolEntry) == 0x000008, "Wrong alignment on FNPCStorylineFallbackPoolEntry");
static_assert(sizeof(FNPCStorylineFallbackPoolEntry) == 0x000010, "Wrong size on FNPCStorylineFallbackPoolEntry");
static_assert(offsetof(FNPCStorylineFallbackPoolEntry, TrialsPlayedRequirementMin) == 0x000000, "Member 'FNPCStorylineFallbackPoolEntry::TrialsPlayedRequirementMin' has a wrong offset!");
static_assert(offsetof(FNPCStorylineFallbackPoolEntry, TrialsPlayedRequirementMax) == 0x000004, "Member 'FNPCStorylineFallbackPoolEntry::TrialsPlayedRequirementMax' has a wrong offset!");
static_assert(offsetof(FNPCStorylineFallbackPoolEntry, StorylineVO) == 0x000008, "Member 'FNPCStorylineFallbackPoolEntry::StorylineVO' has a wrong offset!");

// ScriptStruct OPP.NPCStorylineFallbackPool
// 0x0010 (0x0010 - 0x0000)
struct FNPCStorylineFallbackPool final
{
public:
	TArray<struct FNPCStorylineFallbackPoolEntry> StorylineFallBackPoolEntries;                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCStorylineFallbackPool) == 0x000008, "Wrong alignment on FNPCStorylineFallbackPool");
static_assert(sizeof(FNPCStorylineFallbackPool) == 0x000010, "Wrong size on FNPCStorylineFallbackPool");
static_assert(offsetof(FNPCStorylineFallbackPool, StorylineFallBackPoolEntries) == 0x000000, "Member 'FNPCStorylineFallbackPool::StorylineFallBackPoolEntries' has a wrong offset!");

// ScriptStruct OPP.PlayerColdData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerColdData final
{
public:
	class FName                                   SourceName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPawnTime;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopPawnTime;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartServerTime;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopServerTime;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerColdData) == 0x000004, "Wrong alignment on FPlayerColdData");
static_assert(sizeof(FPlayerColdData) == 0x000018, "Wrong size on FPlayerColdData");
static_assert(offsetof(FPlayerColdData, SourceName) == 0x000000, "Member 'FPlayerColdData::SourceName' has a wrong offset!");
static_assert(offsetof(FPlayerColdData, StartPawnTime) == 0x000008, "Member 'FPlayerColdData::StartPawnTime' has a wrong offset!");
static_assert(offsetof(FPlayerColdData, StopPawnTime) == 0x00000C, "Member 'FPlayerColdData::StopPawnTime' has a wrong offset!");
static_assert(offsetof(FPlayerColdData, StartServerTime) == 0x000010, "Member 'FPlayerColdData::StartServerTime' has a wrong offset!");
static_assert(offsetof(FPlayerColdData, StopServerTime) == 0x000014, "Member 'FPlayerColdData::StopServerTime' has a wrong offset!");

// ScriptStruct OPP.SummonedBotDebugInfo
// 0x0048 (0x0048 - 0x0000)
struct FSummonedBotDebugInfo final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnedStageTime;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetiredStageTime;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBeforeRetirement;                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InitialTargetPlayer;                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RuleName;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonedBotDebugInfo) == 0x000008, "Wrong alignment on FSummonedBotDebugInfo");
static_assert(sizeof(FSummonedBotDebugInfo) == 0x000048, "Wrong size on FSummonedBotDebugInfo");
static_assert(offsetof(FSummonedBotDebugInfo, NPCType) == 0x000000, "Member 'FSummonedBotDebugInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, BotName) == 0x000008, "Member 'FSummonedBotDebugInfo::BotName' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, SpawnedStageTime) == 0x000018, "Member 'FSummonedBotDebugInfo::SpawnedStageTime' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, RetiredStageTime) == 0x00001C, "Member 'FSummonedBotDebugInfo::RetiredStageTime' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, MinTimeBeforeRetirement) == 0x000020, "Member 'FSummonedBotDebugInfo::MinTimeBeforeRetirement' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, InitialTargetPlayer) == 0x000028, "Member 'FSummonedBotDebugInfo::InitialTargetPlayer' has a wrong offset!");
static_assert(offsetof(FSummonedBotDebugInfo, RuleName) == 0x000038, "Member 'FSummonedBotDebugInfo::RuleName' has a wrong offset!");

// ScriptStruct OPP.FindPathParameter
// 0x0020 (0x0020 - 0x0000)
struct FFindPathParameter final
{
public:
	bool                                          bAllowedCoopRoom;                                  // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedClosedConnection;                          // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathDistance;                                   // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFloorChange;                                 // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBRoomGroup*>                   RestrictedSections;                                // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFindPathParameter) == 0x000008, "Wrong alignment on FFindPathParameter");
static_assert(sizeof(FFindPathParameter) == 0x000020, "Wrong size on FFindPathParameter");
static_assert(offsetof(FFindPathParameter, bAllowedCoopRoom) == 0x000000, "Member 'FFindPathParameter::bAllowedCoopRoom' has a wrong offset!");
static_assert(offsetof(FFindPathParameter, bAllowedClosedConnection) == 0x000001, "Member 'FFindPathParameter::bAllowedClosedConnection' has a wrong offset!");
static_assert(offsetof(FFindPathParameter, MaxPathDistance) == 0x000004, "Member 'FFindPathParameter::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(FFindPathParameter, bAllowFloorChange) == 0x000008, "Member 'FFindPathParameter::bAllowFloorChange' has a wrong offset!");
static_assert(offsetof(FFindPathParameter, RestrictedSections) == 0x000010, "Member 'FFindPathParameter::RestrictedSections' has a wrong offset!");

// ScriptStruct OPP.StaminaRestoreData
// 0x000C (0x000C - 0x0000)
struct FStaminaRestoreData final
{
public:
	float                                         PawnTime;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoStaminaRegenTime;                                // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaminaRestoreData) == 0x000004, "Wrong alignment on FStaminaRestoreData");
static_assert(sizeof(FStaminaRestoreData) == 0x00000C, "Wrong size on FStaminaRestoreData");
static_assert(offsetof(FStaminaRestoreData, PawnTime) == 0x000000, "Member 'FStaminaRestoreData::PawnTime' has a wrong offset!");
static_assert(offsetof(FStaminaRestoreData, Amount) == 0x000004, "Member 'FStaminaRestoreData::Amount' has a wrong offset!");
static_assert(offsetof(FStaminaRestoreData, NoStaminaRegenTime) == 0x000008, "Member 'FStaminaRestoreData::NoStaminaRegenTime' has a wrong offset!");

// ScriptStruct OPP.DizzinessData
// 0x0158 (0x0158 - 0x0000)
struct alignas(0x04) FDizzinessData final
{
public:
	uint8                                         Pad_0[0x158];                                      // 0x0000(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDizzinessData) == 0x000004, "Wrong alignment on FDizzinessData");
static_assert(sizeof(FDizzinessData) == 0x000158, "Wrong size on FDizzinessData");

// ScriptStruct OPP.AIMolotovData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAIMolotovData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIMolotovData) == 0x000004, "Wrong alignment on FAIMolotovData");
static_assert(sizeof(FAIMolotovData) == 0x000010, "Wrong size on FAIMolotovData");

// ScriptStruct OPP.NetworkVector2D
// 0x001C (0x001C - 0x0000)
struct FNetworkVector2D final
{
public:
	struct FVector2D                              ReplicatedValue;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x14];                                       // 0x0008(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkVector2D) == 0x000004, "Wrong alignment on FNetworkVector2D");
static_assert(sizeof(FNetworkVector2D) == 0x00001C, "Wrong size on FNetworkVector2D");
static_assert(offsetof(FNetworkVector2D, ReplicatedValue) == 0x000000, "Member 'FNetworkVector2D::ReplicatedValue' has a wrong offset!");

// ScriptStruct OPP.RBSelectableStageInfo
// 0x0040 (0x0040 - 0x0000)
struct FRBSelectableStageInfo final
{
public:
	class FName                                   StageName;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StageDisplayName;                                  // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           MissionOptions;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           MissionOptionDisplayNames;                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBSelectableStageInfo) == 0x000008, "Wrong alignment on FRBSelectableStageInfo");
static_assert(sizeof(FRBSelectableStageInfo) == 0x000040, "Wrong size on FRBSelectableStageInfo");
static_assert(offsetof(FRBSelectableStageInfo, StageName) == 0x000000, "Member 'FRBSelectableStageInfo::StageName' has a wrong offset!");
static_assert(offsetof(FRBSelectableStageInfo, StageDisplayName) == 0x000008, "Member 'FRBSelectableStageInfo::StageDisplayName' has a wrong offset!");
static_assert(offsetof(FRBSelectableStageInfo, MissionOptions) == 0x000020, "Member 'FRBSelectableStageInfo::MissionOptions' has a wrong offset!");
static_assert(offsetof(FRBSelectableStageInfo, MissionOptionDisplayNames) == 0x000030, "Member 'FRBSelectableStageInfo::MissionOptionDisplayNames' has a wrong offset!");

// ScriptStruct OPP.RBSelectableExperimentInfo
// 0x0030 (0x0030 - 0x0000)
struct FRBSelectableExperimentInfo final
{
public:
	class FName                                   ExperimentName;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ExperimentDisplayName;                             // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRBSelectableStageInfo>         AvailableStageInfos;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBSelectableExperimentInfo) == 0x000008, "Wrong alignment on FRBSelectableExperimentInfo");
static_assert(sizeof(FRBSelectableExperimentInfo) == 0x000030, "Wrong size on FRBSelectableExperimentInfo");
static_assert(offsetof(FRBSelectableExperimentInfo, ExperimentName) == 0x000000, "Member 'FRBSelectableExperimentInfo::ExperimentName' has a wrong offset!");
static_assert(offsetof(FRBSelectableExperimentInfo, ExperimentDisplayName) == 0x000008, "Member 'FRBSelectableExperimentInfo::ExperimentDisplayName' has a wrong offset!");
static_assert(offsetof(FRBSelectableExperimentInfo, AvailableStageInfos) == 0x000020, "Member 'FRBSelectableExperimentInfo::AvailableStageInfos' has a wrong offset!");

// ScriptStruct OPP.PlayerSpeedModifierData
// 0x001C (0x001C - 0x0000)
struct FPlayerSpeedModifierData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPawnTime;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSpeedModifierData) == 0x000004, "Wrong alignment on FPlayerSpeedModifierData");
static_assert(sizeof(FPlayerSpeedModifierData) == 0x00001C, "Wrong size on FPlayerSpeedModifierData");
static_assert(offsetof(FPlayerSpeedModifierData, ID) == 0x000000, "Member 'FPlayerSpeedModifierData::ID' has a wrong offset!");
static_assert(offsetof(FPlayerSpeedModifierData, StartPawnTime) == 0x000008, "Member 'FPlayerSpeedModifierData::StartPawnTime' has a wrong offset!");
static_assert(offsetof(FPlayerSpeedModifierData, Duration) == 0x00000C, "Member 'FPlayerSpeedModifierData::Duration' has a wrong offset!");
static_assert(offsetof(FPlayerSpeedModifierData, FadeOutDuration) == 0x000010, "Member 'FPlayerSpeedModifierData::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FPlayerSpeedModifierData, Modifier) == 0x000014, "Member 'FPlayerSpeedModifierData::Modifier' has a wrong offset!");
static_assert(offsetof(FPlayerSpeedModifierData, MaxSpeed) == 0x000018, "Member 'FPlayerSpeedModifierData::MaxSpeed' has a wrong offset!");

// ScriptStruct OPP.PlayerInterruptAction
// 0x0048 (0x0048 - 0x0000)
struct FPlayerInterruptAction final
{
public:
	class ARBPawn*                                Interrupter;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Weapon;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerInterruptActionType                    Type;                                              // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x37];                                      // 0x0011(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInterruptAction) == 0x000008, "Wrong alignment on FPlayerInterruptAction");
static_assert(sizeof(FPlayerInterruptAction) == 0x000048, "Wrong size on FPlayerInterruptAction");
static_assert(offsetof(FPlayerInterruptAction, Interrupter) == 0x000000, "Member 'FPlayerInterruptAction::Interrupter' has a wrong offset!");
static_assert(offsetof(FPlayerInterruptAction, Weapon) == 0x000008, "Member 'FPlayerInterruptAction::Weapon' has a wrong offset!");
static_assert(offsetof(FPlayerInterruptAction, Type) == 0x000010, "Member 'FPlayerInterruptAction::Type' has a wrong offset!");

// ScriptStruct OPP.ServerTravelInfo
// 0x0028 (0x0028 - 0x0000)
struct FServerTravelInfo final
{
public:
	EClientTravelSource                           TravelSource;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastStageName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastTrialName;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerTravelInfo) == 0x000008, "Wrong alignment on FServerTravelInfo");
static_assert(sizeof(FServerTravelInfo) == 0x000028, "Wrong size on FServerTravelInfo");
static_assert(offsetof(FServerTravelInfo, TravelSource) == 0x000000, "Member 'FServerTravelInfo::TravelSource' has a wrong offset!");
static_assert(offsetof(FServerTravelInfo, LastStageName) == 0x000008, "Member 'FServerTravelInfo::LastStageName' has a wrong offset!");
static_assert(offsetof(FServerTravelInfo, LastTrialName) == 0x000018, "Member 'FServerTravelInfo::LastTrialName' has a wrong offset!");

// ScriptStruct OPP.SimonTortureSequence
// 0x0010 (0x0010 - 0x0000)
struct FSimonTortureSequence final
{
public:
	TArray<ESimonTortureGameOption>               Sequences;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimonTortureSequence) == 0x000008, "Wrong alignment on FSimonTortureSequence");
static_assert(sizeof(FSimonTortureSequence) == 0x000010, "Wrong size on FSimonTortureSequence");
static_assert(offsetof(FSimonTortureSequence, Sequences) == 0x000000, "Member 'FSimonTortureSequence::Sequences' has a wrong offset!");

// ScriptStruct OPP.SimonTortureGameData
// 0x0010 (0x0010 - 0x0000)
struct FSimonTortureGameData final
{
public:
	TArray<struct FSimonTortureSequence>          RoundOptionSequencesToComplete;                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimonTortureGameData) == 0x000008, "Wrong alignment on FSimonTortureGameData");
static_assert(sizeof(FSimonTortureGameData) == 0x000010, "Wrong size on FSimonTortureGameData");
static_assert(offsetof(FSimonTortureGameData, RoundOptionSequencesToComplete) == 0x000000, "Member 'FSimonTortureGameData::RoundOptionSequencesToComplete' has a wrong offset!");

// ScriptStruct OPP.RBDestructibleBodyInstState
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FRBDestructibleBodyInstState final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBDestructibleBodyInstState) == 0x000010, "Wrong alignment on FRBDestructibleBodyInstState");
static_assert(sizeof(FRBDestructibleBodyInstState) == 0x000070, "Wrong size on FRBDestructibleBodyInstState");

// ScriptStruct OPP.VOMapping
// 0x0028 (0x0028 - 0x0000)
struct FVOMapping final
{
public:
	EVOContext                                    VOContext;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOPriority                                   VOPriority;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Line;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayONOIfInterrupting;                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayBeforeRepeatOnPawn;                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBeforeRepeatGlobal;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayAfterAnySimilarVO;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayAfterAnyVO;                                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimePlayed;                                    // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVOMapping) == 0x000008, "Wrong alignment on FVOMapping");
static_assert(sizeof(FVOMapping) == 0x000028, "Wrong size on FVOMapping");
static_assert(offsetof(FVOMapping, VOContext) == 0x000000, "Member 'FVOMapping::VOContext' has a wrong offset!");
static_assert(offsetof(FVOMapping, VOPriority) == 0x000001, "Member 'FVOMapping::VOPriority' has a wrong offset!");
static_assert(offsetof(FVOMapping, Line) == 0x000008, "Member 'FVOMapping::Line' has a wrong offset!");
static_assert(offsetof(FVOMapping, bPlayONOIfInterrupting) == 0x000010, "Member 'FVOMapping::bPlayONOIfInterrupting' has a wrong offset!");
static_assert(offsetof(FVOMapping, MinDelayBeforeRepeatOnPawn) == 0x000014, "Member 'FVOMapping::MinDelayBeforeRepeatOnPawn' has a wrong offset!");
static_assert(offsetof(FVOMapping, MinDelayBeforeRepeatGlobal) == 0x000018, "Member 'FVOMapping::MinDelayBeforeRepeatGlobal' has a wrong offset!");
static_assert(offsetof(FVOMapping, MinDelayAfterAnySimilarVO) == 0x00001C, "Member 'FVOMapping::MinDelayAfterAnySimilarVO' has a wrong offset!");
static_assert(offsetof(FVOMapping, MinDelayAfterAnyVO) == 0x000020, "Member 'FVOMapping::MinDelayAfterAnyVO' has a wrong offset!");
static_assert(offsetof(FVOMapping, LastTimePlayed) == 0x000024, "Member 'FVOMapping::LastTimePlayed' has a wrong offset!");

// ScriptStruct OPP.ScoringMissionConfig
// 0x00F0 (0x00F0 - 0x0000)
struct FScoringMissionConfig final
{
public:
	struct FRBMissionID                           MissionID;                                         // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       TimeToCompleteSeconds;                             // 0x0028(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringMissionConfig) == 0x000008, "Wrong alignment on FScoringMissionConfig");
static_assert(sizeof(FScoringMissionConfig) == 0x0000F0, "Wrong size on FScoringMissionConfig");
static_assert(offsetof(FScoringMissionConfig, MissionID) == 0x000000, "Member 'FScoringMissionConfig::MissionID' has a wrong offset!");
static_assert(offsetof(FScoringMissionConfig, TimeToCompleteSeconds) == 0x000028, "Member 'FScoringMissionConfig::TimeToCompleteSeconds' has a wrong offset!");

// ScriptStruct OPP.TennisScoreData
// 0x0008 (0x0008 - 0x0000)
struct FTennisScoreData final
{
public:
	int32                                         Player1Score;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Player2Score;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTennisScoreData) == 0x000004, "Wrong alignment on FTennisScoreData");
static_assert(sizeof(FTennisScoreData) == 0x000008, "Wrong size on FTennisScoreData");
static_assert(offsetof(FTennisScoreData, Player1Score) == 0x000000, "Member 'FTennisScoreData::Player1Score' has a wrong offset!");
static_assert(offsetof(FTennisScoreData, Player2Score) == 0x000004, "Member 'FTennisScoreData::Player2Score' has a wrong offset!");

// ScriptStruct OPP.MarkerInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FMarkerInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarkerInfo) == 0x000008, "Wrong alignment on FMarkerInfo");
static_assert(sizeof(FMarkerInfo) == 0x000020, "Wrong size on FMarkerInfo");

// ScriptStruct OPP.AxisSettings
// 0x0008 (0x0008 - 0x0000)
struct FAxisSettings final
{
public:
	EAxis                                         YawRotationAxis;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyOrientationAlpha;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAxisSettings) == 0x000004, "Wrong alignment on FAxisSettings");
static_assert(sizeof(FAxisSettings) == 0x000008, "Wrong size on FAxisSettings");
static_assert(offsetof(FAxisSettings, YawRotationAxis) == 0x000000, "Member 'FAxisSettings::YawRotationAxis' has a wrong offset!");
static_assert(offsetof(FAxisSettings, BodyOrientationAlpha) == 0x000004, "Member 'FAxisSettings::BodyOrientationAlpha' has a wrong offset!");

// ScriptStruct OPP.BoneRef
// 0x0010 (0x0010 - 0x0000)
struct FBoneRef final
{
public:
	struct FBoneReference                         Bone;                                              // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneRef) == 0x000004, "Wrong alignment on FBoneRef");
static_assert(sizeof(FBoneRef) == 0x000010, "Wrong size on FBoneRef");
static_assert(offsetof(FBoneRef, Bone) == 0x000000, "Member 'FBoneRef::Bone' has a wrong offset!");

// ScriptStruct OPP.AnimNode_OrientationWarping
// 0x0050 (0x0060 - 0x0010)
struct FAnimNode_OrientationWarping final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocomotionAngle;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxisSettings                          Settings;                                          // 0x0024(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneRef>                       SpineBones;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         IKFootRootBone;                                    // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_OrientationWarping) == 0x000008, "Wrong alignment on FAnimNode_OrientationWarping");
static_assert(sizeof(FAnimNode_OrientationWarping) == 0x000060, "Wrong size on FAnimNode_OrientationWarping");
static_assert(offsetof(FAnimNode_OrientationWarping, BasePose) == 0x000010, "Member 'FAnimNode_OrientationWarping::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_OrientationWarping, LocomotionAngle) == 0x000020, "Member 'FAnimNode_OrientationWarping::LocomotionAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OrientationWarping, Settings) == 0x000024, "Member 'FAnimNode_OrientationWarping::Settings' has a wrong offset!");
static_assert(offsetof(FAnimNode_OrientationWarping, SpineBones) == 0x000030, "Member 'FAnimNode_OrientationWarping::SpineBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_OrientationWarping, IKFootRootBone) == 0x000040, "Member 'FAnimNode_OrientationWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_OrientationWarping, PelvisBone) == 0x000050, "Member 'FAnimNode_OrientationWarping::PelvisBone' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningManagerRewardVolumeInfo
// 0x0030 (0x0030 - 0x0000)
struct FItemSpawningManagerRewardVolumeInfo final
{
public:
	int32                                         NumberOfItemsRemaining;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URBRewardRoomComponent*                 RewardRoomComponent;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemSpawningManagerRewardItemInfo> RewardItemInfos;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   AvailableContainers;                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawningManagerRewardVolumeInfo) == 0x000008, "Wrong alignment on FItemSpawningManagerRewardVolumeInfo");
static_assert(sizeof(FItemSpawningManagerRewardVolumeInfo) == 0x000030, "Wrong size on FItemSpawningManagerRewardVolumeInfo");
static_assert(offsetof(FItemSpawningManagerRewardVolumeInfo, NumberOfItemsRemaining) == 0x000000, "Member 'FItemSpawningManagerRewardVolumeInfo::NumberOfItemsRemaining' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRewardVolumeInfo, RewardRoomComponent) == 0x000008, "Member 'FItemSpawningManagerRewardVolumeInfo::RewardRoomComponent' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRewardVolumeInfo, RewardItemInfos) == 0x000010, "Member 'FItemSpawningManagerRewardVolumeInfo::RewardItemInfos' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRewardVolumeInfo, AvailableContainers) == 0x000020, "Member 'FItemSpawningManagerRewardVolumeInfo::AvailableContainers' has a wrong offset!");

// ScriptStruct OPP.MovementData
// 0x0058 (0x0058 - 0x0000)
struct FMovementData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRequestID                           RequestID;                                         // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DestinationActor;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x48];                                      // 0x0010(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementData) == 0x000008, "Wrong alignment on FMovementData");
static_assert(sizeof(FMovementData) == 0x000058, "Wrong size on FMovementData");
static_assert(offsetof(FMovementData, RequestID) == 0x000004, "Member 'FMovementData::RequestID' has a wrong offset!");
static_assert(offsetof(FMovementData, DestinationActor) == 0x000008, "Member 'FMovementData::DestinationActor' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBAlignFootIKToFeet
// 0x0050 (0x0118 - 0x00C8)
struct FAnimNode_RBAlignFootIKToFeet final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IK_RootBone;                                       // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftFootBone;                                      // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftIKBone;                                        // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFootBone;                                     // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightIKBone;                                       // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_RBAlignFootIKToFeet) == 0x000008, "Wrong alignment on FAnimNode_RBAlignFootIKToFeet");
static_assert(sizeof(FAnimNode_RBAlignFootIKToFeet) == 0x000118, "Wrong size on FAnimNode_RBAlignFootIKToFeet");
static_assert(offsetof(FAnimNode_RBAlignFootIKToFeet, IK_RootBone) == 0x0000C8, "Member 'FAnimNode_RBAlignFootIKToFeet::IK_RootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToFeet, LeftFootBone) == 0x0000D8, "Member 'FAnimNode_RBAlignFootIKToFeet::LeftFootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToFeet, LeftIKBone) == 0x0000E8, "Member 'FAnimNode_RBAlignFootIKToFeet::LeftIKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToFeet, RightFootBone) == 0x0000F8, "Member 'FAnimNode_RBAlignFootIKToFeet::RightFootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToFeet, RightIKBone) == 0x000108, "Member 'FAnimNode_RBAlignFootIKToFeet::RightIKBone' has a wrong offset!");

// ScriptStruct OPP.VORemapEntry
// 0x0010 (0x0010 - 0x0000)
struct FVORemapEntry final
{
public:
	class UAkAudioEvent*                          SourceEvent;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReplacementEvent;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVORemapEntry) == 0x000008, "Wrong alignment on FVORemapEntry");
static_assert(sizeof(FVORemapEntry) == 0x000010, "Wrong size on FVORemapEntry");
static_assert(offsetof(FVORemapEntry, SourceEvent) == 0x000000, "Member 'FVORemapEntry::SourceEvent' has a wrong offset!");
static_assert(offsetof(FVORemapEntry, ReplacementEvent) == 0x000008, "Member 'FVORemapEntry::ReplacementEvent' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBAlignFootIKToStairs
// 0x0090 (0x0158 - 0x00C8)
struct FAnimNode_RBAlignFootIKToStairs final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         LeftFootBone;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftToeBone;                                       // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftIKBone;                                        // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFootBone;                                     // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightToeBone;                                      // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightIKBone;                                       // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HipsBone;                                          // 0x0128(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnkleOffset;                                       // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectHips;                                        // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x1B];                                     // 0x013D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RBAlignFootIKToStairs) == 0x000008, "Wrong alignment on FAnimNode_RBAlignFootIKToStairs");
static_assert(sizeof(FAnimNode_RBAlignFootIKToStairs) == 0x000158, "Wrong size on FAnimNode_RBAlignFootIKToStairs");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, LeftFootBone) == 0x0000C8, "Member 'FAnimNode_RBAlignFootIKToStairs::LeftFootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, LeftToeBone) == 0x0000D8, "Member 'FAnimNode_RBAlignFootIKToStairs::LeftToeBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, LeftIKBone) == 0x0000E8, "Member 'FAnimNode_RBAlignFootIKToStairs::LeftIKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, RightFootBone) == 0x0000F8, "Member 'FAnimNode_RBAlignFootIKToStairs::RightFootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, RightToeBone) == 0x000108, "Member 'FAnimNode_RBAlignFootIKToStairs::RightToeBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, RightIKBone) == 0x000118, "Member 'FAnimNode_RBAlignFootIKToStairs::RightIKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, HipsBone) == 0x000128, "Member 'FAnimNode_RBAlignFootIKToStairs::HipsBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, AnkleOffset) == 0x000138, "Member 'FAnimNode_RBAlignFootIKToStairs::AnkleOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBAlignFootIKToStairs, AffectHips) == 0x00013C, "Member 'FAnimNode_RBAlignFootIKToStairs::AffectHips' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBFirstPersonRelative
// 0x0078 (0x0140 - 0x00C8)
struct FAnimNode_RBFirstPersonRelative final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         CameraBone;                                        // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 LeftArmBonesToModify;                              // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 RightArmBonesToModify;                             // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LeftArmAlpha;                                      // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightArmAlpha;                                     // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CameraTransformOffset;                             // 0x0100(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RBFirstPersonRelative) == 0x000010, "Wrong alignment on FAnimNode_RBFirstPersonRelative");
static_assert(sizeof(FAnimNode_RBFirstPersonRelative) == 0x000140, "Wrong size on FAnimNode_RBFirstPersonRelative");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, CameraBone) == 0x0000C8, "Member 'FAnimNode_RBFirstPersonRelative::CameraBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, LeftArmBonesToModify) == 0x0000D8, "Member 'FAnimNode_RBFirstPersonRelative::LeftArmBonesToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, RightArmBonesToModify) == 0x0000E8, "Member 'FAnimNode_RBFirstPersonRelative::RightArmBonesToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, LeftArmAlpha) == 0x0000F8, "Member 'FAnimNode_RBFirstPersonRelative::LeftArmAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, RightArmAlpha) == 0x0000FC, "Member 'FAnimNode_RBFirstPersonRelative::RightArmAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBFirstPersonRelative, CameraTransformOffset) == 0x000100, "Member 'FAnimNode_RBFirstPersonRelative::CameraTransformOffset' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBRelativeToCamera
// 0x00A8 (0x0170 - 0x00C8)
struct FAnimNode_RBRelativeToCamera final : public FAnimNode_SkeletalControlBase
{
public:
	struct FComponentSpacePoseLink                ArmPose;                                           // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraTransform;                                   // 0x00E0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CameraBone;                                        // 0x0110(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Bone;                                              // 0x0120(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x40];                                     // 0x0130(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RBRelativeToCamera) == 0x000010, "Wrong alignment on FAnimNode_RBRelativeToCamera");
static_assert(sizeof(FAnimNode_RBRelativeToCamera) == 0x000170, "Wrong size on FAnimNode_RBRelativeToCamera");
static_assert(offsetof(FAnimNode_RBRelativeToCamera, ArmPose) == 0x0000C8, "Member 'FAnimNode_RBRelativeToCamera::ArmPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBRelativeToCamera, CameraTransform) == 0x0000E0, "Member 'FAnimNode_RBRelativeToCamera::CameraTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBRelativeToCamera, CameraBone) == 0x000110, "Member 'FAnimNode_RBRelativeToCamera::CameraBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBRelativeToCamera, Bone) == 0x000120, "Member 'FAnimNode_RBRelativeToCamera::Bone' has a wrong offset!");

// ScriptStruct OPP.RandomSpawnNPCInfo
// 0x0002 (0x0002 - 0x0000)
struct FRandomSpawnNPCInfo final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomSpawnNPCInfo) == 0x000001, "Wrong alignment on FRandomSpawnNPCInfo");
static_assert(sizeof(FRandomSpawnNPCInfo) == 0x000002, "Wrong size on FRandomSpawnNPCInfo");
static_assert(offsetof(FRandomSpawnNPCInfo, NPCType) == 0x000000, "Member 'FRandomSpawnNPCInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FRandomSpawnNPCInfo, NPCFlavor) == 0x000001, "Member 'FRandomSpawnNPCInfo::NPCFlavor' has a wrong offset!");

// ScriptStruct OPP.RBGameConditionSet
// 0x0000 (0x0010 - 0x0010)
struct FRBGameConditionSet final : public FRBGenericConditionSet
{
};
static_assert(alignof(FRBGameConditionSet) == 0x000008, "Wrong alignment on FRBGameConditionSet");
static_assert(sizeof(FRBGameConditionSet) == 0x000010, "Wrong size on FRBGameConditionSet");

// ScriptStruct OPP.RBPlayerConditionSet
// 0x0000 (0x0010 - 0x0010)
struct FRBPlayerConditionSet final : public FRBGenericConditionSet
{
};
static_assert(alignof(FRBPlayerConditionSet) == 0x000008, "Wrong alignment on FRBPlayerConditionSet");
static_assert(sizeof(FRBPlayerConditionSet) == 0x000010, "Wrong size on FRBPlayerConditionSet");

// ScriptStruct OPP.SpawnEventConditions
// 0x04D8 (0x04D8 - 0x0000)
struct FSpawnEventConditions final
{
public:
	struct FConfigurableInt                       MinNumHealthyPlayers;                              // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MinDelayForSpawns;                                 // 0x00C8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MaxDelayForSpawns;                                 // 0x0190(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MaxActiveBotsOfSameType;                           // 0x0258(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBGameConditionSet                    GlobalSpawnConditions;                             // 0x0320(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bMustTargetSpecificPlayer;                         // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBPlayerConditionSet                  TargetConditions;                                  // 0x0338(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MaxSpawnDistanceToTarget;                          // 0x0348(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MinSpawnDistanceToTarget;                          // 0x0410(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnEventConditions) == 0x000008, "Wrong alignment on FSpawnEventConditions");
static_assert(sizeof(FSpawnEventConditions) == 0x0004D8, "Wrong size on FSpawnEventConditions");
static_assert(offsetof(FSpawnEventConditions, MinNumHealthyPlayers) == 0x000000, "Member 'FSpawnEventConditions::MinNumHealthyPlayers' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, MinDelayForSpawns) == 0x0000C8, "Member 'FSpawnEventConditions::MinDelayForSpawns' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, MaxDelayForSpawns) == 0x000190, "Member 'FSpawnEventConditions::MaxDelayForSpawns' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, MaxActiveBotsOfSameType) == 0x000258, "Member 'FSpawnEventConditions::MaxActiveBotsOfSameType' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, GlobalSpawnConditions) == 0x000320, "Member 'FSpawnEventConditions::GlobalSpawnConditions' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, bMustTargetSpecificPlayer) == 0x000330, "Member 'FSpawnEventConditions::bMustTargetSpecificPlayer' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, TargetConditions) == 0x000338, "Member 'FSpawnEventConditions::TargetConditions' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, MaxSpawnDistanceToTarget) == 0x000348, "Member 'FSpawnEventConditions::MaxSpawnDistanceToTarget' has a wrong offset!");
static_assert(offsetof(FSpawnEventConditions, MinSpawnDistanceToTarget) == 0x000410, "Member 'FSpawnEventConditions::MinSpawnDistanceToTarget' has a wrong offset!");

// ScriptStruct OPP.RandomSpawnParams
// 0x05C0 (0x05C0 - 0x0000)
struct FRandomSpawnParams final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomSpawnNPCInfo>            RandomNPCInfos;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSpawnEventConditions                  SpawnConditions;                                   // 0x0018(0x04D8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MinBotLifetime;                                    // 0x04F0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartAlertedTowardsTargetPlayer;                  // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomSpawnParams) == 0x000008, "Wrong alignment on FRandomSpawnParams");
static_assert(sizeof(FRandomSpawnParams) == 0x0005C0, "Wrong size on FRandomSpawnParams");
static_assert(offsetof(FRandomSpawnParams, NPCType) == 0x000000, "Member 'FRandomSpawnParams::NPCType' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, NPCFlavor) == 0x000001, "Member 'FRandomSpawnParams::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, bEnable) == 0x000002, "Member 'FRandomSpawnParams::bEnable' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, RandomNPCInfos) == 0x000008, "Member 'FRandomSpawnParams::RandomNPCInfos' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, SpawnConditions) == 0x000018, "Member 'FRandomSpawnParams::SpawnConditions' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, MinBotLifetime) == 0x0004F0, "Member 'FRandomSpawnParams::MinBotLifetime' has a wrong offset!");
static_assert(offsetof(FRandomSpawnParams, bStartAlertedTowardsTargetPlayer) == 0x0005B8, "Member 'FRandomSpawnParams::bStartAlertedTowardsTargetPlayer' has a wrong offset!");

// ScriptStruct OPP.AnimNode_RBScaleStride
// 0x0028 (0x00F0 - 0x00C8)
struct FAnimNode_RBScaleStride final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         LeftFoot;                                          // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFoot;                                         // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinimumZ;                                          // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideScale;                                       // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_RBScaleStride) == 0x000008, "Wrong alignment on FAnimNode_RBScaleStride");
static_assert(sizeof(FAnimNode_RBScaleStride) == 0x0000F0, "Wrong size on FAnimNode_RBScaleStride");
static_assert(offsetof(FAnimNode_RBScaleStride, LeftFoot) == 0x0000C8, "Member 'FAnimNode_RBScaleStride::LeftFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBScaleStride, RightFoot) == 0x0000D8, "Member 'FAnimNode_RBScaleStride::RightFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBScaleStride, MinimumZ) == 0x0000E8, "Member 'FAnimNode_RBScaleStride::MinimumZ' has a wrong offset!");
static_assert(offsetof(FAnimNode_RBScaleStride, StrideScale) == 0x0000EC, "Member 'FAnimNode_RBScaleStride::StrideScale' has a wrong offset!");

// ScriptStruct OPP.IKFootLocation
// 0x0030 (0x0030 - 0x0000)
struct FIKFootLocation final
{
public:
	struct FVector                                LimbRootLocation;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActualLocation;                                    // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLocation;                                       // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKFootLocation) == 0x000004, "Wrong alignment on FIKFootLocation");
static_assert(sizeof(FIKFootLocation) == 0x000030, "Wrong size on FIKFootLocation");
static_assert(offsetof(FIKFootLocation, LimbRootLocation) == 0x000000, "Member 'FIKFootLocation::LimbRootLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, OriginLocation) == 0x00000C, "Member 'FIKFootLocation::OriginLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, ActualLocation) == 0x000018, "Member 'FIKFootLocation::ActualLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, NewLocation) == 0x000024, "Member 'FIKFootLocation::NewLocation' has a wrong offset!");

// ScriptStruct OPP.RBActiveSkillSettings
// 0x002C (0x002C - 0x0000)
struct FRBActiveSkillSettings final
{
public:
	EActiveSkillType                              ActiveSkillType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownBetweenCharges;                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerRadius;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerDelay;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeDuration;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Effect;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadius;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimeAssetEffectDurationMultiplier;                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration2;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistractionRange;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBActiveSkillSettings) == 0x000004, "Wrong alignment on FRBActiveSkillSettings");
static_assert(sizeof(FRBActiveSkillSettings) == 0x00002C, "Wrong size on FRBActiveSkillSettings");
static_assert(offsetof(FRBActiveSkillSettings, ActiveSkillType) == 0x000000, "Member 'FRBActiveSkillSettings::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, CooldownBetweenCharges) == 0x000004, "Member 'FRBActiveSkillSettings::CooldownBetweenCharges' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, TriggerRadius) == 0x000008, "Member 'FRBActiveSkillSettings::TriggerRadius' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, TriggerDelay) == 0x00000C, "Member 'FRBActiveSkillSettings::TriggerDelay' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, ChargeDuration) == 0x000010, "Member 'FRBActiveSkillSettings::ChargeDuration' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, Effect) == 0x000014, "Member 'FRBActiveSkillSettings::Effect' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, EffectRadius) == 0x000018, "Member 'FRBActiveSkillSettings::EffectRadius' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, EffectDuration) == 0x00001C, "Member 'FRBActiveSkillSettings::EffectDuration' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, PrimeAssetEffectDurationMultiplier) == 0x000020, "Member 'FRBActiveSkillSettings::PrimeAssetEffectDurationMultiplier' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, EffectDuration2) == 0x000024, "Member 'FRBActiveSkillSettings::EffectDuration2' has a wrong offset!");
static_assert(offsetof(FRBActiveSkillSettings, DistractionRange) == 0x000028, "Member 'FRBActiveSkillSettings::DistractionRange' has a wrong offset!");

// ScriptStruct OPP.RBRoundResult
// 0x0014 (0x0014 - 0x0000)
struct FRBRoundResult final
{
public:
	int32                                         RoundNumber;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         WinningTeam;                                       // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdversarialRole                              WinningRole;                                       // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundWinCondition                            WinCondition;                                      // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLeft;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team1Death;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team2Death;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBRoundResult) == 0x000004, "Wrong alignment on FRBRoundResult");
static_assert(sizeof(FRBRoundResult) == 0x000014, "Wrong size on FRBRoundResult");
static_assert(offsetof(FRBRoundResult, RoundNumber) == 0x000000, "Member 'FRBRoundResult::RoundNumber' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, WinningTeam) == 0x000004, "Member 'FRBRoundResult::WinningTeam' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, WinningRole) == 0x000005, "Member 'FRBRoundResult::WinningRole' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, WinCondition) == 0x000006, "Member 'FRBRoundResult::WinCondition' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, TimeLeft) == 0x000008, "Member 'FRBRoundResult::TimeLeft' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, Team1Death) == 0x00000C, "Member 'FRBRoundResult::Team1Death' has a wrong offset!");
static_assert(offsetof(FRBRoundResult, Team2Death) == 0x000010, "Member 'FRBRoundResult::Team2Death' has a wrong offset!");

// ScriptStruct OPP.PathBlockingCoordinationInfo
// 0x0020 (0x0020 - 0x0000)
struct FPathBlockingCoordinationInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBAreaExitPoint*>               ReservedExitPoints;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathBlockingCoordinationInfo) == 0x000008, "Wrong alignment on FPathBlockingCoordinationInfo");
static_assert(sizeof(FPathBlockingCoordinationInfo) == 0x000020, "Wrong size on FPathBlockingCoordinationInfo");
static_assert(offsetof(FPathBlockingCoordinationInfo, ReservedExitPoints) == 0x000010, "Member 'FPathBlockingCoordinationInfo::ReservedExitPoints' has a wrong offset!");

// ScriptStruct OPP.InvestigationInterestPointData
// 0x0028 (0x0028 - 0x0000)
struct FInvestigationInterestPointData final
{
public:
	class URBNPCInterestPointComponent*           InterestPoint;                                     // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExplicitInterestLocation;                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearLineCheck;                                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xB];                                       // 0x0019(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookDuration;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationInterestPointData) == 0x000008, "Wrong alignment on FInvestigationInterestPointData");
static_assert(sizeof(FInvestigationInterestPointData) == 0x000028, "Wrong size on FInvestigationInterestPointData");
static_assert(offsetof(FInvestigationInterestPointData, InterestPoint) == 0x000000, "Member 'FInvestigationInterestPointData::InterestPoint' has a wrong offset!");
static_assert(offsetof(FInvestigationInterestPointData, ExplicitInterestLocation) == 0x000008, "Member 'FInvestigationInterestPointData::ExplicitInterestLocation' has a wrong offset!");
static_assert(offsetof(FInvestigationInterestPointData, Score) == 0x000014, "Member 'FInvestigationInterestPointData::Score' has a wrong offset!");
static_assert(offsetof(FInvestigationInterestPointData, bClearLineCheck) == 0x000018, "Member 'FInvestigationInterestPointData::bClearLineCheck' has a wrong offset!");
static_assert(offsetof(FInvestigationInterestPointData, LookDuration) == 0x000024, "Member 'FInvestigationInterestPointData::LookDuration' has a wrong offset!");

// ScriptStruct OPP.OptionData
// 0x00E0 (0x00E0 - 0x0000)
struct FOptionData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DescriptionImage;                                  // 0x0018(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ErrorText;                                         // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EOptionsMenuOption                            EntryType;                                         // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGamepadOption;                                  // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackingId;                                        // 0x00D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOptionData) == 0x000008, "Wrong alignment on FOptionData");
static_assert(sizeof(FOptionData) == 0x0000E0, "Wrong size on FOptionData");
static_assert(offsetof(FOptionData, Title) == 0x000000, "Member 'FOptionData::Title' has a wrong offset!");
static_assert(offsetof(FOptionData, DescriptionImage) == 0x000018, "Member 'FOptionData::DescriptionImage' has a wrong offset!");
static_assert(offsetof(FOptionData, DescriptionText) == 0x0000A0, "Member 'FOptionData::DescriptionText' has a wrong offset!");
static_assert(offsetof(FOptionData, ErrorText) == 0x0000B8, "Member 'FOptionData::ErrorText' has a wrong offset!");
static_assert(offsetof(FOptionData, EntryType) == 0x0000D0, "Member 'FOptionData::EntryType' has a wrong offset!");
static_assert(offsetof(FOptionData, bIsGamepadOption) == 0x0000D1, "Member 'FOptionData::bIsGamepadOption' has a wrong offset!");
static_assert(offsetof(FOptionData, TrackingId) == 0x0000D4, "Member 'FOptionData::TrackingId' has a wrong offset!");

// ScriptStruct OPP.RBAICommandRef
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FRBAICommandRef final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBAICommandRef) == 0x000004, "Wrong alignment on FRBAICommandRef");
static_assert(sizeof(FRBAICommandRef) == 0x00000C, "Wrong size on FRBAICommandRef");

// ScriptStruct OPP.RBAIConditionSet
// 0x0000 (0x0010 - 0x0010)
struct FRBAIConditionSet final : public FRBGenericConditionSet
{
};
static_assert(alignof(FRBAIConditionSet) == 0x000008, "Wrong alignment on FRBAIConditionSet");
static_assert(sizeof(FRBAIConditionSet) == 0x000010, "Wrong size on FRBAIConditionSet");

// ScriptStruct OPP.NPCReplicatedConfig
// 0x0020 (0x0020 - 0x0000)
struct FNPCReplicatedConfig final
{
public:
	ENPCFlavor                                    NPCFlavor;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepHeaviness;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyEffectIntensity;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreathing;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayContinuousSound;                              // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeAfterDamageForContinuous;                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicLookScanRange;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicLookScanFrequency;                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NPCLifetimeRandomSelector;                         // 0x001C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCReplicatedConfig) == 0x000004, "Wrong alignment on FNPCReplicatedConfig");
static_assert(sizeof(FNPCReplicatedConfig) == 0x000020, "Wrong size on FNPCReplicatedConfig");
static_assert(offsetof(FNPCReplicatedConfig, NPCFlavor) == 0x000000, "Member 'FNPCReplicatedConfig::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, StepHeaviness) == 0x000004, "Member 'FNPCReplicatedConfig::StepHeaviness' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, BodyEffectIntensity) == 0x000008, "Member 'FNPCReplicatedConfig::BodyEffectIntensity' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, bBreathing) == 0x00000C, "Member 'FNPCReplicatedConfig::bBreathing' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, bPlayContinuousSound) == 0x00000D, "Member 'FNPCReplicatedConfig::bPlayContinuousSound' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, MinTimeAfterDamageForContinuous) == 0x000010, "Member 'FNPCReplicatedConfig::MinTimeAfterDamageForContinuous' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, DynamicLookScanRange) == 0x000014, "Member 'FNPCReplicatedConfig::DynamicLookScanRange' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, DynamicLookScanFrequency) == 0x000018, "Member 'FNPCReplicatedConfig::DynamicLookScanFrequency' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedConfig, NPCLifetimeRandomSelector) == 0x00001C, "Member 'FNPCReplicatedConfig::NPCLifetimeRandomSelector' has a wrong offset!");

// ScriptStruct OPP.RoomLocationHint
// 0x0040 (0x0040 - 0x0000)
struct FRoomLocationHint final
{
public:
	TSoftObjectPtr<class ARBRoom>                 Room;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomLocationHint) == 0x000008, "Wrong alignment on FRoomLocationHint");
static_assert(sizeof(FRoomLocationHint) == 0x000040, "Wrong size on FRoomLocationHint");
static_assert(offsetof(FRoomLocationHint, Room) == 0x000000, "Member 'FRoomLocationHint::Room' has a wrong offset!");
static_assert(offsetof(FRoomLocationHint, HintText) == 0x000028, "Member 'FRoomLocationHint::HintText' has a wrong offset!");

// ScriptStruct OPP.AIGlobalConfig
// 0x0060 (0x0060 - 0x0000)
struct FAIGlobalConfig final
{
public:
	ENPCFlavor                                    NPCFlavor;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NPCFlavor : 1;                           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIgnorePlayers;                                    // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bIgnorePlayers : 1;                      // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIgnoreNonFakePlayers;                             // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bIgnoreNonFakePlayers : 1;               // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bStartNeutral;                                     // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bStartNeutral : 1;                       // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bChasePlayers;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bChasePlayers : 1;                       // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAlwaysChase;                                      // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysChase : 1;                        // 0x000B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAlwaysIntense;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysIntense : 1;                      // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanPlayLookAts;                                   // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanPlayLookAts : 1;                     // 0x000F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanTakeDamage;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanTakeDamage : 1;                      // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseHealth;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BaseHealth : 1;                          // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCWeapon                                    Weapon;                                            // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Weapon : 1;                              // 0x001A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bRelevantForMusic;                                 // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bRelevantForMusic : 1;                   // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         YieldPriority;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldPriority : 1;                       // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanYield;                                         // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanYield : 1;                           // 0x0026(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxClimbHeight;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxClimbHeight : 1;                      // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDropHeight;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDropHeight : 1;                       // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EBotDoorPassBehavior                          DoorPassBehavior;                                  // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorPassBehavior : 1;                    // 0x0036(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorCloseProbability;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorCloseProbability : 1;                // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorLockProbability;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorLockProbability : 1;                 // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedMoveInterruptByOtherUnawareTime;             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedMoveInterruptByOtherUnawareTime : 1; // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedMoveInterruptByTargetUnawareTime;            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedMoveInterruptByTargetUnawareTime : 1; // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCHitReactionType                           SmallInterruptionReactionType;                     // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SmallInterruptionReactionType : 1;       // 0x0056(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCHitReactionType                           InterruptionReactionType;                          // 0x0057(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InterruptionReactionType : 1;            // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCHitReactionType                           UpgradedInterruptionReactionType;                  // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UpgradedInterruptionReactionType : 1;    // 0x005A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCHitReactionType                           FallingReactionType;                               // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FallingReactionType : 1;                 // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGlobalConfig) == 0x000004, "Wrong alignment on FAIGlobalConfig");
static_assert(sizeof(FAIGlobalConfig) == 0x000060, "Wrong size on FAIGlobalConfig");
static_assert(offsetof(FAIGlobalConfig, NPCFlavor) == 0x000000, "Member 'FAIGlobalConfig::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bIgnorePlayers) == 0x000002, "Member 'FAIGlobalConfig::bIgnorePlayers' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bIgnoreNonFakePlayers) == 0x000004, "Member 'FAIGlobalConfig::bIgnoreNonFakePlayers' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bStartNeutral) == 0x000006, "Member 'FAIGlobalConfig::bStartNeutral' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bChasePlayers) == 0x000008, "Member 'FAIGlobalConfig::bChasePlayers' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bAlwaysChase) == 0x00000A, "Member 'FAIGlobalConfig::bAlwaysChase' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bAlwaysIntense) == 0x00000C, "Member 'FAIGlobalConfig::bAlwaysIntense' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bCanPlayLookAts) == 0x00000E, "Member 'FAIGlobalConfig::bCanPlayLookAts' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bCanTakeDamage) == 0x000010, "Member 'FAIGlobalConfig::bCanTakeDamage' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, BaseHealth) == 0x000014, "Member 'FAIGlobalConfig::BaseHealth' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, Weapon) == 0x000019, "Member 'FAIGlobalConfig::Weapon' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bRelevantForMusic) == 0x00001B, "Member 'FAIGlobalConfig::bRelevantForMusic' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, YieldPriority) == 0x000020, "Member 'FAIGlobalConfig::YieldPriority' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, bCanYield) == 0x000025, "Member 'FAIGlobalConfig::bCanYield' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, MaxClimbHeight) == 0x000028, "Member 'FAIGlobalConfig::MaxClimbHeight' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, MaxDropHeight) == 0x000030, "Member 'FAIGlobalConfig::MaxDropHeight' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, DoorPassBehavior) == 0x000035, "Member 'FAIGlobalConfig::DoorPassBehavior' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, DoorCloseProbability) == 0x000038, "Member 'FAIGlobalConfig::DoorCloseProbability' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, DoorLockProbability) == 0x000040, "Member 'FAIGlobalConfig::DoorLockProbability' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, PairedMoveInterruptByOtherUnawareTime) == 0x000048, "Member 'FAIGlobalConfig::PairedMoveInterruptByOtherUnawareTime' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, PairedMoveInterruptByTargetUnawareTime) == 0x000050, "Member 'FAIGlobalConfig::PairedMoveInterruptByTargetUnawareTime' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, SmallInterruptionReactionType) == 0x000055, "Member 'FAIGlobalConfig::SmallInterruptionReactionType' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, InterruptionReactionType) == 0x000057, "Member 'FAIGlobalConfig::InterruptionReactionType' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, UpgradedInterruptionReactionType) == 0x000059, "Member 'FAIGlobalConfig::UpgradedInterruptionReactionType' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, FallingReactionType) == 0x00005B, "Member 'FAIGlobalConfig::FallingReactionType' has a wrong offset!");

// ScriptStruct OPP.AIStimulusValueConfig
// 0x0040 (0x0040 - 0x0000)
struct FAIStimulusValueConfig final
{
public:
	float                                         PartialPlayerVisibilityValue;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PartialPlayerVisibilityValue : 1;        // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullPlayerVisibilityValue;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullPlayerVisibilityValue : 1;           // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LostChasedPlayerValue;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LostChasedPlayerValue : 1;               // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinorAudioValue;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinorAudioValue : 1;                     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalAudioValue;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NormalAudioValue : 1;                    // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObviousAudioValue;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ObviousAudioValue : 1;                   // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceMovementValue;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SurfaceMovementValue : 1;                // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HighPriorityEventValue;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HighPriorityEventValue : 1;              // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStimulusValueConfig) == 0x000004, "Wrong alignment on FAIStimulusValueConfig");
static_assert(sizeof(FAIStimulusValueConfig) == 0x000040, "Wrong size on FAIStimulusValueConfig");
static_assert(offsetof(FAIStimulusValueConfig, PartialPlayerVisibilityValue) == 0x000000, "Member 'FAIStimulusValueConfig::PartialPlayerVisibilityValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, FullPlayerVisibilityValue) == 0x000008, "Member 'FAIStimulusValueConfig::FullPlayerVisibilityValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, LostChasedPlayerValue) == 0x000010, "Member 'FAIStimulusValueConfig::LostChasedPlayerValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, MinorAudioValue) == 0x000018, "Member 'FAIStimulusValueConfig::MinorAudioValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, NormalAudioValue) == 0x000020, "Member 'FAIStimulusValueConfig::NormalAudioValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, ObviousAudioValue) == 0x000028, "Member 'FAIStimulusValueConfig::ObviousAudioValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, SurfaceMovementValue) == 0x000030, "Member 'FAIStimulusValueConfig::SurfaceMovementValue' has a wrong offset!");
static_assert(offsetof(FAIStimulusValueConfig, HighPriorityEventValue) == 0x000038, "Member 'FAIStimulusValueConfig::HighPriorityEventValue' has a wrong offset!");

// ScriptStruct OPP.AIStimulusOptionConfig
// 0x0010 (0x0010 - 0x0000)
struct FAIStimulusOptionConfig final
{
public:
	bool                                          bPartialPlayerVisibility;                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bPartialPlayerVisibility : 1;            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bFullPlayerVisibility;                             // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bFullPlayerVisibility : 1;               // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bLostChasedPlayer;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bLostChasedPlayer : 1;                   // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bMinorAudio;                                       // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bMinorAudio : 1;                         // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNormalAudio;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bNormalAudio : 1;                        // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bObviousAudio;                                     // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bObviousAudio : 1;                       // 0x000B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bSurfaceMovement;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bSurfaceMovement : 1;                    // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bHighPriorityEvent;                                // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bHighPriorityEvent : 1;                  // 0x000F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAIStimulusOptionConfig) == 0x000001, "Wrong alignment on FAIStimulusOptionConfig");
static_assert(sizeof(FAIStimulusOptionConfig) == 0x000010, "Wrong size on FAIStimulusOptionConfig");
static_assert(offsetof(FAIStimulusOptionConfig, bPartialPlayerVisibility) == 0x000000, "Member 'FAIStimulusOptionConfig::bPartialPlayerVisibility' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bFullPlayerVisibility) == 0x000002, "Member 'FAIStimulusOptionConfig::bFullPlayerVisibility' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bLostChasedPlayer) == 0x000004, "Member 'FAIStimulusOptionConfig::bLostChasedPlayer' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bMinorAudio) == 0x000006, "Member 'FAIStimulusOptionConfig::bMinorAudio' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bNormalAudio) == 0x000008, "Member 'FAIStimulusOptionConfig::bNormalAudio' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bObviousAudio) == 0x00000A, "Member 'FAIStimulusOptionConfig::bObviousAudio' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bSurfaceMovement) == 0x00000C, "Member 'FAIStimulusOptionConfig::bSurfaceMovement' has a wrong offset!");
static_assert(offsetof(FAIStimulusOptionConfig, bHighPriorityEvent) == 0x00000E, "Member 'FAIStimulusOptionConfig::bHighPriorityEvent' has a wrong offset!");

// ScriptStruct OPP.AIAwarenessConfig
// 0x0268 (0x0268 - 0x0000)
struct FAIAwarenessConfig final
{
public:
	bool                                          bAllowAwarenessLoop;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAllowAwarenessLoop : 1;                 // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bConvertHighPriorityToObvious;                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bConvertHighPriorityToObvious : 1;       // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanEnterSuspicious;                               // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanEnterSuspicious : 1;                 // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAlwaysAlerted;                                    // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysAlerted : 1;                      // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         AlertedFromUnawareStartingMeter;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AlertedFromUnawareStartingMeter : 1;     // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumStimulusStrenght;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumStimulusStrenght : 1;             // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayBetweenInvestigationTargetSwitch;          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayBetweenInvestigationTargetSwitch : 1; // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceForInvestigationTargetSwitch;           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDistanceForInvestigationTargetSwitch : 1; // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAngleForInvestigationTargetSwitch;              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinAngleForInvestigationTargetSwitch : 1; // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 UnawareStimulusMeterValues;                        // 0x0030(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnawareStimulusMeterValues : 1;          // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeUnawareMeterDecay;                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBeforeUnawareMeterDecay : 1;         // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnawareMeterDecaySpeed;                            // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnawareMeterDecaySpeed : 1;              // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeExitingChaseAfterLostSight;              // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBeforeExitingChaseAfterLostSight : 1; // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeExitingChaseAfterInvalidExecute;         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBeforeExitingChaseAfterInvalidExecute : 1; // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 SuspiciousStimulusMeterValues;                     // 0x0094(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SuspiciousStimulusMeterValues : 1;       // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSuspiciousInvestigationTime;                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxSuspiciousInvestigationTime : 1;      // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FAIStimulusOptionConfig                StimulusForProgressiveAlertedMeter;                // 0x00DD(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StimulusForProgressiveAlertedMeter : 1;  // 0x00ED(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 ProgressiveAlertedMeterValues;                     // 0x00F0(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ProgressiveAlertedMeterValues : 1;       // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAlertedSourceInvestigationTime;                 // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAlertedSourceInvestigationTime : 1;   // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 StimuliPriorities;                                 // 0x013C(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StimuliPriorities : 1;                   // 0x017C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxQueuedStimulusTime;                             // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxQueuedStimulusTime : 1;               // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bBreakChaseForHighPriorityEvent;                   // 0x0185(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bBreakChaseForHighPriorityEvent : 1;     // 0x0186(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_187[0x1];                                      // 0x0187(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToBreakChaseForHighPriorityEvent;          // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceToBreakChaseForHighPriorityEvent : 1; // 0x018C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceFromHighPriorityToResumeChase;             // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceFromHighPriorityToResumeChase : 1; // 0x0194(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLastSeenDistFromHidingSpotForGuess;             // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxLastSeenDistFromHidingSpotForGuess : 1; // 0x019C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHidingSpotDistFromOtherSpotForGuess;            // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxHidingSpotDistFromOtherSpotForGuess : 1; // 0x01A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BerserkerMaxDistanceForInstantAttack;              // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BerserkerMaxDistanceForInstantAttack : 1; // 0x01AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedAwareNoSeeAllowedAttackDistance;             // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ForcedAwareNoSeeAllowedAttackDistance : 1; // 0x01B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 StrengthOfStimulusFromWhichToSwitchDirectlyToAlerted; // 0x01B8(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StrengthOfStimulusFromWhichToSwitchDirectlyToAlerted : 1; // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulusValueConfig                 StrengthOfStimulusFromWhichToSkipBeingSuspicious;  // 0x01FC(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StrengthOfStimulusFromWhichToSkipBeingSuspicious : 1; // 0x023C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrengthOfStimulusFromWhichToSkipBeingStartled;    // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StrengthOfStimulusFromWhichToSkipBeingStartled : 1; // 0x0244(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrengthOfStimulusFromWhichToReactByShooting;      // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StrengthOfStimulusFromWhichToReactByShooting : 1; // 0x024C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrengthOfStimulusFromWhichToReactByThrowing;      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StrengthOfStimulusFromWhichToReactByThrowing : 1; // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceFromObstaclesToReactByShooting;     // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDistanceFromObstaclesToReactByShooting : 1; // 0x025C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceFromObstaclesToReactByThrowing;     // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDistanceFromObstaclesToReactByThrowing : 1; // 0x0264(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAwarenessConfig) == 0x000004, "Wrong alignment on FAIAwarenessConfig");
static_assert(sizeof(FAIAwarenessConfig) == 0x000268, "Wrong size on FAIAwarenessConfig");
static_assert(offsetof(FAIAwarenessConfig, bAllowAwarenessLoop) == 0x000000, "Member 'FAIAwarenessConfig::bAllowAwarenessLoop' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, bConvertHighPriorityToObvious) == 0x000002, "Member 'FAIAwarenessConfig::bConvertHighPriorityToObvious' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, bCanEnterSuspicious) == 0x000004, "Member 'FAIAwarenessConfig::bCanEnterSuspicious' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, bAlwaysAlerted) == 0x000006, "Member 'FAIAwarenessConfig::bAlwaysAlerted' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, AlertedFromUnawareStartingMeter) == 0x000008, "Member 'FAIAwarenessConfig::AlertedFromUnawareStartingMeter' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinimumStimulusStrenght) == 0x000010, "Member 'FAIAwarenessConfig::MinimumStimulusStrenght' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinDelayBetweenInvestigationTargetSwitch) == 0x000018, "Member 'FAIAwarenessConfig::MinDelayBetweenInvestigationTargetSwitch' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinDistanceForInvestigationTargetSwitch) == 0x000020, "Member 'FAIAwarenessConfig::MinDistanceForInvestigationTargetSwitch' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinAngleForInvestigationTargetSwitch) == 0x000028, "Member 'FAIAwarenessConfig::MinAngleForInvestigationTargetSwitch' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, UnawareStimulusMeterValues) == 0x000030, "Member 'FAIAwarenessConfig::UnawareStimulusMeterValues' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, TimeBeforeUnawareMeterDecay) == 0x000074, "Member 'FAIAwarenessConfig::TimeBeforeUnawareMeterDecay' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, UnawareMeterDecaySpeed) == 0x00007C, "Member 'FAIAwarenessConfig::UnawareMeterDecaySpeed' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, TimeBeforeExitingChaseAfterLostSight) == 0x000084, "Member 'FAIAwarenessConfig::TimeBeforeExitingChaseAfterLostSight' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, TimeBeforeExitingChaseAfterInvalidExecute) == 0x00008C, "Member 'FAIAwarenessConfig::TimeBeforeExitingChaseAfterInvalidExecute' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, SuspiciousStimulusMeterValues) == 0x000094, "Member 'FAIAwarenessConfig::SuspiciousStimulusMeterValues' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MaxSuspiciousInvestigationTime) == 0x0000D8, "Member 'FAIAwarenessConfig::MaxSuspiciousInvestigationTime' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StimulusForProgressiveAlertedMeter) == 0x0000DD, "Member 'FAIAwarenessConfig::StimulusForProgressiveAlertedMeter' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, ProgressiveAlertedMeterValues) == 0x0000F0, "Member 'FAIAwarenessConfig::ProgressiveAlertedMeterValues' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MaxAlertedSourceInvestigationTime) == 0x000134, "Member 'FAIAwarenessConfig::MaxAlertedSourceInvestigationTime' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StimuliPriorities) == 0x00013C, "Member 'FAIAwarenessConfig::StimuliPriorities' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MaxQueuedStimulusTime) == 0x000180, "Member 'FAIAwarenessConfig::MaxQueuedStimulusTime' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, bBreakChaseForHighPriorityEvent) == 0x000185, "Member 'FAIAwarenessConfig::bBreakChaseForHighPriorityEvent' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, DistanceToBreakChaseForHighPriorityEvent) == 0x000188, "Member 'FAIAwarenessConfig::DistanceToBreakChaseForHighPriorityEvent' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, DistanceFromHighPriorityToResumeChase) == 0x000190, "Member 'FAIAwarenessConfig::DistanceFromHighPriorityToResumeChase' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MaxLastSeenDistFromHidingSpotForGuess) == 0x000198, "Member 'FAIAwarenessConfig::MaxLastSeenDistFromHidingSpotForGuess' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MaxHidingSpotDistFromOtherSpotForGuess) == 0x0001A0, "Member 'FAIAwarenessConfig::MaxHidingSpotDistFromOtherSpotForGuess' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, BerserkerMaxDistanceForInstantAttack) == 0x0001A8, "Member 'FAIAwarenessConfig::BerserkerMaxDistanceForInstantAttack' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, ForcedAwareNoSeeAllowedAttackDistance) == 0x0001B0, "Member 'FAIAwarenessConfig::ForcedAwareNoSeeAllowedAttackDistance' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StrengthOfStimulusFromWhichToSwitchDirectlyToAlerted) == 0x0001B8, "Member 'FAIAwarenessConfig::StrengthOfStimulusFromWhichToSwitchDirectlyToAlerted' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StrengthOfStimulusFromWhichToSkipBeingSuspicious) == 0x0001FC, "Member 'FAIAwarenessConfig::StrengthOfStimulusFromWhichToSkipBeingSuspicious' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StrengthOfStimulusFromWhichToSkipBeingStartled) == 0x000240, "Member 'FAIAwarenessConfig::StrengthOfStimulusFromWhichToSkipBeingStartled' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StrengthOfStimulusFromWhichToReactByShooting) == 0x000248, "Member 'FAIAwarenessConfig::StrengthOfStimulusFromWhichToReactByShooting' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, StrengthOfStimulusFromWhichToReactByThrowing) == 0x000250, "Member 'FAIAwarenessConfig::StrengthOfStimulusFromWhichToReactByThrowing' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinimumDistanceFromObstaclesToReactByShooting) == 0x000258, "Member 'FAIAwarenessConfig::MinimumDistanceFromObstaclesToReactByShooting' has a wrong offset!");
static_assert(offsetof(FAIAwarenessConfig, MinimumDistanceFromObstaclesToReactByThrowing) == 0x000260, "Member 'FAIAwarenessConfig::MinimumDistanceFromObstaclesToReactByThrowing' has a wrong offset!");

// ScriptStruct OPP.AIVisionConfig
// 0x0188 (0x0188 - 0x0000)
struct FAIVisionConfig final
{
public:
	bool                                          bCanSeePlayers;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanSeePlayers : 1;                      // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAlwaysSeePlayers;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysSeePlayers : 1;                   // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIgnoreDarkness;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bIgnoreDarkness : 1;                     // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIVisionCone                          FullVisibilityCone;                                // 0x0008(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullVisibilityCone : 1;                  // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIVisionCone                          PartialVisibilityCone;                             // 0x003C(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PartialVisibilityCone : 1;               // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIVisionCone                          DarknessFullVisibilityCone;                        // 0x0070(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessFullVisibilityCone : 1;          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIVisionCone                          DarknessPartialVisibilityCone;                     // 0x00A4(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessPartialVisibilityCone : 1;       // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseDistance_FullVisibility;                      // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseDistance_FullVisibility : 1;        // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseDistance_PartialVisibility;                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseDistance_PartialVisibility : 1;     // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DarknessCloseDistance_FullVisibility;              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessCloseDistance_FullVisibility : 1; // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DarknessCloseDistance_PartialVisibility;           // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessCloseDistance_PartialVisibility : 1; // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeeOnlyEyesVisionMultiplier;                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SeeOnlyEyesVisionMultiplier : 1;         // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeeOnlyTorsoVisionMultiplier;                      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SeeOnlyTorsoVisionMultiplier : 1;        // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeeOnlyEyesVisionMultiplierInPartial;              // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SeeOnlyEyesVisionMultiplierInPartial : 1; // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeeOnlyTorsoVisionMultiplierInPartial;             // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SeeOnlyTorsoVisionMultiplierInPartial : 1; // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DarknessVisionMultiplier;                          // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DarknessVisionMultiplier : 1;            // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PeripheralVisionMultiplier;                        // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PeripheralVisionMultiplier : 1;          // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseRangeVisionMultiplier;                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseRangeVisionMultiplier : 1;          // 0x012C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandingStillVisionMultiplier;                     // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StandingStillVisionMultiplier : 1;       // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingVisionMultiplier;                           // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_WalkingVisionMultiplier : 1;             // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunningVisionMultiplier;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RunningVisionMultiplier : 1;             // 0x0144(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchingVisionMultiplier;                         // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CrouchingVisionMultiplier : 1;           // 0x014C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HidespotPeekingVisionMultiplier;                   // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HidespotPeekingVisionMultiplier : 1;     // 0x0154(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HidespotHiddenVisionMultiplier;                    // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HidespotHiddenVisionMultiplier : 1;      // 0x015C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumVisionMultiplierToBeSeen;                   // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumVisionMultiplierToBeSeen : 1;     // 0x0164(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullVisToPartialVisVisionMultiplierThreshold;      // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FullVisToPartialVisVisionMultiplierThreshold : 1; // 0x016C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BotVisionCheckSlicing;                             // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BotVisionCheckSlicing : 1;               // 0x0174(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeHeightForTheTorso;                         // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RelativeHeightForTheTorso : 1;           // 0x017C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalNumberOfClearChecks;                          // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TotalNumberOfClearChecks : 1;            // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIVisionConfig) == 0x000004, "Wrong alignment on FAIVisionConfig");
static_assert(sizeof(FAIVisionConfig) == 0x000188, "Wrong size on FAIVisionConfig");
static_assert(offsetof(FAIVisionConfig, bCanSeePlayers) == 0x000000, "Member 'FAIVisionConfig::bCanSeePlayers' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, bAlwaysSeePlayers) == 0x000002, "Member 'FAIVisionConfig::bAlwaysSeePlayers' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, bIgnoreDarkness) == 0x000004, "Member 'FAIVisionConfig::bIgnoreDarkness' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, FullVisibilityCone) == 0x000008, "Member 'FAIVisionConfig::FullVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, PartialVisibilityCone) == 0x00003C, "Member 'FAIVisionConfig::PartialVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, DarknessFullVisibilityCone) == 0x000070, "Member 'FAIVisionConfig::DarknessFullVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, DarknessPartialVisibilityCone) == 0x0000A4, "Member 'FAIVisionConfig::DarknessPartialVisibilityCone' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, CloseDistance_FullVisibility) == 0x0000D8, "Member 'FAIVisionConfig::CloseDistance_FullVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, CloseDistance_PartialVisibility) == 0x0000E0, "Member 'FAIVisionConfig::CloseDistance_PartialVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, DarknessCloseDistance_FullVisibility) == 0x0000E8, "Member 'FAIVisionConfig::DarknessCloseDistance_FullVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, DarknessCloseDistance_PartialVisibility) == 0x0000F0, "Member 'FAIVisionConfig::DarknessCloseDistance_PartialVisibility' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, SeeOnlyEyesVisionMultiplier) == 0x0000F8, "Member 'FAIVisionConfig::SeeOnlyEyesVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, SeeOnlyTorsoVisionMultiplier) == 0x000100, "Member 'FAIVisionConfig::SeeOnlyTorsoVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, SeeOnlyEyesVisionMultiplierInPartial) == 0x000108, "Member 'FAIVisionConfig::SeeOnlyEyesVisionMultiplierInPartial' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, SeeOnlyTorsoVisionMultiplierInPartial) == 0x000110, "Member 'FAIVisionConfig::SeeOnlyTorsoVisionMultiplierInPartial' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, DarknessVisionMultiplier) == 0x000118, "Member 'FAIVisionConfig::DarknessVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, PeripheralVisionMultiplier) == 0x000120, "Member 'FAIVisionConfig::PeripheralVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, CloseRangeVisionMultiplier) == 0x000128, "Member 'FAIVisionConfig::CloseRangeVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, StandingStillVisionMultiplier) == 0x000130, "Member 'FAIVisionConfig::StandingStillVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, WalkingVisionMultiplier) == 0x000138, "Member 'FAIVisionConfig::WalkingVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, RunningVisionMultiplier) == 0x000140, "Member 'FAIVisionConfig::RunningVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, CrouchingVisionMultiplier) == 0x000148, "Member 'FAIVisionConfig::CrouchingVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, HidespotPeekingVisionMultiplier) == 0x000150, "Member 'FAIVisionConfig::HidespotPeekingVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, HidespotHiddenVisionMultiplier) == 0x000158, "Member 'FAIVisionConfig::HidespotHiddenVisionMultiplier' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, MinimumVisionMultiplierToBeSeen) == 0x000160, "Member 'FAIVisionConfig::MinimumVisionMultiplierToBeSeen' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, FullVisToPartialVisVisionMultiplierThreshold) == 0x000168, "Member 'FAIVisionConfig::FullVisToPartialVisVisionMultiplierThreshold' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, BotVisionCheckSlicing) == 0x000170, "Member 'FAIVisionConfig::BotVisionCheckSlicing' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, RelativeHeightForTheTorso) == 0x000178, "Member 'FAIVisionConfig::RelativeHeightForTheTorso' has a wrong offset!");
static_assert(offsetof(FAIVisionConfig, TotalNumberOfClearChecks) == 0x000180, "Member 'FAIVisionConfig::TotalNumberOfClearChecks' has a wrong offset!");

// ScriptStruct OPP.AIHearingConfig
// 0x001C (0x001C - 0x0000)
struct FAIHearingConfig final
{
public:
	bool                                          bCanHearPlayers;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanHearPlayers : 1;                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHearingDistance;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxHearingDistance : 1;                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlindPaintMaxHearingDistanceMultiplier;            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BlindPaintMaxHearingDistanceMultiplier : 1; // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudioPerceptionScaling;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AudioPerceptionScaling : 1;              // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIHearingConfig) == 0x000004, "Wrong alignment on FAIHearingConfig");
static_assert(sizeof(FAIHearingConfig) == 0x00001C, "Wrong size on FAIHearingConfig");
static_assert(offsetof(FAIHearingConfig, bCanHearPlayers) == 0x000000, "Member 'FAIHearingConfig::bCanHearPlayers' has a wrong offset!");
static_assert(offsetof(FAIHearingConfig, MaxHearingDistance) == 0x000004, "Member 'FAIHearingConfig::MaxHearingDistance' has a wrong offset!");
static_assert(offsetof(FAIHearingConfig, BlindPaintMaxHearingDistanceMultiplier) == 0x00000C, "Member 'FAIHearingConfig::BlindPaintMaxHearingDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FAIHearingConfig, AudioPerceptionScaling) == 0x000014, "Member 'FAIHearingConfig::AudioPerceptionScaling' has a wrong offset!");

// ScriptStruct OPP.AITargettingConfig
// 0x0074 (0x0074 - 0x0000)
struct FAITargettingConfig final
{
public:
	bool                                          bAlwaysTargetLastAttacker;                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysTargetLastAttacker : 1;           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bSwitchTargetAfterAttack;                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bSwitchTargetAfterAttack : 1;            // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         TimeForSwitchTargetAfterAttack;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeForSwitchTargetAfterAttack : 1;      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeForSwitchTargetAfterBeingAttacked;             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeForSwitchTargetAfterBeingAttacked : 1; // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeForLastSwitchTargetBias;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeForLastSwitchTargetBias : 1;         // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSwitchTargetBias;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LastSwitchTargetBias : 1;                // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackDistanceMultiplier;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BackDistanceMultiplier : 1;              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightDistanceMultiplier;                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HeightDistanceMultiplier : 1;            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerIncapacitatedBias;                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerIncapacitatedBias : 1;             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerOutsideLeashBias;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerOutsideLeashBias : 1;              // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerNotVisibleBias;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerNotVisibleBias : 1;                // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerIsHighPriorityBias;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerIsHighPriorityBias : 1;            // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTargetBias;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CurrentTargetBias : 1;                   // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchAfterAttackBias;                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SwitchAfterAttackBias : 1;               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlreadyTargettedPenalty;                           // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AlreadyTargettedPenalty : 1;             // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GracePeriodAfterKnockdown;                         // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GracePeriodAfterKnockdown : 1;           // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanForceExecutePlayers;                           // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanForceExecutePlayers : 1;             // 0x0072(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_73[0x1];                                       // 0x0073(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITargettingConfig) == 0x000004, "Wrong alignment on FAITargettingConfig");
static_assert(sizeof(FAITargettingConfig) == 0x000074, "Wrong size on FAITargettingConfig");
static_assert(offsetof(FAITargettingConfig, bAlwaysTargetLastAttacker) == 0x000000, "Member 'FAITargettingConfig::bAlwaysTargetLastAttacker' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, bSwitchTargetAfterAttack) == 0x000002, "Member 'FAITargettingConfig::bSwitchTargetAfterAttack' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, TimeForSwitchTargetAfterAttack) == 0x000004, "Member 'FAITargettingConfig::TimeForSwitchTargetAfterAttack' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, TimeForSwitchTargetAfterBeingAttacked) == 0x00000C, "Member 'FAITargettingConfig::TimeForSwitchTargetAfterBeingAttacked' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, TimeForLastSwitchTargetBias) == 0x000014, "Member 'FAITargettingConfig::TimeForLastSwitchTargetBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, LastSwitchTargetBias) == 0x00001C, "Member 'FAITargettingConfig::LastSwitchTargetBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, BackDistanceMultiplier) == 0x000024, "Member 'FAITargettingConfig::BackDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, HeightDistanceMultiplier) == 0x00002C, "Member 'FAITargettingConfig::HeightDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, PlayerIncapacitatedBias) == 0x000034, "Member 'FAITargettingConfig::PlayerIncapacitatedBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, PlayerOutsideLeashBias) == 0x00003C, "Member 'FAITargettingConfig::PlayerOutsideLeashBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, PlayerNotVisibleBias) == 0x000044, "Member 'FAITargettingConfig::PlayerNotVisibleBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, PlayerIsHighPriorityBias) == 0x00004C, "Member 'FAITargettingConfig::PlayerIsHighPriorityBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, CurrentTargetBias) == 0x000054, "Member 'FAITargettingConfig::CurrentTargetBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, SwitchAfterAttackBias) == 0x00005C, "Member 'FAITargettingConfig::SwitchAfterAttackBias' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, AlreadyTargettedPenalty) == 0x000064, "Member 'FAITargettingConfig::AlreadyTargettedPenalty' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, GracePeriodAfterKnockdown) == 0x00006C, "Member 'FAITargettingConfig::GracePeriodAfterKnockdown' has a wrong offset!");
static_assert(offsetof(FAITargettingConfig, bCanForceExecutePlayers) == 0x000071, "Member 'FAITargettingConfig::bCanForceExecutePlayers' has a wrong offset!");

// ScriptStruct OPP.StartleAnimConfig
// 0x0004 (0x0004 - 0x0000)
struct FStartleAnimConfig final
{
public:
	EStartleType                                  StartleType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StartleType : 1;                         // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EStartleSpeed                                 StartleSpeed;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StartleSpeed : 1;                        // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FStartleAnimConfig) == 0x000001, "Wrong alignment on FStartleAnimConfig");
static_assert(sizeof(FStartleAnimConfig) == 0x000004, "Wrong size on FStartleAnimConfig");
static_assert(offsetof(FStartleAnimConfig, StartleType) == 0x000000, "Member 'FStartleAnimConfig::StartleType' has a wrong offset!");
static_assert(offsetof(FStartleAnimConfig, StartleSpeed) == 0x000002, "Member 'FStartleAnimConfig::StartleSpeed' has a wrong offset!");

// ScriptStruct OPP.DisturbanceConfig
// 0x0016 (0x0016 - 0x0000)
struct FDisturbanceConfig final
{
public:
	bool                                          bCanBeDisturbed;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanBeDisturbed : 1;                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanPlayStartle;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanPlayStartle : 1;                     // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bReactToImperativeDisturbances;                    // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bReactToImperativeDisturbances : 1;      // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FStartleAnimConfig                     AmbientStartleConfig;                              // 0x0006(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStartleAnimConfig                     SuspiciousStartleConfig;                           // 0x000A(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStartleAnimConfig                     AlertedStartleConfig;                              // 0x000E(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStartleAnimConfig                     AlertedFromUnawareStartleConfig;                   // 0x0012(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisturbanceConfig) == 0x000001, "Wrong alignment on FDisturbanceConfig");
static_assert(sizeof(FDisturbanceConfig) == 0x000016, "Wrong size on FDisturbanceConfig");
static_assert(offsetof(FDisturbanceConfig, bCanBeDisturbed) == 0x000000, "Member 'FDisturbanceConfig::bCanBeDisturbed' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, bCanPlayStartle) == 0x000002, "Member 'FDisturbanceConfig::bCanPlayStartle' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, bReactToImperativeDisturbances) == 0x000004, "Member 'FDisturbanceConfig::bReactToImperativeDisturbances' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, AmbientStartleConfig) == 0x000006, "Member 'FDisturbanceConfig::AmbientStartleConfig' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, SuspiciousStartleConfig) == 0x00000A, "Member 'FDisturbanceConfig::SuspiciousStartleConfig' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, AlertedStartleConfig) == 0x00000E, "Member 'FDisturbanceConfig::AlertedStartleConfig' has a wrong offset!");
static_assert(offsetof(FDisturbanceConfig, AlertedFromUnawareStartleConfig) == 0x000012, "Member 'FDisturbanceConfig::AlertedFromUnawareStartleConfig' has a wrong offset!");

// ScriptStruct OPP.AIAttackConfig
// 0x01F8 (0x01F8 - 0x0000)
struct FAIAttackConfig final
{
public:
	bool                                          bCanAttack;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanAttack : 1;                          // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanCancelActiveAttack;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanCancelActiveAttack : 1;              // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bUseAttackStance;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bUseAttackStance : 1;                    // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanSlideBackwardsWhenAttacking;                   // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanSlideBackwardsWhenAttacking : 1;     // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         AttackRange;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackRange : 1;                         // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackRangeLowAttack;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackRangeLowAttack : 1;                // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAttackAngle;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAttackAngle : 1;                      // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFatalityRange;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxFatalityRange : 1;                    // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAdjustForwardDistance;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAdjustForwardDistance : 1;            // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCorrectionLinearVelocity;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxCorrectionLinearVelocity : 1;         // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCorrectionAngularVelocity;                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxCorrectionAngularVelocity : 1;        // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNoFail;                                           // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bNoFail : 1;                             // 0x003E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bOnlyUsePushAttack;                                // 0x003F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bOnlyUsePushAttack : 1;                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableBlockingAttacks;                            // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableBlockingAttacks : 1;              // 0x0042(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableBlockingAttacksTracking;                    // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableBlockingAttacksTracking : 1;      // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockingAttackMaxRange;                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BlockingAttackMaxRange : 1;              // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockingAttackMinPlayerSpeed;                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BlockingAttackMinPlayerSpeed : 1;        // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockingAttackTrackingTargetOffset;                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BlockingAttackTrackingTargetOffset : 1;  // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayForSuccessiveBlockingAttack;               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayForSuccessiveBlockingAttack : 1; // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackStandardDamage;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackStandardDamage : 1;                // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackProjectileDamage;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackProjectileDamage : 1;              // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackGrabAndThrowDamage;                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackGrabAndThrowDamage : 1;            // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierVeryLow;                           // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierVeryLow : 1;             // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierLow;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierLow : 1;                 // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierMedium;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierMedium : 1;              // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierHigh;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierHigh : 1;                // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierVeryHigh;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierVeryHigh : 1;            // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuccessiveAttackerDamageMultiplier;                // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SuccessiveAttackerDamageMultiplier : 1;  // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuccessiveAttackerReducedDamageDuration;           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SuccessiveAttackerReducedDamageDuration : 1; // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackNormalKnockbackPower;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackNormalKnockbackPower : 1;          // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayForAttack;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayForAttack : 1;                   // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDelayForAttack;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDelayForAttack : 1;                   // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenTransitAttack;                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBetweenTransitAttack : 1;           // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayForAttackFailed;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayForAttackFailed : 1;             // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDelayForAttackFailed;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDelayForAttackFailed : 1;             // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayForAttackAfterTargetBackUp;                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayForAttackAfterTargetBackUp : 1;     // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackRangeExtension;                              // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackRangeExtension : 1;                // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bForceGrab;                                        // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bForceGrab : 1;                          // 0x00F6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bForcePairedAttack;                                // 0x00F7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bForcePairedAttack : 1;                  // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrabAttackProbabilityOnCrouchedTarget;             // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GrabAttackProbabilityOnCrouchedTarget : 1; // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeStandingGrabRange;                             // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FreeStandingGrabRange : 1;               // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeStandingGrabCooldown;                          // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FreeStandingGrabCooldown : 1;            // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeStandingMaxPlayerSpeed;                        // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FreeStandingMaxPlayerSpeed : 1;          // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeStandingMaxPlayerDistanceSinceHit;             // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FreeStandingMaxPlayerDistanceSinceHit : 1; // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrabAboveMinHeight;                                // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GrabAboveMinHeight : 1;                  // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrabAboveMaxHeight;                                // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GrabAboveMaxHeight : 1;                  // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanUseLungeAttacks;                               // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanUseLungeAttacks : 1;                 // 0x0132(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LungeMinDist;                                      // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LungeMinDist : 1;                        // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LungeMaxDist;                                      // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LungeMaxDist : 1;                        // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LungeCooldownTime;                                 // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LungeCooldownTime : 1;                   // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceForRangedAttacks;                   // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDistanceForRangedAttacks : 1;     // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumDistanceForRangedAttacks;                   // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumDistanceForRangedAttacks : 1;     // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeFirstRangeAttackWhenUnaware;            // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeFirstRangeAttackWhenUnaware : 1; // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeFirstRangeAttackWhenAlerted;            // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeFirstRangeAttackWhenAlerted : 1; // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterReloading;          // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterReloading : 1; // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterMissing;            // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterMissing : 1; // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterCausingFlinch;      // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterCausingFlinch : 1; // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterCausingLightReaction; // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterCausingLightReaction : 1; // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterCausingMediumReaction; // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterCausingMediumReaction : 1; // 0x0190(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterCausingHeavyReaction; // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterCausingHeavyReaction : 1; // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextRangeAttackAfterCausingKnockDown;   // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DelayBeforeNextRangeAttackAfterCausingKnockDown : 1; // 0x01A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnticipationTimeBeforeRangeAttacks;                // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AnticipationTimeBeforeRangeAttacks : 1;  // 0x01A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumDamagePerRangedAttack;                      // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumDamagePerRangedAttack : 1;        // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierForRangedAttacks;                  // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierForRangedAttacks : 1;    // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadingMultiplierForRangedAttacks;               // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpreadingMultiplierForRangedAttacks : 1; // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToKeepAimingAtTargetAfterVisibilityIsLost;     // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeToKeepAimingAtTargetAfterVisibilityIsLost : 1; // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToKeepAimingAtTargetAfterItWasLostInTheDark;   // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeToKeepAimingAtTargetAfterItWasLostInTheDark : 1; // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedAttackActiveSkillDisablingDuration;          // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackActiveSkillDisablingDuration : 1; // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedAttackActiveSkillDisablingRestrictedToPairedAttacks; // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackActiveSkillDisablingRestrictedToPairedAttacks : 1; // 0x01E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          AttackActiveSkillCooldownRestart;                  // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackActiveSkillCooldownRestart : 1;    // 0x01E2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          AttackActiveSkillCooldownRestartAfterDisableIsOver; // 0x01E3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AttackActiveSkillCooldownRestartAfterDisableIsOver : 1; // 0x01E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedAttackBleedingAmount;                        // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackBleedingAmount : 1;          // 0x01EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairedAttackBleedingRestrictedToPairedAttacks;     // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PairedAttackBleedingRestrictedToPairedAttacks : 1; // 0x01F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAttackConfig) == 0x000004, "Wrong alignment on FAIAttackConfig");
static_assert(sizeof(FAIAttackConfig) == 0x0001F8, "Wrong size on FAIAttackConfig");
static_assert(offsetof(FAIAttackConfig, bCanAttack) == 0x000000, "Member 'FAIAttackConfig::bCanAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bCanCancelActiveAttack) == 0x000002, "Member 'FAIAttackConfig::bCanCancelActiveAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bUseAttackStance) == 0x000004, "Member 'FAIAttackConfig::bUseAttackStance' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bCanSlideBackwardsWhenAttacking) == 0x000006, "Member 'FAIAttackConfig::bCanSlideBackwardsWhenAttacking' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackRange) == 0x000008, "Member 'FAIAttackConfig::AttackRange' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackRangeLowAttack) == 0x000010, "Member 'FAIAttackConfig::AttackRangeLowAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxAttackAngle) == 0x000018, "Member 'FAIAttackConfig::MaxAttackAngle' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxFatalityRange) == 0x000020, "Member 'FAIAttackConfig::MaxFatalityRange' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxAdjustForwardDistance) == 0x000028, "Member 'FAIAttackConfig::MaxAdjustForwardDistance' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxCorrectionLinearVelocity) == 0x000030, "Member 'FAIAttackConfig::MaxCorrectionLinearVelocity' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxCorrectionAngularVelocity) == 0x000038, "Member 'FAIAttackConfig::MaxCorrectionAngularVelocity' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bNoFail) == 0x00003D, "Member 'FAIAttackConfig::bNoFail' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bOnlyUsePushAttack) == 0x00003F, "Member 'FAIAttackConfig::bOnlyUsePushAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bEnableBlockingAttacks) == 0x000041, "Member 'FAIAttackConfig::bEnableBlockingAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bEnableBlockingAttacksTracking) == 0x000043, "Member 'FAIAttackConfig::bEnableBlockingAttacksTracking' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, BlockingAttackMaxRange) == 0x000048, "Member 'FAIAttackConfig::BlockingAttackMaxRange' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, BlockingAttackMinPlayerSpeed) == 0x000050, "Member 'FAIAttackConfig::BlockingAttackMinPlayerSpeed' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, BlockingAttackTrackingTargetOffset) == 0x000058, "Member 'FAIAttackConfig::BlockingAttackTrackingTargetOffset' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MinDelayForSuccessiveBlockingAttack) == 0x000060, "Member 'FAIAttackConfig::MinDelayForSuccessiveBlockingAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackStandardDamage) == 0x000068, "Member 'FAIAttackConfig::AttackStandardDamage' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackProjectileDamage) == 0x000070, "Member 'FAIAttackConfig::AttackProjectileDamage' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackGrabAndThrowDamage) == 0x000078, "Member 'FAIAttackConfig::AttackGrabAndThrowDamage' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierVeryLow) == 0x000080, "Member 'FAIAttackConfig::DamageMultiplierVeryLow' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierLow) == 0x000088, "Member 'FAIAttackConfig::DamageMultiplierLow' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierMedium) == 0x000090, "Member 'FAIAttackConfig::DamageMultiplierMedium' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierHigh) == 0x000098, "Member 'FAIAttackConfig::DamageMultiplierHigh' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierVeryHigh) == 0x0000A0, "Member 'FAIAttackConfig::DamageMultiplierVeryHigh' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, SuccessiveAttackerDamageMultiplier) == 0x0000A8, "Member 'FAIAttackConfig::SuccessiveAttackerDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, SuccessiveAttackerReducedDamageDuration) == 0x0000B0, "Member 'FAIAttackConfig::SuccessiveAttackerReducedDamageDuration' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackNormalKnockbackPower) == 0x0000B8, "Member 'FAIAttackConfig::AttackNormalKnockbackPower' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MinDelayForAttack) == 0x0000C0, "Member 'FAIAttackConfig::MinDelayForAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxDelayForAttack) == 0x0000C8, "Member 'FAIAttackConfig::MaxDelayForAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBetweenTransitAttack) == 0x0000D0, "Member 'FAIAttackConfig::DelayBetweenTransitAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MinDelayForAttackFailed) == 0x0000D8, "Member 'FAIAttackConfig::MinDelayForAttackFailed' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaxDelayForAttackFailed) == 0x0000E0, "Member 'FAIAttackConfig::MaxDelayForAttackFailed' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayForAttackAfterTargetBackUp) == 0x0000E8, "Member 'FAIAttackConfig::DelayForAttackAfterTargetBackUp' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackRangeExtension) == 0x0000F0, "Member 'FAIAttackConfig::AttackRangeExtension' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bForceGrab) == 0x0000F5, "Member 'FAIAttackConfig::bForceGrab' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bForcePairedAttack) == 0x0000F7, "Member 'FAIAttackConfig::bForcePairedAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, GrabAttackProbabilityOnCrouchedTarget) == 0x0000FC, "Member 'FAIAttackConfig::GrabAttackProbabilityOnCrouchedTarget' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, FreeStandingGrabRange) == 0x000104, "Member 'FAIAttackConfig::FreeStandingGrabRange' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, FreeStandingGrabCooldown) == 0x00010C, "Member 'FAIAttackConfig::FreeStandingGrabCooldown' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, FreeStandingMaxPlayerSpeed) == 0x000114, "Member 'FAIAttackConfig::FreeStandingMaxPlayerSpeed' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, FreeStandingMaxPlayerDistanceSinceHit) == 0x00011C, "Member 'FAIAttackConfig::FreeStandingMaxPlayerDistanceSinceHit' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, GrabAboveMinHeight) == 0x000124, "Member 'FAIAttackConfig::GrabAboveMinHeight' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, GrabAboveMaxHeight) == 0x00012C, "Member 'FAIAttackConfig::GrabAboveMaxHeight' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, bCanUseLungeAttacks) == 0x000131, "Member 'FAIAttackConfig::bCanUseLungeAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, LungeMinDist) == 0x000134, "Member 'FAIAttackConfig::LungeMinDist' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, LungeMaxDist) == 0x00013C, "Member 'FAIAttackConfig::LungeMaxDist' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, LungeCooldownTime) == 0x000144, "Member 'FAIAttackConfig::LungeCooldownTime' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MinimumDistanceForRangedAttacks) == 0x00014C, "Member 'FAIAttackConfig::MinimumDistanceForRangedAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaximumDistanceForRangedAttacks) == 0x000154, "Member 'FAIAttackConfig::MaximumDistanceForRangedAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeFirstRangeAttackWhenUnaware) == 0x00015C, "Member 'FAIAttackConfig::DelayBeforeFirstRangeAttackWhenUnaware' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeFirstRangeAttackWhenAlerted) == 0x000164, "Member 'FAIAttackConfig::DelayBeforeFirstRangeAttackWhenAlerted' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterReloading) == 0x00016C, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterReloading' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterMissing) == 0x000174, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterMissing' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterCausingFlinch) == 0x00017C, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterCausingFlinch' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterCausingLightReaction) == 0x000184, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterCausingLightReaction' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterCausingMediumReaction) == 0x00018C, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterCausingMediumReaction' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterCausingHeavyReaction) == 0x000194, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterCausingHeavyReaction' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DelayBeforeNextRangeAttackAfterCausingKnockDown) == 0x00019C, "Member 'FAIAttackConfig::DelayBeforeNextRangeAttackAfterCausingKnockDown' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AnticipationTimeBeforeRangeAttacks) == 0x0001A4, "Member 'FAIAttackConfig::AnticipationTimeBeforeRangeAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, MaximumDamagePerRangedAttack) == 0x0001AC, "Member 'FAIAttackConfig::MaximumDamagePerRangedAttack' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, DamageMultiplierForRangedAttacks) == 0x0001B4, "Member 'FAIAttackConfig::DamageMultiplierForRangedAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, SpreadingMultiplierForRangedAttacks) == 0x0001BC, "Member 'FAIAttackConfig::SpreadingMultiplierForRangedAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, TimeToKeepAimingAtTargetAfterVisibilityIsLost) == 0x0001C4, "Member 'FAIAttackConfig::TimeToKeepAimingAtTargetAfterVisibilityIsLost' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, TimeToKeepAimingAtTargetAfterItWasLostInTheDark) == 0x0001CC, "Member 'FAIAttackConfig::TimeToKeepAimingAtTargetAfterItWasLostInTheDark' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, PairedAttackActiveSkillDisablingDuration) == 0x0001D4, "Member 'FAIAttackConfig::PairedAttackActiveSkillDisablingDuration' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, PairedAttackActiveSkillDisablingRestrictedToPairedAttacks) == 0x0001DC, "Member 'FAIAttackConfig::PairedAttackActiveSkillDisablingRestrictedToPairedAttacks' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackActiveSkillCooldownRestart) == 0x0001E1, "Member 'FAIAttackConfig::AttackActiveSkillCooldownRestart' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, AttackActiveSkillCooldownRestartAfterDisableIsOver) == 0x0001E3, "Member 'FAIAttackConfig::AttackActiveSkillCooldownRestartAfterDisableIsOver' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, PairedAttackBleedingAmount) == 0x0001E8, "Member 'FAIAttackConfig::PairedAttackBleedingAmount' has a wrong offset!");
static_assert(offsetof(FAIAttackConfig, PairedAttackBleedingRestrictedToPairedAttacks) == 0x0001F0, "Member 'FAIAttackConfig::PairedAttackBleedingRestrictedToPairedAttacks' has a wrong offset!");

// ScriptStruct OPP.AIChaseConfig
// 0x0130 (0x0130 - 0x0000)
struct FAIChaseConfig final
{
public:
	bool                                          bReactBeforeChase;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bReactBeforeChase : 1;                   // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedAwaressOnStimuliDistance;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ForcedAwaressOnStimuliDistance : 1;      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAnticipatePlayerPosition;                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAnticipatePlayerPosition : 1;           // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanGiveUpChase;                                   // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanGiveUpChase : 1;                     // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumChaseDurationBeforeGiveUp;                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumChaseDurationBeforeGiveUp : 1;    // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GiveUpDistance;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GiveUpDistance : 1;                      // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GiveUpSlowDownDuration;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GiveUpSlowDownDuration : 1;              // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GiveUpWaitDuration;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GiveUpWaitDuration : 1;                  // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestinationDistanceBuffer;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DestinationDistanceBuffer : 1;           // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestinationDistanceBufferKnockedDown;              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DestinationDistanceBufferKnockedDown : 1; // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestinationDistanceBufferFatality;                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DestinationDistanceBufferFatality : 1;   // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestinationDistanceBufferHidden;                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DestinationDistanceBufferHidden : 1;     // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredDistanceFromTargetWhenWieldingRangedWeapon; // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DesiredDistanceFromTargetWhenWieldingRangedWeapon : 1; // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceToTravelWhenWieldingRangedWeapon;   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDistanceToTravelWhenWieldingRangedWeapon : 1; // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumAngleWithTargetWhileHoldingPosition;        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumAngleWithTargetWhileHoldingPosition : 1; // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnticipationTimeOfTargetWhileHoldingPosition;      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AnticipationTimeOfTargetWhileHoldingPosition : 1; // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanYieldChase;                                    // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanYieldChase : 1;                      // 0x006E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldCloseDistanceThreshold;                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldCloseDistanceThreshold : 1;         // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoYieldDistAhead;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NoYieldDistAhead : 1;                    // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bYieldToHigherGrade;                               // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bYieldToHigherGrade : 1;                 // 0x007E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldDistClose;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldDistClose : 1;                      // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldDistFar;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldDistFar : 1;                        // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldSlowDownDuration;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldSlowDownDuration : 1;               // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldFastSlowDownDuration;                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldFastSlowDownDuration : 1;           // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YieldWaitDuration;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_YieldWaitDuration : 1;                   // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxNoSightYieldDuration;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxNoSightYieldDuration : 1;             // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanPathBlock;                                     // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanPathBlock : 1;                       // 0x00AE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathBlockForwardTargetOffset;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PathBlockForwardTargetOffset : 1;        // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathBlockMinIdleWaitTime;                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PathBlockMinIdleWaitTime : 1;            // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathBlockMaxIdleWaitTime;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PathBlockMaxIdleWaitTime : 1;            // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          PathBlockRequiresAnyActiveChase;                   // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PathBlockRequiresAnyActiveChase : 1;     // 0x00C6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedChaseNoContactTimeout;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ForcedChaseNoContactTimeout : 1;         // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbandonAfterUnreacheableDuration;                  // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AbandonAfterUnreacheableDuration : 1;    // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumTargetDistToStartChase;                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumTargetDistToStartChase : 1;       // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanPerformTaunt;                                  // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanPerformTaunt : 1;                    // 0x00DE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DF[0x1];                                       // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeFirstTaunt;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBeforeFirstTaunt : 1;                // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenTaunts;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBetweenTaunts : 1;                   // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceFromTargetForHoldingPosition;       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDistanceFromTargetForHoldingPosition : 1; // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceAtWhichToStopBeforeLosingLineOfSight;      // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceAtWhichToStopBeforeLosingLineOfSight : 1; // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumAngleBetweenHeadingAndTargetToKeepMoving;   // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumAngleBetweenHeadingAndTargetToKeepMoving : 1; // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightForClearanceTestWhileTargetIsStanding;       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HeightForClearanceTestWhileTargetIsStanding : 1; // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightForClearanceTestWhileTargetIsCrouched;       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HeightForClearanceTestWhileTargetIsCrouched : 1; // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadiusForClearanceTestWhenStopping;                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RadiusForClearanceTestWhenStopping : 1;  // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadiusForClearanceTestWhileMoving;                 // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RadiusForClearanceTestWhileMoving : 1;   // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadiusForClearanceTestWhileStationary;             // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RadiusForClearanceTestWhileStationary : 1; // 0x012C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIChaseConfig) == 0x000004, "Wrong alignment on FAIChaseConfig");
static_assert(sizeof(FAIChaseConfig) == 0x000130, "Wrong size on FAIChaseConfig");
static_assert(offsetof(FAIChaseConfig, bReactBeforeChase) == 0x000000, "Member 'FAIChaseConfig::bReactBeforeChase' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, ForcedAwaressOnStimuliDistance) == 0x000004, "Member 'FAIChaseConfig::ForcedAwaressOnStimuliDistance' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bAnticipatePlayerPosition) == 0x000009, "Member 'FAIChaseConfig::bAnticipatePlayerPosition' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bCanGiveUpChase) == 0x00000B, "Member 'FAIChaseConfig::bCanGiveUpChase' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MinimumChaseDurationBeforeGiveUp) == 0x000010, "Member 'FAIChaseConfig::MinimumChaseDurationBeforeGiveUp' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, GiveUpDistance) == 0x000018, "Member 'FAIChaseConfig::GiveUpDistance' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, GiveUpSlowDownDuration) == 0x000020, "Member 'FAIChaseConfig::GiveUpSlowDownDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, GiveUpWaitDuration) == 0x000028, "Member 'FAIChaseConfig::GiveUpWaitDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DestinationDistanceBuffer) == 0x000030, "Member 'FAIChaseConfig::DestinationDistanceBuffer' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DestinationDistanceBufferKnockedDown) == 0x000038, "Member 'FAIChaseConfig::DestinationDistanceBufferKnockedDown' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DestinationDistanceBufferFatality) == 0x000040, "Member 'FAIChaseConfig::DestinationDistanceBufferFatality' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DestinationDistanceBufferHidden) == 0x000048, "Member 'FAIChaseConfig::DestinationDistanceBufferHidden' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DesiredDistanceFromTargetWhenWieldingRangedWeapon) == 0x000050, "Member 'FAIChaseConfig::DesiredDistanceFromTargetWhenWieldingRangedWeapon' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MinimumDistanceToTravelWhenWieldingRangedWeapon) == 0x000058, "Member 'FAIChaseConfig::MinimumDistanceToTravelWhenWieldingRangedWeapon' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MaximumAngleWithTargetWhileHoldingPosition) == 0x000060, "Member 'FAIChaseConfig::MaximumAngleWithTargetWhileHoldingPosition' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, AnticipationTimeOfTargetWhileHoldingPosition) == 0x000068, "Member 'FAIChaseConfig::AnticipationTimeOfTargetWhileHoldingPosition' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bCanYieldChase) == 0x00006D, "Member 'FAIChaseConfig::bCanYieldChase' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldCloseDistanceThreshold) == 0x000070, "Member 'FAIChaseConfig::YieldCloseDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, NoYieldDistAhead) == 0x000078, "Member 'FAIChaseConfig::NoYieldDistAhead' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bYieldToHigherGrade) == 0x00007D, "Member 'FAIChaseConfig::bYieldToHigherGrade' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldDistClose) == 0x000080, "Member 'FAIChaseConfig::YieldDistClose' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldDistFar) == 0x000088, "Member 'FAIChaseConfig::YieldDistFar' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldSlowDownDuration) == 0x000090, "Member 'FAIChaseConfig::YieldSlowDownDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldFastSlowDownDuration) == 0x000098, "Member 'FAIChaseConfig::YieldFastSlowDownDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, YieldWaitDuration) == 0x0000A0, "Member 'FAIChaseConfig::YieldWaitDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MaxNoSightYieldDuration) == 0x0000A8, "Member 'FAIChaseConfig::MaxNoSightYieldDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bCanPathBlock) == 0x0000AD, "Member 'FAIChaseConfig::bCanPathBlock' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, PathBlockForwardTargetOffset) == 0x0000B0, "Member 'FAIChaseConfig::PathBlockForwardTargetOffset' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, PathBlockMinIdleWaitTime) == 0x0000B8, "Member 'FAIChaseConfig::PathBlockMinIdleWaitTime' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, PathBlockMaxIdleWaitTime) == 0x0000C0, "Member 'FAIChaseConfig::PathBlockMaxIdleWaitTime' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, PathBlockRequiresAnyActiveChase) == 0x0000C5, "Member 'FAIChaseConfig::PathBlockRequiresAnyActiveChase' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, ForcedChaseNoContactTimeout) == 0x0000C8, "Member 'FAIChaseConfig::ForcedChaseNoContactTimeout' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, AbandonAfterUnreacheableDuration) == 0x0000D0, "Member 'FAIChaseConfig::AbandonAfterUnreacheableDuration' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MaximumTargetDistToStartChase) == 0x0000D8, "Member 'FAIChaseConfig::MaximumTargetDistToStartChase' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, bCanPerformTaunt) == 0x0000DD, "Member 'FAIChaseConfig::bCanPerformTaunt' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, TimeBeforeFirstTaunt) == 0x0000E0, "Member 'FAIChaseConfig::TimeBeforeFirstTaunt' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, TimeBetweenTaunts) == 0x0000E8, "Member 'FAIChaseConfig::TimeBetweenTaunts' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MinimumDistanceFromTargetForHoldingPosition) == 0x0000F0, "Member 'FAIChaseConfig::MinimumDistanceFromTargetForHoldingPosition' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, DistanceAtWhichToStopBeforeLosingLineOfSight) == 0x0000F8, "Member 'FAIChaseConfig::DistanceAtWhichToStopBeforeLosingLineOfSight' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, MaximumAngleBetweenHeadingAndTargetToKeepMoving) == 0x000100, "Member 'FAIChaseConfig::MaximumAngleBetweenHeadingAndTargetToKeepMoving' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, HeightForClearanceTestWhileTargetIsStanding) == 0x000108, "Member 'FAIChaseConfig::HeightForClearanceTestWhileTargetIsStanding' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, HeightForClearanceTestWhileTargetIsCrouched) == 0x000110, "Member 'FAIChaseConfig::HeightForClearanceTestWhileTargetIsCrouched' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, RadiusForClearanceTestWhenStopping) == 0x000118, "Member 'FAIChaseConfig::RadiusForClearanceTestWhenStopping' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, RadiusForClearanceTestWhileMoving) == 0x000120, "Member 'FAIChaseConfig::RadiusForClearanceTestWhileMoving' has a wrong offset!");
static_assert(offsetof(FAIChaseConfig, RadiusForClearanceTestWhileStationary) == 0x000128, "Member 'FAIChaseConfig::RadiusForClearanceTestWhileStationary' has a wrong offset!");

// ScriptStruct OPP.AICombatConfig
// 0x0006 (0x0006 - 0x0000)
struct FAICombatConfig final
{
public:
	bool                                          bCanBeAffectedByActiveSkillsAMP;                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanBeAffectedByActiveSkillsAMP : 1;     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCHitReactionType                           ActiveSkillsReplacementReactionAMP;                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ActiveSkillsReplacementReactionAMP : 1;  // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanBeAffectedByActiveSkillsPaint;                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanBeAffectedByActiveSkillsPaint : 1;   // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAICombatConfig) == 0x000001, "Wrong alignment on FAICombatConfig");
static_assert(sizeof(FAICombatConfig) == 0x000006, "Wrong size on FAICombatConfig");
static_assert(offsetof(FAICombatConfig, bCanBeAffectedByActiveSkillsAMP) == 0x000000, "Member 'FAICombatConfig::bCanBeAffectedByActiveSkillsAMP' has a wrong offset!");
static_assert(offsetof(FAICombatConfig, ActiveSkillsReplacementReactionAMP) == 0x000002, "Member 'FAICombatConfig::ActiveSkillsReplacementReactionAMP' has a wrong offset!");
static_assert(offsetof(FAICombatConfig, bCanBeAffectedByActiveSkillsPaint) == 0x000004, "Member 'FAICombatConfig::bCanBeAffectedByActiveSkillsPaint' has a wrong offset!");

// ScriptStruct OPP.AIInvestigationBiasConfig
// 0x0150 (0x0150 - 0x0000)
struct FAIInvestigationBiasConfig final
{
public:
	float                                         MaxPointSearchDistance;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPointSearchDistance : 1;              // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPointSearchHeight;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPointSearchHeight : 1;                // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathDistance;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPathDistance : 1;                     // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bUseClosestPlayerIfNoRelativePlayer;               // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bUseClosestPlayerIfNoRelativePlayer : 1; // 0x0016(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointWeightContrib;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PointWeightContrib : 1;                  // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointWeight;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PointWeight : 1;                         // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoGeneratedWeight;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AutoGeneratedWeight : 1;                 // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HidingSpotWeight;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HidingSpotWeight : 1;                    // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimpleInteractWeight;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SimpleInteractWeight : 1;                // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorOpenedByPlayerWeight;                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorOpenedByPlayerWeight : 1;            // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorDefaultWeight;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorDefaultWeight : 1;                   // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorListeningProbability;                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorListeningProbability : 1;            // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorPeekProbability;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorPeekProbability : 1;                 // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GenericInvestigationClearanceDistance;             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GenericInvestigationClearanceDistance : 1; // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FindHiddenPlayerProbability;                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FindHiddenPlayerProbability : 1;         // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasVisitedContrib;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasVisitedContrib : 1;                  // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasTowardsPlayerContrib;                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasTowardsPlayerContrib : 1;            // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasTowardsLastPlayerDirectionContrib;             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasTowardsLastPlayerDirectionContrib : 1; // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasGeneralInvestigationDirectionContrib;          // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasGeneralInvestigationDirectionContrib : 1; // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasNearPlayerDistance;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasNearPlayerDistance : 1;              // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasNearPlayerContrib;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasNearPlayerContrib : 1;               // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasNearPlayerContrib1stPoint;                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasNearPlayerContrib1stPoint : 1;       // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasIdealDistanceFromBot;                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasIdealDistanceFromBot : 1;            // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasIdealDistanceFromBotContrib;                   // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasIdealDistanceFromBotContrib : 1;     // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasDifferentHeightThreshold;                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasDifferentHeightThreshold : 1;        // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasDifferentHeightToBotContrib;                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasDifferentHeightToBotContrib : 1;     // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasDifferentHeightToPlayerContrib;                // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasDifferentHeightToPlayerContrib : 1;  // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasInSearchDistanceContrib;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasInSearchDistanceContrib : 1;         // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasCloseToOtherBotDistance;                       // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasCloseToOtherBotDistance : 1;         // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasCloseToOtherBotContrib;                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasCloseToOtherBotContrib : 1;          // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasAwayFromIncapacitatedDistance;                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasAwayFromIncapacitatedDistance : 1;   // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasAwayFromIncapacitatedContrib;                  // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasAwayFromIncapacitatedContrib : 1;    // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasInvestigatedRecentlyDelay;                     // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasInvestigatedRecentlyDelay : 1;       // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasInvestigatedRecentlyContrib;                   // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasInvestigatedRecentlyContrib : 1;     // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasCloseToLastPointsDistance;                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasCloseToLastPointsDistance : 1;       // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasCloseToLastPointsContrib;                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasCloseToLastPointsContrib : 1;        // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasRecentlyVisitedOtherRoomContrib;               // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasRecentlyVisitedOtherRoomContrib : 1; // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasCurrentRoomHidingSpotContrib;                  // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasCurrentRoomHidingSpotContrib : 1;    // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasOtherRoomHidingSpotContrib;                    // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasOtherRoomHidingSpotContrib : 1;      // 0x012C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasUnvisitedOtherRoomInvPointContrib;             // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasUnvisitedOtherRoomInvPointContrib : 1; // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasAdjacentToNPCVisitedRoom;                      // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasAdjacentToNPCVisitedRoom : 1;        // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasRandomContrib;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasRandomContrib : 1;                   // 0x0144(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BiasOutsidePathingDistContrib;                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BiasOutsidePathingDistContrib : 1;       // 0x014C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIInvestigationBiasConfig) == 0x000004, "Wrong alignment on FAIInvestigationBiasConfig");
static_assert(sizeof(FAIInvestigationBiasConfig) == 0x000150, "Wrong size on FAIInvestigationBiasConfig");
static_assert(offsetof(FAIInvestigationBiasConfig, MaxPointSearchDistance) == 0x000000, "Member 'FAIInvestigationBiasConfig::MaxPointSearchDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, MaxPointSearchHeight) == 0x000008, "Member 'FAIInvestigationBiasConfig::MaxPointSearchHeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, MaxPathDistance) == 0x000010, "Member 'FAIInvestigationBiasConfig::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, bUseClosestPlayerIfNoRelativePlayer) == 0x000015, "Member 'FAIInvestigationBiasConfig::bUseClosestPlayerIfNoRelativePlayer' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, PointWeightContrib) == 0x000018, "Member 'FAIInvestigationBiasConfig::PointWeightContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, PointWeight) == 0x000020, "Member 'FAIInvestigationBiasConfig::PointWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, AutoGeneratedWeight) == 0x000028, "Member 'FAIInvestigationBiasConfig::AutoGeneratedWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, HidingSpotWeight) == 0x000030, "Member 'FAIInvestigationBiasConfig::HidingSpotWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, SimpleInteractWeight) == 0x000038, "Member 'FAIInvestigationBiasConfig::SimpleInteractWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, DoorOpenedByPlayerWeight) == 0x000040, "Member 'FAIInvestigationBiasConfig::DoorOpenedByPlayerWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, DoorDefaultWeight) == 0x000048, "Member 'FAIInvestigationBiasConfig::DoorDefaultWeight' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, DoorListeningProbability) == 0x000050, "Member 'FAIInvestigationBiasConfig::DoorListeningProbability' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, DoorPeekProbability) == 0x000058, "Member 'FAIInvestigationBiasConfig::DoorPeekProbability' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, GenericInvestigationClearanceDistance) == 0x000060, "Member 'FAIInvestigationBiasConfig::GenericInvestigationClearanceDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, FindHiddenPlayerProbability) == 0x000068, "Member 'FAIInvestigationBiasConfig::FindHiddenPlayerProbability' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasVisitedContrib) == 0x000070, "Member 'FAIInvestigationBiasConfig::BiasVisitedContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasTowardsPlayerContrib) == 0x000078, "Member 'FAIInvestigationBiasConfig::BiasTowardsPlayerContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasTowardsLastPlayerDirectionContrib) == 0x000080, "Member 'FAIInvestigationBiasConfig::BiasTowardsLastPlayerDirectionContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasGeneralInvestigationDirectionContrib) == 0x000088, "Member 'FAIInvestigationBiasConfig::BiasGeneralInvestigationDirectionContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasNearPlayerDistance) == 0x000090, "Member 'FAIInvestigationBiasConfig::BiasNearPlayerDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasNearPlayerContrib) == 0x000098, "Member 'FAIInvestigationBiasConfig::BiasNearPlayerContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasNearPlayerContrib1stPoint) == 0x0000A0, "Member 'FAIInvestigationBiasConfig::BiasNearPlayerContrib1stPoint' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasIdealDistanceFromBot) == 0x0000A8, "Member 'FAIInvestigationBiasConfig::BiasIdealDistanceFromBot' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasIdealDistanceFromBotContrib) == 0x0000B0, "Member 'FAIInvestigationBiasConfig::BiasIdealDistanceFromBotContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasDifferentHeightThreshold) == 0x0000B8, "Member 'FAIInvestigationBiasConfig::BiasDifferentHeightThreshold' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasDifferentHeightToBotContrib) == 0x0000C0, "Member 'FAIInvestigationBiasConfig::BiasDifferentHeightToBotContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasDifferentHeightToPlayerContrib) == 0x0000C8, "Member 'FAIInvestigationBiasConfig::BiasDifferentHeightToPlayerContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasInSearchDistanceContrib) == 0x0000D0, "Member 'FAIInvestigationBiasConfig::BiasInSearchDistanceContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasCloseToOtherBotDistance) == 0x0000D8, "Member 'FAIInvestigationBiasConfig::BiasCloseToOtherBotDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasCloseToOtherBotContrib) == 0x0000E0, "Member 'FAIInvestigationBiasConfig::BiasCloseToOtherBotContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasAwayFromIncapacitatedDistance) == 0x0000E8, "Member 'FAIInvestigationBiasConfig::BiasAwayFromIncapacitatedDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasAwayFromIncapacitatedContrib) == 0x0000F0, "Member 'FAIInvestigationBiasConfig::BiasAwayFromIncapacitatedContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasInvestigatedRecentlyDelay) == 0x0000F8, "Member 'FAIInvestigationBiasConfig::BiasInvestigatedRecentlyDelay' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasInvestigatedRecentlyContrib) == 0x000100, "Member 'FAIInvestigationBiasConfig::BiasInvestigatedRecentlyContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasCloseToLastPointsDistance) == 0x000108, "Member 'FAIInvestigationBiasConfig::BiasCloseToLastPointsDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasCloseToLastPointsContrib) == 0x000110, "Member 'FAIInvestigationBiasConfig::BiasCloseToLastPointsContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasRecentlyVisitedOtherRoomContrib) == 0x000118, "Member 'FAIInvestigationBiasConfig::BiasRecentlyVisitedOtherRoomContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasCurrentRoomHidingSpotContrib) == 0x000120, "Member 'FAIInvestigationBiasConfig::BiasCurrentRoomHidingSpotContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasOtherRoomHidingSpotContrib) == 0x000128, "Member 'FAIInvestigationBiasConfig::BiasOtherRoomHidingSpotContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasUnvisitedOtherRoomInvPointContrib) == 0x000130, "Member 'FAIInvestigationBiasConfig::BiasUnvisitedOtherRoomInvPointContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasAdjacentToNPCVisitedRoom) == 0x000138, "Member 'FAIInvestigationBiasConfig::BiasAdjacentToNPCVisitedRoom' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasRandomContrib) == 0x000140, "Member 'FAIInvestigationBiasConfig::BiasRandomContrib' has a wrong offset!");
static_assert(offsetof(FAIInvestigationBiasConfig, BiasOutsidePathingDistContrib) == 0x000148, "Member 'FAIInvestigationBiasConfig::BiasOutsidePathingDistContrib' has a wrong offset!");

// ScriptStruct OPP.AIInvestigationConfig
// 0x0308 (0x0308 - 0x0000)
struct FAIInvestigationConfig final
{
public:
	bool                                          bCanInvestigate;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanInvestigate : 1;                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInvestigateOnIdleFallback;                        // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bInvestigateOnIdleFallback : 1;          // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInvestigateOnPlaceWhileSuspicious;                // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bInvestigateOnPlaceWhileSuspicious : 1;  // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bUseInvPointAnimsForSimpleInv;                     // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bUseInvPointAnimsForSimpleInv : 1;       // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanInvestigatePlayersInHidespots;                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanInvestigatePlayersInHidespots : 1;   // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPointsToCheckAlertedAfterLKP;                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NumPointsToCheckAlertedAfterLKP : 1;     // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bFindInvestigationPointForSourceInvestigation;     // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bFindInvestigationPointForSourceInvestigation : 1; // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bPlayGiveUpAnim;                                   // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bPlayGiveUpAnim : 1;                     // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPointsToGenerate;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinPointsToGenerate : 1;                 // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedPointsMinRadius;                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GeneratedPointsMinRadius : 1;            // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedPointsMaxRadius;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GeneratedPointsMaxRadius : 1;            // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCountAsOtherBotForInvestigationBias;              // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCountAsOtherBotForInvestigationBias : 1; // 0x002E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanBreakHidespot;                                 // 0x002F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanBreakHidespot : 1;                   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BreakHidespotProbability;                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BreakHidespotProbability : 1;            // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistFromChasedPlayer;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDistFromChasedPlayer : 1;             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bStopIfPlayerOutOfRange;                           // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bStopIfPlayerOutOfRange : 1;             // 0x0042(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bUseCapsuleOrientationForVisionCones;              // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bUseCapsuleOrientationForVisionCones : 1; // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bForceDynamicLook;                                 // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bForceDynamicLook : 1;                   // 0x0046(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPointsForFinishIncapacitated;                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPointsForFinishIncapacitated : 1;     // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimplePointDestinationBuffer;                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SimplePointDestinationBuffer : 1;        // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnownPlayerPointDestinationBuffer;                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_KnownPlayerPointDestinationBuffer : 1;   // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SouceInvestigationPointSearchDistance;             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SouceInvestigationPointSearchDistance : 1; // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIInvestigationBiasConfig             AlertedInvestigationBiasConfig;                    // 0x0068(0x0150)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIInvestigationBiasConfig             PatrolInvestigationBiasConfig;                     // 0x01B8(0x0150)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIInvestigationConfig) == 0x000004, "Wrong alignment on FAIInvestigationConfig");
static_assert(sizeof(FAIInvestigationConfig) == 0x000308, "Wrong size on FAIInvestigationConfig");
static_assert(offsetof(FAIInvestigationConfig, bCanInvestigate) == 0x000000, "Member 'FAIInvestigationConfig::bCanInvestigate' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bInvestigateOnIdleFallback) == 0x000002, "Member 'FAIInvestigationConfig::bInvestigateOnIdleFallback' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bInvestigateOnPlaceWhileSuspicious) == 0x000004, "Member 'FAIInvestigationConfig::bInvestigateOnPlaceWhileSuspicious' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bUseInvPointAnimsForSimpleInv) == 0x000006, "Member 'FAIInvestigationConfig::bUseInvPointAnimsForSimpleInv' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bCanInvestigatePlayersInHidespots) == 0x000008, "Member 'FAIInvestigationConfig::bCanInvestigatePlayersInHidespots' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, NumPointsToCheckAlertedAfterLKP) == 0x00000C, "Member 'FAIInvestigationConfig::NumPointsToCheckAlertedAfterLKP' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bFindInvestigationPointForSourceInvestigation) == 0x000011, "Member 'FAIInvestigationConfig::bFindInvestigationPointForSourceInvestigation' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bPlayGiveUpAnim) == 0x000013, "Member 'FAIInvestigationConfig::bPlayGiveUpAnim' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, MinPointsToGenerate) == 0x000018, "Member 'FAIInvestigationConfig::MinPointsToGenerate' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, GeneratedPointsMinRadius) == 0x000020, "Member 'FAIInvestigationConfig::GeneratedPointsMinRadius' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, GeneratedPointsMaxRadius) == 0x000028, "Member 'FAIInvestigationConfig::GeneratedPointsMaxRadius' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bCountAsOtherBotForInvestigationBias) == 0x00002D, "Member 'FAIInvestigationConfig::bCountAsOtherBotForInvestigationBias' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bCanBreakHidespot) == 0x00002F, "Member 'FAIInvestigationConfig::bCanBreakHidespot' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, BreakHidespotProbability) == 0x000034, "Member 'FAIInvestigationConfig::BreakHidespotProbability' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, MinDistFromChasedPlayer) == 0x00003C, "Member 'FAIInvestigationConfig::MinDistFromChasedPlayer' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bStopIfPlayerOutOfRange) == 0x000041, "Member 'FAIInvestigationConfig::bStopIfPlayerOutOfRange' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bUseCapsuleOrientationForVisionCones) == 0x000043, "Member 'FAIInvestigationConfig::bUseCapsuleOrientationForVisionCones' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, bForceDynamicLook) == 0x000045, "Member 'FAIInvestigationConfig::bForceDynamicLook' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, MaxPointsForFinishIncapacitated) == 0x000048, "Member 'FAIInvestigationConfig::MaxPointsForFinishIncapacitated' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, SimplePointDestinationBuffer) == 0x000050, "Member 'FAIInvestigationConfig::SimplePointDestinationBuffer' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, KnownPlayerPointDestinationBuffer) == 0x000058, "Member 'FAIInvestigationConfig::KnownPlayerPointDestinationBuffer' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, SouceInvestigationPointSearchDistance) == 0x000060, "Member 'FAIInvestigationConfig::SouceInvestigationPointSearchDistance' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, AlertedInvestigationBiasConfig) == 0x000068, "Member 'FAIInvestigationConfig::AlertedInvestigationBiasConfig' has a wrong offset!");
static_assert(offsetof(FAIInvestigationConfig, PatrolInvestigationBiasConfig) == 0x0001B8, "Member 'FAIInvestigationConfig::PatrolInvestigationBiasConfig' has a wrong offset!");

// ScriptStruct OPP.AIDynamicLookConfig
// 0x0174 (0x0174 - 0x0000)
struct FAIDynamicLookConfig final
{
public:
	bool                                          bEnableDynamicLook;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableDynamicLook : 1;                  // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalProbability;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_GlobalProbability : 1;                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxConsecutivePoints;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxConsecutivePoints : 1;                // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayBetweenActivations;                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayBetweenActivations : 1;          // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayAfterInvestigationStart;                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayAfterInvestigationStart : 1;     // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointAvailabilityDurationBeforeActivation;         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PointAvailabilityDurationBeforeActivation : 1; // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistToDestinationForActivation;                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistToDestinationForActivation : 1;   // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdatePointsInterval;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UpdatePointsInterval : 1;                // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastLookAtLargeAngleProbability;                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FastLookAtLargeAngleProbability : 1;     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastLookMaxDuration;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FastLookMaxDuration : 1;                 // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedChangeSmoothingDuration;                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SpeedChangeSmoothingDuration : 1;        // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddedScanAngleRange;                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AddedScanAngleRange : 1;                 // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddedScanFrequency;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AddedScanFrequency : 1;                  // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterestPointMinRelativeYaw;                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InterestPointMinRelativeYaw : 1;         // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceClose;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceClose : 1;                       // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceIdeal;                                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceIdeal : 1;                       // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceTooFar;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceTooFar : 1;                      // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceScoreContribClose;                         // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceScoreContribClose : 1;           // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceScoreContribIdeal;                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistanceScoreContribIdeal : 1;           // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LargeAngleThreshold;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LargeAngleThreshold : 1;                 // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LargeAngleScoreContrib;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LargeAngleScoreContrib : 1;              // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomScoreContrib;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RandomScoreContrib : 1;                  // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayForPointReuse;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDelayForPointReuse : 1;               // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPointDurationClose;                             // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinPointDurationClose : 1;               // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPointDurationClose;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPointDurationClose : 1;               // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPointDurationFar;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinPointDurationFar : 1;                 // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPointDurationFar;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPointDurationFar : 1;                 // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseDistanceForLookDuration;                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CloseDistanceForLookDuration : 1;        // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FarDistanceForLookDuration;                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FarDistanceForLookDuration : 1;          // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleForMinLookDuration;                           // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AngleForMinLookDuration : 1;             // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDurationForLargeAngle;                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinDurationForLargeAngle : 1;            // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowInvestigationDurationBias;                     // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SlowInvestigationDurationBias : 1;       // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastInvestigationDurationBias;                     // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FastInvestigationDurationBias : 1;       // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExplicitInvestigationMaxNumPoints;                 // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitInvestigationMaxNumPoints : 1;   // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitCloseLookClearanceDark;                    // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitCloseLookClearanceDark : 1;      // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitCloseLookClearanceNormal;                  // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitCloseLookClearanceNormal : 1;    // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitFarLookClearanceDark;                      // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitFarLookClearanceDark : 1;        // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitFarLookClearanceNormal;                    // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitFarLookClearanceNormal : 1;      // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitMinLookDurationClose;                      // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitMinLookDurationClose : 1;        // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitMinLookDurationFar;                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitMinLookDurationFar : 1;          // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitMaxLookDurationClose;                      // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitMaxLookDurationClose : 1;        // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplicitMaxLookDurationFar;                        // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplicitMaxLookDurationFar : 1;          // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackLookMinAngle;                              // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FallbackLookMinAngle : 1;                // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackLookMaxAngle;                              // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FallbackLookMaxAngle : 1;                // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackLookMinDuration;                           // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FallbackLookMinDuration : 1;             // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackLookMaxDuration;                           // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FallbackLookMaxDuration : 1;             // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumScoreForAimingAtFocus;                      // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumScoreForAimingAtFocus : 1;        // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDynamicLookConfig) == 0x000004, "Wrong alignment on FAIDynamicLookConfig");
static_assert(sizeof(FAIDynamicLookConfig) == 0x000174, "Wrong size on FAIDynamicLookConfig");
static_assert(offsetof(FAIDynamicLookConfig, bEnableDynamicLook) == 0x000000, "Member 'FAIDynamicLookConfig::bEnableDynamicLook' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, GlobalProbability) == 0x000004, "Member 'FAIDynamicLookConfig::GlobalProbability' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MaxConsecutivePoints) == 0x00000C, "Member 'FAIDynamicLookConfig::MaxConsecutivePoints' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinDelayBetweenActivations) == 0x000014, "Member 'FAIDynamicLookConfig::MinDelayBetweenActivations' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinDelayAfterInvestigationStart) == 0x00001C, "Member 'FAIDynamicLookConfig::MinDelayAfterInvestigationStart' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, PointAvailabilityDurationBeforeActivation) == 0x000024, "Member 'FAIDynamicLookConfig::PointAvailabilityDurationBeforeActivation' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MaxDistToDestinationForActivation) == 0x00002C, "Member 'FAIDynamicLookConfig::MaxDistToDestinationForActivation' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, UpdatePointsInterval) == 0x000034, "Member 'FAIDynamicLookConfig::UpdatePointsInterval' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FastLookAtLargeAngleProbability) == 0x00003C, "Member 'FAIDynamicLookConfig::FastLookAtLargeAngleProbability' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FastLookMaxDuration) == 0x000044, "Member 'FAIDynamicLookConfig::FastLookMaxDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, SpeedChangeSmoothingDuration) == 0x00004C, "Member 'FAIDynamicLookConfig::SpeedChangeSmoothingDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, AddedScanAngleRange) == 0x000054, "Member 'FAIDynamicLookConfig::AddedScanAngleRange' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, AddedScanFrequency) == 0x00005C, "Member 'FAIDynamicLookConfig::AddedScanFrequency' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, InterestPointMinRelativeYaw) == 0x000064, "Member 'FAIDynamicLookConfig::InterestPointMinRelativeYaw' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, DistanceClose) == 0x00006C, "Member 'FAIDynamicLookConfig::DistanceClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, DistanceIdeal) == 0x000074, "Member 'FAIDynamicLookConfig::DistanceIdeal' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, DistanceTooFar) == 0x00007C, "Member 'FAIDynamicLookConfig::DistanceTooFar' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, DistanceScoreContribClose) == 0x000084, "Member 'FAIDynamicLookConfig::DistanceScoreContribClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, DistanceScoreContribIdeal) == 0x00008C, "Member 'FAIDynamicLookConfig::DistanceScoreContribIdeal' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, LargeAngleThreshold) == 0x000094, "Member 'FAIDynamicLookConfig::LargeAngleThreshold' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, LargeAngleScoreContrib) == 0x00009C, "Member 'FAIDynamicLookConfig::LargeAngleScoreContrib' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, RandomScoreContrib) == 0x0000A4, "Member 'FAIDynamicLookConfig::RandomScoreContrib' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinDelayForPointReuse) == 0x0000AC, "Member 'FAIDynamicLookConfig::MinDelayForPointReuse' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinPointDurationClose) == 0x0000B4, "Member 'FAIDynamicLookConfig::MinPointDurationClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MaxPointDurationClose) == 0x0000BC, "Member 'FAIDynamicLookConfig::MaxPointDurationClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinPointDurationFar) == 0x0000C4, "Member 'FAIDynamicLookConfig::MinPointDurationFar' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MaxPointDurationFar) == 0x0000CC, "Member 'FAIDynamicLookConfig::MaxPointDurationFar' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, CloseDistanceForLookDuration) == 0x0000D4, "Member 'FAIDynamicLookConfig::CloseDistanceForLookDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FarDistanceForLookDuration) == 0x0000DC, "Member 'FAIDynamicLookConfig::FarDistanceForLookDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, AngleForMinLookDuration) == 0x0000E4, "Member 'FAIDynamicLookConfig::AngleForMinLookDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinDurationForLargeAngle) == 0x0000EC, "Member 'FAIDynamicLookConfig::MinDurationForLargeAngle' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, SlowInvestigationDurationBias) == 0x0000F4, "Member 'FAIDynamicLookConfig::SlowInvestigationDurationBias' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FastInvestigationDurationBias) == 0x0000FC, "Member 'FAIDynamicLookConfig::FastInvestigationDurationBias' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitInvestigationMaxNumPoints) == 0x000104, "Member 'FAIDynamicLookConfig::ExplicitInvestigationMaxNumPoints' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitCloseLookClearanceDark) == 0x00010C, "Member 'FAIDynamicLookConfig::ExplicitCloseLookClearanceDark' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitCloseLookClearanceNormal) == 0x000114, "Member 'FAIDynamicLookConfig::ExplicitCloseLookClearanceNormal' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitFarLookClearanceDark) == 0x00011C, "Member 'FAIDynamicLookConfig::ExplicitFarLookClearanceDark' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitFarLookClearanceNormal) == 0x000124, "Member 'FAIDynamicLookConfig::ExplicitFarLookClearanceNormal' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitMinLookDurationClose) == 0x00012C, "Member 'FAIDynamicLookConfig::ExplicitMinLookDurationClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitMinLookDurationFar) == 0x000134, "Member 'FAIDynamicLookConfig::ExplicitMinLookDurationFar' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitMaxLookDurationClose) == 0x00013C, "Member 'FAIDynamicLookConfig::ExplicitMaxLookDurationClose' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, ExplicitMaxLookDurationFar) == 0x000144, "Member 'FAIDynamicLookConfig::ExplicitMaxLookDurationFar' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FallbackLookMinAngle) == 0x00014C, "Member 'FAIDynamicLookConfig::FallbackLookMinAngle' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FallbackLookMaxAngle) == 0x000154, "Member 'FAIDynamicLookConfig::FallbackLookMaxAngle' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FallbackLookMinDuration) == 0x00015C, "Member 'FAIDynamicLookConfig::FallbackLookMinDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, FallbackLookMaxDuration) == 0x000164, "Member 'FAIDynamicLookConfig::FallbackLookMaxDuration' has a wrong offset!");
static_assert(offsetof(FAIDynamicLookConfig, MinimumScoreForAimingAtFocus) == 0x00016C, "Member 'FAIDynamicLookConfig::MinimumScoreForAimingAtFocus' has a wrong offset!");

// ScriptStruct OPP.AIIdleFocusConfig
// 0x0068 (0x0068 - 0x0000)
struct FAIIdleFocusConfig final
{
public:
	float                                         NormalStayDurationMinTime;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NormalStayDurationMinTime : 1;           // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalStayDurationMaxTime;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NormalStayDurationMaxTime : 1;           // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinInterestTime;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinInterestTime : 1;                     // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInterestTime;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxInterestTime : 1;                     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToPlayer;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceToPlayer : 1;                 // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeadingAngleToPlayer;                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxHeadingAngleToPlayer : 1;             // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLookingAngleToPlayer;                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxLookingAngleToPlayer : 1;             // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToNPC;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceToNPC : 1;                    // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeadingAngleToNPC;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxHeadingAngleToNPC : 1;                // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLookingAngleToNPC;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxLookingAngleToNPC : 1;                // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToDoor;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistanceToDoor : 1;                   // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeadingAngleToDoor;                             // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxHeadingAngleToDoor : 1;               // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLookingAngleToDoor;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxLookingAngleToDoor : 1;               // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIIdleFocusConfig) == 0x000004, "Wrong alignment on FAIIdleFocusConfig");
static_assert(sizeof(FAIIdleFocusConfig) == 0x000068, "Wrong size on FAIIdleFocusConfig");
static_assert(offsetof(FAIIdleFocusConfig, NormalStayDurationMinTime) == 0x000000, "Member 'FAIIdleFocusConfig::NormalStayDurationMinTime' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, NormalStayDurationMaxTime) == 0x000008, "Member 'FAIIdleFocusConfig::NormalStayDurationMaxTime' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MinInterestTime) == 0x000010, "Member 'FAIIdleFocusConfig::MinInterestTime' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxInterestTime) == 0x000018, "Member 'FAIIdleFocusConfig::MaxInterestTime' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxDistanceToPlayer) == 0x000020, "Member 'FAIIdleFocusConfig::MaxDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxHeadingAngleToPlayer) == 0x000028, "Member 'FAIIdleFocusConfig::MaxHeadingAngleToPlayer' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxLookingAngleToPlayer) == 0x000030, "Member 'FAIIdleFocusConfig::MaxLookingAngleToPlayer' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxDistanceToNPC) == 0x000038, "Member 'FAIIdleFocusConfig::MaxDistanceToNPC' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxHeadingAngleToNPC) == 0x000040, "Member 'FAIIdleFocusConfig::MaxHeadingAngleToNPC' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxLookingAngleToNPC) == 0x000048, "Member 'FAIIdleFocusConfig::MaxLookingAngleToNPC' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxDistanceToDoor) == 0x000050, "Member 'FAIIdleFocusConfig::MaxDistanceToDoor' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxHeadingAngleToDoor) == 0x000058, "Member 'FAIIdleFocusConfig::MaxHeadingAngleToDoor' has a wrong offset!");
static_assert(offsetof(FAIIdleFocusConfig, MaxLookingAngleToDoor) == 0x000060, "Member 'FAIIdleFocusConfig::MaxLookingAngleToDoor' has a wrong offset!");

// ScriptStruct OPP.AIAmbientConfig
// 0x0074 (0x0074 - 0x0000)
struct FAIAmbientConfig final
{
public:
	bool                                          bEnableAmbientPatrol;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableAmbientPatrol : 1;                // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAllowAmbientConfigWithNoNPCTags;                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAllowAmbientConfigWithNoNPCTags : 1;    // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         PatrolDestinationBuffer;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PatrolDestinationBuffer : 1;             // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultMinStayDuration;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultMinStayDuration : 1;              // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultMaxStayDuration;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DefaultMaxStayDuration : 1;              // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPlayerDistForRelocation;                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinPlayerDistForRelocation : 1;          // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bResetNeutralWhenStartingAmbient;                  // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bResetNeutralWhenStartingAmbient : 1;    // 0x0022(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinIdealDistToNextPoint;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinIdealDistToNextPoint : 1;             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxIdealDistToNextPoint;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxIdealDistToNextPoint : 1;             // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotRecentlyUsedDelay;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NotRecentlyUsedDelay : 1;                // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdealDistScorePoints;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IdealDistScorePoints : 1;                // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalityScorePoints;                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HorizontalityScorePoints : 1;            // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnusedScorePoints;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnusedScorePoints : 1;                   // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotRecentlyUsedScorePoints;                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_NotRecentlyUsedScorePoints : 1;          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomScorePoints;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RandomScorePoints : 1;                   // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactToPlayerDistance;                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ReactToPlayerDistance : 1;               // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PassiveUnawareVOMinDistance;                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PassiveUnawareVOMinDistance : 1;         // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAmbientConfig) == 0x000004, "Wrong alignment on FAIAmbientConfig");
static_assert(sizeof(FAIAmbientConfig) == 0x000074, "Wrong size on FAIAmbientConfig");
static_assert(offsetof(FAIAmbientConfig, bEnableAmbientPatrol) == 0x000000, "Member 'FAIAmbientConfig::bEnableAmbientPatrol' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, bAllowAmbientConfigWithNoNPCTags) == 0x000002, "Member 'FAIAmbientConfig::bAllowAmbientConfigWithNoNPCTags' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, PatrolDestinationBuffer) == 0x000004, "Member 'FAIAmbientConfig::PatrolDestinationBuffer' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, DefaultMinStayDuration) == 0x00000C, "Member 'FAIAmbientConfig::DefaultMinStayDuration' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, DefaultMaxStayDuration) == 0x000014, "Member 'FAIAmbientConfig::DefaultMaxStayDuration' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, MinPlayerDistForRelocation) == 0x00001C, "Member 'FAIAmbientConfig::MinPlayerDistForRelocation' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, bResetNeutralWhenStartingAmbient) == 0x000021, "Member 'FAIAmbientConfig::bResetNeutralWhenStartingAmbient' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, MinIdealDistToNextPoint) == 0x000024, "Member 'FAIAmbientConfig::MinIdealDistToNextPoint' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, MaxIdealDistToNextPoint) == 0x00002C, "Member 'FAIAmbientConfig::MaxIdealDistToNextPoint' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, NotRecentlyUsedDelay) == 0x000034, "Member 'FAIAmbientConfig::NotRecentlyUsedDelay' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, IdealDistScorePoints) == 0x00003C, "Member 'FAIAmbientConfig::IdealDistScorePoints' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, HorizontalityScorePoints) == 0x000044, "Member 'FAIAmbientConfig::HorizontalityScorePoints' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, UnusedScorePoints) == 0x00004C, "Member 'FAIAmbientConfig::UnusedScorePoints' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, NotRecentlyUsedScorePoints) == 0x000054, "Member 'FAIAmbientConfig::NotRecentlyUsedScorePoints' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, RandomScorePoints) == 0x00005C, "Member 'FAIAmbientConfig::RandomScorePoints' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, ReactToPlayerDistance) == 0x000064, "Member 'FAIAmbientConfig::ReactToPlayerDistance' has a wrong offset!");
static_assert(offsetof(FAIAmbientConfig, PassiveUnawareVOMinDistance) == 0x00006C, "Member 'FAIAmbientConfig::PassiveUnawareVOMinDistance' has a wrong offset!");

// ScriptStruct OPP.AIPlayerAvoidanceConfig
// 0x0050 (0x0050 - 0x0000)
struct FAIPlayerAvoidanceConfig final
{
public:
	float                                         MinPlayerAvoidanceDuration;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinPlayerAvoidanceDuration : 1;          // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAvoidanceDurationAfterPlayerSight;              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinAvoidanceDurationAfterPlayerSight : 1; // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClosePointDist;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ClosePointDist : 1;                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdealPointDist;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IdealPointDist : 1;                      // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistScoreContrib;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DistScoreContrib : 1;                    // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomScoreContrib;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RandomScoreContrib : 1;                  // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AwayFromPlayerMaxContrib;                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AwayFromPlayerMaxContrib : 1;            // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAlarmDurationAfterSpottingPlayer;               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAlarmDurationAfterSpottingPlayer : 1; // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAlarmRange;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAlarmRange : 1;                       // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckSurroundingsAtWaypointProbability;            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CheckSurroundingsAtWaypointProbability : 1; // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPlayerAvoidanceConfig) == 0x000004, "Wrong alignment on FAIPlayerAvoidanceConfig");
static_assert(sizeof(FAIPlayerAvoidanceConfig) == 0x000050, "Wrong size on FAIPlayerAvoidanceConfig");
static_assert(offsetof(FAIPlayerAvoidanceConfig, MinPlayerAvoidanceDuration) == 0x000000, "Member 'FAIPlayerAvoidanceConfig::MinPlayerAvoidanceDuration' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, MinAvoidanceDurationAfterPlayerSight) == 0x000008, "Member 'FAIPlayerAvoidanceConfig::MinAvoidanceDurationAfterPlayerSight' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, ClosePointDist) == 0x000010, "Member 'FAIPlayerAvoidanceConfig::ClosePointDist' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, IdealPointDist) == 0x000018, "Member 'FAIPlayerAvoidanceConfig::IdealPointDist' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, DistScoreContrib) == 0x000020, "Member 'FAIPlayerAvoidanceConfig::DistScoreContrib' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, RandomScoreContrib) == 0x000028, "Member 'FAIPlayerAvoidanceConfig::RandomScoreContrib' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, AwayFromPlayerMaxContrib) == 0x000030, "Member 'FAIPlayerAvoidanceConfig::AwayFromPlayerMaxContrib' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, MaxAlarmDurationAfterSpottingPlayer) == 0x000038, "Member 'FAIPlayerAvoidanceConfig::MaxAlarmDurationAfterSpottingPlayer' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, MaxAlarmRange) == 0x000040, "Member 'FAIPlayerAvoidanceConfig::MaxAlarmRange' has a wrong offset!");
static_assert(offsetof(FAIPlayerAvoidanceConfig, CheckSurroundingsAtWaypointProbability) == 0x000048, "Member 'FAIPlayerAvoidanceConfig::CheckSurroundingsAtWaypointProbability' has a wrong offset!");

// ScriptStruct OPP.AIRepulsionParameters
// 0x0054 (0x0054 - 0x0000)
struct FAIRepulsionParameters final
{
public:
	bool                                          bDisableRepulsion;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDisableRepulsion : 1;                   // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bDisableSynchronizedAvoidance;                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDisableSynchronizedAvoidance : 1;       // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         MagneticRepulsionDistance;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MagneticRepulsionDistance : 1;           // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearRepulsionDistance;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LinearRepulsionDistance : 1;             // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepulsionForce;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RepulsionForce : 1;                      // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRelativeVelocity;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinRelativeVelocity : 1;                 // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRelativeVelocity;                               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxRelativeVelocity : 1;                 // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeVelocityRepulsionScale;                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RelativeVelocityRepulsionScale : 1;      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRelVelForMovingRepulsion;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxRelVelForMovingRepulsion : 1;         // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVelForMovingRepulsion;                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinVelForMovingRepulsion : 1;            // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingRepulsionMaxSlowdown;                        // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MovingRepulsionMaxSlowdown : 1;          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMovingRepulsionDist;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxMovingRepulsionDist : 1;              // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRepulsionParameters) == 0x000004, "Wrong alignment on FAIRepulsionParameters");
static_assert(sizeof(FAIRepulsionParameters) == 0x000054, "Wrong size on FAIRepulsionParameters");
static_assert(offsetof(FAIRepulsionParameters, bDisableRepulsion) == 0x000000, "Member 'FAIRepulsionParameters::bDisableRepulsion' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, bDisableSynchronizedAvoidance) == 0x000002, "Member 'FAIRepulsionParameters::bDisableSynchronizedAvoidance' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MagneticRepulsionDistance) == 0x000004, "Member 'FAIRepulsionParameters::MagneticRepulsionDistance' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, LinearRepulsionDistance) == 0x00000C, "Member 'FAIRepulsionParameters::LinearRepulsionDistance' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, RepulsionForce) == 0x000014, "Member 'FAIRepulsionParameters::RepulsionForce' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MinRelativeVelocity) == 0x00001C, "Member 'FAIRepulsionParameters::MinRelativeVelocity' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MaxRelativeVelocity) == 0x000024, "Member 'FAIRepulsionParameters::MaxRelativeVelocity' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, RelativeVelocityRepulsionScale) == 0x00002C, "Member 'FAIRepulsionParameters::RelativeVelocityRepulsionScale' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MaxRelVelForMovingRepulsion) == 0x000034, "Member 'FAIRepulsionParameters::MaxRelVelForMovingRepulsion' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MinVelForMovingRepulsion) == 0x00003C, "Member 'FAIRepulsionParameters::MinVelForMovingRepulsion' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MovingRepulsionMaxSlowdown) == 0x000044, "Member 'FAIRepulsionParameters::MovingRepulsionMaxSlowdown' has a wrong offset!");
static_assert(offsetof(FAIRepulsionParameters, MaxMovingRepulsionDist) == 0x00004C, "Member 'FAIRepulsionParameters::MaxMovingRepulsionDist' has a wrong offset!");

// ScriptStruct OPP.AIPitcherConfig
// 0x0048 (0x0048 - 0x0000)
struct FAIPitcherConfig final
{
public:
	float                                         DamageForFireBreathAttacks;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageForFireBreathAttacks : 1;          // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeForFireBreathAttacks;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RangeForFireBreathAttacks : 1;           // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleForFireBreathAttacks;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_AngleForFireBreathAttacks : 1;           // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOffsetOfTargetFromGround;                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumOffsetOfTargetFromGround : 1;     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRotationSpeed;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinRotationSpeed : 1;                    // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRotationSpeed;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxRotationSpeed : 1;                    // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxThrowsBeforeRetirement;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxThrowsBeforeRetirement : 1;           // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplierForMolotovFire;                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamageMultiplierForMolotovFire : 1;      // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EMolotovSize                                  MolotovSize;                                       // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MolotovSize : 1;                         // 0x003E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MolotovDurationMultipliyer;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MolotovDurationMultipliyer : 1;          // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPitcherConfig) == 0x000004, "Wrong alignment on FAIPitcherConfig");
static_assert(sizeof(FAIPitcherConfig) == 0x000048, "Wrong size on FAIPitcherConfig");
static_assert(offsetof(FAIPitcherConfig, DamageForFireBreathAttacks) == 0x000000, "Member 'FAIPitcherConfig::DamageForFireBreathAttacks' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, RangeForFireBreathAttacks) == 0x000008, "Member 'FAIPitcherConfig::RangeForFireBreathAttacks' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, AngleForFireBreathAttacks) == 0x000010, "Member 'FAIPitcherConfig::AngleForFireBreathAttacks' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MinimumOffsetOfTargetFromGround) == 0x000018, "Member 'FAIPitcherConfig::MinimumOffsetOfTargetFromGround' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MinRotationSpeed) == 0x000020, "Member 'FAIPitcherConfig::MinRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MaxRotationSpeed) == 0x000028, "Member 'FAIPitcherConfig::MaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MaxThrowsBeforeRetirement) == 0x000030, "Member 'FAIPitcherConfig::MaxThrowsBeforeRetirement' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, DamageMultiplierForMolotovFire) == 0x000038, "Member 'FAIPitcherConfig::DamageMultiplierForMolotovFire' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MolotovSize) == 0x00003D, "Member 'FAIPitcherConfig::MolotovSize' has a wrong offset!");
static_assert(offsetof(FAIPitcherConfig, MolotovDurationMultipliyer) == 0x000040, "Member 'FAIPitcherConfig::MolotovDurationMultipliyer' has a wrong offset!");

// ScriptStruct OPP.AISleeperScreamerConfig
// 0x0040 (0x0040 - 0x0000)
struct FAISleeperScreamerConfig final
{
public:
	float                                         SleeperScreamAlarmRange;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SleeperScreamAlarmRange : 1;             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SleeperStunZoneDuration;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SleeperStunZoneDuration : 1;             // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SleeperDelayBetweenStartles;                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SleeperDelayBetweenStartles : 1;         // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAllowAudioPathingForDisturbance;                  // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAllowAudioPathingForDisturbance : 1;    // 0x0016(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WokenUpRunDuration;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_WokenUpRunDuration : 1;                  // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WokenUpRunSmoothingDuration;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_WokenUpRunSmoothingDuration : 1;         // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenScreams;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinTimeBetweenScreams : 1;               // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanScreamInTransit;                               // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanScreamInTransit : 1;                 // 0x002E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerProximityRatioForTransitScream;              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PlayerProximityRatioForTransitScream : 1; // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWakeUpCountBeforeRetirement;                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxWakeUpCountBeforeRetirement : 1;      // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISleeperScreamerConfig) == 0x000004, "Wrong alignment on FAISleeperScreamerConfig");
static_assert(sizeof(FAISleeperScreamerConfig) == 0x000040, "Wrong size on FAISleeperScreamerConfig");
static_assert(offsetof(FAISleeperScreamerConfig, SleeperScreamAlarmRange) == 0x000000, "Member 'FAISleeperScreamerConfig::SleeperScreamAlarmRange' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, SleeperStunZoneDuration) == 0x000008, "Member 'FAISleeperScreamerConfig::SleeperStunZoneDuration' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, SleeperDelayBetweenStartles) == 0x000010, "Member 'FAISleeperScreamerConfig::SleeperDelayBetweenStartles' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, bAllowAudioPathingForDisturbance) == 0x000015, "Member 'FAISleeperScreamerConfig::bAllowAudioPathingForDisturbance' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, WokenUpRunDuration) == 0x000018, "Member 'FAISleeperScreamerConfig::WokenUpRunDuration' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, WokenUpRunSmoothingDuration) == 0x000020, "Member 'FAISleeperScreamerConfig::WokenUpRunSmoothingDuration' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, MinTimeBetweenScreams) == 0x000028, "Member 'FAISleeperScreamerConfig::MinTimeBetweenScreams' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, bCanScreamInTransit) == 0x00002D, "Member 'FAISleeperScreamerConfig::bCanScreamInTransit' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, PlayerProximityRatioForTransitScream) == 0x000030, "Member 'FAISleeperScreamerConfig::PlayerProximityRatioForTransitScream' has a wrong offset!");
static_assert(offsetof(FAISleeperScreamerConfig, MaxWakeUpCountBeforeRetirement) == 0x000038, "Member 'FAISleeperScreamerConfig::MaxWakeUpCountBeforeRetirement' has a wrong offset!");

// ScriptStruct OPP.AIPouncerConfig
// 0x002C (0x002C - 0x0000)
struct FAIPouncerConfig final
{
public:
	bool                                          bCanPeek;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanPeek : 1;                            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TryPeekingMinInterval;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TryPeekingMinInterval : 1;               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TryPeekingMaxInterval;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TryPeekingMaxInterval : 1;               // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bUsesShyness;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bUsesShyness : 1;                        // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShynessIncreaseRate;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShynessIncreaseRate : 1;                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShynessCooldownRate;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShynessCooldownRate : 1;                 // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPouncesBeforeRetirement;                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxPouncesBeforeRetirement : 1;          // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPouncerConfig) == 0x000004, "Wrong alignment on FAIPouncerConfig");
static_assert(sizeof(FAIPouncerConfig) == 0x00002C, "Wrong size on FAIPouncerConfig");
static_assert(offsetof(FAIPouncerConfig, bCanPeek) == 0x000000, "Member 'FAIPouncerConfig::bCanPeek' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, TryPeekingMinInterval) == 0x000004, "Member 'FAIPouncerConfig::TryPeekingMinInterval' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, TryPeekingMaxInterval) == 0x00000C, "Member 'FAIPouncerConfig::TryPeekingMaxInterval' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, bUsesShyness) == 0x000011, "Member 'FAIPouncerConfig::bUsesShyness' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, ShynessIncreaseRate) == 0x000014, "Member 'FAIPouncerConfig::ShynessIncreaseRate' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, ShynessCooldownRate) == 0x00001C, "Member 'FAIPouncerConfig::ShynessCooldownRate' has a wrong offset!");
static_assert(offsetof(FAIPouncerConfig, MaxPouncesBeforeRetirement) == 0x000024, "Member 'FAIPouncerConfig::MaxPouncesBeforeRetirement' has a wrong offset!");

// ScriptStruct OPP.AINightHunterConfig
// 0x0028 (0x0028 - 0x0000)
struct FAINightHunterConfig final
{
public:
	float                                         MaximumPlayerSensingDistanceAware;                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumPlayerSensingDistanceAware : 1;   // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumPlayerSensingDistanceUnaware;               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaximumPlayerSensingDistanceUnaware : 1; // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumPlayerSpeedForUnawareDisturbance;           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumPlayerSpeedForUnawareDisturbance : 1; // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnawareDetectionDuration;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnawareDetectionDuration : 1;            // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetectionMeterCooldownDuration;                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DetectionMeterCooldownDuration : 1;      // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAINightHunterConfig) == 0x000004, "Wrong alignment on FAINightHunterConfig");
static_assert(sizeof(FAINightHunterConfig) == 0x000028, "Wrong size on FAINightHunterConfig");
static_assert(offsetof(FAINightHunterConfig, MaximumPlayerSensingDistanceAware) == 0x000000, "Member 'FAINightHunterConfig::MaximumPlayerSensingDistanceAware' has a wrong offset!");
static_assert(offsetof(FAINightHunterConfig, MaximumPlayerSensingDistanceUnaware) == 0x000008, "Member 'FAINightHunterConfig::MaximumPlayerSensingDistanceUnaware' has a wrong offset!");
static_assert(offsetof(FAINightHunterConfig, MinimumPlayerSpeedForUnawareDisturbance) == 0x000010, "Member 'FAINightHunterConfig::MinimumPlayerSpeedForUnawareDisturbance' has a wrong offset!");
static_assert(offsetof(FAINightHunterConfig, UnawareDetectionDuration) == 0x000018, "Member 'FAINightHunterConfig::UnawareDetectionDuration' has a wrong offset!");
static_assert(offsetof(FAINightHunterConfig, DetectionMeterCooldownDuration) == 0x000020, "Member 'FAINightHunterConfig::DetectionMeterCooldownDuration' has a wrong offset!");

// ScriptStruct OPP.AIBerserkerConfig
// 0x0040 (0x0040 - 0x0000)
struct FAIBerserkerConfig final
{
public:
	float                                         MinIdleAttackTime;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinIdleAttackTime : 1;                   // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxIdleAttackTime;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxIdleAttackTime : 1;                   // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceOfIdleBreakerInsteadOfAttack;                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChanceOfIdleBreakerInsteadOfAttack : 1;  // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeReturningToLeash;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeBeforeReturningToLeash : 1;          // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShortIdleAttackDistance;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ShortIdleAttackDistance : 1;             // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LongIdleAttackDistance;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_LongIdleAttackDistance : 1;              // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvulnerabilityAfterDamageDuration;                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_InvulnerabilityAfterDamageDuration : 1;  // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceIgnoreDamagedPlayerDuration;                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ForceIgnoreDamagedPlayerDuration : 1;    // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBerserkerConfig) == 0x000004, "Wrong alignment on FAIBerserkerConfig");
static_assert(sizeof(FAIBerserkerConfig) == 0x000040, "Wrong size on FAIBerserkerConfig");
static_assert(offsetof(FAIBerserkerConfig, MinIdleAttackTime) == 0x000000, "Member 'FAIBerserkerConfig::MinIdleAttackTime' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, MaxIdleAttackTime) == 0x000008, "Member 'FAIBerserkerConfig::MaxIdleAttackTime' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, ChanceOfIdleBreakerInsteadOfAttack) == 0x000010, "Member 'FAIBerserkerConfig::ChanceOfIdleBreakerInsteadOfAttack' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, TimeBeforeReturningToLeash) == 0x000018, "Member 'FAIBerserkerConfig::TimeBeforeReturningToLeash' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, ShortIdleAttackDistance) == 0x000020, "Member 'FAIBerserkerConfig::ShortIdleAttackDistance' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, LongIdleAttackDistance) == 0x000028, "Member 'FAIBerserkerConfig::LongIdleAttackDistance' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, InvulnerabilityAfterDamageDuration) == 0x000030, "Member 'FAIBerserkerConfig::InvulnerabilityAfterDamageDuration' has a wrong offset!");
static_assert(offsetof(FAIBerserkerConfig, ForceIgnoreDamagedPlayerDuration) == 0x000038, "Member 'FAIBerserkerConfig::ForceIgnoreDamagedPlayerDuration' has a wrong offset!");

// ScriptStruct OPP.AIStalkerTargetConfig
// 0x0020 (0x0020 - 0x0000)
struct FAIStalkerTargetConfig final
{
public:
	float                                         MaxChaseTime;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxChaseTime : 1;                        // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfInvestigates;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxNumberOfInvestigates : 1;             // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxNumberOfInvestigatesTimeInverval;               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxNumberOfInvestigatesTimeInverval : 1; // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInvestigatingTimeAfterLightBulbExplode;         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxInvestigatingTimeAfterLightBulbExplode : 1; // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStalkerTargetConfig) == 0x000004, "Wrong alignment on FAIStalkerTargetConfig");
static_assert(sizeof(FAIStalkerTargetConfig) == 0x000020, "Wrong size on FAIStalkerTargetConfig");
static_assert(offsetof(FAIStalkerTargetConfig, MaxChaseTime) == 0x000000, "Member 'FAIStalkerTargetConfig::MaxChaseTime' has a wrong offset!");
static_assert(offsetof(FAIStalkerTargetConfig, MaxNumberOfInvestigates) == 0x000008, "Member 'FAIStalkerTargetConfig::MaxNumberOfInvestigates' has a wrong offset!");
static_assert(offsetof(FAIStalkerTargetConfig, MaxNumberOfInvestigatesTimeInverval) == 0x000010, "Member 'FAIStalkerTargetConfig::MaxNumberOfInvestigatesTimeInverval' has a wrong offset!");
static_assert(offsetof(FAIStalkerTargetConfig, MaxInvestigatingTimeAfterLightBulbExplode) == 0x000018, "Member 'FAIStalkerTargetConfig::MaxInvestigatingTimeAfterLightBulbExplode' has a wrong offset!");

// ScriptStruct OPP.AIGroundAndPoundConfig
// 0x0060 (0x0060 - 0x0000)
struct FAIGroundAndPoundConfig final
{
public:
	bool                                          bCanGroundAndPound;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bCanGroundAndPound : 1;                  // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAmbushChasedPlayers;                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAmbushChasedPlayers : 1;                // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAmbushJumpingPlayers;                             // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAmbushJumpingPlayers : 1;               // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamagePerPunch;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DamagePerPunch : 1;                      // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetTotalDamage;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TargetTotalDamage : 1;                   // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDamage;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumDamage : 1;                       // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNonFatalDamage;                                   // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bNonFatalDamage : 1;                     // 0x001E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinReenterInterval;                                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinReenterInterval : 1;                  // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRetryInterval;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinRetryInterval : 1;                    // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnterProbability;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_EnterProbability : 1;                    // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistForTryTackle;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistForTryTackle : 1;                 // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngleForTryTackle;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAngleForTryTackle : 1;                // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistForTackleSuccess;                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxDistForTackleSuccess : 1;             // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngleForTackleSuccess;                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MaxAngleForTackleSuccess : 1;            // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumProximityToPushableForAmbush;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinimumProximityToPushableForAmbush : 1; // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGroundAndPoundConfig) == 0x000004, "Wrong alignment on FAIGroundAndPoundConfig");
static_assert(sizeof(FAIGroundAndPoundConfig) == 0x000060, "Wrong size on FAIGroundAndPoundConfig");
static_assert(offsetof(FAIGroundAndPoundConfig, bCanGroundAndPound) == 0x000000, "Member 'FAIGroundAndPoundConfig::bCanGroundAndPound' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, bAmbushChasedPlayers) == 0x000002, "Member 'FAIGroundAndPoundConfig::bAmbushChasedPlayers' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, bAmbushJumpingPlayers) == 0x000004, "Member 'FAIGroundAndPoundConfig::bAmbushJumpingPlayers' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, DamagePerPunch) == 0x000008, "Member 'FAIGroundAndPoundConfig::DamagePerPunch' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, TargetTotalDamage) == 0x000010, "Member 'FAIGroundAndPoundConfig::TargetTotalDamage' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MinimumDamage) == 0x000018, "Member 'FAIGroundAndPoundConfig::MinimumDamage' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, bNonFatalDamage) == 0x00001D, "Member 'FAIGroundAndPoundConfig::bNonFatalDamage' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MinReenterInterval) == 0x000020, "Member 'FAIGroundAndPoundConfig::MinReenterInterval' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MinRetryInterval) == 0x000028, "Member 'FAIGroundAndPoundConfig::MinRetryInterval' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, EnterProbability) == 0x000030, "Member 'FAIGroundAndPoundConfig::EnterProbability' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MaxDistForTryTackle) == 0x000038, "Member 'FAIGroundAndPoundConfig::MaxDistForTryTackle' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MaxAngleForTryTackle) == 0x000040, "Member 'FAIGroundAndPoundConfig::MaxAngleForTryTackle' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MaxDistForTackleSuccess) == 0x000048, "Member 'FAIGroundAndPoundConfig::MaxDistForTackleSuccess' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MaxAngleForTackleSuccess) == 0x000050, "Member 'FAIGroundAndPoundConfig::MaxAngleForTackleSuccess' has a wrong offset!");
static_assert(offsetof(FAIGroundAndPoundConfig, MinimumProximityToPushableForAmbush) == 0x000058, "Member 'FAIGroundAndPoundConfig::MinimumProximityToPushableForAmbush' has a wrong offset!");

// ScriptStruct OPP.AIActiveSkillsConfig
// 0x0010 (0x0010 - 0x0000)
struct FAIActiveSkillsConfig final
{
public:
	float                                         BerserkChaseSpeed;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BerserkChaseSpeed : 1;                   // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BerserkRandomMovementSpeed;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BerserkRandomMovementSpeed : 1;          // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIActiveSkillsConfig) == 0x000004, "Wrong alignment on FAIActiveSkillsConfig");
static_assert(sizeof(FAIActiveSkillsConfig) == 0x000010, "Wrong size on FAIActiveSkillsConfig");
static_assert(offsetof(FAIActiveSkillsConfig, BerserkChaseSpeed) == 0x000000, "Member 'FAIActiveSkillsConfig::BerserkChaseSpeed' has a wrong offset!");
static_assert(offsetof(FAIActiveSkillsConfig, BerserkRandomMovementSpeed) == 0x000008, "Member 'FAIActiveSkillsConfig::BerserkRandomMovementSpeed' has a wrong offset!");

// ScriptStruct OPP.AIAnimConfig
// 0x0030 (0x0030 - 0x0000)
struct FAIAnimConfig final
{
public:
	bool                                          bForceAnimStyle;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bForceAnimStyle : 1;                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENPCAnimStyle                                 ForcedAnimStyle;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ForcedAnimStyle : 1;                     // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         StepHeaviness;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_StepHeaviness : 1;                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyEffectIntensity;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BodyEffectIntensity : 1;                 // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bBreathing;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bBreathing : 1;                          // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableChaseBreakers;                              // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableChaseBreakers : 1;                // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChaseBreakerAverageDelay;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ChaseBreakerAverageDelay : 1;            // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bEnableCycleBreakers;                              // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bEnableCycleBreakers : 1;                // 0x001E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CycleBreakerMinInterval;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CycleBreakerMinInterval : 1;             // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CycleBreakerMaxInterval;                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_CycleBreakerMaxInterval : 1;             // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAnimConfig) == 0x000004, "Wrong alignment on FAIAnimConfig");
static_assert(sizeof(FAIAnimConfig) == 0x000030, "Wrong size on FAIAnimConfig");
static_assert(offsetof(FAIAnimConfig, bForceAnimStyle) == 0x000000, "Member 'FAIAnimConfig::bForceAnimStyle' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, ForcedAnimStyle) == 0x000002, "Member 'FAIAnimConfig::ForcedAnimStyle' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, StepHeaviness) == 0x000004, "Member 'FAIAnimConfig::StepHeaviness' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, BodyEffectIntensity) == 0x00000C, "Member 'FAIAnimConfig::BodyEffectIntensity' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, bBreathing) == 0x000011, "Member 'FAIAnimConfig::bBreathing' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, bEnableChaseBreakers) == 0x000013, "Member 'FAIAnimConfig::bEnableChaseBreakers' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, ChaseBreakerAverageDelay) == 0x000018, "Member 'FAIAnimConfig::ChaseBreakerAverageDelay' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, bEnableCycleBreakers) == 0x00001D, "Member 'FAIAnimConfig::bEnableCycleBreakers' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, CycleBreakerMinInterval) == 0x000020, "Member 'FAIAnimConfig::CycleBreakerMinInterval' has a wrong offset!");
static_assert(offsetof(FAIAnimConfig, CycleBreakerMaxInterval) == 0x000028, "Member 'FAIAnimConfig::CycleBreakerMaxInterval' has a wrong offset!");

// ScriptStruct OPP.AISpecialConfigData
// 0x0014 (0x0014 - 0x0000)
struct FAISpecialConfigData final
{
public:
	float                                         UnspawnIsolationDistance;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnspawnIsolationDistance : 1;            // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnspawnIsolationTime;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_UnspawnIsolationTime : 1;                // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bDisableAutomaticBehaviors;                        // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDisableAutomaticBehaviors : 1;          // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAlwaysBashDoors;                                  // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAlwaysBashDoors : 1;                    // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISpecialConfigData) == 0x000004, "Wrong alignment on FAISpecialConfigData");
static_assert(sizeof(FAISpecialConfigData) == 0x000014, "Wrong size on FAISpecialConfigData");
static_assert(offsetof(FAISpecialConfigData, UnspawnIsolationDistance) == 0x000000, "Member 'FAISpecialConfigData::UnspawnIsolationDistance' has a wrong offset!");
static_assert(offsetof(FAISpecialConfigData, UnspawnIsolationTime) == 0x000008, "Member 'FAISpecialConfigData::UnspawnIsolationTime' has a wrong offset!");
static_assert(offsetof(FAISpecialConfigData, bDisableAutomaticBehaviors) == 0x00000D, "Member 'FAISpecialConfigData::bDisableAutomaticBehaviors' has a wrong offset!");
static_assert(offsetof(FAISpecialConfigData, bAlwaysBashDoors) == 0x00000F, "Member 'FAISpecialConfigData::bAlwaysBashDoors' has a wrong offset!");

// ScriptStruct OPP.AISystemsConfig
// 0x0014 (0x0014 - 0x0000)
struct FAISystemsConfig final
{
public:
	bool                                          bDisableServerAnimationsAtRange;                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDisableServerAnimationsAtRange : 1;     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableServerAnimationsRange;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DisableServerAnimationsRange : 1;        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bDisableAnimOptims;                                // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bDisableAnimOptims : 1;                  // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathPushDistanceAwayFromSides;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PathPushDistanceAwayFromSides : 1;       // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISystemsConfig) == 0x000004, "Wrong alignment on FAISystemsConfig");
static_assert(sizeof(FAISystemsConfig) == 0x000014, "Wrong size on FAISystemsConfig");
static_assert(offsetof(FAISystemsConfig, bDisableServerAnimationsAtRange) == 0x000000, "Member 'FAISystemsConfig::bDisableServerAnimationsAtRange' has a wrong offset!");
static_assert(offsetof(FAISystemsConfig, DisableServerAnimationsRange) == 0x000004, "Member 'FAISystemsConfig::DisableServerAnimationsRange' has a wrong offset!");
static_assert(offsetof(FAISystemsConfig, bDisableAnimOptims) == 0x000009, "Member 'FAISystemsConfig::bDisableAnimOptims' has a wrong offset!");
static_assert(offsetof(FAISystemsConfig, PathPushDistanceAwayFromSides) == 0x00000C, "Member 'FAISystemsConfig::PathPushDistanceAwayFromSides' has a wrong offset!");

// ScriptStruct OPP.AIUIConfig
// 0x0002 (0x0002 - 0x0000)
struct FAIUIConfig final
{
public:
	bool                                          bAllowPlayerPing;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bAllowPlayerPing : 1;                    // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAIUIConfig) == 0x000001, "Wrong alignment on FAIUIConfig");
static_assert(sizeof(FAIUIConfig) == 0x000002, "Wrong size on FAIUIConfig");
static_assert(offsetof(FAIUIConfig, bAllowPlayerPing) == 0x000000, "Member 'FAIUIConfig::bAllowPlayerPing' has a wrong offset!");

// ScriptStruct OPP.AIIllnessConfig
// 0x0020 (0x0020 - 0x0000)
struct FAIIllnessConfig final
{
public:
	float                                         IllnessInitialDelay;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IllnessInitialDelay : 1;                 // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IllnessMinimumInterval;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IllnessMinimumInterval : 1;              // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IllnessMaximumInterval;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IllnessMaximumInterval : 1;              // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IllnessNumberOfReactions;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_IllnessNumberOfReactions : 1;            // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIIllnessConfig) == 0x000004, "Wrong alignment on FAIIllnessConfig");
static_assert(sizeof(FAIIllnessConfig) == 0x000020, "Wrong size on FAIIllnessConfig");
static_assert(offsetof(FAIIllnessConfig, IllnessInitialDelay) == 0x000000, "Member 'FAIIllnessConfig::IllnessInitialDelay' has a wrong offset!");
static_assert(offsetof(FAIIllnessConfig, IllnessMinimumInterval) == 0x000008, "Member 'FAIIllnessConfig::IllnessMinimumInterval' has a wrong offset!");
static_assert(offsetof(FAIIllnessConfig, IllnessMaximumInterval) == 0x000010, "Member 'FAIIllnessConfig::IllnessMaximumInterval' has a wrong offset!");
static_assert(offsetof(FAIIllnessConfig, IllnessNumberOfReactions) == 0x000018, "Member 'FAIIllnessConfig::IllnessNumberOfReactions' has a wrong offset!");

// ScriptStruct OPP.AIConfigData
// 0x14DC (0x14DC - 0x0000)
struct FAIConfigData final
{
public:
	struct FAIGlobalConfig                        Global;                                            // 0x0000(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIClosetConfig                        Closet;                                            // 0x0060(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAISpeedConfig                         Speed;                                             // 0x0088(0x0140)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAdvancedSpeedConfig                 AdvancedSpeed;                                     // 0x01C8(0x00A0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIHealthConfig                        Health;                                            // 0x0268(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIVisionConfig                        Vision;                                            // 0x028C(0x0188)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIHearingConfig                       Hearing;                                           // 0x0414(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAwarenessConfig                     Awareness;                                         // 0x0430(0x0268)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITargettingConfig                    Targetting;                                        // 0x0698(0x0074)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDisturbanceConfig                     Disturbance;                                       // 0x070C(0x0016)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_722[0x2];                                      // 0x0722(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAttackConfig                        Attack;                                            // 0x0724(0x01F8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIChaseConfig                         Chase;                                             // 0x091C(0x0130)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAICombatConfig                        Combat;                                            // 0x0A4C(0x0006)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A52[0x2];                                      // 0x0A52(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIInvestigationConfig                 Investigation;                                     // 0x0A54(0x0308)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPatrolConfig                        Patrol;                                            // 0x0D5C(0x00B8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDynamicLookConfig                   DynamicLook;                                       // 0x0E14(0x0174)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIIdleFocusConfig                     IdleFocus;                                         // 0x0F88(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAmbientConfig                       Ambient;                                           // 0x0FF0(0x0074)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPlayerAvoidanceConfig               PlayerAvoidance;                                   // 0x1064(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRetirementConfig                    Retirement;                                        // 0x10B4(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIVOConfig                            VO;                                                // 0x10D4(0x0070)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAudioConfig                         Audio;                                             // 0x1144(0x007C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRepulsionParameters                 Repulsion;                                         // 0x11C0(0x0054)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAILeashParameters                     Leash;                                             // 0x1214(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAISabotageConfig                      Sabotage;                                          // 0x1254(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPitcherConfig                       Pitcher;                                           // 0x1278(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPusherConfig                        Pusher;                                            // 0x12C0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAISleeperScreamerConfig               SleeperScreamer;                                   // 0x12E8(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIPouncerConfig                       Pouncer;                                           // 0x1328(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAINightHunterConfig                   NightHunter;                                       // 0x1354(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIBerserkerConfig                     Berserker;                                         // 0x137C(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStalkerTargetConfig                 StalkerTarget;                                     // 0x13BC(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIGroundAndPoundConfig                GroundAndPound;                                    // 0x13DC(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIActiveSkillsConfig                  ActiveSkills;                                      // 0x143C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAnimConfig                          Animation;                                         // 0x144C(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAISpecialConfigData                   Special;                                           // 0x147C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAISystemsConfig                       Systems;                                           // 0x1490(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIUIConfig                            UI;                                                // 0x14A4(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A6[0x2];                                     // 0x14A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerProximityConfig                 PlayerProximity;                                   // 0x14A8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIIllnessConfig                       Illness;                                           // 0x14BC(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIConfigData) == 0x000004, "Wrong alignment on FAIConfigData");
static_assert(sizeof(FAIConfigData) == 0x0014DC, "Wrong size on FAIConfigData");
static_assert(offsetof(FAIConfigData, Global) == 0x000000, "Member 'FAIConfigData::Global' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Closet) == 0x000060, "Member 'FAIConfigData::Closet' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Speed) == 0x000088, "Member 'FAIConfigData::Speed' has a wrong offset!");
static_assert(offsetof(FAIConfigData, AdvancedSpeed) == 0x0001C8, "Member 'FAIConfigData::AdvancedSpeed' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Health) == 0x000268, "Member 'FAIConfigData::Health' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Vision) == 0x00028C, "Member 'FAIConfigData::Vision' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Hearing) == 0x000414, "Member 'FAIConfigData::Hearing' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Awareness) == 0x000430, "Member 'FAIConfigData::Awareness' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Targetting) == 0x000698, "Member 'FAIConfigData::Targetting' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Disturbance) == 0x00070C, "Member 'FAIConfigData::Disturbance' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Attack) == 0x000724, "Member 'FAIConfigData::Attack' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Chase) == 0x00091C, "Member 'FAIConfigData::Chase' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Combat) == 0x000A4C, "Member 'FAIConfigData::Combat' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Investigation) == 0x000A54, "Member 'FAIConfigData::Investigation' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Patrol) == 0x000D5C, "Member 'FAIConfigData::Patrol' has a wrong offset!");
static_assert(offsetof(FAIConfigData, DynamicLook) == 0x000E14, "Member 'FAIConfigData::DynamicLook' has a wrong offset!");
static_assert(offsetof(FAIConfigData, IdleFocus) == 0x000F88, "Member 'FAIConfigData::IdleFocus' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Ambient) == 0x000FF0, "Member 'FAIConfigData::Ambient' has a wrong offset!");
static_assert(offsetof(FAIConfigData, PlayerAvoidance) == 0x001064, "Member 'FAIConfigData::PlayerAvoidance' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Retirement) == 0x0010B4, "Member 'FAIConfigData::Retirement' has a wrong offset!");
static_assert(offsetof(FAIConfigData, VO) == 0x0010D4, "Member 'FAIConfigData::VO' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Audio) == 0x001144, "Member 'FAIConfigData::Audio' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Repulsion) == 0x0011C0, "Member 'FAIConfigData::Repulsion' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Leash) == 0x001214, "Member 'FAIConfigData::Leash' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Sabotage) == 0x001254, "Member 'FAIConfigData::Sabotage' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Pitcher) == 0x001278, "Member 'FAIConfigData::Pitcher' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Pusher) == 0x0012C0, "Member 'FAIConfigData::Pusher' has a wrong offset!");
static_assert(offsetof(FAIConfigData, SleeperScreamer) == 0x0012E8, "Member 'FAIConfigData::SleeperScreamer' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Pouncer) == 0x001328, "Member 'FAIConfigData::Pouncer' has a wrong offset!");
static_assert(offsetof(FAIConfigData, NightHunter) == 0x001354, "Member 'FAIConfigData::NightHunter' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Berserker) == 0x00137C, "Member 'FAIConfigData::Berserker' has a wrong offset!");
static_assert(offsetof(FAIConfigData, StalkerTarget) == 0x0013BC, "Member 'FAIConfigData::StalkerTarget' has a wrong offset!");
static_assert(offsetof(FAIConfigData, GroundAndPound) == 0x0013DC, "Member 'FAIConfigData::GroundAndPound' has a wrong offset!");
static_assert(offsetof(FAIConfigData, ActiveSkills) == 0x00143C, "Member 'FAIConfigData::ActiveSkills' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Animation) == 0x00144C, "Member 'FAIConfigData::Animation' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Special) == 0x00147C, "Member 'FAIConfigData::Special' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Systems) == 0x001490, "Member 'FAIConfigData::Systems' has a wrong offset!");
static_assert(offsetof(FAIConfigData, UI) == 0x0014A4, "Member 'FAIConfigData::UI' has a wrong offset!");
static_assert(offsetof(FAIConfigData, PlayerProximity) == 0x0014A8, "Member 'FAIConfigData::PlayerProximity' has a wrong offset!");
static_assert(offsetof(FAIConfigData, Illness) == 0x0014BC, "Member 'FAIConfigData::Illness' has a wrong offset!");

// ScriptStruct OPP.MissionDoorReplacementData
// 0x0038 (0x0038 - 0x0000)
struct FMissionDoorReplacementData final
{
public:
	bool                                          bRandomDirection;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseDirection;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveDoorFrame;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseLockPosition;                              // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ARBDoor>                 DoorToReplace;                                     // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DoorReplaceClass;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionDoorReplacementData) == 0x000008, "Wrong alignment on FMissionDoorReplacementData");
static_assert(sizeof(FMissionDoorReplacementData) == 0x000038, "Wrong size on FMissionDoorReplacementData");
static_assert(offsetof(FMissionDoorReplacementData, bRandomDirection) == 0x000000, "Member 'FMissionDoorReplacementData::bRandomDirection' has a wrong offset!");
static_assert(offsetof(FMissionDoorReplacementData, bInverseDirection) == 0x000001, "Member 'FMissionDoorReplacementData::bInverseDirection' has a wrong offset!");
static_assert(offsetof(FMissionDoorReplacementData, bRemoveDoorFrame) == 0x000002, "Member 'FMissionDoorReplacementData::bRemoveDoorFrame' has a wrong offset!");
static_assert(offsetof(FMissionDoorReplacementData, bInverseLockPosition) == 0x000003, "Member 'FMissionDoorReplacementData::bInverseLockPosition' has a wrong offset!");
static_assert(offsetof(FMissionDoorReplacementData, DoorToReplace) == 0x000008, "Member 'FMissionDoorReplacementData::DoorToReplace' has a wrong offset!");
static_assert(offsetof(FMissionDoorReplacementData, DoorReplaceClass) == 0x000030, "Member 'FMissionDoorReplacementData::DoorReplaceClass' has a wrong offset!");

// ScriptStruct OPP.MovieSubtitlePart
// 0x0018 (0x0018 - 0x0000)
struct FMovieSubtitlePart final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextId;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSubtitlePart) == 0x000008, "Wrong alignment on FMovieSubtitlePart");
static_assert(sizeof(FMovieSubtitlePart) == 0x000018, "Wrong size on FMovieSubtitlePart");
static_assert(offsetof(FMovieSubtitlePart, StartTime) == 0x000000, "Member 'FMovieSubtitlePart::StartTime' has a wrong offset!");
static_assert(offsetof(FMovieSubtitlePart, EndTime) == 0x000004, "Member 'FMovieSubtitlePart::EndTime' has a wrong offset!");
static_assert(offsetof(FMovieSubtitlePart, TextId) == 0x000008, "Member 'FMovieSubtitlePart::TextId' has a wrong offset!");

// ScriptStruct OPP.JumpScareDetectionEntry
// 0x0010 (0x0010 - 0x0000)
struct FJumpScareDetectionEntry final
{
public:
	class AActor*                                 DetectedActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionTimestamp;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpScareDetectionEntry) == 0x000008, "Wrong alignment on FJumpScareDetectionEntry");
static_assert(sizeof(FJumpScareDetectionEntry) == 0x000010, "Wrong size on FJumpScareDetectionEntry");
static_assert(offsetof(FJumpScareDetectionEntry, DetectedActor) == 0x000000, "Member 'FJumpScareDetectionEntry::DetectedActor' has a wrong offset!");
static_assert(offsetof(FJumpScareDetectionEntry, DetectionTimestamp) == 0x000008, "Member 'FJumpScareDetectionEntry::DetectionTimestamp' has a wrong offset!");

// ScriptStruct OPP.NetworkSoundActorRTPCData
// 0x000C (0x000C - 0x0000)
struct FNetworkSoundActorRTPCData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkSoundActorRTPCData) == 0x000004, "Wrong alignment on FNetworkSoundActorRTPCData");
static_assert(sizeof(FNetworkSoundActorRTPCData) == 0x00000C, "Wrong size on FNetworkSoundActorRTPCData");
static_assert(offsetof(FNetworkSoundActorRTPCData, Name) == 0x000000, "Member 'FNetworkSoundActorRTPCData::Name' has a wrong offset!");
static_assert(offsetof(FNetworkSoundActorRTPCData, Value) == 0x000008, "Member 'FNetworkSoundActorRTPCData::Value' has a wrong offset!");

// ScriptStruct OPP.AIAmbushVisibilityData
// 0x0010 (0x0010 - 0x0000)
struct FAIAmbushVisibilityData final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAmbushVisibilityData) == 0x000008, "Wrong alignment on FAIAmbushVisibilityData");
static_assert(sizeof(FAIAmbushVisibilityData) == 0x000010, "Wrong size on FAIAmbushVisibilityData");
static_assert(offsetof(FAIAmbushVisibilityData, Player) == 0x000000, "Member 'FAIAmbushVisibilityData::Player' has a wrong offset!");

// ScriptStruct OPP.AIAmbushData
// 0x0048 (0x0048 - 0x0000)
struct FAIAmbushData final
{
public:
	class URBHidespotComponent*                   Hidespot;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AmbushIdle;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIAmbushVisibilityData>        PlayerVisibilityCheckList;                         // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x28];                                      // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAmbushData) == 0x000008, "Wrong alignment on FAIAmbushData");
static_assert(sizeof(FAIAmbushData) == 0x000048, "Wrong size on FAIAmbushData");
static_assert(offsetof(FAIAmbushData, Hidespot) == 0x000000, "Member 'FAIAmbushData::Hidespot' has a wrong offset!");
static_assert(offsetof(FAIAmbushData, AmbushIdle) == 0x000008, "Member 'FAIAmbushData::AmbushIdle' has a wrong offset!");
static_assert(offsetof(FAIAmbushData, PlayerVisibilityCheckList) == 0x000010, "Member 'FAIAmbushData::PlayerVisibilityCheckList' has a wrong offset!");

// ScriptStruct OPP.AIAmbientData
// 0x0038 (0x0038 - 0x0000)
struct FAIAmbientData final
{
public:
	class URBAmbientStationComponent*             CurrentAmbientStation;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientStartedTime;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStayDuration;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAmbientData) == 0x000008, "Wrong alignment on FAIAmbientData");
static_assert(sizeof(FAIAmbientData) == 0x000038, "Wrong size on FAIAmbientData");
static_assert(offsetof(FAIAmbientData, CurrentAmbientStation) == 0x000000, "Member 'FAIAmbientData::CurrentAmbientStation' has a wrong offset!");
static_assert(offsetof(FAIAmbientData, AmbientStartedTime) == 0x000008, "Member 'FAIAmbientData::AmbientStartedTime' has a wrong offset!");
static_assert(offsetof(FAIAmbientData, MaxStayDuration) == 0x00000C, "Member 'FAIAmbientData::MaxStayDuration' has a wrong offset!");

// ScriptStruct OPP.AIScriptedData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FAIScriptedData final
{
public:
	EAIScriptedState                              ScriptedState;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1F];                                       // 0x0001(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIScriptedData) == 0x000004, "Wrong alignment on FAIScriptedData");
static_assert(sizeof(FAIScriptedData) == 0x000020, "Wrong size on FAIScriptedData");
static_assert(offsetof(FAIScriptedData, ScriptedState) == 0x000000, "Member 'FAIScriptedData::ScriptedState' has a wrong offset!");

// ScriptStruct OPP.AIScriptedConfig
// 0x0080 (0x0080 - 0x0000)
struct FAIScriptedConfig final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBAIConditionSet                      ExitConditions;                                    // 0x0018(0x0010)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ExitAnim;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SingleShotAnim;                                    // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBScriptedAnimStation*                 ScriptedAnimStation;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIScriptedConfig) == 0x000008, "Wrong alignment on FAIScriptedConfig");
static_assert(sizeof(FAIScriptedConfig) == 0x000080, "Wrong size on FAIScriptedConfig");
static_assert(offsetof(FAIScriptedConfig, ExitConditions) == 0x000018, "Member 'FAIScriptedConfig::ExitConditions' has a wrong offset!");
static_assert(offsetof(FAIScriptedConfig, IdleAnim) == 0x000028, "Member 'FAIScriptedConfig::IdleAnim' has a wrong offset!");
static_assert(offsetof(FAIScriptedConfig, ExitAnim) == 0x000030, "Member 'FAIScriptedConfig::ExitAnim' has a wrong offset!");
static_assert(offsetof(FAIScriptedConfig, SingleShotAnim) == 0x000048, "Member 'FAIScriptedConfig::SingleShotAnim' has a wrong offset!");
static_assert(offsetof(FAIScriptedConfig, ScriptedAnimStation) == 0x000050, "Member 'FAIScriptedConfig::ScriptedAnimStation' has a wrong offset!");
static_assert(offsetof(FAIScriptedConfig, TargetActor) == 0x000068, "Member 'FAIScriptedConfig::TargetActor' has a wrong offset!");

// ScriptStruct OPP.InvestigationDebugData
// 0x0038 (0x0038 - 0x0000)
struct FInvestigationDebugData final
{
public:
	uint8                                         NbPointsToCheck;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NbPointsChecked;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NumInvestigationPoints;                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              TargetPlayer;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicLookActive;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicLookExplicit;                              // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigatingDisturbance;                         // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAtInvestigationPoint;                             // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigatingSource;                              // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URBNPCInterestPointComponent*           CurrentInterestPointComp;                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExplicitInterestLocation;                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestLookDuration;                              // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumInterestPoints;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvestigationDebugData) == 0x000008, "Wrong alignment on FInvestigationDebugData");
static_assert(sizeof(FInvestigationDebugData) == 0x000038, "Wrong size on FInvestigationDebugData");
static_assert(offsetof(FInvestigationDebugData, NbPointsToCheck) == 0x000000, "Member 'FInvestigationDebugData::NbPointsToCheck' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, NbPointsChecked) == 0x000001, "Member 'FInvestigationDebugData::NbPointsChecked' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, NumInvestigationPoints) == 0x000002, "Member 'FInvestigationDebugData::NumInvestigationPoints' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, TargetPlayer) == 0x000008, "Member 'FInvestigationDebugData::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, bDynamicLookActive) == 0x000010, "Member 'FInvestigationDebugData::bDynamicLookActive' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, bDynamicLookExplicit) == 0x000011, "Member 'FInvestigationDebugData::bDynamicLookExplicit' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, bInvestigatingDisturbance) == 0x000012, "Member 'FInvestigationDebugData::bInvestigatingDisturbance' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, bAtInvestigationPoint) == 0x000013, "Member 'FInvestigationDebugData::bAtInvestigationPoint' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, bInvestigatingSource) == 0x000014, "Member 'FInvestigationDebugData::bInvestigatingSource' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, CurrentInterestPointComp) == 0x000018, "Member 'FInvestigationDebugData::CurrentInterestPointComp' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, ExplicitInterestLocation) == 0x000020, "Member 'FInvestigationDebugData::ExplicitInterestLocation' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, InterestLookDuration) == 0x00002C, "Member 'FInvestigationDebugData::InterestLookDuration' has a wrong offset!");
static_assert(offsetof(FInvestigationDebugData, NumInterestPoints) == 0x000030, "Member 'FInvestigationDebugData::NumInterestPoints' has a wrong offset!");

// ScriptStruct OPP.PatrolDebugData
// 0x0020 (0x0020 - 0x0000)
struct FPatrolDebugData final
{
public:
	bool                                          bAtWaypoint;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatrolType                                   Type;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatrolWaypointSelectionMode                  Mode;                                              // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NumWaypoints;                                      // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBWaypoint*                            DestinationWaypoint;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationPoint;                                  // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatrolDebugData) == 0x000008, "Wrong alignment on FPatrolDebugData");
static_assert(sizeof(FPatrolDebugData) == 0x000020, "Wrong size on FPatrolDebugData");
static_assert(offsetof(FPatrolDebugData, bAtWaypoint) == 0x000000, "Member 'FPatrolDebugData::bAtWaypoint' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, Type) == 0x000001, "Member 'FPatrolDebugData::Type' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, Mode) == 0x000002, "Member 'FPatrolDebugData::Mode' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, bForced) == 0x000003, "Member 'FPatrolDebugData::bForced' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, NumWaypoints) == 0x000004, "Member 'FPatrolDebugData::NumWaypoints' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, DestinationWaypoint) == 0x000008, "Member 'FPatrolDebugData::DestinationWaypoint' has a wrong offset!");
static_assert(offsetof(FPatrolDebugData, DestinationPoint) == 0x000010, "Member 'FPatrolDebugData::DestinationPoint' has a wrong offset!");

// ScriptStruct OPP.AIEventLogItem
// 0x0020 (0x0020 - 0x0000)
struct FAIEventLogItem final
{
public:
	EAILogVerbosity                               Verbosity;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogLine;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepeatCount;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIEventLogItem) == 0x000008, "Wrong alignment on FAIEventLogItem");
static_assert(sizeof(FAIEventLogItem) == 0x000020, "Wrong size on FAIEventLogItem");
static_assert(offsetof(FAIEventLogItem, Verbosity) == 0x000000, "Member 'FAIEventLogItem::Verbosity' has a wrong offset!");
static_assert(offsetof(FAIEventLogItem, LogLine) == 0x000008, "Member 'FAIEventLogItem::LogLine' has a wrong offset!");
static_assert(offsetof(FAIEventLogItem, Time) == 0x000018, "Member 'FAIEventLogItem::Time' has a wrong offset!");
static_assert(offsetof(FAIEventLogItem, RepeatCount) == 0x00001C, "Member 'FAIEventLogItem::RepeatCount' has a wrong offset!");

// ScriptStruct OPP.AILookAtDebugData
// 0x0020 (0x0020 - 0x0000)
struct FAILookAtDebugData final
{
public:
	bool                                          bLookAtEnabled;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtValidState;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LookAtTarget;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtPosition;                                    // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILookAtDebugData) == 0x000008, "Wrong alignment on FAILookAtDebugData");
static_assert(sizeof(FAILookAtDebugData) == 0x000020, "Wrong size on FAILookAtDebugData");
static_assert(offsetof(FAILookAtDebugData, bLookAtEnabled) == 0x000000, "Member 'FAILookAtDebugData::bLookAtEnabled' has a wrong offset!");
static_assert(offsetof(FAILookAtDebugData, bLookAtValidState) == 0x000001, "Member 'FAILookAtDebugData::bLookAtValidState' has a wrong offset!");
static_assert(offsetof(FAILookAtDebugData, LookAtTarget) == 0x000008, "Member 'FAILookAtDebugData::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FAILookAtDebugData, LookAtPosition) == 0x000010, "Member 'FAILookAtDebugData::LookAtPosition' has a wrong offset!");

// ScriptStruct OPP.AIAimingDebugData
// 0x0010 (0x0010 - 0x0000)
struct FAIAimingDebugData final
{
public:
	bool                                          bAimingEnabled;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetedPosition;                                  // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAimingDebugData) == 0x000004, "Wrong alignment on FAIAimingDebugData");
static_assert(sizeof(FAIAimingDebugData) == 0x000010, "Wrong size on FAIAimingDebugData");
static_assert(offsetof(FAIAimingDebugData, bAimingEnabled) == 0x000000, "Member 'FAIAimingDebugData::bAimingEnabled' has a wrong offset!");
static_assert(offsetof(FAIAimingDebugData, TargetedPosition) == 0x000004, "Member 'FAIAimingDebugData::TargetedPosition' has a wrong offset!");

// ScriptStruct OPP.BotDebugInfo
// 0x0358 (0x0358 - 0x0000)
struct FBotDebugInfo final
{
public:
	class ARBNPC*                                 NPC;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharLocation;                                      // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckStuckTimer;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            ConfigAsset;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBPartialAIConfig*>             PartialConfigs;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EAIDebugConfigFlags                           ConfigFlags;                                       // 0x0030(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDebugErrorFlags                            ErrorFlags;                                        // 0x0032(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAISpawnSource                                SpawnSource;                                       // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnedTime;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActivity                                   Activity;                                          // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AIActivityDebugString;                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveStatus                                   MoveStatus;                                        // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveDest;                                          // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDestBuffer;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaused;                                         // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationMode                                 RotationMode;                                      // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAmbientData                         Ambient;                                           // 0x0068(0x0038)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIScriptedData                        Scripted;                                          // 0x00A0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIScriptedConfig                      ScriptedConfig;                                    // 0x00C0(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAmbushData                          Ambush;                                            // 0x0140(0x0048)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FInvestigationDebugData                Investigation;                                     // 0x0188(0x0038)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FPatrolDebugData                       Patrol;                                            // 0x01C0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAIPerPlayerDebugData>          PlayerData;                                        // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAIVisionDebugData                     VisionData;                                        // 0x01F0(0x00D0)(NoDestructor, NativeAccessSpecifierPublic)
	EAIAwarenessStateType                         AwarenessStateType;                                // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AwarenessStateDebugString;                         // 0x02C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLeash;                                         // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConsideredOutsideLeashStartTime;                   // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsideredOutsideLeash;                           // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInOpenedSection;                                // 0x02E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x2];                                      // 0x02E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stamina;                                           // 0x02E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExausted;                                       // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIEventLogItem>                RecentEvents;                                      // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsSeekingRetirement;                              // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAILookAtDebugData                     LookAtData;                                        // 0x0308(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAimingDebugData                     AimingData;                                        // 0x0328(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                VisionBoneLoc;                                     // 0x0338(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               VisionBoneRot;                                     // 0x0344(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastUpdatedTime;                                   // 0x0350(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotDebugInfo) == 0x000008, "Wrong alignment on FBotDebugInfo");
static_assert(sizeof(FBotDebugInfo) == 0x000358, "Wrong size on FBotDebugInfo");
static_assert(offsetof(FBotDebugInfo, NPC) == 0x000000, "Member 'FBotDebugInfo::NPC' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, CharLocation) == 0x000008, "Member 'FBotDebugInfo::CharLocation' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, CheckStuckTimer) == 0x000014, "Member 'FBotDebugInfo::CheckStuckTimer' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, ConfigAsset) == 0x000018, "Member 'FBotDebugInfo::ConfigAsset' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, PartialConfigs) == 0x000020, "Member 'FBotDebugInfo::PartialConfigs' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, ConfigFlags) == 0x000030, "Member 'FBotDebugInfo::ConfigFlags' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, ErrorFlags) == 0x000032, "Member 'FBotDebugInfo::ErrorFlags' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, SpawnSource) == 0x000034, "Member 'FBotDebugInfo::SpawnSource' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, SpawnedTime) == 0x000038, "Member 'FBotDebugInfo::SpawnedTime' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Activity) == 0x00003C, "Member 'FBotDebugInfo::Activity' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, AIActivityDebugString) == 0x000040, "Member 'FBotDebugInfo::AIActivityDebugString' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, MoveStatus) == 0x000050, "Member 'FBotDebugInfo::MoveStatus' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, MoveDest) == 0x000054, "Member 'FBotDebugInfo::MoveDest' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, MoveDestBuffer) == 0x000060, "Member 'FBotDebugInfo::MoveDestBuffer' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bIsPaused) == 0x000064, "Member 'FBotDebugInfo::bIsPaused' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, RotationMode) == 0x000065, "Member 'FBotDebugInfo::RotationMode' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Ambient) == 0x000068, "Member 'FBotDebugInfo::Ambient' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Scripted) == 0x0000A0, "Member 'FBotDebugInfo::Scripted' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, ScriptedConfig) == 0x0000C0, "Member 'FBotDebugInfo::ScriptedConfig' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Ambush) == 0x000140, "Member 'FBotDebugInfo::Ambush' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Investigation) == 0x000188, "Member 'FBotDebugInfo::Investigation' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Patrol) == 0x0001C0, "Member 'FBotDebugInfo::Patrol' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, PlayerData) == 0x0001E0, "Member 'FBotDebugInfo::PlayerData' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, VisionData) == 0x0001F0, "Member 'FBotDebugInfo::VisionData' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, AwarenessStateType) == 0x0002C0, "Member 'FBotDebugInfo::AwarenessStateType' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, AwarenessStateDebugString) == 0x0002C8, "Member 'FBotDebugInfo::AwarenessStateDebugString' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bHasLeash) == 0x0002D8, "Member 'FBotDebugInfo::bHasLeash' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, ConsideredOutsideLeashStartTime) == 0x0002DC, "Member 'FBotDebugInfo::ConsideredOutsideLeashStartTime' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bConsideredOutsideLeash) == 0x0002E0, "Member 'FBotDebugInfo::bConsideredOutsideLeash' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bIsInOpenedSection) == 0x0002E1, "Member 'FBotDebugInfo::bIsInOpenedSection' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, Stamina) == 0x0002E4, "Member 'FBotDebugInfo::Stamina' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bIsExausted) == 0x0002E8, "Member 'FBotDebugInfo::bIsExausted' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, RecentEvents) == 0x0002F0, "Member 'FBotDebugInfo::RecentEvents' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, bIsSeekingRetirement) == 0x000300, "Member 'FBotDebugInfo::bIsSeekingRetirement' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, LookAtData) == 0x000308, "Member 'FBotDebugInfo::LookAtData' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, AimingData) == 0x000328, "Member 'FBotDebugInfo::AimingData' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, VisionBoneLoc) == 0x000338, "Member 'FBotDebugInfo::VisionBoneLoc' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, VisionBoneRot) == 0x000344, "Member 'FBotDebugInfo::VisionBoneRot' has a wrong offset!");
static_assert(offsetof(FBotDebugInfo, LastUpdatedTime) == 0x000350, "Member 'FBotDebugInfo::LastUpdatedTime' has a wrong offset!");

// ScriptStruct OPP.QueuedLine
// 0x0028 (0x0028 - 0x0000)
struct FQueuedLine final
{
public:
	class AActor*                                 Talker;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueuedLine) == 0x000008, "Wrong alignment on FQueuedLine");
static_assert(sizeof(FQueuedLine) == 0x000028, "Wrong size on FQueuedLine");
static_assert(offsetof(FQueuedLine, Talker) == 0x000000, "Member 'FQueuedLine::Talker' has a wrong offset!");
static_assert(offsetof(FQueuedLine, AkEvent) == 0x000008, "Member 'FQueuedLine::AkEvent' has a wrong offset!");

// ScriptStruct OPP.BotRandomVOConfig
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FBotRandomVOConfig final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotRandomVOConfig) == 0x000004, "Wrong alignment on FBotRandomVOConfig");
static_assert(sizeof(FBotRandomVOConfig) == 0x00000C, "Wrong size on FBotRandomVOConfig");

// ScriptStruct OPP.RewardSwapConfig
// 0x00E0 (0x00E0 - 0x0000)
struct FRewardSwapConfig final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemType>                             SwappableItemTypes;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       Count;                                             // 0x0018(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardSwapConfig) == 0x000008, "Wrong alignment on FRewardSwapConfig");
static_assert(sizeof(FRewardSwapConfig) == 0x0000E0, "Wrong size on FRewardSwapConfig");
static_assert(offsetof(FRewardSwapConfig, ItemType) == 0x000000, "Member 'FRewardSwapConfig::ItemType' has a wrong offset!");
static_assert(offsetof(FRewardSwapConfig, SwappableItemTypes) == 0x000008, "Member 'FRewardSwapConfig::SwappableItemTypes' has a wrong offset!");
static_assert(offsetof(FRewardSwapConfig, Count) == 0x000018, "Member 'FRewardSwapConfig::Count' has a wrong offset!");

// ScriptStruct OPP.RBBattlePassDataRow
// 0x0110 (0x0118 - 0x0008)
struct FRBBattlePassDataRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   HeaderText;                                        // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SeasonText;                                        // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Poster;                                            // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Header;                                            // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PopupBackground;                                   // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainColor;                                         // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderColor;                                       // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockItemId;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 UnlockCurrencyType;                                // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockCurrencyCost;                                // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimeLimited;                                      // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FeatureSwitch;                                     // 0x0108(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBattlePassDataRow) == 0x000008, "Wrong alignment on FRBBattlePassDataRow");
static_assert(sizeof(FRBBattlePassDataRow) == 0x000118, "Wrong size on FRBBattlePassDataRow");
static_assert(offsetof(FRBBattlePassDataRow, ID) == 0x000008, "Member 'FRBBattlePassDataRow::ID' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, Name) == 0x000010, "Member 'FRBBattlePassDataRow::Name' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, HeaderText) == 0x000028, "Member 'FRBBattlePassDataRow::HeaderText' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, SeasonText) == 0x000040, "Member 'FRBBattlePassDataRow::SeasonText' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, Poster) == 0x000058, "Member 'FRBBattlePassDataRow::Poster' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, Header) == 0x000080, "Member 'FRBBattlePassDataRow::Header' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, PopupBackground) == 0x0000A8, "Member 'FRBBattlePassDataRow::PopupBackground' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, MainColor) == 0x0000D0, "Member 'FRBBattlePassDataRow::MainColor' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, HeaderColor) == 0x0000E0, "Member 'FRBBattlePassDataRow::HeaderColor' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, UnlockItemId) == 0x0000F0, "Member 'FRBBattlePassDataRow::UnlockItemId' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, UnlockCurrencyType) == 0x0000F8, "Member 'FRBBattlePassDataRow::UnlockCurrencyType' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, UnlockCurrencyCost) == 0x0000FC, "Member 'FRBBattlePassDataRow::UnlockCurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, bTimeLimited) == 0x000100, "Member 'FRBBattlePassDataRow::bTimeLimited' has a wrong offset!");
static_assert(offsetof(FRBBattlePassDataRow, FeatureSwitch) == 0x000108, "Member 'FRBBattlePassDataRow::FeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.BotDirectorData
// 0x0020 (0x0020 - 0x0000)
struct FBotDirectorData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              InitialTargetPlayer;                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotDirectorData) == 0x000008, "Wrong alignment on FBotDirectorData");
static_assert(sizeof(FBotDirectorData) == 0x000020, "Wrong size on FBotDirectorData");
static_assert(offsetof(FBotDirectorData, InitialTargetPlayer) == 0x000018, "Member 'FBotDirectorData::InitialTargetPlayer' has a wrong offset!");

// ScriptStruct OPP.VOLine
// 0x0018 (0x0018 - 0x0000)
struct FVOLine final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVOLine) == 0x000008, "Wrong alignment on FVOLine");
static_assert(sizeof(FVOLine) == 0x000018, "Wrong size on FVOLine");
static_assert(offsetof(FVOLine, AkEvent) == 0x000000, "Member 'FVOLine::AkEvent' has a wrong offset!");

// ScriptStruct OPP.RandomMovementParams
// 0x0018 (0x0018 - 0x0000)
struct FRandomMovementParams final
{
public:
	float                                         MinStayDuration;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStayDuration;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLocomotionRandomMax;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBRandomPathMarker*                    RandomPath;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomMovementParams) == 0x000008, "Wrong alignment on FRandomMovementParams");
static_assert(sizeof(FRandomMovementParams) == 0x000018, "Wrong size on FRandomMovementParams");
static_assert(offsetof(FRandomMovementParams, MinStayDuration) == 0x000000, "Member 'FRandomMovementParams::MinStayDuration' has a wrong offset!");
static_assert(offsetof(FRandomMovementParams, MaxStayDuration) == 0x000004, "Member 'FRandomMovementParams::MaxStayDuration' has a wrong offset!");
static_assert(offsetof(FRandomMovementParams, StartLocomotionRandomMax) == 0x000008, "Member 'FRandomMovementParams::StartLocomotionRandomMax' has a wrong offset!");
static_assert(offsetof(FRandomMovementParams, RandomPath) == 0x000010, "Member 'FRandomMovementParams::RandomPath' has a wrong offset!");

// ScriptStruct OPP.PeriodicHazardPostProcessSettingData
// 0x0040 (0x0040 - 0x0000)
struct FPeriodicHazardPostProcessSettingData final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URBPostProcessSettings>  PostProcessSettingsRef;                            // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPostProcessSettings*                 LoadedPostProcessSettings;                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPeriodicHazardPostProcessSettingData) == 0x000008, "Wrong alignment on FPeriodicHazardPostProcessSettingData");
static_assert(sizeof(FPeriodicHazardPostProcessSettingData) == 0x000040, "Wrong size on FPeriodicHazardPostProcessSettingData");
static_assert(offsetof(FPeriodicHazardPostProcessSettingData, Priority) == 0x000000, "Member 'FPeriodicHazardPostProcessSettingData::Priority' has a wrong offset!");
static_assert(offsetof(FPeriodicHazardPostProcessSettingData, Name) == 0x000004, "Member 'FPeriodicHazardPostProcessSettingData::Name' has a wrong offset!");
static_assert(offsetof(FPeriodicHazardPostProcessSettingData, PostProcessSettingsRef) == 0x000010, "Member 'FPeriodicHazardPostProcessSettingData::PostProcessSettingsRef' has a wrong offset!");
static_assert(offsetof(FPeriodicHazardPostProcessSettingData, LoadedPostProcessSettings) == 0x000038, "Member 'FPeriodicHazardPostProcessSettingData::LoadedPostProcessSettings' has a wrong offset!");

// ScriptStruct OPP.RBDestructibleAction
// 0x0028 (0x0028 - 0x0000)
struct FRBDestructibleAction final
{
public:
	EDestructibleActionType                       ActionType;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Falloff;                                           // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBDestructibleAction) == 0x000004, "Wrong alignment on FRBDestructibleAction");
static_assert(sizeof(FRBDestructibleAction) == 0x000028, "Wrong size on FRBDestructibleAction");
static_assert(offsetof(FRBDestructibleAction, ActionType) == 0x000000, "Member 'FRBDestructibleAction::ActionType' has a wrong offset!");
static_assert(offsetof(FRBDestructibleAction, Origin) == 0x000004, "Member 'FRBDestructibleAction::Origin' has a wrong offset!");
static_assert(offsetof(FRBDestructibleAction, Direction) == 0x000010, "Member 'FRBDestructibleAction::Direction' has a wrong offset!");
static_assert(offsetof(FRBDestructibleAction, Radius) == 0x00001C, "Member 'FRBDestructibleAction::Radius' has a wrong offset!");
static_assert(offsetof(FRBDestructibleAction, Strength) == 0x000020, "Member 'FRBDestructibleAction::Strength' has a wrong offset!");
static_assert(offsetof(FRBDestructibleAction, Falloff) == 0x000024, "Member 'FRBDestructibleAction::Falloff' has a wrong offset!");

// ScriptStruct OPP.WWWPlayerDebuggingData
// 0x0018 (0x0018 - 0x0000)
struct FWWWPlayerDebuggingData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          MostRelevantAnim;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWPlayerDebuggingData) == 0x000008, "Wrong alignment on FWWWPlayerDebuggingData");
static_assert(sizeof(FWWWPlayerDebuggingData) == 0x000018, "Wrong size on FWWWPlayerDebuggingData");
static_assert(offsetof(FWWWPlayerDebuggingData, MostRelevantAnim) == 0x000008, "Member 'FWWWPlayerDebuggingData::MostRelevantAnim' has a wrong offset!");

// ScriptStruct OPP.WaterValveSectionConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FWaterValveSectionConfig final
{
public:
	class FText                                   SectionObjectiveTextLine;                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SectionPumpObjectiveTextLine;                      // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SectionPipeMaterial;                               // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  Pump;                                              // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          Valves;                                            // 0x0068(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ARBTriggerable>>  WaterTriggerables;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          LinkedActorForMaterials;                           // 0x0088(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          LinkedActorForVisibilityOn;                        // 0x0098(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          LinkedActorForVisibilityOff;                       // 0x00A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterValveSectionConfig) == 0x000008, "Wrong alignment on FWaterValveSectionConfig");
static_assert(sizeof(FWaterValveSectionConfig) == 0x0000B8, "Wrong size on FWaterValveSectionConfig");
static_assert(offsetof(FWaterValveSectionConfig, SectionObjectiveTextLine) == 0x000000, "Member 'FWaterValveSectionConfig::SectionObjectiveTextLine' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, SectionPumpObjectiveTextLine) == 0x000018, "Member 'FWaterValveSectionConfig::SectionPumpObjectiveTextLine' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, SectionName) == 0x000030, "Member 'FWaterValveSectionConfig::SectionName' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, SectionPipeMaterial) == 0x000038, "Member 'FWaterValveSectionConfig::SectionPipeMaterial' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, Pump) == 0x000040, "Member 'FWaterValveSectionConfig::Pump' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, Valves) == 0x000068, "Member 'FWaterValveSectionConfig::Valves' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, WaterTriggerables) == 0x000078, "Member 'FWaterValveSectionConfig::WaterTriggerables' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, LinkedActorForMaterials) == 0x000088, "Member 'FWaterValveSectionConfig::LinkedActorForMaterials' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, LinkedActorForVisibilityOn) == 0x000098, "Member 'FWaterValveSectionConfig::LinkedActorForVisibilityOn' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionConfig, LinkedActorForVisibilityOff) == 0x0000A8, "Member 'FWaterValveSectionConfig::LinkedActorForVisibilityOff' has a wrong offset!");

// ScriptStruct OPP.IntermediateObjectiveData
// 0x0020 (0x0020 - 0x0000)
struct FIntermediateObjectiveData final
{
public:
	class FText                                   ObjectiveText;                                     // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsDone;                                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntermediateObjectiveData) == 0x000008, "Wrong alignment on FIntermediateObjectiveData");
static_assert(sizeof(FIntermediateObjectiveData) == 0x000020, "Wrong size on FIntermediateObjectiveData");
static_assert(offsetof(FIntermediateObjectiveData, ObjectiveText) == 0x000000, "Member 'FIntermediateObjectiveData::ObjectiveText' has a wrong offset!");
static_assert(offsetof(FIntermediateObjectiveData, bIsDone) == 0x000018, "Member 'FIntermediateObjectiveData::bIsDone' has a wrong offset!");

// ScriptStruct OPP.DizzinessMovementConfig
// 0x0018 (0x0018 - 0x0000)
struct FDizzinessMovementConfig final
{
public:
	float                                         MinDelayForAngleChange;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDelayForAngleChange;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleOffset;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinApproachCoeff;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxApproachCoeff;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomMotion;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDizzinessMovementConfig) == 0x000004, "Wrong alignment on FDizzinessMovementConfig");
static_assert(sizeof(FDizzinessMovementConfig) == 0x000018, "Wrong size on FDizzinessMovementConfig");
static_assert(offsetof(FDizzinessMovementConfig, MinDelayForAngleChange) == 0x000000, "Member 'FDizzinessMovementConfig::MinDelayForAngleChange' has a wrong offset!");
static_assert(offsetof(FDizzinessMovementConfig, MaxDelayForAngleChange) == 0x000004, "Member 'FDizzinessMovementConfig::MaxDelayForAngleChange' has a wrong offset!");
static_assert(offsetof(FDizzinessMovementConfig, MaxAngleOffset) == 0x000008, "Member 'FDizzinessMovementConfig::MaxAngleOffset' has a wrong offset!");
static_assert(offsetof(FDizzinessMovementConfig, MinApproachCoeff) == 0x00000C, "Member 'FDizzinessMovementConfig::MinApproachCoeff' has a wrong offset!");
static_assert(offsetof(FDizzinessMovementConfig, MaxApproachCoeff) == 0x000010, "Member 'FDizzinessMovementConfig::MaxApproachCoeff' has a wrong offset!");
static_assert(offsetof(FDizzinessMovementConfig, RandomMotion) == 0x000014, "Member 'FDizzinessMovementConfig::RandomMotion' has a wrong offset!");

// ScriptStruct OPP.ActiveBotDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FActiveBotDebugInfo final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnedStageTime;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActivity                                   Activity;                                          // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeLeftBeforeRetirement;                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveBotDebugInfo) == 0x000008, "Wrong alignment on FActiveBotDebugInfo");
static_assert(sizeof(FActiveBotDebugInfo) == 0x000028, "Wrong size on FActiveBotDebugInfo");
static_assert(offsetof(FActiveBotDebugInfo, NPCType) == 0x000000, "Member 'FActiveBotDebugInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FActiveBotDebugInfo, BotName) == 0x000008, "Member 'FActiveBotDebugInfo::BotName' has a wrong offset!");
static_assert(offsetof(FActiveBotDebugInfo, SpawnedStageTime) == 0x000018, "Member 'FActiveBotDebugInfo::SpawnedStageTime' has a wrong offset!");
static_assert(offsetof(FActiveBotDebugInfo, Activity) == 0x00001C, "Member 'FActiveBotDebugInfo::Activity' has a wrong offset!");
static_assert(offsetof(FActiveBotDebugInfo, MinTimeLeftBeforeRetirement) == 0x000020, "Member 'FActiveBotDebugInfo::MinTimeLeftBeforeRetirement' has a wrong offset!");

// ScriptStruct OPP.FailedBotSummonDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FFailedBotSummonDebugInfo final
{
public:
	float                                         StageTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      NPCType;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RuleName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnavailabilityReason;                              // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFailedBotSummonDebugInfo) == 0x000008, "Wrong alignment on FFailedBotSummonDebugInfo");
static_assert(sizeof(FFailedBotSummonDebugInfo) == 0x000028, "Wrong size on FFailedBotSummonDebugInfo");
static_assert(offsetof(FFailedBotSummonDebugInfo, StageTime) == 0x000000, "Member 'FFailedBotSummonDebugInfo::StageTime' has a wrong offset!");
static_assert(offsetof(FFailedBotSummonDebugInfo, NPCType) == 0x000004, "Member 'FFailedBotSummonDebugInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FFailedBotSummonDebugInfo, RuleName) == 0x000008, "Member 'FFailedBotSummonDebugInfo::RuleName' has a wrong offset!");
static_assert(offsetof(FFailedBotSummonDebugInfo, UnavailabilityReason) == 0x000018, "Member 'FFailedBotSummonDebugInfo::UnavailabilityReason' has a wrong offset!");

// ScriptStruct OPP.AIDirectorDebugInfo
// 0x0060 (0x0060 - 0x0000)
struct FAIDirectorDebugInfo final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URBAIDirectorConfig*                    AIDirectorConfig;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveBotDebugInfo>            ActiveSummonedBots;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         RetiringNPCs;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         RetirementPendingNPCs;                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSummonedBotDebugInfo>          SummonedBotsLog;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFailedBotSummonDebugInfo>      LastFailedSummons;                                 // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDirectorDebugInfo) == 0x000008, "Wrong alignment on FAIDirectorDebugInfo");
static_assert(sizeof(FAIDirectorDebugInfo) == 0x000060, "Wrong size on FAIDirectorDebugInfo");
static_assert(offsetof(FAIDirectorDebugInfo, bEnabled) == 0x000000, "Member 'FAIDirectorDebugInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, AIDirectorConfig) == 0x000008, "Member 'FAIDirectorDebugInfo::AIDirectorConfig' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, ActiveSummonedBots) == 0x000010, "Member 'FAIDirectorDebugInfo::ActiveSummonedBots' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, RetiringNPCs) == 0x000020, "Member 'FAIDirectorDebugInfo::RetiringNPCs' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, RetirementPendingNPCs) == 0x000030, "Member 'FAIDirectorDebugInfo::RetirementPendingNPCs' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, SummonedBotsLog) == 0x000040, "Member 'FAIDirectorDebugInfo::SummonedBotsLog' has a wrong offset!");
static_assert(offsetof(FAIDirectorDebugInfo, LastFailedSummons) == 0x000050, "Member 'FAIDirectorDebugInfo::LastFailedSummons' has a wrong offset!");

// ScriptStruct OPP.AIImperativeActionData
// 0x0030 (0x0030 - 0x0000)
struct FAIImperativeActionData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIImperativeActionData) == 0x000008, "Wrong alignment on FAIImperativeActionData");
static_assert(sizeof(FAIImperativeActionData) == 0x000030, "Wrong size on FAIImperativeActionData");
static_assert(offsetof(FAIImperativeActionData, Actor) == 0x000008, "Member 'FAIImperativeActionData::Actor' has a wrong offset!");

// ScriptStruct OPP.MoveFailedInfo
// 0x0010 (0x0010 - 0x0000)
struct FMoveFailedInfo final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DestActor;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveFailedInfo) == 0x000008, "Wrong alignment on FMoveFailedInfo");
static_assert(sizeof(FMoveFailedInfo) == 0x000010, "Wrong size on FMoveFailedInfo");
static_assert(offsetof(FMoveFailedInfo, Time) == 0x000000, "Member 'FMoveFailedInfo::Time' has a wrong offset!");
static_assert(offsetof(FMoveFailedInfo, DestActor) == 0x000008, "Member 'FMoveFailedInfo::DestActor' has a wrong offset!");

// ScriptStruct OPP.RBAIDirectorSpawningModifier
// 0x0008 (0x0008 - 0x0000)
struct FRBAIDirectorSpawningModifier final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowed;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawningFrequencyMultiplier;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBAIDirectorSpawningModifier) == 0x000004, "Wrong alignment on FRBAIDirectorSpawningModifier");
static_assert(sizeof(FRBAIDirectorSpawningModifier) == 0x000008, "Wrong size on FRBAIDirectorSpawningModifier");
static_assert(offsetof(FRBAIDirectorSpawningModifier, NPCType) == 0x000000, "Member 'FRBAIDirectorSpawningModifier::NPCType' has a wrong offset!");
static_assert(offsetof(FRBAIDirectorSpawningModifier, NPCFlavor) == 0x000001, "Member 'FRBAIDirectorSpawningModifier::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FRBAIDirectorSpawningModifier, bAllowed) == 0x000002, "Member 'FRBAIDirectorSpawningModifier::bAllowed' has a wrong offset!");
static_assert(offsetof(FRBAIDirectorSpawningModifier, SpawningFrequencyMultiplier) == 0x000004, "Member 'FRBAIDirectorSpawningModifier::SpawningFrequencyMultiplier' has a wrong offset!");

// ScriptStruct OPP.RandomSpecialistSpawningData
// 0x0068 (0x0068 - 0x0000)
struct FRandomSpecialistSpawningData final
{
public:
	class URBAIDirectorConfig*                    OwningConfig;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomSpawnNPCInfo>            RandomNPCInfos;                                    // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 UnavailabilityReason;                              // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSpawned;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBBot*>                         CurrentBots;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomSpecialistSpawningData) == 0x000008, "Wrong alignment on FRandomSpecialistSpawningData");
static_assert(sizeof(FRandomSpecialistSpawningData) == 0x000068, "Wrong size on FRandomSpecialistSpawningData");
static_assert(offsetof(FRandomSpecialistSpawningData, OwningConfig) == 0x000000, "Member 'FRandomSpecialistSpawningData::OwningConfig' has a wrong offset!");
static_assert(offsetof(FRandomSpecialistSpawningData, RandomNPCInfos) == 0x000018, "Member 'FRandomSpecialistSpawningData::RandomNPCInfos' has a wrong offset!");
static_assert(offsetof(FRandomSpecialistSpawningData, UnavailabilityReason) == 0x000028, "Member 'FRandomSpecialistSpawningData::UnavailabilityReason' has a wrong offset!");
static_assert(offsetof(FRandomSpecialistSpawningData, NumSpawned) == 0x000050, "Member 'FRandomSpecialistSpawningData::NumSpawned' has a wrong offset!");
static_assert(offsetof(FRandomSpecialistSpawningData, CurrentBots) == 0x000058, "Member 'FRandomSpecialistSpawningData::CurrentBots' has a wrong offset!");

// ScriptStruct OPP.PatrolData
// 0x0050 (0x0050 - 0x0000)
struct FPatrolData final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWaypointSelectionDebugData>    WaypointSelectionData;                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolData) == 0x000008, "Wrong alignment on FPatrolData");
static_assert(sizeof(FPatrolData) == 0x000050, "Wrong size on FPatrolData");
static_assert(offsetof(FPatrolData, WaypointSelectionData) == 0x000040, "Member 'FPatrolData::WaypointSelectionData' has a wrong offset!");

// ScriptStruct OPP.SpecialistSpawnedData
// 0x0018 (0x0018 - 0x0000)
struct FSpecialistSpawnedData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              TargetPlayer;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialistSpawnedData) == 0x000008, "Wrong alignment on FSpecialistSpawnedData");
static_assert(sizeof(FSpecialistSpawnedData) == 0x000018, "Wrong size on FSpecialistSpawnedData");
static_assert(offsetof(FSpecialistSpawnedData, TargetPlayer) == 0x000008, "Member 'FSpecialistSpawnedData::TargetPlayer' has a wrong offset!");

// ScriptStruct OPP.WWWPlaybackStateData
// 0x0020 (0x0020 - 0x0000)
struct FWWWPlaybackStateData final
{
public:
	class UAnimSequence*                          AnimSeq;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWPlaybackStateData) == 0x000008, "Wrong alignment on FWWWPlaybackStateData");
static_assert(sizeof(FWWWPlaybackStateData) == 0x000020, "Wrong size on FWWWPlaybackStateData");
static_assert(offsetof(FWWWPlaybackStateData, AnimSeq) == 0x000000, "Member 'FWWWPlaybackStateData::AnimSeq' has a wrong offset!");

// ScriptStruct OPP.PlayerSummonRequestData
// 0x0030 (0x0030 - 0x0000)
struct FPlayerSummonRequestData final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARBNPC>                     PawnClass;                                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            PawnConfig;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSummonRequestData) == 0x000008, "Wrong alignment on FPlayerSummonRequestData");
static_assert(sizeof(FPlayerSummonRequestData) == 0x000030, "Wrong size on FPlayerSummonRequestData");
static_assert(offsetof(FPlayerSummonRequestData, Player) == 0x000000, "Member 'FPlayerSummonRequestData::Player' has a wrong offset!");
static_assert(offsetof(FPlayerSummonRequestData, TargetActor) == 0x000008, "Member 'FPlayerSummonRequestData::TargetActor' has a wrong offset!");
static_assert(offsetof(FPlayerSummonRequestData, PawnClass) == 0x000020, "Member 'FPlayerSummonRequestData::PawnClass' has a wrong offset!");
static_assert(offsetof(FPlayerSummonRequestData, PawnConfig) == 0x000028, "Member 'FPlayerSummonRequestData::PawnConfig' has a wrong offset!");

// ScriptStruct OPP.PlayerSummonedBotData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerSummonedBotData final
{
public:
	class ARBBot*                                 bot;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSummonedBotData) == 0x000008, "Wrong alignment on FPlayerSummonedBotData");
static_assert(sizeof(FPlayerSummonedBotData) == 0x000010, "Wrong size on FPlayerSummonedBotData");
static_assert(offsetof(FPlayerSummonedBotData, bot) == 0x000000, "Member 'FPlayerSummonedBotData::bot' has a wrong offset!");

// ScriptStruct OPP.BreadcrumbScenario
// 0x0010 (0x0010 - 0x0000)
struct FBreadcrumbScenario final
{
public:
	TArray<TSoftObjectPtr<class ARBTimedBreadcrumb>> BreadcrumbScenario;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBreadcrumbScenario) == 0x000008, "Wrong alignment on FBreadcrumbScenario");
static_assert(sizeof(FBreadcrumbScenario) == 0x000010, "Wrong size on FBreadcrumbScenario");
static_assert(offsetof(FBreadcrumbScenario, BreadcrumbScenario) == 0x000000, "Member 'FBreadcrumbScenario::BreadcrumbScenario' has a wrong offset!");

// ScriptStruct OPP.AIPlayerAvoidanceData
// 0x0058 (0x0058 - 0x0000)
struct FAIPlayerAvoidanceData final
{
public:
	class ARBPlayer*                              PlayerBeingAvoided;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPlayerAvoidanceData) == 0x000008, "Wrong alignment on FAIPlayerAvoidanceData");
static_assert(sizeof(FAIPlayerAvoidanceData) == 0x000058, "Wrong size on FAIPlayerAvoidanceData");
static_assert(offsetof(FAIPlayerAvoidanceData, PlayerBeingAvoided) == 0x000000, "Member 'FAIPlayerAvoidanceData::PlayerBeingAvoided' has a wrong offset!");

// ScriptStruct OPP.InvestigatedDoorData
// 0x0018 (0x0018 - 0x0000)
struct FInvestigatedDoorData final
{
public:
	class ARBDoor*                                Door;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBBot*                                 bot;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvestigatedDoorData) == 0x000008, "Wrong alignment on FInvestigatedDoorData");
static_assert(sizeof(FInvestigatedDoorData) == 0x000018, "Wrong size on FInvestigatedDoorData");
static_assert(offsetof(FInvestigatedDoorData, Door) == 0x000000, "Member 'FInvestigatedDoorData::Door' has a wrong offset!");
static_assert(offsetof(FInvestigatedDoorData, bot) == 0x000008, "Member 'FInvestigatedDoorData::bot' has a wrong offset!");

// ScriptStruct OPP.NavmeshDestination
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FNavmeshDestination final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavmeshDestination) == 0x000004, "Wrong alignment on FNavmeshDestination");
static_assert(sizeof(FNavmeshDestination) == 0x00001C, "Wrong size on FNavmeshDestination");

// ScriptStruct OPP.AIIdleFocusData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAIIdleFocusData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIIdleFocusData) == 0x000004, "Wrong alignment on FAIIdleFocusData");
static_assert(sizeof(FAIIdleFocusData) == 0x00000C, "Wrong size on FAIIdleFocusData");

// ScriptStruct OPP.ActiveDeployableSkillItemData
// 0x0048 (0x0068 - 0x0020)
struct FActiveDeployableSkillItemData final : public FBaseZoneModifierData
{
public:
	struct FRBActiveSkillSettings                 Params;                                            // 0x0020(0x002C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBDeployableSkillItem*                 ChargeActor;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBPawn*>                        AffectedPawns;                                     // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveDeployableSkillItemData) == 0x000008, "Wrong alignment on FActiveDeployableSkillItemData");
static_assert(sizeof(FActiveDeployableSkillItemData) == 0x000068, "Wrong size on FActiveDeployableSkillItemData");
static_assert(offsetof(FActiveDeployableSkillItemData, Params) == 0x000020, "Member 'FActiveDeployableSkillItemData::Params' has a wrong offset!");
static_assert(offsetof(FActiveDeployableSkillItemData, ChargeActor) == 0x000050, "Member 'FActiveDeployableSkillItemData::ChargeActor' has a wrong offset!");
static_assert(offsetof(FActiveDeployableSkillItemData, AffectedPawns) == 0x000058, "Member 'FActiveDeployableSkillItemData::AffectedPawns' has a wrong offset!");

// ScriptStruct OPP.TemporaryAttachmentInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FTemporaryAttachmentInfo final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachedComponent;                                 // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        InitialAttachedComponentParent;                    // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x48];                                      // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTemporaryAttachmentInfo) == 0x000010, "Wrong alignment on FTemporaryAttachmentInfo");
static_assert(sizeof(FTemporaryAttachmentInfo) == 0x000060, "Wrong size on FTemporaryAttachmentInfo");
static_assert(offsetof(FTemporaryAttachmentInfo, Owner) == 0x000000, "Member 'FTemporaryAttachmentInfo::Owner' has a wrong offset!");
static_assert(offsetof(FTemporaryAttachmentInfo, AttachedComponent) == 0x000008, "Member 'FTemporaryAttachmentInfo::AttachedComponent' has a wrong offset!");
static_assert(offsetof(FTemporaryAttachmentInfo, InitialAttachedComponentParent) == 0x000010, "Member 'FTemporaryAttachmentInfo::InitialAttachedComponentParent' has a wrong offset!");

// ScriptStruct OPP.BotCollisionInfo
// 0x0030 (0x0030 - 0x0000)
struct FBotCollisionInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBBot*                                 Collider;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBBot*                                 Collidee;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBBot*                                 ExtraParticipant;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotCollisionInfo) == 0x000008, "Wrong alignment on FBotCollisionInfo");
static_assert(sizeof(FBotCollisionInfo) == 0x000030, "Wrong size on FBotCollisionInfo");
static_assert(offsetof(FBotCollisionInfo, Collider) == 0x000008, "Member 'FBotCollisionInfo::Collider' has a wrong offset!");
static_assert(offsetof(FBotCollisionInfo, Collidee) == 0x000010, "Member 'FBotCollisionInfo::Collidee' has a wrong offset!");
static_assert(offsetof(FBotCollisionInfo, ExtraParticipant) == 0x000018, "Member 'FBotCollisionInfo::ExtraParticipant' has a wrong offset!");

// ScriptStruct OPP.GameplayParams
// 0x0068 (0x0068 - 0x0000)
struct FGameplayParams final
{
public:
	bool                                          bDisableCollisions;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMoveInput;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookInput;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanWalk;                                          // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysEnableRootMotion;                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWalkingZDisplacement;                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableGravity;                                   // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePawnCollisions;                            // 0x0007(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePawnRepulsion;                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionRadius;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionHalfHeight;                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeAttacked;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPeek;                                          // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanLookBack;                                      // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInteractibleCamParams;                         // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftArmFirstPersonRelativeAnimation;              // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightArmFirstPersonRelativeAnimation;             // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStepHeight;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldClearAnyInteraction;                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStaminaRegen;                                // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideEquippedItem;                                 // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EquippedItemHideDelay;                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquippedItemUnhideDelay;                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderInForeground;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNPCWallSeparation;                           // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClothBlendActive;                                 // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraParameters                      CamParams;                                         // 0x0030(0x0034)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayParams) == 0x000004, "Wrong alignment on FGameplayParams");
static_assert(sizeof(FGameplayParams) == 0x000068, "Wrong size on FGameplayParams");
static_assert(offsetof(FGameplayParams, bDisableCollisions) == 0x000000, "Member 'FGameplayParams::bDisableCollisions' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bDisableMoveInput) == 0x000001, "Member 'FGameplayParams::bDisableMoveInput' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bDisableLookInput) == 0x000002, "Member 'FGameplayParams::bDisableLookInput' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bCanWalk) == 0x000003, "Member 'FGameplayParams::bCanWalk' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bAlwaysEnableRootMotion) == 0x000004, "Member 'FGameplayParams::bAlwaysEnableRootMotion' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bEnableWalkingZDisplacement) == 0x000005, "Member 'FGameplayParams::bEnableWalkingZDisplacement' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bDisableGravity) == 0x000006, "Member 'FGameplayParams::bDisableGravity' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bDisablePawnCollisions) == 0x000007, "Member 'FGameplayParams::bDisablePawnCollisions' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bEnablePawnRepulsion) == 0x000008, "Member 'FGameplayParams::bEnablePawnRepulsion' has a wrong offset!");
static_assert(offsetof(FGameplayParams, CollisionRadius) == 0x00000C, "Member 'FGameplayParams::CollisionRadius' has a wrong offset!");
static_assert(offsetof(FGameplayParams, CollisionHalfHeight) == 0x000010, "Member 'FGameplayParams::CollisionHalfHeight' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bCanBeAttacked) == 0x000014, "Member 'FGameplayParams::bCanBeAttacked' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bCanPeek) == 0x000015, "Member 'FGameplayParams::bCanPeek' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bCanLookBack) == 0x000016, "Member 'FGameplayParams::bCanLookBack' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bUseInteractibleCamParams) == 0x000017, "Member 'FGameplayParams::bUseInteractibleCamParams' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bLeftArmFirstPersonRelativeAnimation) == 0x000018, "Member 'FGameplayParams::bLeftArmFirstPersonRelativeAnimation' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bRightArmFirstPersonRelativeAnimation) == 0x000019, "Member 'FGameplayParams::bRightArmFirstPersonRelativeAnimation' has a wrong offset!");
static_assert(offsetof(FGameplayParams, MaxStepHeight) == 0x00001C, "Member 'FGameplayParams::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bShouldClearAnyInteraction) == 0x000020, "Member 'FGameplayParams::bShouldClearAnyInteraction' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bAllowStaminaRegen) == 0x000021, "Member 'FGameplayParams::bAllowStaminaRegen' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bHideEquippedItem) == 0x000022, "Member 'FGameplayParams::bHideEquippedItem' has a wrong offset!");
static_assert(offsetof(FGameplayParams, EquippedItemHideDelay) == 0x000024, "Member 'FGameplayParams::EquippedItemHideDelay' has a wrong offset!");
static_assert(offsetof(FGameplayParams, EquippedItemUnhideDelay) == 0x000028, "Member 'FGameplayParams::EquippedItemUnhideDelay' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bRenderInForeground) == 0x00002C, "Member 'FGameplayParams::bRenderInForeground' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bAllowNPCWallSeparation) == 0x00002D, "Member 'FGameplayParams::bAllowNPCWallSeparation' has a wrong offset!");
static_assert(offsetof(FGameplayParams, bClothBlendActive) == 0x00002E, "Member 'FGameplayParams::bClothBlendActive' has a wrong offset!");
static_assert(offsetof(FGameplayParams, CamParams) == 0x000030, "Member 'FGameplayParams::CamParams' has a wrong offset!");

// ScriptStruct OPP.AILocoModeParameters
// 0x0068 (0x0068 - 0x0000)
struct FAILocoModeParameters final
{
public:
	struct FGameplayParams                        GP;                                                // 0x0000(0x0068)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILocoModeParameters) == 0x000004, "Wrong alignment on FAILocoModeParameters");
static_assert(sizeof(FAILocoModeParameters) == 0x000068, "Wrong size on FAILocoModeParameters");
static_assert(offsetof(FAILocoModeParameters, GP) == 0x000000, "Member 'FAILocoModeParameters::GP' has a wrong offset!");

// ScriptStruct OPP.AIPerPlayerReacheabilityInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FAIPerPlayerReacheabilityInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPerPlayerReacheabilityInfo) == 0x000004, "Wrong alignment on FAIPerPlayerReacheabilityInfo");
static_assert(sizeof(FAIPerPlayerReacheabilityInfo) == 0x000028, "Wrong size on FAIPerPlayerReacheabilityInfo");

// ScriptStruct OPP.AIPlayerPerceptionData
// 0x005C (0x005C - 0x0000)
struct alignas(0x04) FAIPlayerPerceptionData final
{
public:
	uint8                                         Pad_0[0x5C];                                       // 0x0000(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPlayerPerceptionData) == 0x000004, "Wrong alignment on FAIPlayerPerceptionData");
static_assert(sizeof(FAIPlayerPerceptionData) == 0x00005C, "Wrong size on FAIPlayerPerceptionData");

// ScriptStruct OPP.ObjectiveTargetParams
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveTargetParams final
{
public:
	TSubclassOf<class ARBNPC>                     PawnClass;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            ConfigAsset;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveTargetParams) == 0x000008, "Wrong alignment on FObjectiveTargetParams");
static_assert(sizeof(FObjectiveTargetParams) == 0x000010, "Wrong size on FObjectiveTargetParams");
static_assert(offsetof(FObjectiveTargetParams, PawnClass) == 0x000000, "Member 'FObjectiveTargetParams::PawnClass' has a wrong offset!");
static_assert(offsetof(FObjectiveTargetParams, ConfigAsset) == 0x000008, "Member 'FObjectiveTargetParams::ConfigAsset' has a wrong offset!");

// ScriptStruct OPP.ObjectiveTargetsSpawnInfo
// 0x0018 (0x0018 - 0x0000)
struct FObjectiveTargetsSpawnInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObjectiveTargetParams>         TargetsInfo;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveTargetsSpawnInfo) == 0x000008, "Wrong alignment on FObjectiveTargetsSpawnInfo");
static_assert(sizeof(FObjectiveTargetsSpawnInfo) == 0x000018, "Wrong size on FObjectiveTargetsSpawnInfo");
static_assert(offsetof(FObjectiveTargetsSpawnInfo, TargetsInfo) == 0x000008, "Member 'FObjectiveTargetsSpawnInfo::TargetsInfo' has a wrong offset!");

// ScriptStruct OPP.RBTrialConfigDataOverrides
// 0x0040 (0x0040 - 0x0000)
struct FRBTrialConfigDataOverrides final
{
public:
	float                                         RollingGateRandomizationBlockedCountModifier;      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationBlockedCountModifier;             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockableRandomizationBlockedCountModifier;        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationPadLockedCountRatioFromBlockedDoors; // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationReplacedCountModifier;            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationTrappedCountModifier;             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationLockedCountModifier;              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationOpenCountModifier;                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorRandomizationBlockedPathMaxDetourDistanceModifier; // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HidespotRandomizationDisabledRatioModifier;        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapGroupCountModifier;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundTrapCountModifier;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveTrapCountModifier;                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricFloorTrapCountModifier;                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychosisMineTrapCountModifier;                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveWireTrapsCountModifier;                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialConfigDataOverrides) == 0x000004, "Wrong alignment on FRBTrialConfigDataOverrides");
static_assert(sizeof(FRBTrialConfigDataOverrides) == 0x000040, "Wrong size on FRBTrialConfigDataOverrides");
static_assert(offsetof(FRBTrialConfigDataOverrides, RollingGateRandomizationBlockedCountModifier) == 0x000000, "Member 'FRBTrialConfigDataOverrides::RollingGateRandomizationBlockedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationBlockedCountModifier) == 0x000004, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationBlockedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, BlockableRandomizationBlockedCountModifier) == 0x000008, "Member 'FRBTrialConfigDataOverrides::BlockableRandomizationBlockedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationPadLockedCountRatioFromBlockedDoors) == 0x00000C, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationPadLockedCountRatioFromBlockedDoors' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationReplacedCountModifier) == 0x000010, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationReplacedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationTrappedCountModifier) == 0x000014, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationTrappedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationLockedCountModifier) == 0x000018, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationLockedCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationOpenCountModifier) == 0x00001C, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationOpenCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, DoorRandomizationBlockedPathMaxDetourDistanceModifier) == 0x000020, "Member 'FRBTrialConfigDataOverrides::DoorRandomizationBlockedPathMaxDetourDistanceModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, HidespotRandomizationDisabledRatioModifier) == 0x000024, "Member 'FRBTrialConfigDataOverrides::HidespotRandomizationDisabledRatioModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, TrapGroupCountModifier) == 0x000028, "Member 'FRBTrialConfigDataOverrides::TrapGroupCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, SoundTrapCountModifier) == 0x00002C, "Member 'FRBTrialConfigDataOverrides::SoundTrapCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, ExplosiveTrapCountModifier) == 0x000030, "Member 'FRBTrialConfigDataOverrides::ExplosiveTrapCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, ElectricFloorTrapCountModifier) == 0x000034, "Member 'FRBTrialConfigDataOverrides::ElectricFloorTrapCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, PsychosisMineTrapCountModifier) == 0x000038, "Member 'FRBTrialConfigDataOverrides::PsychosisMineTrapCountModifier' has a wrong offset!");
static_assert(offsetof(FRBTrialConfigDataOverrides, ExplosiveWireTrapsCountModifier) == 0x00003C, "Member 'FRBTrialConfigDataOverrides::ExplosiveWireTrapsCountModifier' has a wrong offset!");

// ScriptStruct OPP.GlobalAnimData
// 0x0040 (0x0040 - 0x0000)
struct FGlobalAnimData final
{
public:
	ELocomotionMode                               AnimLocomotionMode;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthFactor;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstPerson;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAIControlled;                                   // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLookingBack;                                    // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftArmFirstPersonRelativeAnimAlpha;               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightArmFirstPersonRelativeAnimAlpha;              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeckOffsetRatio;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarknessAlpha;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedEyePitch;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedEyeYaw;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PeekAmount;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EyeRotation;                                       // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCustomActionBP;                                // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalAnimData) == 0x000004, "Wrong alignment on FGlobalAnimData");
static_assert(sizeof(FGlobalAnimData) == 0x000040, "Wrong size on FGlobalAnimData");
static_assert(offsetof(FGlobalAnimData, AnimLocomotionMode) == 0x000000, "Member 'FGlobalAnimData::AnimLocomotionMode' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, Health) == 0x000004, "Member 'FGlobalAnimData::Health' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, HealthFactor) == 0x000008, "Member 'FGlobalAnimData::HealthFactor' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, bIsFirstPerson) == 0x00000C, "Member 'FGlobalAnimData::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, bIsAIControlled) == 0x00000D, "Member 'FGlobalAnimData::bIsAIControlled' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, bIsLookingBack) == 0x00000E, "Member 'FGlobalAnimData::bIsLookingBack' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, LeftArmFirstPersonRelativeAnimAlpha) == 0x000010, "Member 'FGlobalAnimData::LeftArmFirstPersonRelativeAnimAlpha' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, RightArmFirstPersonRelativeAnimAlpha) == 0x000014, "Member 'FGlobalAnimData::RightArmFirstPersonRelativeAnimAlpha' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, NeckOffsetRatio) == 0x000018, "Member 'FGlobalAnimData::NeckOffsetRatio' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, DarknessAlpha) == 0x00001C, "Member 'FGlobalAnimData::DarknessAlpha' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, SmoothedEyePitch) == 0x000020, "Member 'FGlobalAnimData::SmoothedEyePitch' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, SmoothedEyeYaw) == 0x000024, "Member 'FGlobalAnimData::SmoothedEyeYaw' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, PeekAmount) == 0x000028, "Member 'FGlobalAnimData::PeekAmount' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, EyeRotation) == 0x000030, "Member 'FGlobalAnimData::EyeRotation' has a wrong offset!");
static_assert(offsetof(FGlobalAnimData, bUseCustomActionBP) == 0x00003C, "Member 'FGlobalAnimData::bUseCustomActionBP' has a wrong offset!");

// ScriptStruct OPP.BlendSpaceAnimData
// 0x0020 (0x0020 - 0x0000)
struct FBlendSpaceAnimData final
{
public:
	bool                                          bPlayingBlendSpace;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControlValueX;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlValueY;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeIn;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeOut;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        BlendSpaceSlot;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendSpaceAnimData) == 0x000008, "Wrong alignment on FBlendSpaceAnimData");
static_assert(sizeof(FBlendSpaceAnimData) == 0x000020, "Wrong size on FBlendSpaceAnimData");
static_assert(offsetof(FBlendSpaceAnimData, bPlayingBlendSpace) == 0x000000, "Member 'FBlendSpaceAnimData::bPlayingBlendSpace' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, ControlValueX) == 0x000004, "Member 'FBlendSpaceAnimData::ControlValueX' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, ControlValueY) == 0x000008, "Member 'FBlendSpaceAnimData::ControlValueY' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, PlayRate) == 0x00000C, "Member 'FBlendSpaceAnimData::PlayRate' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, BlendTimeIn) == 0x000010, "Member 'FBlendSpaceAnimData::BlendTimeIn' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, BlendTimeOut) == 0x000014, "Member 'FBlendSpaceAnimData::BlendTimeOut' has a wrong offset!");
static_assert(offsetof(FBlendSpaceAnimData, BlendSpaceSlot) == 0x000018, "Member 'FBlendSpaceAnimData::BlendSpaceSlot' has a wrong offset!");

// ScriptStruct OPP.MovementAnimData
// 0x0018 (0x0018 - 0x0000)
struct FMovementAnimData final
{
public:
	float                                         FwdAnimSpeed;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideAnimSpeed;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstantRotationSpeed;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedRotationSpeed;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELargeObjectType                              LargeObjectType;                                   // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementAnimData) == 0x000004, "Wrong alignment on FMovementAnimData");
static_assert(sizeof(FMovementAnimData) == 0x000018, "Wrong size on FMovementAnimData");
static_assert(offsetof(FMovementAnimData, FwdAnimSpeed) == 0x000000, "Member 'FMovementAnimData::FwdAnimSpeed' has a wrong offset!");
static_assert(offsetof(FMovementAnimData, SideAnimSpeed) == 0x000004, "Member 'FMovementAnimData::SideAnimSpeed' has a wrong offset!");
static_assert(offsetof(FMovementAnimData, MovementSpeed) == 0x000008, "Member 'FMovementAnimData::MovementSpeed' has a wrong offset!");
static_assert(offsetof(FMovementAnimData, InstantRotationSpeed) == 0x00000C, "Member 'FMovementAnimData::InstantRotationSpeed' has a wrong offset!");
static_assert(offsetof(FMovementAnimData, SmoothedRotationSpeed) == 0x000010, "Member 'FMovementAnimData::SmoothedRotationSpeed' has a wrong offset!");
static_assert(offsetof(FMovementAnimData, LargeObjectType) == 0x000014, "Member 'FMovementAnimData::LargeObjectType' has a wrong offset!");

// ScriptStruct OPP.TraversalAnimData
// 0x0020 (0x0020 - 0x0000)
struct FTraversalAnimData final
{
public:
	bool                                          bShouldTraversalMoveFinish;                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbHeight;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbWidth;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunning;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TraversalActor;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustCrouchAfterMove;                              // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarryingLargeObject;                            // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraversalAnimData) == 0x000008, "Wrong alignment on FTraversalAnimData");
static_assert(sizeof(FTraversalAnimData) == 0x000020, "Wrong size on FTraversalAnimData");
static_assert(offsetof(FTraversalAnimData, bShouldTraversalMoveFinish) == 0x000000, "Member 'FTraversalAnimData::bShouldTraversalMoveFinish' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, ClimbHeight) == 0x000004, "Member 'FTraversalAnimData::ClimbHeight' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, ClimbWidth) == 0x000008, "Member 'FTraversalAnimData::ClimbWidth' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, bRunning) == 0x00000C, "Member 'FTraversalAnimData::bRunning' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, TraversalActor) == 0x000010, "Member 'FTraversalAnimData::TraversalActor' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, bMustCrouchAfterMove) == 0x000018, "Member 'FTraversalAnimData::bMustCrouchAfterMove' has a wrong offset!");
static_assert(offsetof(FTraversalAnimData, bIsCarryingLargeObject) == 0x000019, "Member 'FTraversalAnimData::bIsCarryingLargeObject' has a wrong offset!");

// ScriptStruct OPP.InteractionAnimData
// 0x0008 (0x0008 - 0x0000)
struct FInteractionAnimData final
{
public:
	EHidespotCategory                             HidespotType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorOpenRatio;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionAnimData) == 0x000004, "Wrong alignment on FInteractionAnimData");
static_assert(sizeof(FInteractionAnimData) == 0x000008, "Wrong size on FInteractionAnimData");
static_assert(offsetof(FInteractionAnimData, HidespotType) == 0x000000, "Member 'FInteractionAnimData::HidespotType' has a wrong offset!");
static_assert(offsetof(FInteractionAnimData, DoorOpenRatio) == 0x000004, "Member 'FInteractionAnimData::DoorOpenRatio' has a wrong offset!");

// ScriptStruct OPP.CoopMoveAnimData
// 0x0004 (0x0004 - 0x0000)
struct FCoopMoveAnimData final
{
public:
	bool                                          bIsDoingCoopMove;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeader;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoopMoveType                                 CoopMoveType;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustCrouchAfterMove;                              // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoopMoveAnimData) == 0x000001, "Wrong alignment on FCoopMoveAnimData");
static_assert(sizeof(FCoopMoveAnimData) == 0x000004, "Wrong size on FCoopMoveAnimData");
static_assert(offsetof(FCoopMoveAnimData, bIsDoingCoopMove) == 0x000000, "Member 'FCoopMoveAnimData::bIsDoingCoopMove' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimData, bIsLeader) == 0x000001, "Member 'FCoopMoveAnimData::bIsLeader' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimData, CoopMoveType) == 0x000002, "Member 'FCoopMoveAnimData::CoopMoveType' has a wrong offset!");
static_assert(offsetof(FCoopMoveAnimData, bMustCrouchAfterMove) == 0x000003, "Member 'FCoopMoveAnimData::bMustCrouchAfterMove' has a wrong offset!");

// ScriptStruct OPP.AttackAnimData
// 0x0014 (0x0014 - 0x0000)
struct FAttackAnimData final
{
public:
	bool                                          bIsInAttackStance;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackStanceRatio;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargingAttack;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargingAttackRatio;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargingLeft;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackAnimData) == 0x000004, "Wrong alignment on FAttackAnimData");
static_assert(sizeof(FAttackAnimData) == 0x000014, "Wrong size on FAttackAnimData");
static_assert(offsetof(FAttackAnimData, bIsInAttackStance) == 0x000000, "Member 'FAttackAnimData::bIsInAttackStance' has a wrong offset!");
static_assert(offsetof(FAttackAnimData, AttackStanceRatio) == 0x000004, "Member 'FAttackAnimData::AttackStanceRatio' has a wrong offset!");
static_assert(offsetof(FAttackAnimData, bChargingAttack) == 0x000008, "Member 'FAttackAnimData::bChargingAttack' has a wrong offset!");
static_assert(offsetof(FAttackAnimData, ChargingAttackRatio) == 0x00000C, "Member 'FAttackAnimData::ChargingAttackRatio' has a wrong offset!");
static_assert(offsetof(FAttackAnimData, bChargingLeft) == 0x000010, "Member 'FAttackAnimData::bChargingLeft' has a wrong offset!");

// ScriptStruct OPP.SpecialAttackAnimData
// 0x0003 (0x0003 - 0x0000)
struct FSpecialAttackAnimData final
{
public:
	bool                                          bInGrabFromBehindState;                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGroundAndPoundState;                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttacker;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialAttackAnimData) == 0x000001, "Wrong alignment on FSpecialAttackAnimData");
static_assert(sizeof(FSpecialAttackAnimData) == 0x000003, "Wrong size on FSpecialAttackAnimData");
static_assert(offsetof(FSpecialAttackAnimData, bInGrabFromBehindState) == 0x000000, "Member 'FSpecialAttackAnimData::bInGrabFromBehindState' has a wrong offset!");
static_assert(offsetof(FSpecialAttackAnimData, bInGroundAndPoundState) == 0x000001, "Member 'FSpecialAttackAnimData::bInGroundAndPoundState' has a wrong offset!");
static_assert(offsetof(FSpecialAttackAnimData, bIsAttacker) == 0x000002, "Member 'FSpecialAttackAnimData::bIsAttacker' has a wrong offset!");

// ScriptStruct OPP.InventoryAnimData
// 0x000C (0x000C - 0x0000)
struct FInventoryAnimData final
{
public:
	EItemAnimType                                 ItemAnimType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingItem;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreparingItem;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WatchUpRatio;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GivingItemHandUpRatio;                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryAnimData) == 0x000004, "Wrong alignment on FInventoryAnimData");
static_assert(sizeof(FInventoryAnimData) == 0x00000C, "Wrong size on FInventoryAnimData");
static_assert(offsetof(FInventoryAnimData, ItemAnimType) == 0x000000, "Member 'FInventoryAnimData::ItemAnimType' has a wrong offset!");
static_assert(offsetof(FInventoryAnimData, ItemType) == 0x000001, "Member 'FInventoryAnimData::ItemType' has a wrong offset!");
static_assert(offsetof(FInventoryAnimData, bUsingItem) == 0x000002, "Member 'FInventoryAnimData::bUsingItem' has a wrong offset!");
static_assert(offsetof(FInventoryAnimData, bPreparingItem) == 0x000003, "Member 'FInventoryAnimData::bPreparingItem' has a wrong offset!");
static_assert(offsetof(FInventoryAnimData, WatchUpRatio) == 0x000004, "Member 'FInventoryAnimData::WatchUpRatio' has a wrong offset!");
static_assert(offsetof(FInventoryAnimData, GivingItemHandUpRatio) == 0x000008, "Member 'FInventoryAnimData::GivingItemHandUpRatio' has a wrong offset!");

// ScriptStruct OPP.LookAtAnimData
// 0x0010 (0x0010 - 0x0000)
struct FLookAtAnimData final
{
public:
	bool                                          bEnableLookAt;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtRelativeYaw;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtPitch;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtAnimData) == 0x000004, "Wrong alignment on FLookAtAnimData");
static_assert(sizeof(FLookAtAnimData) == 0x000010, "Wrong size on FLookAtAnimData");
static_assert(offsetof(FLookAtAnimData, bEnableLookAt) == 0x000000, "Member 'FLookAtAnimData::bEnableLookAt' has a wrong offset!");
static_assert(offsetof(FLookAtAnimData, LookAtAlpha) == 0x000004, "Member 'FLookAtAnimData::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(FLookAtAnimData, LookAtRelativeYaw) == 0x000008, "Member 'FLookAtAnimData::LookAtRelativeYaw' has a wrong offset!");
static_assert(offsetof(FLookAtAnimData, LookAtPitch) == 0x00000C, "Member 'FLookAtAnimData::LookAtPitch' has a wrong offset!");

// ScriptStruct OPP.NPCAnimData
// 0x0010 (0x0010 - 0x0000)
struct FNPCAnimData final
{
public:
	ENPCAnimStyle                                 AnimStyle;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepHeaviness;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyEffectIntensity;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreathingIntensity;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCAnimData) == 0x000004, "Wrong alignment on FNPCAnimData");
static_assert(sizeof(FNPCAnimData) == 0x000010, "Wrong size on FNPCAnimData");
static_assert(offsetof(FNPCAnimData, AnimStyle) == 0x000000, "Member 'FNPCAnimData::AnimStyle' has a wrong offset!");
static_assert(offsetof(FNPCAnimData, StepHeaviness) == 0x000004, "Member 'FNPCAnimData::StepHeaviness' has a wrong offset!");
static_assert(offsetof(FNPCAnimData, BodyEffectIntensity) == 0x000008, "Member 'FNPCAnimData::BodyEffectIntensity' has a wrong offset!");
static_assert(offsetof(FNPCAnimData, BreathingIntensity) == 0x00000C, "Member 'FNPCAnimData::BreathingIntensity' has a wrong offset!");

// ScriptStruct OPP.SpecialAnimData
// 0x0010 (0x0010 - 0x0000)
struct FSpecialAnimData final
{
public:
	bool                                          bIsInPsychosis;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToSpectre;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBNPC*                                 SpectreNPC;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialAnimData) == 0x000008, "Wrong alignment on FSpecialAnimData");
static_assert(sizeof(FSpecialAnimData) == 0x000010, "Wrong size on FSpecialAnimData");
static_assert(offsetof(FSpecialAnimData, bIsInPsychosis) == 0x000000, "Member 'FSpecialAnimData::bIsInPsychosis' has a wrong offset!");
static_assert(offsetof(FSpecialAnimData, DistanceToSpectre) == 0x000004, "Member 'FSpecialAnimData::DistanceToSpectre' has a wrong offset!");
static_assert(offsetof(FSpecialAnimData, SpectreNPC) == 0x000008, "Member 'FSpecialAnimData::SpectreNPC' has a wrong offset!");

// ScriptStruct OPP.PawnAnimData
// 0x0118 (0x0118 - 0x0000)
struct FPawnAnimData final
{
public:
	struct FGlobalAnimData                        Global;                                            // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlendSpaceAnimData                    BlendSpace;                                        // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMovementAnimData                      Movement;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTraversalAnimData                     Traversal;                                         // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FInteractionAnimData                   Interaction;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoopMoveAnimData                      CoopMove;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttackAnimData                        Attack;                                            // 0x00A4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpecialAttackAnimData                 SpecialAttacks;                                    // 0x00B8(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x1];                                       // 0x00BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryAnimData                     Inventory;                                         // 0x00BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAmbientAnimData                     Ambient;                                           // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLookAtAnimData                        LookAt;                                            // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCAnimData                           NPC;                                               // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpecialAnimData                       Special;                                           // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnAnimData) == 0x000008, "Wrong alignment on FPawnAnimData");
static_assert(sizeof(FPawnAnimData) == 0x000118, "Wrong size on FPawnAnimData");
static_assert(offsetof(FPawnAnimData, Global) == 0x000000, "Member 'FPawnAnimData::Global' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, BlendSpace) == 0x000040, "Member 'FPawnAnimData::BlendSpace' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Movement) == 0x000060, "Member 'FPawnAnimData::Movement' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Traversal) == 0x000078, "Member 'FPawnAnimData::Traversal' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Interaction) == 0x000098, "Member 'FPawnAnimData::Interaction' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, CoopMove) == 0x0000A0, "Member 'FPawnAnimData::CoopMove' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Attack) == 0x0000A4, "Member 'FPawnAnimData::Attack' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, SpecialAttacks) == 0x0000B8, "Member 'FPawnAnimData::SpecialAttacks' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Inventory) == 0x0000BC, "Member 'FPawnAnimData::Inventory' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Ambient) == 0x0000C8, "Member 'FPawnAnimData::Ambient' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, LookAt) == 0x0000E8, "Member 'FPawnAnimData::LookAt' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, NPC) == 0x0000F8, "Member 'FPawnAnimData::NPC' has a wrong offset!");
static_assert(offsetof(FPawnAnimData, Special) == 0x000108, "Member 'FPawnAnimData::Special' has a wrong offset!");

// ScriptStruct OPP.AIAttackTarget
// 0x0028 (0x0028 - 0x0000)
struct FAIAttackTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPawn*                                TargetPawn;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              TargetPlayer;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAttackTarget) == 0x000008, "Wrong alignment on FAIAttackTarget");
static_assert(sizeof(FAIAttackTarget) == 0x000028, "Wrong size on FAIAttackTarget");
static_assert(offsetof(FAIAttackTarget, TargetActor) == 0x000000, "Member 'FAIAttackTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FAIAttackTarget, TargetPawn) == 0x000008, "Member 'FAIAttackTarget::TargetPawn' has a wrong offset!");
static_assert(offsetof(FAIAttackTarget, TargetPlayer) == 0x000010, "Member 'FAIAttackTarget::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FAIAttackTarget, TargetPosition) == 0x000018, "Member 'FAIAttackTarget::TargetPosition' has a wrong offset!");

// ScriptStruct OPP.RBChunkRule
// 0x0018 (0x0018 - 0x0000)
struct FRBChunkRule final
{
public:
	ERBChunkRuleMode                              Mode;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pattern;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBChunkRule) == 0x000008, "Wrong alignment on FRBChunkRule");
static_assert(sizeof(FRBChunkRule) == 0x000018, "Wrong size on FRBChunkRule");
static_assert(offsetof(FRBChunkRule, Mode) == 0x000000, "Member 'FRBChunkRule::Mode' has a wrong offset!");
static_assert(offsetof(FRBChunkRule, Pattern) == 0x000008, "Member 'FRBChunkRule::Pattern' has a wrong offset!");

// ScriptStruct OPP.SpectatorData
// 0x0018 (0x0018 - 0x0000)
struct FSpectatorData final
{
public:
	class ARBPlayer*                              TargetPlayer;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              TargetPlayer_Local;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPlayerTimestamp_Local;                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpectatorMode                                SpectatorMode;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpectatorData) == 0x000008, "Wrong alignment on FSpectatorData");
static_assert(sizeof(FSpectatorData) == 0x000018, "Wrong size on FSpectatorData");
static_assert(offsetof(FSpectatorData, TargetPlayer) == 0x000000, "Member 'FSpectatorData::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FSpectatorData, TargetPlayer_Local) == 0x000008, "Member 'FSpectatorData::TargetPlayer_Local' has a wrong offset!");
static_assert(offsetof(FSpectatorData, TargetPlayerTimestamp_Local) == 0x000010, "Member 'FSpectatorData::TargetPlayerTimestamp_Local' has a wrong offset!");
static_assert(offsetof(FSpectatorData, SpectatorMode) == 0x000014, "Member 'FSpectatorData::SpectatorMode' has a wrong offset!");

// ScriptStruct OPP.CachedRuntimeCustomizationResources
// 0x0020 (0x0020 - 0x0000)
struct FCachedRuntimeCustomizationResources final
{
public:
	struct FProfileId                             ProfileId;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Resources;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedRuntimeCustomizationResources) == 0x000008, "Wrong alignment on FCachedRuntimeCustomizationResources");
static_assert(sizeof(FCachedRuntimeCustomizationResources) == 0x000020, "Wrong size on FCachedRuntimeCustomizationResources");
static_assert(offsetof(FCachedRuntimeCustomizationResources, ProfileId) == 0x000000, "Member 'FCachedRuntimeCustomizationResources::ProfileId' has a wrong offset!");
static_assert(offsetof(FCachedRuntimeCustomizationResources, Resources) == 0x000010, "Member 'FCachedRuntimeCustomizationResources::Resources' has a wrong offset!");

// ScriptStruct OPP.NPCHitReactionParams
// 0x0038 (0x0038 - 0x0000)
struct FNPCHitReactionParams final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCHitReactionType                           ReactionType;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactYawWS;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEffects;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ImpactLocation;                                    // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPos;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDir;                                         // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCHitReactionParams) == 0x000008, "Wrong alignment on FNPCHitReactionParams");
static_assert(sizeof(FNPCHitReactionParams) == 0x000038, "Wrong size on FNPCHitReactionParams");
static_assert(offsetof(FNPCHitReactionParams, AnimSequence) == 0x000000, "Member 'FNPCHitReactionParams::AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, ReactionType) == 0x000008, "Member 'FNPCHitReactionParams::ReactionType' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, ImpactYawWS) == 0x00000C, "Member 'FNPCHitReactionParams::ImpactYawWS' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, bPlayEffects) == 0x000010, "Member 'FNPCHitReactionParams::bPlayEffects' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, ImpactLocation) == 0x000014, "Member 'FNPCHitReactionParams::ImpactLocation' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, TargetPos) == 0x000020, "Member 'FNPCHitReactionParams::TargetPos' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionParams, TargetDir) == 0x00002C, "Member 'FNPCHitReactionParams::TargetDir' has a wrong offset!");

// ScriptStruct OPP.BasicDirectionAnimations
// 0x0020 (0x0020 - 0x0000)
struct FBasicDirectionAnimations final
{
public:
	class UAnimSequence*                          Front;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Back;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Left;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Right;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicDirectionAnimations) == 0x000008, "Wrong alignment on FBasicDirectionAnimations");
static_assert(sizeof(FBasicDirectionAnimations) == 0x000020, "Wrong size on FBasicDirectionAnimations");
static_assert(offsetof(FBasicDirectionAnimations, Front) == 0x000000, "Member 'FBasicDirectionAnimations::Front' has a wrong offset!");
static_assert(offsetof(FBasicDirectionAnimations, Back) == 0x000008, "Member 'FBasicDirectionAnimations::Back' has a wrong offset!");
static_assert(offsetof(FBasicDirectionAnimations, Left) == 0x000010, "Member 'FBasicDirectionAnimations::Left' has a wrong offset!");
static_assert(offsetof(FBasicDirectionAnimations, Right) == 0x000018, "Member 'FBasicDirectionAnimations::Right' has a wrong offset!");

// ScriptStruct OPP.ContainerForcedContentSettings
// 0x0010 (0x0010 - 0x0000)
struct FContainerForcedContentSettings final
{
public:
	TArray<struct FContainerForcedContentItemSettings> ForcedItemPossibilities;                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerForcedContentSettings) == 0x000008, "Wrong alignment on FContainerForcedContentSettings");
static_assert(sizeof(FContainerForcedContentSettings) == 0x000010, "Wrong size on FContainerForcedContentSettings");
static_assert(offsetof(FContainerForcedContentSettings, ForcedItemPossibilities) == 0x000000, "Member 'FContainerForcedContentSettings::ForcedItemPossibilities' has a wrong offset!");

// ScriptStruct OPP.OperatableAnimationData
// 0x0018 (0x0018 - 0x0000)
struct FOperatableAnimationData final
{
public:
	class UAnimSequence*                          Start;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Loop;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          End;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOperatableAnimationData) == 0x000008, "Wrong alignment on FOperatableAnimationData");
static_assert(sizeof(FOperatableAnimationData) == 0x000018, "Wrong size on FOperatableAnimationData");
static_assert(offsetof(FOperatableAnimationData, Start) == 0x000000, "Member 'FOperatableAnimationData::Start' has a wrong offset!");
static_assert(offsetof(FOperatableAnimationData, Loop) == 0x000008, "Member 'FOperatableAnimationData::Loop' has a wrong offset!");
static_assert(offsetof(FOperatableAnimationData, End) == 0x000010, "Member 'FOperatableAnimationData::End' has a wrong offset!");

// ScriptStruct OPP.NPCDerivedAnimDataContext
// 0x00B0 (0x00B0 - 0x0000)
struct FNPCDerivedAnimDataContext final
{
public:
	uint8                                         Pad_0[0xA8];                                       // 0x0000(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBNPC*                                 NPC;                                               // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCDerivedAnimDataContext) == 0x000008, "Wrong alignment on FNPCDerivedAnimDataContext");
static_assert(sizeof(FNPCDerivedAnimDataContext) == 0x0000B0, "Wrong size on FNPCDerivedAnimDataContext");
static_assert(offsetof(FNPCDerivedAnimDataContext, NPC) == 0x0000A8, "Member 'FNPCDerivedAnimDataContext::NPC' has a wrong offset!");

// ScriptStruct OPP.NPCDoorInvestigationAnimDataHalfSet
// 0x0150 (0x0150 - 0x0000)
struct FNPCDoorInvestigationAnimDataHalfSet final
{
public:
	struct FNPCDoorInteractionAnimData            OpenToInvestigate_Side;                            // 0x0000(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            OpenToInvestigate_Wide;                            // 0x0040(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            ClosedToInvestigate_Side;                          // 0x0080(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            ClosedToInvestigate_Wide;                          // 0x00C0(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCDoorInteractionAnimData            ClosedToInvestigate_Peek;                          // 0x0100(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FNPCDoorInteractionAnimData>    LockedToInvestigate_List;                          // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCDoorInvestigationAnimDataHalfSet) == 0x000008, "Wrong alignment on FNPCDoorInvestigationAnimDataHalfSet");
static_assert(sizeof(FNPCDoorInvestigationAnimDataHalfSet) == 0x000150, "Wrong size on FNPCDoorInvestigationAnimDataHalfSet");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, OpenToInvestigate_Side) == 0x000000, "Member 'FNPCDoorInvestigationAnimDataHalfSet::OpenToInvestigate_Side' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, OpenToInvestigate_Wide) == 0x000040, "Member 'FNPCDoorInvestigationAnimDataHalfSet::OpenToInvestigate_Wide' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, ClosedToInvestigate_Side) == 0x000080, "Member 'FNPCDoorInvestigationAnimDataHalfSet::ClosedToInvestigate_Side' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, ClosedToInvestigate_Wide) == 0x0000C0, "Member 'FNPCDoorInvestigationAnimDataHalfSet::ClosedToInvestigate_Wide' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, ClosedToInvestigate_Peek) == 0x000100, "Member 'FNPCDoorInvestigationAnimDataHalfSet::ClosedToInvestigate_Peek' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataHalfSet, LockedToInvestigate_List) == 0x000140, "Member 'FNPCDoorInvestigationAnimDataHalfSet::LockedToInvestigate_List' has a wrong offset!");

// ScriptStruct OPP.NPCDoorInvestigationAnimDataSet
// 0x02A0 (0x02A0 - 0x0000)
struct FNPCDoorInvestigationAnimDataSet final
{
public:
	struct FNPCDoorInvestigationAnimDataHalfSet   Left;                                              // 0x0000(0x0150)(Edit, NativeAccessSpecifierPublic)
	struct FNPCDoorInvestigationAnimDataHalfSet   Right;                                             // 0x0150(0x0150)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCDoorInvestigationAnimDataSet) == 0x000008, "Wrong alignment on FNPCDoorInvestigationAnimDataSet");
static_assert(sizeof(FNPCDoorInvestigationAnimDataSet) == 0x0002A0, "Wrong size on FNPCDoorInvestigationAnimDataSet");
static_assert(offsetof(FNPCDoorInvestigationAnimDataSet, Left) == 0x000000, "Member 'FNPCDoorInvestigationAnimDataSet::Left' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationAnimDataSet, Right) == 0x000150, "Member 'FNPCDoorInvestigationAnimDataSet::Right' has a wrong offset!");

// ScriptStruct OPP.AttackStrike
// 0x0014 (0x0014 - 0x0000)
struct FAttackStrike final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   AttackType;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKnockbackValue                               KnockbackType;                                     // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackLocation;                                    // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackStrike) == 0x000004, "Wrong alignment on FAttackStrike");
static_assert(sizeof(FAttackStrike) == 0x000014, "Wrong size on FAttackStrike");
static_assert(offsetof(FAttackStrike, Damage) == 0x000000, "Member 'FAttackStrike::Damage' has a wrong offset!");
static_assert(offsetof(FAttackStrike, AttackType) == 0x000004, "Member 'FAttackStrike::AttackType' has a wrong offset!");
static_assert(offsetof(FAttackStrike, DamageType) == 0x000005, "Member 'FAttackStrike::DamageType' has a wrong offset!");
static_assert(offsetof(FAttackStrike, KnockbackType) == 0x000006, "Member 'FAttackStrike::KnockbackType' has a wrong offset!");
static_assert(offsetof(FAttackStrike, ItemCategory) == 0x000007, "Member 'FAttackStrike::ItemCategory' has a wrong offset!");
static_assert(offsetof(FAttackStrike, AttackLocation) == 0x000008, "Member 'FAttackStrike::AttackLocation' has a wrong offset!");

// ScriptStruct OPP.ActorInViewDebugData
// 0x0010 (0x0010 - 0x0000)
struct FActorInViewDebugData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DebugActor;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorInViewDebugData) == 0x000008, "Wrong alignment on FActorInViewDebugData");
static_assert(sizeof(FActorInViewDebugData) == 0x000010, "Wrong size on FActorInViewDebugData");
static_assert(offsetof(FActorInViewDebugData, DebugActor) == 0x000008, "Member 'FActorInViewDebugData::DebugActor' has a wrong offset!");

// ScriptStruct OPP.NPCDoorPassthroughAnimDataSet
// 0x0430 (0x0430 - 0x0000)
struct FNPCDoorPassthroughAnimDataSet final
{
public:
	struct FNPCDoorPassthroughAnimDataHalfSet     Left;                                              // 0x0000(0x0210)(Edit, NativeAccessSpecifierPublic)
	struct FNPCDoorPassthroughAnimDataHalfSet     Right;                                             // 0x0210(0x0210)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FNPCConditionalDoorInteractionAnimData> Overrides;                                         // 0x0420(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCDoorPassthroughAnimDataSet) == 0x000008, "Wrong alignment on FNPCDoorPassthroughAnimDataSet");
static_assert(sizeof(FNPCDoorPassthroughAnimDataSet) == 0x000430, "Wrong size on FNPCDoorPassthroughAnimDataSet");
static_assert(offsetof(FNPCDoorPassthroughAnimDataSet, Left) == 0x000000, "Member 'FNPCDoorPassthroughAnimDataSet::Left' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataSet, Right) == 0x000210, "Member 'FNPCDoorPassthroughAnimDataSet::Right' has a wrong offset!");
static_assert(offsetof(FNPCDoorPassthroughAnimDataSet, Overrides) == 0x000420, "Member 'FNPCDoorPassthroughAnimDataSet::Overrides' has a wrong offset!");

// ScriptStruct OPP.CustomTrialEntry
// 0x0040 (0x0040 - 0x0000)
struct FCustomTrialEntry final
{
public:
	class ARBPlayerState*                         AssociatedPlayerState;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelf;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Code;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           VariatorIds;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomTrialEntry) == 0x000008, "Wrong alignment on FCustomTrialEntry");
static_assert(sizeof(FCustomTrialEntry) == 0x000040, "Wrong size on FCustomTrialEntry");
static_assert(offsetof(FCustomTrialEntry, AssociatedPlayerState) == 0x000000, "Member 'FCustomTrialEntry::AssociatedPlayerState' has a wrong offset!");
static_assert(offsetof(FCustomTrialEntry, bIsSelf) == 0x000008, "Member 'FCustomTrialEntry::bIsSelf' has a wrong offset!");
static_assert(offsetof(FCustomTrialEntry, Code) == 0x000010, "Member 'FCustomTrialEntry::Code' has a wrong offset!");
static_assert(offsetof(FCustomTrialEntry, TrialId) == 0x000020, "Member 'FCustomTrialEntry::TrialId' has a wrong offset!");
static_assert(offsetof(FCustomTrialEntry, VariatorIds) == 0x000028, "Member 'FCustomTrialEntry::VariatorIds' has a wrong offset!");
static_assert(offsetof(FCustomTrialEntry, Index) == 0x000038, "Member 'FCustomTrialEntry::Index' has a wrong offset!");

// ScriptStruct OPP.NPCHitReactionAnimData
// 0x0010 (0x0010 - 0x0000)
struct FNPCHitReactionAnimData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCHitReactionType                           ReactionType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasicDirection                               Direction;                                         // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCHitReactionAnimData) == 0x000008, "Wrong alignment on FNPCHitReactionAnimData");
static_assert(sizeof(FNPCHitReactionAnimData) == 0x000010, "Wrong size on FNPCHitReactionAnimData");
static_assert(offsetof(FNPCHitReactionAnimData, AnimSequence) == 0x000000, "Member 'FNPCHitReactionAnimData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionAnimData, ReactionType) == 0x000008, "Member 'FNPCHitReactionAnimData::ReactionType' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionAnimData, bMoving) == 0x000009, "Member 'FNPCHitReactionAnimData::bMoving' has a wrong offset!");
static_assert(offsetof(FNPCHitReactionAnimData, Direction) == 0x00000A, "Member 'FNPCHitReactionAnimData::Direction' has a wrong offset!");

// ScriptStruct OPP.NPCInvestigationSelectionParams
// 0x0020 (0x0020 - 0x0000)
struct FNPCInvestigationSelectionParams final
{
public:
	class ARBInvestigationPoint*                  InvPoint;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCInvestigationSelectionParams) == 0x000008, "Wrong alignment on FNPCInvestigationSelectionParams");
static_assert(sizeof(FNPCInvestigationSelectionParams) == 0x000020, "Wrong size on FNPCInvestigationSelectionParams");
static_assert(offsetof(FNPCInvestigationSelectionParams, InvPoint) == 0x000000, "Member 'FNPCInvestigationSelectionParams::InvPoint' has a wrong offset!");

// ScriptStruct OPP.NPCSourceInvestigationAnimData
// 0x0010 (0x0010 - 0x0000)
struct FNPCSourceInvestigationAnimData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCSourceInvestigationAnimData) == 0x000008, "Wrong alignment on FNPCSourceInvestigationAnimData");
static_assert(sizeof(FNPCSourceInvestigationAnimData) == 0x000010, "Wrong size on FNPCSourceInvestigationAnimData");
static_assert(offsetof(FNPCSourceInvestigationAnimData, AnimSequence) == 0x000000, "Member 'FNPCSourceInvestigationAnimData::AnimSequence' has a wrong offset!");

// ScriptStruct OPP.RBCollectibleDocumentDefinitionRow
// 0x00C8 (0x00D0 - 0x0008)
struct FRBCollectibleDocumentDefinitionRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECollectibleType                              Type;                                              // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Content;                                           // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Photo;                                             // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayGroupId;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Thumbnail;                                         // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBCollectibleDocumentDefinitionRow) == 0x000008, "Wrong alignment on FRBCollectibleDocumentDefinitionRow");
static_assert(sizeof(FRBCollectibleDocumentDefinitionRow) == 0x0000D0, "Wrong size on FRBCollectibleDocumentDefinitionRow");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, ID) == 0x000008, "Member 'FRBCollectibleDocumentDefinitionRow::ID' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Name) == 0x000010, "Member 'FRBCollectibleDocumentDefinitionRow::Name' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Category) == 0x000028, "Member 'FRBCollectibleDocumentDefinitionRow::Category' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Date) == 0x000040, "Member 'FRBCollectibleDocumentDefinitionRow::Date' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Type) == 0x000058, "Member 'FRBCollectibleDocumentDefinitionRow::Type' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Content) == 0x000060, "Member 'FRBCollectibleDocumentDefinitionRow::Content' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Photo) == 0x000078, "Member 'FRBCollectibleDocumentDefinitionRow::Photo' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, DisplayGroupId) == 0x0000A0, "Member 'FRBCollectibleDocumentDefinitionRow::DisplayGroupId' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentDefinitionRow, Thumbnail) == 0x0000A8, "Member 'FRBCollectibleDocumentDefinitionRow::Thumbnail' has a wrong offset!");

// ScriptStruct OPP.NPCInvestigationSightRequirement
// 0x000C (0x000C - 0x0000)
struct FNPCInvestigationSightRequirement final
{
public:
	float                                         DistanceOffset;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeLookAngle;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookDuration;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCInvestigationSightRequirement) == 0x000004, "Wrong alignment on FNPCInvestigationSightRequirement");
static_assert(sizeof(FNPCInvestigationSightRequirement) == 0x00000C, "Wrong size on FNPCInvestigationSightRequirement");
static_assert(offsetof(FNPCInvestigationSightRequirement, DistanceOffset) == 0x000000, "Member 'FNPCInvestigationSightRequirement::DistanceOffset' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSightRequirement, RelativeLookAngle) == 0x000004, "Member 'FNPCInvestigationSightRequirement::RelativeLookAngle' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSightRequirement, LookDuration) == 0x000008, "Member 'FNPCInvestigationSightRequirement::LookDuration' has a wrong offset!");

// ScriptStruct OPP.NPCInvestigationAnimData
// 0x0038 (0x0038 - 0x0000)
struct FNPCInvestigationAnimData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityModifier;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCInvestigationAnimIntensity                Intensity;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCInvestigationAnimCategory                 Category;                                          // 0x000D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnteringInMotion;                                 // 0x000E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EntrySpeed;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryPhase;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistTravelled;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCInvestigationSightRequirement> SightRequirements;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCInvestigationAnimData) == 0x000008, "Wrong alignment on FNPCInvestigationAnimData");
static_assert(sizeof(FNPCInvestigationAnimData) == 0x000038, "Wrong size on FNPCInvestigationAnimData");
static_assert(offsetof(FNPCInvestigationAnimData, AnimSequence) == 0x000000, "Member 'FNPCInvestigationAnimData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, ProbabilityModifier) == 0x000008, "Member 'FNPCInvestigationAnimData::ProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, Intensity) == 0x00000C, "Member 'FNPCInvestigationAnimData::Intensity' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, Category) == 0x00000D, "Member 'FNPCInvestigationAnimData::Category' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, bEnteringInMotion) == 0x00000E, "Member 'FNPCInvestigationAnimData::bEnteringInMotion' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, EntrySpeed) == 0x000010, "Member 'FNPCInvestigationAnimData::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, EntryPhase) == 0x000014, "Member 'FNPCInvestigationAnimData::EntryPhase' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, DistTravelled) == 0x000018, "Member 'FNPCInvestigationAnimData::DistTravelled' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationAnimData, SightRequirements) == 0x000020, "Member 'FNPCInvestigationAnimData::SightRequirements' has a wrong offset!");

// ScriptStruct OPP.NPCGroupAttackAnimData
// 0x0000 (0x0018 - 0x0018)
struct FNPCGroupAttackAnimData final : public FConditionalAnimSequence
{
};
static_assert(alignof(FNPCGroupAttackAnimData) == 0x000008, "Wrong alignment on FNPCGroupAttackAnimData");
static_assert(sizeof(FNPCGroupAttackAnimData) == 0x000018, "Wrong size on FNPCGroupAttackAnimData");

// ScriptStruct OPP.UILinearInventoryItem
// 0x0088 (0x0088 - 0x0000)
struct FUILinearInventoryItem final
{
public:
	class ARBPickup*                              Item;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemDefinition                        ItemDefinition;                                    // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownRatio;                                     // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUILinearInventoryItem) == 0x000008, "Wrong alignment on FUILinearInventoryItem");
static_assert(sizeof(FUILinearInventoryItem) == 0x000088, "Wrong size on FUILinearInventoryItem");
static_assert(offsetof(FUILinearInventoryItem, Item) == 0x000000, "Member 'FUILinearInventoryItem::Item' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, DisplayName) == 0x000008, "Member 'FUILinearInventoryItem::DisplayName' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, Icon) == 0x000020, "Member 'FUILinearInventoryItem::Icon' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, ItemDefinition) == 0x000028, "Member 'FUILinearInventoryItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, SlotIndex) == 0x000078, "Member 'FUILinearInventoryItem::SlotIndex' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, IsAvailable) == 0x00007C, "Member 'FUILinearInventoryItem::IsAvailable' has a wrong offset!");
static_assert(offsetof(FUILinearInventoryItem, CooldownRatio) == 0x000080, "Member 'FUILinearInventoryItem::CooldownRatio' has a wrong offset!");

// ScriptStruct OPP.AttackMove
// 0x0038 (0x0038 - 0x0000)
struct FAttackMove final
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityModifier;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDamage;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAttackClearanceType                        RequiredAttackClearance;                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredCeilingClearance;                          // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBGenericConditionSet                 Conditions;                                        // 0x0020(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackMove) == 0x000008, "Wrong alignment on FAttackMove");
static_assert(sizeof(FAttackMove) == 0x000038, "Wrong size on FAttackMove");
static_assert(offsetof(FAttackMove, Sequence) == 0x000000, "Member 'FAttackMove::Sequence' has a wrong offset!");
static_assert(offsetof(FAttackMove, ProbabilityModifier) == 0x000008, "Member 'FAttackMove::ProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FAttackMove, Rotation) == 0x00000C, "Member 'FAttackMove::Rotation' has a wrong offset!");
static_assert(offsetof(FAttackMove, Distance) == 0x000010, "Member 'FAttackMove::Distance' has a wrong offset!");
static_assert(offsetof(FAttackMove, TimeToDamage) == 0x000014, "Member 'FAttackMove::TimeToDamage' has a wrong offset!");
static_assert(offsetof(FAttackMove, RequiredAttackClearance) == 0x000018, "Member 'FAttackMove::RequiredAttackClearance' has a wrong offset!");
static_assert(offsetof(FAttackMove, RequiredCeilingClearance) == 0x00001C, "Member 'FAttackMove::RequiredCeilingClearance' has a wrong offset!");
static_assert(offsetof(FAttackMove, Conditions) == 0x000020, "Member 'FAttackMove::Conditions' has a wrong offset!");

// ScriptStruct OPP.DeadBodyConfigPart
// 0x0018 (0x0018 - 0x0000)
struct FDeadBodyConfigPart final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeadBodyConfigPart) == 0x000008, "Wrong alignment on FDeadBodyConfigPart");
static_assert(sizeof(FDeadBodyConfigPart) == 0x000018, "Wrong size on FDeadBodyConfigPart");
static_assert(offsetof(FDeadBodyConfigPart, Mesh) == 0x000000, "Member 'FDeadBodyConfigPart::Mesh' has a wrong offset!");
static_assert(offsetof(FDeadBodyConfigPart, Materials) == 0x000008, "Member 'FDeadBodyConfigPart::Materials' has a wrong offset!");

// ScriptStruct OPP.EmoteAnimData
// 0x0018 (0x0018 - 0x0000)
struct FEmoteAnimData final
{
public:
	class UAnimSequence*                          EmoteAnim1P;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EmoteAnim3P;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EmoteAnimCrouched;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmoteAnimData) == 0x000008, "Wrong alignment on FEmoteAnimData");
static_assert(sizeof(FEmoteAnimData) == 0x000018, "Wrong size on FEmoteAnimData");
static_assert(offsetof(FEmoteAnimData, EmoteAnim1P) == 0x000000, "Member 'FEmoteAnimData::EmoteAnim1P' has a wrong offset!");
static_assert(offsetof(FEmoteAnimData, EmoteAnim3P) == 0x000008, "Member 'FEmoteAnimData::EmoteAnim3P' has a wrong offset!");
static_assert(offsetof(FEmoteAnimData, EmoteAnimCrouched) == 0x000010, "Member 'FEmoteAnimData::EmoteAnimCrouched' has a wrong offset!");

// ScriptStruct OPP.WorldDisturbanceData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FWorldDisturbanceData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldDisturbanceData) == 0x000004, "Wrong alignment on FWorldDisturbanceData");
static_assert(sizeof(FWorldDisturbanceData) == 0x000010, "Wrong size on FWorldDisturbanceData");

// ScriptStruct OPP.PawnInsideCameraInfo
// 0x0010 (0x0010 - 0x0000)
struct FPawnInsideCameraInfo final
{
public:
	class ARBPawn*                                Pawn;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnInsideCameraInfo) == 0x000008, "Wrong alignment on FPawnInsideCameraInfo");
static_assert(sizeof(FPawnInsideCameraInfo) == 0x000010, "Wrong size on FPawnInsideCameraInfo");
static_assert(offsetof(FPawnInsideCameraInfo, Pawn) == 0x000000, "Member 'FPawnInsideCameraInfo::Pawn' has a wrong offset!");

// ScriptStruct OPP.PawnAnimOptimData
// 0x0020 (0x0020 - 0x0000)
struct FPawnAnimOptimData final
{
public:
	class ARBPawn*                                RBPawn;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnAnimOptimData) == 0x000008, "Wrong alignment on FPawnAnimOptimData");
static_assert(sizeof(FPawnAnimOptimData) == 0x000020, "Wrong size on FPawnAnimOptimData");
static_assert(offsetof(FPawnAnimOptimData, RBPawn) == 0x000000, "Member 'FPawnAnimOptimData::RBPawn' has a wrong offset!");

// ScriptStruct OPP.AnimPlayStat
// 0x00B8 (0x00B8 - 0x0000)
struct FAnimPlayStat final
{
public:
	class UAnimSequence*                          AnimSeq;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  SpecialMove;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayCount;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPlayTime;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ENPCType>                                NPCTypes;                                          // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TSet<uint16>                                  NPCIds;                                            // 0x0068(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimPlayStat) == 0x000008, "Wrong alignment on FAnimPlayStat");
static_assert(sizeof(FAnimPlayStat) == 0x0000B8, "Wrong size on FAnimPlayStat");
static_assert(offsetof(FAnimPlayStat, AnimSeq) == 0x000000, "Member 'FAnimPlayStat::AnimSeq' has a wrong offset!");
static_assert(offsetof(FAnimPlayStat, SpecialMove) == 0x000008, "Member 'FAnimPlayStat::SpecialMove' has a wrong offset!");
static_assert(offsetof(FAnimPlayStat, PlayCount) == 0x00000C, "Member 'FAnimPlayStat::PlayCount' has a wrong offset!");
static_assert(offsetof(FAnimPlayStat, LastPlayTime) == 0x000010, "Member 'FAnimPlayStat::LastPlayTime' has a wrong offset!");
static_assert(offsetof(FAnimPlayStat, NPCTypes) == 0x000018, "Member 'FAnimPlayStat::NPCTypes' has a wrong offset!");
static_assert(offsetof(FAnimPlayStat, NPCIds) == 0x000068, "Member 'FAnimPlayStat::NPCIds' has a wrong offset!");

// ScriptStruct OPP.AnimCategoryStats
// 0x0010 (0x0010 - 0x0000)
struct FAnimCategoryStats final
{
public:
	TArray<struct FAnimPlayStat>                  Stats;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimCategoryStats) == 0x000008, "Wrong alignment on FAnimCategoryStats");
static_assert(sizeof(FAnimCategoryStats) == 0x000010, "Wrong size on FAnimCategoryStats");
static_assert(offsetof(FAnimCategoryStats, Stats) == 0x000000, "Member 'FAnimCategoryStats::Stats' has a wrong offset!");

// ScriptStruct OPP.RBResultScreenMurkoffCommentRow
// 0x0048 (0x0050 - 0x0008)
struct FRBResultScreenMurkoffCommentRow final : public FTableRowBase
{
public:
	EPlayerTrialRating                            MinimumRating;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerTrialRating                            MaximumRating;                                     // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumDeathCount;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumDeathCount;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPlayerCount;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumPlayerCount;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerEvent>                          RequiredScoringEvents;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBResultScreenMurkoffCommentRow) == 0x000008, "Wrong alignment on FRBResultScreenMurkoffCommentRow");
static_assert(sizeof(FRBResultScreenMurkoffCommentRow) == 0x000050, "Wrong size on FRBResultScreenMurkoffCommentRow");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MinimumRating) == 0x000008, "Member 'FRBResultScreenMurkoffCommentRow::MinimumRating' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MaximumRating) == 0x000009, "Member 'FRBResultScreenMurkoffCommentRow::MaximumRating' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MinimumDeathCount) == 0x00000C, "Member 'FRBResultScreenMurkoffCommentRow::MinimumDeathCount' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MaximumDeathCount) == 0x000010, "Member 'FRBResultScreenMurkoffCommentRow::MaximumDeathCount' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MinimumPlayerCount) == 0x000014, "Member 'FRBResultScreenMurkoffCommentRow::MinimumPlayerCount' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, MaximumPlayerCount) == 0x000018, "Member 'FRBResultScreenMurkoffCommentRow::MaximumPlayerCount' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, RequiredScoringEvents) == 0x000020, "Member 'FRBResultScreenMurkoffCommentRow::RequiredScoringEvents' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, Weight) == 0x000030, "Member 'FRBResultScreenMurkoffCommentRow::Weight' has a wrong offset!");
static_assert(offsetof(FRBResultScreenMurkoffCommentRow, Text) == 0x000038, "Member 'FRBResultScreenMurkoffCommentRow::Text' has a wrong offset!");

// ScriptStruct OPP.AnimLogItem
// 0x0020 (0x0020 - 0x0000)
struct FAnimLogItem final
{
public:
	class FString                                 PawnName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimLogCategory                              Category;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  SpecialMove;                                       // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSeq;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimLogItem) == 0x000008, "Wrong alignment on FAnimLogItem");
static_assert(sizeof(FAnimLogItem) == 0x000020, "Wrong size on FAnimLogItem");
static_assert(offsetof(FAnimLogItem, PawnName) == 0x000000, "Member 'FAnimLogItem::PawnName' has a wrong offset!");
static_assert(offsetof(FAnimLogItem, Category) == 0x000010, "Member 'FAnimLogItem::Category' has a wrong offset!");
static_assert(offsetof(FAnimLogItem, SpecialMove) == 0x000011, "Member 'FAnimLogItem::SpecialMove' has a wrong offset!");
static_assert(offsetof(FAnimLogItem, AnimSeq) == 0x000018, "Member 'FAnimLogItem::AnimSeq' has a wrong offset!");

// ScriptStruct OPP.DizzinessIdleDriftConfig
// 0x0044 (0x0044 - 0x0000)
struct FDizzinessIdleDriftConfig final
{
public:
	float                                         YawDriftAmpl;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchDriftAmpl;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollDriftAmpl;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriftPeriod;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedMultiplierDuration;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedMultiplierDuration;                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedMultiplier;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedMultiplier;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplierApproach;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAmpMultiplier;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAmpMultiplier;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAutoRoll;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTotalRoll;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoRollForFullWeight;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoRollApproach;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRotSpdThresh;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRotSpdForMaxAutoRoll;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDizzinessIdleDriftConfig) == 0x000004, "Wrong alignment on FDizzinessIdleDriftConfig");
static_assert(sizeof(FDizzinessIdleDriftConfig) == 0x000044, "Wrong size on FDizzinessIdleDriftConfig");
static_assert(offsetof(FDizzinessIdleDriftConfig, YawDriftAmpl) == 0x000000, "Member 'FDizzinessIdleDriftConfig::YawDriftAmpl' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, PitchDriftAmpl) == 0x000004, "Member 'FDizzinessIdleDriftConfig::PitchDriftAmpl' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, RollDriftAmpl) == 0x000008, "Member 'FDizzinessIdleDriftConfig::RollDriftAmpl' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, DriftPeriod) == 0x00000C, "Member 'FDizzinessIdleDriftConfig::DriftPeriod' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MinSpeedMultiplierDuration) == 0x000010, "Member 'FDizzinessIdleDriftConfig::MinSpeedMultiplierDuration' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MaxSpeedMultiplierDuration) == 0x000014, "Member 'FDizzinessIdleDriftConfig::MaxSpeedMultiplierDuration' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MinSpeedMultiplier) == 0x000018, "Member 'FDizzinessIdleDriftConfig::MinSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MaxSpeedMultiplier) == 0x00001C, "Member 'FDizzinessIdleDriftConfig::MaxSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, SpeedMultiplierApproach) == 0x000020, "Member 'FDizzinessIdleDriftConfig::SpeedMultiplierApproach' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MinAmpMultiplier) == 0x000024, "Member 'FDizzinessIdleDriftConfig::MinAmpMultiplier' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MaxAmpMultiplier) == 0x000028, "Member 'FDizzinessIdleDriftConfig::MaxAmpMultiplier' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MaxAutoRoll) == 0x00002C, "Member 'FDizzinessIdleDriftConfig::MaxAutoRoll' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, MaxTotalRoll) == 0x000030, "Member 'FDizzinessIdleDriftConfig::MaxTotalRoll' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, AutoRollForFullWeight) == 0x000034, "Member 'FDizzinessIdleDriftConfig::AutoRollForFullWeight' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, AutoRollApproach) == 0x000038, "Member 'FDizzinessIdleDriftConfig::AutoRollApproach' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, PlayerRotSpdThresh) == 0x00003C, "Member 'FDizzinessIdleDriftConfig::PlayerRotSpdThresh' has a wrong offset!");
static_assert(offsetof(FDizzinessIdleDriftConfig, PlayerRotSpdForMaxAutoRoll) == 0x000040, "Member 'FDizzinessIdleDriftConfig::PlayerRotSpdForMaxAutoRoll' has a wrong offset!");

// ScriptStruct OPP.DizzinessThrobbingConfig
// 0x0014 (0x0014 - 0x0000)
struct FDizzinessThrobbingConfig final
{
public:
	float                                         Freq;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SineExp;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvelopeExp;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantRatio;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDizzinessThrobbingConfig) == 0x000004, "Wrong alignment on FDizzinessThrobbingConfig");
static_assert(sizeof(FDizzinessThrobbingConfig) == 0x000014, "Wrong size on FDizzinessThrobbingConfig");
static_assert(offsetof(FDizzinessThrobbingConfig, Freq) == 0x000000, "Member 'FDizzinessThrobbingConfig::Freq' has a wrong offset!");
static_assert(offsetof(FDizzinessThrobbingConfig, SineExp) == 0x000004, "Member 'FDizzinessThrobbingConfig::SineExp' has a wrong offset!");
static_assert(offsetof(FDizzinessThrobbingConfig, EnvelopeExp) == 0x000008, "Member 'FDizzinessThrobbingConfig::EnvelopeExp' has a wrong offset!");
static_assert(offsetof(FDizzinessThrobbingConfig, Phase) == 0x00000C, "Member 'FDizzinessThrobbingConfig::Phase' has a wrong offset!");
static_assert(offsetof(FDizzinessThrobbingConfig, ConstantRatio) == 0x000010, "Member 'FDizzinessThrobbingConfig::ConstantRatio' has a wrong offset!");

// ScriptStruct OPP.DizzinessConfig
// 0x00D4 (0x00D4 - 0x0000)
struct FDizzinessConfig final
{
public:
	float                                         Intensity;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         blendInTime;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         blendOutTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlur;                                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInertialCameraDrift;                              // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleCameraDrift;                                  // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectMovementHeading;                            // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableJump;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapPlayerSpeed;                                   // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bThrobbing;                                        // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlurAmount;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayerSpeed;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCameraRotationSpeed;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDizzinessIdleDriftConfig              IdleDrift;                                         // 0x0024(0x0044)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDizzinessInertialDriftConfig          InertialDrift;                                     // 0x0068(0x0040)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDizzinessMovementConfig               Movement;                                          // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDizzinessThrobbingConfig              Throbbing;                                         // 0x00C0(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDizzinessConfig) == 0x000004, "Wrong alignment on FDizzinessConfig");
static_assert(sizeof(FDizzinessConfig) == 0x0000D4, "Wrong size on FDizzinessConfig");
static_assert(offsetof(FDizzinessConfig, Intensity) == 0x000000, "Member 'FDizzinessConfig::Intensity' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, Duration) == 0x000004, "Member 'FDizzinessConfig::Duration' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, blendInTime) == 0x000008, "Member 'FDizzinessConfig::blendInTime' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, blendOutTime) == 0x00000C, "Member 'FDizzinessConfig::blendOutTime' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bBlur) == 0x000010, "Member 'FDizzinessConfig::bBlur' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bInertialCameraDrift) == 0x000011, "Member 'FDizzinessConfig::bInertialCameraDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bIdleCameraDrift) == 0x000012, "Member 'FDizzinessConfig::bIdleCameraDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bAffectMovementHeading) == 0x000013, "Member 'FDizzinessConfig::bAffectMovementHeading' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bDisableJump) == 0x000014, "Member 'FDizzinessConfig::bDisableJump' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bCapPlayerSpeed) == 0x000015, "Member 'FDizzinessConfig::bCapPlayerSpeed' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, bThrobbing) == 0x000016, "Member 'FDizzinessConfig::bThrobbing' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, BlurAmount) == 0x000018, "Member 'FDizzinessConfig::BlurAmount' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, MaxPlayerSpeed) == 0x00001C, "Member 'FDizzinessConfig::MaxPlayerSpeed' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, MaxCameraRotationSpeed) == 0x000020, "Member 'FDizzinessConfig::MaxCameraRotationSpeed' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, IdleDrift) == 0x000024, "Member 'FDizzinessConfig::IdleDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, InertialDrift) == 0x000068, "Member 'FDizzinessConfig::InertialDrift' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, Movement) == 0x0000A8, "Member 'FDizzinessConfig::Movement' has a wrong offset!");
static_assert(offsetof(FDizzinessConfig, Throbbing) == 0x0000C0, "Member 'FDizzinessConfig::Throbbing' has a wrong offset!");

// ScriptStruct OPP.CrouchUnderAnimRefs
// 0x0010 (0x0010 - 0x0000)
struct FCrouchUnderAnimRefs final
{
public:
	class UAnimSequence*                          CrouchUnderStandPatrol;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchUnderMoveChase;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrouchUnderAnimRefs) == 0x000008, "Wrong alignment on FCrouchUnderAnimRefs");
static_assert(sizeof(FCrouchUnderAnimRefs) == 0x000010, "Wrong size on FCrouchUnderAnimRefs");
static_assert(offsetof(FCrouchUnderAnimRefs, CrouchUnderStandPatrol) == 0x000000, "Member 'FCrouchUnderAnimRefs::CrouchUnderStandPatrol' has a wrong offset!");
static_assert(offsetof(FCrouchUnderAnimRefs, CrouchUnderMoveChase) == 0x000008, "Member 'FCrouchUnderAnimRefs::CrouchUnderMoveChase' has a wrong offset!");

// ScriptStruct OPP.VFXParams
// 0x00F0 (0x00F0 - 0x0000)
struct FVFXParams final
{
public:
	TMap<class FName, float>                      FloatParamaters;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             VectorParamaters;                                  // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        ColorParamaters;                                   // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVFXParams) == 0x000008, "Wrong alignment on FVFXParams");
static_assert(sizeof(FVFXParams) == 0x0000F0, "Wrong size on FVFXParams");
static_assert(offsetof(FVFXParams, FloatParamaters) == 0x000000, "Member 'FVFXParams::FloatParamaters' has a wrong offset!");
static_assert(offsetof(FVFXParams, VectorParamaters) == 0x000050, "Member 'FVFXParams::VectorParamaters' has a wrong offset!");
static_assert(offsetof(FVFXParams, ColorParamaters) == 0x0000A0, "Member 'FVFXParams::ColorParamaters' has a wrong offset!");

// ScriptStruct OPP.ItemSequences
// 0x0168 (0x0168 - 0x0000)
struct FItemSequences final
{
public:
	class UAnimSequence*                          HandPose;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HandPoseCrouching;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EnterTradePose;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ExitTradePose;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TradePose;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EnterTradePoseCrouching;                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ExitTradePoseCrouching;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TradePoseCrouching;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyStart;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyPose;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyStop;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyStartCrouching;                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyPoseCrouching;                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InteractReadyStopCrouching;                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InteractReadyRequiresLeftHand;                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActivelyUsingItemStart;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemPose;                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemStop;                             // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemAlternateStop;                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemStartCrouching;                   // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemPoseCrouching;                    // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemStopCrouching;                    // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActivelyUsingItemAlternateStopCrouching;           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Equip;                                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EquipCrouching;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnEquip;                                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnEquipCrouching;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pickup;                                            // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DefaultPickUpPose;                                 // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PutDownStanding;                                   // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PutDownCrouching;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ConsumeStanding;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ConsumeCrouching;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ConsumeHidespot;                                   // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ConsumeLoopHidespot;                               // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ThrowSequence;                                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ThrowSequenceCrouching;                            // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowStart;                                 // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowStartCrouching;                        // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowIdle;                                  // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowIdleCrouching;                         // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowStop;                                  // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RaiseToThrowStopCrouching;                         // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  Breakers;                                          // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSequences) == 0x000008, "Wrong alignment on FItemSequences");
static_assert(sizeof(FItemSequences) == 0x000168, "Wrong size on FItemSequences");
static_assert(offsetof(FItemSequences, HandPose) == 0x000000, "Member 'FItemSequences::HandPose' has a wrong offset!");
static_assert(offsetof(FItemSequences, HandPoseCrouching) == 0x000008, "Member 'FItemSequences::HandPoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, EnterTradePose) == 0x000010, "Member 'FItemSequences::EnterTradePose' has a wrong offset!");
static_assert(offsetof(FItemSequences, ExitTradePose) == 0x000018, "Member 'FItemSequences::ExitTradePose' has a wrong offset!");
static_assert(offsetof(FItemSequences, TradePose) == 0x000020, "Member 'FItemSequences::TradePose' has a wrong offset!");
static_assert(offsetof(FItemSequences, EnterTradePoseCrouching) == 0x000028, "Member 'FItemSequences::EnterTradePoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ExitTradePoseCrouching) == 0x000030, "Member 'FItemSequences::ExitTradePoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, TradePoseCrouching) == 0x000038, "Member 'FItemSequences::TradePoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyStart) == 0x000040, "Member 'FItemSequences::InteractReadyStart' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyPose) == 0x000048, "Member 'FItemSequences::InteractReadyPose' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyStop) == 0x000050, "Member 'FItemSequences::InteractReadyStop' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyStartCrouching) == 0x000058, "Member 'FItemSequences::InteractReadyStartCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyPoseCrouching) == 0x000060, "Member 'FItemSequences::InteractReadyPoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyStopCrouching) == 0x000068, "Member 'FItemSequences::InteractReadyStopCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, InteractReadyRequiresLeftHand) == 0x000070, "Member 'FItemSequences::InteractReadyRequiresLeftHand' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemStart) == 0x000078, "Member 'FItemSequences::ActivelyUsingItemStart' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemPose) == 0x000080, "Member 'FItemSequences::ActivelyUsingItemPose' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemStop) == 0x000088, "Member 'FItemSequences::ActivelyUsingItemStop' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemAlternateStop) == 0x000090, "Member 'FItemSequences::ActivelyUsingItemAlternateStop' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemStartCrouching) == 0x000098, "Member 'FItemSequences::ActivelyUsingItemStartCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemPoseCrouching) == 0x0000A0, "Member 'FItemSequences::ActivelyUsingItemPoseCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemStopCrouching) == 0x0000A8, "Member 'FItemSequences::ActivelyUsingItemStopCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ActivelyUsingItemAlternateStopCrouching) == 0x0000B0, "Member 'FItemSequences::ActivelyUsingItemAlternateStopCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, Equip) == 0x0000B8, "Member 'FItemSequences::Equip' has a wrong offset!");
static_assert(offsetof(FItemSequences, EquipCrouching) == 0x0000C0, "Member 'FItemSequences::EquipCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, UnEquip) == 0x0000C8, "Member 'FItemSequences::UnEquip' has a wrong offset!");
static_assert(offsetof(FItemSequences, UnEquipCrouching) == 0x0000D0, "Member 'FItemSequences::UnEquipCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, Pickup) == 0x0000D8, "Member 'FItemSequences::Pickup' has a wrong offset!");
static_assert(offsetof(FItemSequences, DefaultPickUpPose) == 0x0000E0, "Member 'FItemSequences::DefaultPickUpPose' has a wrong offset!");
static_assert(offsetof(FItemSequences, PutDownStanding) == 0x0000E8, "Member 'FItemSequences::PutDownStanding' has a wrong offset!");
static_assert(offsetof(FItemSequences, PutDownCrouching) == 0x0000F0, "Member 'FItemSequences::PutDownCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ConsumeStanding) == 0x0000F8, "Member 'FItemSequences::ConsumeStanding' has a wrong offset!");
static_assert(offsetof(FItemSequences, ConsumeCrouching) == 0x000100, "Member 'FItemSequences::ConsumeCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, ConsumeHidespot) == 0x000108, "Member 'FItemSequences::ConsumeHidespot' has a wrong offset!");
static_assert(offsetof(FItemSequences, ConsumeLoopHidespot) == 0x000110, "Member 'FItemSequences::ConsumeLoopHidespot' has a wrong offset!");
static_assert(offsetof(FItemSequences, ThrowSequence) == 0x000118, "Member 'FItemSequences::ThrowSequence' has a wrong offset!");
static_assert(offsetof(FItemSequences, ThrowSequenceCrouching) == 0x000120, "Member 'FItemSequences::ThrowSequenceCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowStart) == 0x000128, "Member 'FItemSequences::RaiseToThrowStart' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowStartCrouching) == 0x000130, "Member 'FItemSequences::RaiseToThrowStartCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowIdle) == 0x000138, "Member 'FItemSequences::RaiseToThrowIdle' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowIdleCrouching) == 0x000140, "Member 'FItemSequences::RaiseToThrowIdleCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowStop) == 0x000148, "Member 'FItemSequences::RaiseToThrowStop' has a wrong offset!");
static_assert(offsetof(FItemSequences, RaiseToThrowStopCrouching) == 0x000150, "Member 'FItemSequences::RaiseToThrowStopCrouching' has a wrong offset!");
static_assert(offsetof(FItemSequences, Breakers) == 0x000158, "Member 'FItemSequences::Breakers' has a wrong offset!");

// ScriptStruct OPP.GrabAttackData
// 0x01B8 (0x01B8 - 0x0000)
struct FGrabAttackData final
{
public:
	bool                                          bAllowGrabWithoutDamage;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPairedAnim                            EnterStand;                                        // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterCrouch;                                       // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterAbove;                                        // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingStandLeft;                              // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingStandRight;                             // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingProneLeft;                              // 0x0080(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingProneRight;                             // 0x0098(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingCrouch;                                 // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingContainer;                              // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedAnim                            EnterHidingBarrel;                                 // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGrabExitData                          Exits;                                             // 0x00F8(0x0060)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGrabExitData                          ToKnockdownExits;                                  // 0x0158(0x0060)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrabAttackData) == 0x000008, "Wrong alignment on FGrabAttackData");
static_assert(sizeof(FGrabAttackData) == 0x0001B8, "Wrong size on FGrabAttackData");
static_assert(offsetof(FGrabAttackData, bAllowGrabWithoutDamage) == 0x000000, "Member 'FGrabAttackData::bAllowGrabWithoutDamage' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterStand) == 0x000008, "Member 'FGrabAttackData::EnterStand' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterCrouch) == 0x000020, "Member 'FGrabAttackData::EnterCrouch' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterAbove) == 0x000038, "Member 'FGrabAttackData::EnterAbove' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingStandLeft) == 0x000050, "Member 'FGrabAttackData::EnterHidingStandLeft' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingStandRight) == 0x000068, "Member 'FGrabAttackData::EnterHidingStandRight' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingProneLeft) == 0x000080, "Member 'FGrabAttackData::EnterHidingProneLeft' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingProneRight) == 0x000098, "Member 'FGrabAttackData::EnterHidingProneRight' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingCrouch) == 0x0000B0, "Member 'FGrabAttackData::EnterHidingCrouch' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingContainer) == 0x0000C8, "Member 'FGrabAttackData::EnterHidingContainer' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, EnterHidingBarrel) == 0x0000E0, "Member 'FGrabAttackData::EnterHidingBarrel' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, Exits) == 0x0000F8, "Member 'FGrabAttackData::Exits' has a wrong offset!");
static_assert(offsetof(FGrabAttackData, ToKnockdownExits) == 0x000158, "Member 'FGrabAttackData::ToKnockdownExits' has a wrong offset!");

// ScriptStruct OPP.AdditiveFOVData
// 0x0018 (0x0018 - 0x0000)
struct FAdditiveFOVData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FOVCurve;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditiveFOVData) == 0x000008, "Wrong alignment on FAdditiveFOVData");
static_assert(sizeof(FAdditiveFOVData) == 0x000018, "Wrong size on FAdditiveFOVData");
static_assert(offsetof(FAdditiveFOVData, FOVCurve) == 0x000010, "Member 'FAdditiveFOVData::FOVCurve' has a wrong offset!");

// ScriptStruct OPP.NPCAttackSelectionParams
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FNPCAttackSelectionParams final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAttackSelectionParams) == 0x000008, "Wrong alignment on FNPCAttackSelectionParams");
static_assert(sizeof(FNPCAttackSelectionParams) == 0x000048, "Wrong size on FNPCAttackSelectionParams");

// ScriptStruct OPP.RBDoorReplacementData
// 0x0038 (0x0038 - 0x0000)
struct FRBDoorReplacementData final
{
public:
	bool                                          bRandomDirection;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseDirection;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveDoorFrame;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseLockPosition;                              // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ARBDoor>                 DoorToReplace;                                     // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DoorReplaceClass;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBDoorReplacementData) == 0x000008, "Wrong alignment on FRBDoorReplacementData");
static_assert(sizeof(FRBDoorReplacementData) == 0x000038, "Wrong size on FRBDoorReplacementData");
static_assert(offsetof(FRBDoorReplacementData, bRandomDirection) == 0x000000, "Member 'FRBDoorReplacementData::bRandomDirection' has a wrong offset!");
static_assert(offsetof(FRBDoorReplacementData, bInverseDirection) == 0x000001, "Member 'FRBDoorReplacementData::bInverseDirection' has a wrong offset!");
static_assert(offsetof(FRBDoorReplacementData, bRemoveDoorFrame) == 0x000002, "Member 'FRBDoorReplacementData::bRemoveDoorFrame' has a wrong offset!");
static_assert(offsetof(FRBDoorReplacementData, bInverseLockPosition) == 0x000003, "Member 'FRBDoorReplacementData::bInverseLockPosition' has a wrong offset!");
static_assert(offsetof(FRBDoorReplacementData, DoorToReplace) == 0x000008, "Member 'FRBDoorReplacementData::DoorToReplace' has a wrong offset!");
static_assert(offsetof(FRBDoorReplacementData, DoorReplaceClass) == 0x000030, "Member 'FRBDoorReplacementData::DoorReplaceClass' has a wrong offset!");

// ScriptStruct OPP.LocomotionStopOptions
// 0x0030 (0x0030 - 0x0000)
struct FLocomotionStopOptions final
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBlendOutDuration;                              // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomBlendOutDuration;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomAnimTurnCurve;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionStopOptions) == 0x000008, "Wrong alignment on FLocomotionStopOptions");
static_assert(sizeof(FLocomotionStopOptions) == 0x000030, "Wrong size on FLocomotionStopOptions");
static_assert(offsetof(FLocomotionStopOptions, Sequence) == 0x000000, "Member 'FLocomotionStopOptions::Sequence' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, BlendSpace) == 0x000008, "Member 'FLocomotionStopOptions::BlendSpace' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, Curve) == 0x000010, "Member 'FLocomotionStopOptions::Curve' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, MaxDistance) == 0x000018, "Member 'FLocomotionStopOptions::MaxDistance' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, MinDistance) == 0x00001C, "Member 'FLocomotionStopOptions::MinDistance' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, AutoBlendOutDuration) == 0x000020, "Member 'FLocomotionStopOptions::AutoBlendOutDuration' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, CustomBlendOutDuration) == 0x000024, "Member 'FLocomotionStopOptions::CustomBlendOutDuration' has a wrong offset!");
static_assert(offsetof(FLocomotionStopOptions, bCustomAnimTurnCurve) == 0x000028, "Member 'FLocomotionStopOptions::bCustomAnimTurnCurve' has a wrong offset!");

// ScriptStruct OPP.LocomotionAlternateModeAnimations
// 0x0060 (0x0060 - 0x0000)
struct FLocomotionAlternateModeAnimations final
{
public:
	class UAnimSequence*                          Start;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        StartBlendSpace;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Loop;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        LoopBlendSpace;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle;                                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        IdleBlendSpace;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocomotionStopOptions                 Stop;                                              // 0x0030(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionAlternateModeAnimations) == 0x000008, "Wrong alignment on FLocomotionAlternateModeAnimations");
static_assert(sizeof(FLocomotionAlternateModeAnimations) == 0x000060, "Wrong size on FLocomotionAlternateModeAnimations");
static_assert(offsetof(FLocomotionAlternateModeAnimations, Start) == 0x000000, "Member 'FLocomotionAlternateModeAnimations::Start' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, StartBlendSpace) == 0x000008, "Member 'FLocomotionAlternateModeAnimations::StartBlendSpace' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, Loop) == 0x000010, "Member 'FLocomotionAlternateModeAnimations::Loop' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, LoopBlendSpace) == 0x000018, "Member 'FLocomotionAlternateModeAnimations::LoopBlendSpace' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, Idle) == 0x000020, "Member 'FLocomotionAlternateModeAnimations::Idle' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, IdleBlendSpace) == 0x000028, "Member 'FLocomotionAlternateModeAnimations::IdleBlendSpace' has a wrong offset!");
static_assert(offsetof(FLocomotionAlternateModeAnimations, Stop) == 0x000030, "Member 'FLocomotionAlternateModeAnimations::Stop' has a wrong offset!");

// ScriptStruct OPP.AIDataBuildInfo
// 0x0010 (0x0010 - 0x0000)
struct FAIDataBuildInfo final
{
public:
	TArray<class URBNPCInterestPointComponent*>   InterestPoints;                                    // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDataBuildInfo) == 0x000008, "Wrong alignment on FAIDataBuildInfo");
static_assert(sizeof(FAIDataBuildInfo) == 0x000010, "Wrong size on FAIDataBuildInfo");
static_assert(offsetof(FAIDataBuildInfo, InterestPoints) == 0x000000, "Member 'FAIDataBuildInfo::InterestPoints' has a wrong offset!");

// ScriptStruct OPP.LocomotionTurnDirectionOptions
// 0x00A8 (0x00A8 - 0x0000)
struct FLocomotionTurnDirectionOptions final
{
public:
	TMap<ELocomotionTurnDirection, class UAnimSequence*> Sequences;                                         // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ELocomotionTurnDirection, class UBlendSpaceBase*> BlendSpaces;                                       // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCustomAnimTurnCurve;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionTurnDirectionOptions) == 0x000008, "Wrong alignment on FLocomotionTurnDirectionOptions");
static_assert(sizeof(FLocomotionTurnDirectionOptions) == 0x0000A8, "Wrong size on FLocomotionTurnDirectionOptions");
static_assert(offsetof(FLocomotionTurnDirectionOptions, Sequences) == 0x000000, "Member 'FLocomotionTurnDirectionOptions::Sequences' has a wrong offset!");
static_assert(offsetof(FLocomotionTurnDirectionOptions, BlendSpaces) == 0x000050, "Member 'FLocomotionTurnDirectionOptions::BlendSpaces' has a wrong offset!");
static_assert(offsetof(FLocomotionTurnDirectionOptions, bCustomAnimTurnCurve) == 0x0000A0, "Member 'FLocomotionTurnDirectionOptions::bCustomAnimTurnCurve' has a wrong offset!");

// ScriptStruct OPP.LocomotionStartleSpeedOptions
// 0x0050 (0x0050 - 0x0000)
struct FLocomotionStartleSpeedOptions final
{
public:
	TMap<EStartleSpeed, struct FLocomotionTurnDirectionOptions> Options;                                           // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionStartleSpeedOptions) == 0x000008, "Wrong alignment on FLocomotionStartleSpeedOptions");
static_assert(sizeof(FLocomotionStartleSpeedOptions) == 0x000050, "Wrong size on FLocomotionStartleSpeedOptions");
static_assert(offsetof(FLocomotionStartleSpeedOptions, Options) == 0x000000, "Member 'FLocomotionStartleSpeedOptions::Options' has a wrong offset!");

// ScriptStruct OPP.RuntimeStageInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FRuntimeStageInfo final
{
public:
	struct FRBGameStageInfo                       GameStageInfo;                                     // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
	float                                         StartedTime;                                       // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attempts;                                          // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucceeded;                                        // 0x00C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               Survivors;                                         // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeStageInfo) == 0x000008, "Wrong alignment on FRuntimeStageInfo");
static_assert(sizeof(FRuntimeStageInfo) == 0x0000D8, "Wrong size on FRuntimeStageInfo");
static_assert(offsetof(FRuntimeStageInfo, GameStageInfo) == 0x000000, "Member 'FRuntimeStageInfo::GameStageInfo' has a wrong offset!");
static_assert(offsetof(FRuntimeStageInfo, StartedTime) == 0x0000B8, "Member 'FRuntimeStageInfo::StartedTime' has a wrong offset!");
static_assert(offsetof(FRuntimeStageInfo, EndTime) == 0x0000BC, "Member 'FRuntimeStageInfo::EndTime' has a wrong offset!");
static_assert(offsetof(FRuntimeStageInfo, Attempts) == 0x0000C0, "Member 'FRuntimeStageInfo::Attempts' has a wrong offset!");
static_assert(offsetof(FRuntimeStageInfo, bSucceeded) == 0x0000C4, "Member 'FRuntimeStageInfo::bSucceeded' has a wrong offset!");
static_assert(offsetof(FRuntimeStageInfo, Survivors) == 0x0000C8, "Member 'FRuntimeStageInfo::Survivors' has a wrong offset!");

// ScriptStruct OPP.PairedAdjustmentParameters
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FPairedAdjustmentParameters final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPairedAdjustmentParameters) == 0x000004, "Wrong alignment on FPairedAdjustmentParameters");
static_assert(sizeof(FPairedAdjustmentParameters) == 0x000010, "Wrong size on FPairedAdjustmentParameters");

// ScriptStruct OPP.SpecialMoveParameters
// 0x00D8 (0x00D8 - 0x0000)
struct FSpecialMoveParameters final
{
public:
	struct FGameplayParams                        GP;                                                // 0x0000(0x0068)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ELocomotionMode                               NextLocomotionMode;                                // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMode                               InterruptLocomotionMode;                           // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMode                               CompletesLocomotionMode;                           // 0x006A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperBody;                                        // 0x006B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperBodyAdditive;                                // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionMode                               SpecialMoveLocomotionMode;                         // 0x006D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustPosition;                                   // 0x006E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnimAfterAdjustPosition;                      // 0x006F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustPositionTimeLeftAnimationTrigger;            // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportCrouchStateChange;                         // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitOnBlendOut;                                   // 0x0075(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysInterruptible;                              // 0x0076(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptibleByChoice;                            // 0x0077(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerHitReactionType                        InterruptibleByHitReaction;                        // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingProceduralMotion;                            // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepExitMomentum;                                 // 0x007A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMoving;                                       // 0x007B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixedDuration;                                    // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimTimeForPositionAdjustment;                 // 0x007D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePawnVelocityForPositionning;                   // 0x007E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepCameraYawWhileAdjusting;                      // 0x007F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepCameraYawWhileRootMotion;                     // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionningLinearVelocity;                        // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionningAngularVelocity;                       // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPositionningTime;                               // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeForUpwardsCorrections;                      // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriggeringStimulusType                       StimulusType;                                      // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropLargeObject;                                  // 0x0095(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepCrouchedState;                                // 0x0096(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCradleLargeObject;                                // 0x0097(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPathBlocking;                                // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearInteractionOnCompleted;                      // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMove                                  PairedMove;                                        // 0x009A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPairedAdjustmentParameters            PairedAdjustParams;                                // 0x009C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPairedCollision;                                  // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreFailSafeTimer;                              // 0x00AD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCrouchDuringSpecialMove;                       // 0x00AE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchAfterSpecialMove;                           // 0x00AF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FailsafeDuration;                                  // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerZeroRootMotionDisableAnimationDelay;         // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AjustmentDuration;                                 // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x00BC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDirection;                                   // 0x00C8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelOnFailedAdjustment;                         // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSpecialMoveNetCorrection;                      // 0x00D5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeRootMotionFromAnimation;                   // 0x00D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetWaitingForMoveInputRelease;                  // 0x00D7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialMoveParameters) == 0x000004, "Wrong alignment on FSpecialMoveParameters");
static_assert(sizeof(FSpecialMoveParameters) == 0x0000D8, "Wrong size on FSpecialMoveParameters");
static_assert(offsetof(FSpecialMoveParameters, GP) == 0x000000, "Member 'FSpecialMoveParameters::GP' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, NextLocomotionMode) == 0x000068, "Member 'FSpecialMoveParameters::NextLocomotionMode' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, InterruptLocomotionMode) == 0x000069, "Member 'FSpecialMoveParameters::InterruptLocomotionMode' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, CompletesLocomotionMode) == 0x00006A, "Member 'FSpecialMoveParameters::CompletesLocomotionMode' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUpperBody) == 0x00006B, "Member 'FSpecialMoveParameters::bUpperBody' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUpperBodyAdditive) == 0x00006C, "Member 'FSpecialMoveParameters::bUpperBodyAdditive' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, SpecialMoveLocomotionMode) == 0x00006D, "Member 'FSpecialMoveParameters::SpecialMoveLocomotionMode' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bAdjustPosition) == 0x00006E, "Member 'FSpecialMoveParameters::bAdjustPosition' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bPlayAnimAfterAdjustPosition) == 0x00006F, "Member 'FSpecialMoveParameters::bPlayAnimAfterAdjustPosition' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, AdjustPositionTimeLeftAnimationTrigger) == 0x000070, "Member 'FSpecialMoveParameters::AdjustPositionTimeLeftAnimationTrigger' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bSupportCrouchStateChange) == 0x000074, "Member 'FSpecialMoveParameters::bSupportCrouchStateChange' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bExitOnBlendOut) == 0x000075, "Member 'FSpecialMoveParameters::bExitOnBlendOut' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bAlwaysInterruptible) == 0x000076, "Member 'FSpecialMoveParameters::bAlwaysInterruptible' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bInterruptibleByChoice) == 0x000077, "Member 'FSpecialMoveParameters::bInterruptibleByChoice' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, InterruptibleByHitReaction) == 0x000078, "Member 'FSpecialMoveParameters::InterruptibleByHitReaction' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUsingProceduralMotion) == 0x000079, "Member 'FSpecialMoveParameters::bUsingProceduralMotion' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bKeepExitMomentum) == 0x00007A, "Member 'FSpecialMoveParameters::bKeepExitMomentum' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bStopMoving) == 0x00007B, "Member 'FSpecialMoveParameters::bStopMoving' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bFixedDuration) == 0x00007C, "Member 'FSpecialMoveParameters::bFixedDuration' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUseAnimTimeForPositionAdjustment) == 0x00007D, "Member 'FSpecialMoveParameters::bUseAnimTimeForPositionAdjustment' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUsePawnVelocityForPositionning) == 0x00007E, "Member 'FSpecialMoveParameters::bUsePawnVelocityForPositionning' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bKeepCameraYawWhileAdjusting) == 0x00007F, "Member 'FSpecialMoveParameters::bKeepCameraYawWhileAdjusting' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bKeepCameraYawWhileRootMotion) == 0x000080, "Member 'FSpecialMoveParameters::bKeepCameraYawWhileRootMotion' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, PositionningLinearVelocity) == 0x000084, "Member 'FSpecialMoveParameters::PositionningLinearVelocity' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, PositionningAngularVelocity) == 0x000088, "Member 'FSpecialMoveParameters::PositionningAngularVelocity' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, MaxPositionningTime) == 0x00008C, "Member 'FSpecialMoveParameters::MaxPositionningTime' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, MaxTimeForUpwardsCorrections) == 0x000090, "Member 'FSpecialMoveParameters::MaxTimeForUpwardsCorrections' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, StimulusType) == 0x000094, "Member 'FSpecialMoveParameters::StimulusType' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bDropLargeObject) == 0x000095, "Member 'FSpecialMoveParameters::bDropLargeObject' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bKeepCrouchedState) == 0x000096, "Member 'FSpecialMoveParameters::bKeepCrouchedState' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bCradleLargeObject) == 0x000097, "Member 'FSpecialMoveParameters::bCradleLargeObject' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bAllowPathBlocking) == 0x000098, "Member 'FSpecialMoveParameters::bAllowPathBlocking' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bClearInteractionOnCompleted) == 0x000099, "Member 'FSpecialMoveParameters::bClearInteractionOnCompleted' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, PairedMove) == 0x00009A, "Member 'FSpecialMoveParameters::PairedMove' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, PairedAdjustParams) == 0x00009C, "Member 'FSpecialMoveParameters::PairedAdjustParams' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bPairedCollision) == 0x0000AC, "Member 'FSpecialMoveParameters::bPairedCollision' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bIgnoreFailSafeTimer) == 0x0000AD, "Member 'FSpecialMoveParameters::bIgnoreFailSafeTimer' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bCanCrouchDuringSpecialMove) == 0x0000AE, "Member 'FSpecialMoveParameters::bCanCrouchDuringSpecialMove' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bCrouchAfterSpecialMove) == 0x0000AF, "Member 'FSpecialMoveParameters::bCrouchAfterSpecialMove' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, FailsafeDuration) == 0x0000B0, "Member 'FSpecialMoveParameters::FailsafeDuration' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, ServerZeroRootMotionDisableAnimationDelay) == 0x0000B4, "Member 'FSpecialMoveParameters::ServerZeroRootMotionDisableAnimationDelay' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, AjustmentDuration) == 0x0000B8, "Member 'FSpecialMoveParameters::AjustmentDuration' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, TargetLocation) == 0x0000BC, "Member 'FSpecialMoveParameters::TargetLocation' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, TargetDirection) == 0x0000C8, "Member 'FSpecialMoveParameters::TargetDirection' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bCancelOnFailedAdjustment) == 0x0000D4, "Member 'FSpecialMoveParameters::bCancelOnFailedAdjustment' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bUseSpecialMoveNetCorrection) == 0x0000D5, "Member 'FSpecialMoveParameters::bUseSpecialMoveNetCorrection' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bComputeRootMotionFromAnimation) == 0x0000D6, "Member 'FSpecialMoveParameters::bComputeRootMotionFromAnimation' has a wrong offset!");
static_assert(offsetof(FSpecialMoveParameters, bResetWaitingForMoveInputRelease) == 0x0000D7, "Member 'FSpecialMoveParameters::bResetWaitingForMoveInputRelease' has a wrong offset!");

// ScriptStruct OPP.InternalBoolByDifficulty
// 0x0008 (0x0008 - 0x0000)
struct FInternalBoolByDifficulty final
{
public:
	bool                                          bOverrideEasyLocalValue;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EasyLocalValue;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNormalLocalValue;                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NormalLocalValue;                                  // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHardLocalValue;                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HardLocalValue;                                    // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInsaneLocalValue;                         // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InsaneLocalValue;                                  // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInternalBoolByDifficulty) == 0x000001, "Wrong alignment on FInternalBoolByDifficulty");
static_assert(sizeof(FInternalBoolByDifficulty) == 0x000008, "Wrong size on FInternalBoolByDifficulty");
static_assert(offsetof(FInternalBoolByDifficulty, bOverrideEasyLocalValue) == 0x000000, "Member 'FInternalBoolByDifficulty::bOverrideEasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, EasyLocalValue) == 0x000001, "Member 'FInternalBoolByDifficulty::EasyLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, bOverrideNormalLocalValue) == 0x000002, "Member 'FInternalBoolByDifficulty::bOverrideNormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, NormalLocalValue) == 0x000003, "Member 'FInternalBoolByDifficulty::NormalLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, bOverrideHardLocalValue) == 0x000004, "Member 'FInternalBoolByDifficulty::bOverrideHardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, HardLocalValue) == 0x000005, "Member 'FInternalBoolByDifficulty::HardLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, bOverrideInsaneLocalValue) == 0x000006, "Member 'FInternalBoolByDifficulty::bOverrideInsaneLocalValue' has a wrong offset!");
static_assert(offsetof(FInternalBoolByDifficulty, InsaneLocalValue) == 0x000007, "Member 'FInternalBoolByDifficulty::InsaneLocalValue' has a wrong offset!");

// ScriptStruct OPP.ConfigurableBool
// 0x0028 (0x0060 - 0x0038)
struct FConfigurableBool final : public FConfigurableValue
{
public:
	struct FInternalBoolByDifficulty              DefaultValues;                                     // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor1P;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInternalBoolByDifficulty              Values1P;                                          // 0x0041(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor2P;                               // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInternalBoolByDifficulty              Values2P;                                          // 0x004A(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOverrideFor3P;                               // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInternalBoolByDifficulty              Values3P;                                          // 0x0053(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConfigurableBool) == 0x000008, "Wrong alignment on FConfigurableBool");
static_assert(sizeof(FConfigurableBool) == 0x000060, "Wrong size on FConfigurableBool");
static_assert(offsetof(FConfigurableBool, DefaultValues) == 0x000038, "Member 'FConfigurableBool::DefaultValues' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, bLocalOverrideFor1P) == 0x000040, "Member 'FConfigurableBool::bLocalOverrideFor1P' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, Values1P) == 0x000041, "Member 'FConfigurableBool::Values1P' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, bLocalOverrideFor2P) == 0x000049, "Member 'FConfigurableBool::bLocalOverrideFor2P' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, Values2P) == 0x00004A, "Member 'FConfigurableBool::Values2P' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, bLocalOverrideFor3P) == 0x000052, "Member 'FConfigurableBool::bLocalOverrideFor3P' has a wrong offset!");
static_assert(offsetof(FConfigurableBool, Values3P) == 0x000053, "Member 'FConfigurableBool::Values3P' has a wrong offset!");

// ScriptStruct OPP.LocomotionStartleSelector
// 0x0003 (0x0003 - 0x0000)
struct FLocomotionStartleSelector final
{
public:
	EStartleType                                  Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartleVariation                             Variation;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartleSpeed                                 Speed;                                             // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionStartleSelector) == 0x000001, "Wrong alignment on FLocomotionStartleSelector");
static_assert(sizeof(FLocomotionStartleSelector) == 0x000003, "Wrong size on FLocomotionStartleSelector");
static_assert(offsetof(FLocomotionStartleSelector, Type) == 0x000000, "Member 'FLocomotionStartleSelector::Type' has a wrong offset!");
static_assert(offsetof(FLocomotionStartleSelector, Variation) == 0x000001, "Member 'FLocomotionStartleSelector::Variation' has a wrong offset!");
static_assert(offsetof(FLocomotionStartleSelector, Speed) == 0x000002, "Member 'FLocomotionStartleSelector::Speed' has a wrong offset!");

// ScriptStruct OPP.LocomotionStopDirectionOptions
// 0x0050 (0x0050 - 0x0000)
struct FLocomotionStopDirectionOptions final
{
public:
	TMap<ELocomotionTurnDirection, struct FLocomotionStopOptions> Sequences;                                         // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionStopDirectionOptions) == 0x000008, "Wrong alignment on FLocomotionStopDirectionOptions");
static_assert(sizeof(FLocomotionStopDirectionOptions) == 0x000050, "Wrong size on FLocomotionStopDirectionOptions");
static_assert(offsetof(FLocomotionStopDirectionOptions, Sequences) == 0x000000, "Member 'FLocomotionStopDirectionOptions::Sequences' has a wrong offset!");

// ScriptStruct OPP.RBAnimLengthStruct
// 0x0004 (0x0004 - 0x0000)
struct FRBAnimLengthStruct final
{
public:
	float                                         AnimationLength;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBAnimLengthStruct) == 0x000004, "Wrong alignment on FRBAnimLengthStruct");
static_assert(sizeof(FRBAnimLengthStruct) == 0x000004, "Wrong size on FRBAnimLengthStruct");
static_assert(offsetof(FRBAnimLengthStruct, AnimationLength) == 0x000000, "Member 'FRBAnimLengthStruct::AnimationLength' has a wrong offset!");

// ScriptStruct OPP.QuickGraph
// 0x0028 (0x0028 - 0x0000)
struct FQuickGraph final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuickGraphEntry>               Entries;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuickGraph) == 0x000008, "Wrong alignment on FQuickGraph");
static_assert(sizeof(FQuickGraph) == 0x000028, "Wrong size on FQuickGraph");
static_assert(offsetof(FQuickGraph, Entries) == 0x000008, "Member 'FQuickGraph::Entries' has a wrong offset!");

// ScriptStruct OPP.MultiPositionGroupSwapEvent
// 0x0018 (0x0018 - 0x0000)
struct FMultiPositionGroupSwapEvent final
{
public:
	class URBSoundComponent*                      Member;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiPositionGroupSwapEvent) == 0x000008, "Wrong alignment on FMultiPositionGroupSwapEvent");
static_assert(sizeof(FMultiPositionGroupSwapEvent) == 0x000018, "Wrong size on FMultiPositionGroupSwapEvent");
static_assert(offsetof(FMultiPositionGroupSwapEvent, Member) == 0x000000, "Member 'FMultiPositionGroupSwapEvent::Member' has a wrong offset!");

// ScriptStruct OPP.FXPostProcessData
// 0x0010 (0x0010 - 0x0000)
struct FFXPostProcessData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Material;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFXPostProcessData) == 0x000008, "Wrong alignment on FFXPostProcessData");
static_assert(sizeof(FFXPostProcessData) == 0x000010, "Wrong size on FFXPostProcessData");
static_assert(offsetof(FFXPostProcessData, Material) == 0x000008, "Member 'FFXPostProcessData::Material' has a wrong offset!");

// ScriptStruct OPP.AudioPathSearchContext
// 0x0030 (0x0030 - 0x0000)
struct FAudioPathSearchContext final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBSoundConnectorComponent*>     DestinationConnectors;                             // 0x0020(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioPathSearchContext) == 0x000008, "Wrong alignment on FAudioPathSearchContext");
static_assert(sizeof(FAudioPathSearchContext) == 0x000030, "Wrong size on FAudioPathSearchContext");
static_assert(offsetof(FAudioPathSearchContext, DestinationConnectors) == 0x000020, "Member 'FAudioPathSearchContext::DestinationConnectors' has a wrong offset!");

// ScriptStruct OPP.QuestItemRuntimeInfo
// 0x0020 (0x0020 - 0x0000)
struct FQuestItemRuntimeInfo final
{
public:
	class AActor*                                 ItemSpawner;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPickup*                              SpawnedObjectiveItem;                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBPickup>                  QuestItemClass;                                    // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickedUp;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSpawner;                                        // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsed;                                             // 0x001A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptyContainer;                                 // 0x001B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestItemRuntimeInfo) == 0x000008, "Wrong alignment on FQuestItemRuntimeInfo");
static_assert(sizeof(FQuestItemRuntimeInfo) == 0x000020, "Wrong size on FQuestItemRuntimeInfo");
static_assert(offsetof(FQuestItemRuntimeInfo, ItemSpawner) == 0x000000, "Member 'FQuestItemRuntimeInfo::ItemSpawner' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, SpawnedObjectiveItem) == 0x000008, "Member 'FQuestItemRuntimeInfo::SpawnedObjectiveItem' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, QuestItemClass) == 0x000010, "Member 'FQuestItemRuntimeInfo::QuestItemClass' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, bPickedUp) == 0x000018, "Member 'FQuestItemRuntimeInfo::bPickedUp' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, bInSpawner) == 0x000019, "Member 'FQuestItemRuntimeInfo::bInSpawner' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, bUsed) == 0x00001A, "Member 'FQuestItemRuntimeInfo::bUsed' has a wrong offset!");
static_assert(offsetof(FQuestItemRuntimeInfo, bIsEmptyContainer) == 0x00001B, "Member 'FQuestItemRuntimeInfo::bIsEmptyContainer' has a wrong offset!");

// ScriptStruct OPP.AudioPathSearchNode
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAudioPathSearchNode final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioPathSearchNode) == 0x000008, "Wrong alignment on FAudioPathSearchNode");
static_assert(sizeof(FAudioPathSearchNode) == 0x000020, "Wrong size on FAudioPathSearchNode");

// ScriptStruct OPP.NPCCapabilities
// 0x0014 (0x0014 - 0x0000)
struct FNPCCapabilities final
{
public:
	bool                                          bSupportsCustomization;                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayAnimatedStarts;                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayAnimatedStops;                             // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanClimbUpLedges;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDropDownLedges;                                // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOpenDoors;                                     // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCloseDoors;                                    // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUnlockDoors;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanLockDoors;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseKickToBreakDoors;                              // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDestroyPathObstacles;                          // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDestroyDynamicObstacles;                       // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCrouchUnder;                                   // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayAttackSelectors;                           // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGrabPlayers;                                   // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayHitReactions;                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayCycleBreakers;                             // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPullOutFromHidespots;                          // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStopActiveTraps;                               // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCCapabilities) == 0x000001, "Wrong alignment on FNPCCapabilities");
static_assert(sizeof(FNPCCapabilities) == 0x000014, "Wrong size on FNPCCapabilities");
static_assert(offsetof(FNPCCapabilities, bSupportsCustomization) == 0x000000, "Member 'FNPCCapabilities::bSupportsCustomization' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPlayAnimatedStarts) == 0x000001, "Member 'FNPCCapabilities::bCanPlayAnimatedStarts' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPlayAnimatedStops) == 0x000002, "Member 'FNPCCapabilities::bCanPlayAnimatedStops' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanStrafe) == 0x000003, "Member 'FNPCCapabilities::bCanStrafe' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanClimbUpLedges) == 0x000004, "Member 'FNPCCapabilities::bCanClimbUpLedges' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanDropDownLedges) == 0x000005, "Member 'FNPCCapabilities::bCanDropDownLedges' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanOpenDoors) == 0x000006, "Member 'FNPCCapabilities::bCanOpenDoors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanCloseDoors) == 0x000007, "Member 'FNPCCapabilities::bCanCloseDoors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanUnlockDoors) == 0x000008, "Member 'FNPCCapabilities::bCanUnlockDoors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanLockDoors) == 0x000009, "Member 'FNPCCapabilities::bCanLockDoors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bUseKickToBreakDoors) == 0x00000A, "Member 'FNPCCapabilities::bUseKickToBreakDoors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanDestroyPathObstacles) == 0x00000B, "Member 'FNPCCapabilities::bCanDestroyPathObstacles' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanDestroyDynamicObstacles) == 0x00000C, "Member 'FNPCCapabilities::bCanDestroyDynamicObstacles' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanCrouchUnder) == 0x00000D, "Member 'FNPCCapabilities::bCanCrouchUnder' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPlayAttackSelectors) == 0x00000E, "Member 'FNPCCapabilities::bCanPlayAttackSelectors' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanGrabPlayers) == 0x00000F, "Member 'FNPCCapabilities::bCanGrabPlayers' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPlayHitReactions) == 0x000010, "Member 'FNPCCapabilities::bCanPlayHitReactions' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPlayCycleBreakers) == 0x000011, "Member 'FNPCCapabilities::bCanPlayCycleBreakers' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanPullOutFromHidespots) == 0x000012, "Member 'FNPCCapabilities::bCanPullOutFromHidespots' has a wrong offset!");
static_assert(offsetof(FNPCCapabilities, bCanStopActiveTraps) == 0x000013, "Member 'FNPCCapabilities::bCanStopActiveTraps' has a wrong offset!");

// ScriptStruct OPP.AudioPathConnection
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAudioPathConnection final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioPathConnection) == 0x000008, "Wrong alignment on FAudioPathConnection");
static_assert(sizeof(FAudioPathConnection) == 0x000010, "Wrong size on FAudioPathConnection");

// ScriptStruct OPP.MusicEventInfo
// 0x0020 (0x0020 - 0x0000)
struct FMusicEventInfo final
{
public:
	EMusicEventType                               EventType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventDesc;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventRealTime;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMusicEventInfo) == 0x000008, "Wrong alignment on FMusicEventInfo");
static_assert(sizeof(FMusicEventInfo) == 0x000020, "Wrong size on FMusicEventInfo");
static_assert(offsetof(FMusicEventInfo, EventType) == 0x000000, "Member 'FMusicEventInfo::EventType' has a wrong offset!");
static_assert(offsetof(FMusicEventInfo, EventDesc) == 0x000008, "Member 'FMusicEventInfo::EventDesc' has a wrong offset!");
static_assert(offsetof(FMusicEventInfo, EventRealTime) == 0x000018, "Member 'FMusicEventInfo::EventRealTime' has a wrong offset!");

// ScriptStruct OPP.DualSidedEmitterTransaction
// 0x0010 (0x0010 - 0x0000)
struct FDualSidedEmitterTransaction final
{
public:
	class URBSoundComponent*                      SoundEmitter;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBSoundConnectorComponent*             SoundConnector;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDualSidedEmitterTransaction) == 0x000008, "Wrong alignment on FDualSidedEmitterTransaction");
static_assert(sizeof(FDualSidedEmitterTransaction) == 0x000010, "Wrong size on FDualSidedEmitterTransaction");
static_assert(offsetof(FDualSidedEmitterTransaction, SoundEmitter) == 0x000000, "Member 'FDualSidedEmitterTransaction::SoundEmitter' has a wrong offset!");
static_assert(offsetof(FDualSidedEmitterTransaction, SoundConnector) == 0x000008, "Member 'FDualSidedEmitterTransaction::SoundConnector' has a wrong offset!");

// ScriptStruct OPP.RTPCActorDebugInfo
// 0x0050 (0x0050 - 0x0000)
struct FRTPCActorDebugInfo final
{
public:
	TMap<TSoftObjectPtr<class UAkComponent>, struct FRTPCComponentDebugInfo> RTPCComponentInfo;                                 // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRTPCActorDebugInfo) == 0x000008, "Wrong alignment on FRTPCActorDebugInfo");
static_assert(sizeof(FRTPCActorDebugInfo) == 0x000050, "Wrong size on FRTPCActorDebugInfo");
static_assert(offsetof(FRTPCActorDebugInfo, RTPCComponentInfo) == 0x000000, "Member 'FRTPCActorDebugInfo::RTPCComponentInfo' has a wrong offset!");

// ScriptStruct OPP.MultiPositionGroup
// 0x0030 (0x0030 - 0x0000)
struct FMultiPositionGroup final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBSoundComponent*>              Members;                                           // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class URBSoundComponent*>              ClosestEmitters;                                   // 0x0018(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiPositionGroup) == 0x000008, "Wrong alignment on FMultiPositionGroup");
static_assert(sizeof(FMultiPositionGroup) == 0x000030, "Wrong size on FMultiPositionGroup");
static_assert(offsetof(FMultiPositionGroup, Members) == 0x000008, "Member 'FMultiPositionGroup::Members' has a wrong offset!");
static_assert(offsetof(FMultiPositionGroup, ClosestEmitters) == 0x000018, "Member 'FMultiPositionGroup::ClosestEmitters' has a wrong offset!");

// ScriptStruct OPP.SoundPathingContextInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FSoundPathingContextInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundPathingContextInfo) == 0x000004, "Wrong alignment on FSoundPathingContextInfo");
static_assert(sizeof(FSoundPathingContextInfo) == 0x000028, "Wrong size on FSoundPathingContextInfo");

// ScriptStruct OPP.RBComponentSelector
// 0x0040 (0x0040 - 0x0000)
struct FRBComponentSelector final
{
public:
	TSubclassOf<class UActorComponent>            SpecificComponentClass;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  TargetActor;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ActorComponent;                                    // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRBComponentSelector) == 0x000008, "Wrong alignment on FRBComponentSelector");
static_assert(sizeof(FRBComponentSelector) == 0x000040, "Wrong size on FRBComponentSelector");
static_assert(offsetof(FRBComponentSelector, SpecificComponentClass) == 0x000000, "Member 'FRBComponentSelector::SpecificComponentClass' has a wrong offset!");
static_assert(offsetof(FRBComponentSelector, TargetActor) == 0x000008, "Member 'FRBComponentSelector::TargetActor' has a wrong offset!");
static_assert(offsetof(FRBComponentSelector, ComponentName) == 0x000030, "Member 'FRBComponentSelector::ComponentName' has a wrong offset!");
static_assert(offsetof(FRBComponentSelector, ActorComponent) == 0x000038, "Member 'FRBComponentSelector::ActorComponent' has a wrong offset!");

// ScriptStruct OPP.SoundTriggerEvent
// 0x0010 (0x0010 - 0x0000)
struct FSoundTriggerEvent final
{
public:
	class UAkAudioEvent*                          EnterEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ExitEvent;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundTriggerEvent) == 0x000008, "Wrong alignment on FSoundTriggerEvent");
static_assert(sizeof(FSoundTriggerEvent) == 0x000010, "Wrong size on FSoundTriggerEvent");
static_assert(offsetof(FSoundTriggerEvent, EnterEvent) == 0x000000, "Member 'FSoundTriggerEvent::EnterEvent' has a wrong offset!");
static_assert(offsetof(FSoundTriggerEvent, ExitEvent) == 0x000008, "Member 'FSoundTriggerEvent::ExitEvent' has a wrong offset!");

// ScriptStruct OPP.BCAnimatedStopData
// 0x0050 (0x0050 - 0x0000)
struct FBCAnimatedStopData final
{
public:
	class UAnimSequence*                          RefStopAnim;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBCAnimatedStopData) == 0x000008, "Wrong alignment on FBCAnimatedStopData");
static_assert(sizeof(FBCAnimatedStopData) == 0x000050, "Wrong size on FBCAnimatedStopData");
static_assert(offsetof(FBCAnimatedStopData, RefStopAnim) == 0x000000, "Member 'FBCAnimatedStopData::RefStopAnim' has a wrong offset!");

// ScriptStruct OPP.RandomStationData
// 0x0010 (0x0010 - 0x0000)
struct FRandomStationData final
{
public:
	class ARBRandomPathMarker*                    PathMarker;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomStationData) == 0x000008, "Wrong alignment on FRandomStationData");
static_assert(sizeof(FRandomStationData) == 0x000010, "Wrong size on FRandomStationData");
static_assert(offsetof(FRandomStationData, PathMarker) == 0x000000, "Member 'FRandomStationData::PathMarker' has a wrong offset!");

// ScriptStruct OPP.RBBattlePassData
// 0x0130 (0x0130 - 0x0000)
struct FRBBattlePassData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   HeaderText;                                        // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   SeasonText;                                        // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Poster;                                            // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Header;                                            // 0x0078(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PopupBackground;                                   // 0x00A0(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainColor;                                         // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeaderColor;                                       // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockItemId;                                      // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 UnlockCurrencyType;                                // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockCurrencyCost;                                // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimeLimited;                                      // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBBattlePassPageData>          Pages;                                             // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FRBBattlePassPageItemData>      Items;                                             // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBattlePassData) == 0x000008, "Wrong alignment on FRBBattlePassData");
static_assert(sizeof(FRBBattlePassData) == 0x000130, "Wrong size on FRBBattlePassData");
static_assert(offsetof(FRBBattlePassData, ID) == 0x000000, "Member 'FRBBattlePassData::ID' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, Name) == 0x000008, "Member 'FRBBattlePassData::Name' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, HeaderText) == 0x000020, "Member 'FRBBattlePassData::HeaderText' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, SeasonText) == 0x000038, "Member 'FRBBattlePassData::SeasonText' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, Poster) == 0x000050, "Member 'FRBBattlePassData::Poster' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, Header) == 0x000078, "Member 'FRBBattlePassData::Header' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, PopupBackground) == 0x0000A0, "Member 'FRBBattlePassData::PopupBackground' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, MainColor) == 0x0000C8, "Member 'FRBBattlePassData::MainColor' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, HeaderColor) == 0x0000D8, "Member 'FRBBattlePassData::HeaderColor' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, FeatureSwitch) == 0x0000E8, "Member 'FRBBattlePassData::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, UnlockItemId) == 0x0000F8, "Member 'FRBBattlePassData::UnlockItemId' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, UnlockCurrencyType) == 0x000100, "Member 'FRBBattlePassData::UnlockCurrencyType' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, UnlockCurrencyCost) == 0x000104, "Member 'FRBBattlePassData::UnlockCurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, bTimeLimited) == 0x000108, "Member 'FRBBattlePassData::bTimeLimited' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, Pages) == 0x000110, "Member 'FRBBattlePassData::Pages' has a wrong offset!");
static_assert(offsetof(FRBBattlePassData, Items) == 0x000120, "Member 'FRBBattlePassData::Items' has a wrong offset!");

// ScriptStruct OPP.BlockableLink
// 0x0048 (0x0048 - 0x0000)
struct FBlockableLink final
{
public:
	int32                                         BlockableLinkId;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlockableLinkType                            LinkType;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          SoftLinkedBlockables;                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  LinkingActor;                                      // 0x0020(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockableLink) == 0x000008, "Wrong alignment on FBlockableLink");
static_assert(sizeof(FBlockableLink) == 0x000048, "Wrong size on FBlockableLink");
static_assert(offsetof(FBlockableLink, BlockableLinkId) == 0x000000, "Member 'FBlockableLink::BlockableLinkId' has a wrong offset!");
static_assert(offsetof(FBlockableLink, LinkType) == 0x000004, "Member 'FBlockableLink::LinkType' has a wrong offset!");
static_assert(offsetof(FBlockableLink, SoftLinkedBlockables) == 0x000008, "Member 'FBlockableLink::SoftLinkedBlockables' has a wrong offset!");
static_assert(offsetof(FBlockableLink, Count) == 0x000018, "Member 'FBlockableLink::Count' has a wrong offset!");
static_assert(offsetof(FBlockableLink, LinkingActor) == 0x000020, "Member 'FBlockableLink::LinkingActor' has a wrong offset!");

// ScriptStruct OPP.LeashData
// 0x0038 (0x0038 - 0x0000)
struct FLeashData final
{
public:
	TArray<class AVolume*>                        LeashVolumes;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsBotOutsideLeash;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsideredOutsideLeash;                         // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutsideLeashStartTime;                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsideredOutsideLeashStartTime;                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastInsideLeashPosition;                           // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBRoom*                                LastInsideLeashRoom;                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeashAllRooms;                                  // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeashData) == 0x000008, "Wrong alignment on FLeashData");
static_assert(sizeof(FLeashData) == 0x000038, "Wrong size on FLeashData");
static_assert(offsetof(FLeashData, LeashVolumes) == 0x000000, "Member 'FLeashData::LeashVolumes' has a wrong offset!");
static_assert(offsetof(FLeashData, bIsBotOutsideLeash) == 0x000010, "Member 'FLeashData::bIsBotOutsideLeash' has a wrong offset!");
static_assert(offsetof(FLeashData, bIsConsideredOutsideLeash) == 0x000011, "Member 'FLeashData::bIsConsideredOutsideLeash' has a wrong offset!");
static_assert(offsetof(FLeashData, OutsideLeashStartTime) == 0x000014, "Member 'FLeashData::OutsideLeashStartTime' has a wrong offset!");
static_assert(offsetof(FLeashData, ConsideredOutsideLeashStartTime) == 0x000018, "Member 'FLeashData::ConsideredOutsideLeashStartTime' has a wrong offset!");
static_assert(offsetof(FLeashData, LastInsideLeashPosition) == 0x00001C, "Member 'FLeashData::LastInsideLeashPosition' has a wrong offset!");
static_assert(offsetof(FLeashData, LastInsideLeashRoom) == 0x000028, "Member 'FLeashData::LastInsideLeashRoom' has a wrong offset!");
static_assert(offsetof(FLeashData, bIsLeashAllRooms) == 0x000030, "Member 'FLeashData::bIsLeashAllRooms' has a wrong offset!");

// ScriptStruct OPP.AIBlindPaintData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FAIBlindPaintData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBlindPaintData) == 0x000004, "Wrong alignment on FAIBlindPaintData");
static_assert(sizeof(FAIBlindPaintData) == 0x00001C, "Wrong size on FAIBlindPaintData");

// ScriptStruct OPP.AIStunGrenadeData
// 0x0001 (0x0001 - 0x0000)
struct FAIStunGrenadeData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStunGrenadeData) == 0x000001, "Wrong alignment on FAIStunGrenadeData");
static_assert(sizeof(FAIStunGrenadeData) == 0x000001, "Wrong size on FAIStunGrenadeData");

// ScriptStruct OPP.ConditionalAIConfigData
// 0x14F8 (0x14F8 - 0x0000)
struct FConditionalAIConfigData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBGenericConditionSet                 Conditions;                                        // 0x0008(0x0010)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIConfigData                          ConfigOverrides;                                   // 0x0018(0x14DC)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F4[0x4];                                     // 0x14F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionalAIConfigData) == 0x000008, "Wrong alignment on FConditionalAIConfigData");
static_assert(sizeof(FConditionalAIConfigData) == 0x0014F8, "Wrong size on FConditionalAIConfigData");
static_assert(offsetof(FConditionalAIConfigData, Conditions) == 0x000008, "Member 'FConditionalAIConfigData::Conditions' has a wrong offset!");
static_assert(offsetof(FConditionalAIConfigData, ConfigOverrides) == 0x000018, "Member 'FConditionalAIConfigData::ConfigOverrides' has a wrong offset!");

// ScriptStruct OPP.BotMemory
// 0x0300 (0x0300 - 0x0000)
struct FBotMemory final
{
public:
	class AActor*                                 SpawnPointActor;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBAISpawner*                           SpawnerOwner;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x170];                                     // 0x0010(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              LastReceivedDamageFrom;                            // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              LastDealtDamageTo;                                 // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastProjectileHitBy;                               // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastLoggedStimulusSourceActor;                     // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimeHitByAProjectile;                          // 0x01A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBDoor*                                LastUsedDoor;                                      // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastImperativeDistractor;                          // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAmbientStationComponent*             LastAmbientStation;                                // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMoveFailedInfo>                FailedMovesToActor;                                // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x130];                                    // 0x01D0(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotMemory) == 0x000008, "Wrong alignment on FBotMemory");
static_assert(sizeof(FBotMemory) == 0x000300, "Wrong size on FBotMemory");
static_assert(offsetof(FBotMemory, SpawnPointActor) == 0x000000, "Member 'FBotMemory::SpawnPointActor' has a wrong offset!");
static_assert(offsetof(FBotMemory, SpawnerOwner) == 0x000008, "Member 'FBotMemory::SpawnerOwner' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastReceivedDamageFrom) == 0x000180, "Member 'FBotMemory::LastReceivedDamageFrom' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastDealtDamageTo) == 0x000188, "Member 'FBotMemory::LastDealtDamageTo' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastProjectileHitBy) == 0x000190, "Member 'FBotMemory::LastProjectileHitBy' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastLoggedStimulusSourceActor) == 0x000198, "Member 'FBotMemory::LastLoggedStimulusSourceActor' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastTimeHitByAProjectile) == 0x0001A0, "Member 'FBotMemory::LastTimeHitByAProjectile' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastUsedDoor) == 0x0001A8, "Member 'FBotMemory::LastUsedDoor' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastImperativeDistractor) == 0x0001B0, "Member 'FBotMemory::LastImperativeDistractor' has a wrong offset!");
static_assert(offsetof(FBotMemory, LastAmbientStation) == 0x0001B8, "Member 'FBotMemory::LastAmbientStation' has a wrong offset!");
static_assert(offsetof(FBotMemory, FailedMovesToActor) == 0x0001C0, "Member 'FBotMemory::FailedMovesToActor' has a wrong offset!");

// ScriptStruct OPP.AIReceivedDamageData
// 0x0018 (0x0018 - 0x0000)
struct FAIReceivedDamageData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPawn*                                Attacker;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIReceivedDamageData) == 0x000008, "Wrong alignment on FAIReceivedDamageData");
static_assert(sizeof(FAIReceivedDamageData) == 0x000018, "Wrong size on FAIReceivedDamageData");
static_assert(offsetof(FAIReceivedDamageData, Attacker) == 0x000008, "Member 'FAIReceivedDamageData::Attacker' has a wrong offset!");

// ScriptStruct OPP.AIIllnessData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAIIllnessData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIIllnessData) == 0x000004, "Wrong alignment on FAIIllnessData");
static_assert(sizeof(FAIIllnessData) == 0x000010, "Wrong size on FAIIllnessData");

// ScriptStruct OPP.AISeekingHidingSpotData
// 0x0018 (0x0018 - 0x0000)
struct FAISeekingHidingSpotData final
{
public:
	class URBHidespotComponent*                   TargetSpot;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISeekingHidingSpotData) == 0x000008, "Wrong alignment on FAISeekingHidingSpotData");
static_assert(sizeof(FAISeekingHidingSpotData) == 0x000018, "Wrong size on FAISeekingHidingSpotData");
static_assert(offsetof(FAISeekingHidingSpotData, TargetSpot) == 0x000000, "Member 'FAISeekingHidingSpotData::TargetSpot' has a wrong offset!");

// ScriptStruct OPP.AIRetirementData
// 0x0028 (0x0028 - 0x0000)
struct FAIRetirementData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBMonsterCloset*                       MonsterClosetDestination;                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRetirementData) == 0x000008, "Wrong alignment on FAIRetirementData");
static_assert(sizeof(FAIRetirementData) == 0x000028, "Wrong size on FAIRetirementData");
static_assert(offsetof(FAIRetirementData, MonsterClosetDestination) == 0x000008, "Member 'FAIRetirementData::MonsterClosetDestination' has a wrong offset!");

// ScriptStruct OPP.AIGroundAndPoundData
// 0x0018 (0x0018 - 0x0000)
struct FAIGroundAndPoundData final
{
public:
	class ARBPlayer*                              TargetPlayer;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGroundAndPoundData) == 0x000008, "Wrong alignment on FAIGroundAndPoundData");
static_assert(sizeof(FAIGroundAndPoundData) == 0x000018, "Wrong size on FAIGroundAndPoundData");
static_assert(offsetof(FAIGroundAndPoundData, TargetPlayer) == 0x000000, "Member 'FAIGroundAndPoundData::TargetPlayer' has a wrong offset!");

// ScriptStruct OPP.AIAttackData
// 0x0070 (0x0070 - 0x0000)
struct FAIAttackData final
{
public:
	struct FAIAttackTarget                        Target;                                            // 0x0000(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAttackData) == 0x000008, "Wrong alignment on FAIAttackData");
static_assert(sizeof(FAIAttackData) == 0x000070, "Wrong size on FAIAttackData");
static_assert(offsetof(FAIAttackData, Target) == 0x000000, "Member 'FAIAttackData::Target' has a wrong offset!");

// ScriptStruct OPP.InvestigationConfig
// 0x0060 (0x0060 - 0x0000)
struct FInvestigationConfig final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpecifiedInvestigationPoints;                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              InitialPlayerTargetLocation;                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvestigationConfig) == 0x000008, "Wrong alignment on FInvestigationConfig");
static_assert(sizeof(FInvestigationConfig) == 0x000060, "Wrong size on FInvestigationConfig");
static_assert(offsetof(FInvestigationConfig, SpecifiedInvestigationPoints) == 0x000010, "Member 'FInvestigationConfig::SpecifiedInvestigationPoints' has a wrong offset!");
static_assert(offsetof(FInvestigationConfig, InitialPlayerTargetLocation) == 0x000030, "Member 'FInvestigationConfig::InitialPlayerTargetLocation' has a wrong offset!");

// ScriptStruct OPP.RBBreadcrumb
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FRBBreadcrumb final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBBreadcrumb) == 0x000004, "Wrong alignment on FRBBreadcrumb");
static_assert(sizeof(FRBBreadcrumb) == 0x000018, "Wrong size on FRBBreadcrumb");

// ScriptStruct OPP.RBBugItDataRequest_Client
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRBBugItDataRequest_Client final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBBugItDataRequest_Client) == 0x000008, "Wrong alignment on FRBBugItDataRequest_Client");
static_assert(sizeof(FRBBugItDataRequest_Client) == 0x000018, "Wrong size on FRBBugItDataRequest_Client");

// ScriptStruct OPP.RBBugItDataRequest_Server
// 0x0020 (0x0020 - 0x0000)
struct FRBBugItDataRequest_Server final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBNPC*>                         NPCsToProcess;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBBugItDataRequest_Server) == 0x000008, "Wrong alignment on FRBBugItDataRequest_Server");
static_assert(sizeof(FRBBugItDataRequest_Server) == 0x000020, "Wrong size on FRBBugItDataRequest_Server");
static_assert(offsetof(FRBBugItDataRequest_Server, NPCsToProcess) == 0x000008, "Member 'FRBBugItDataRequest_Server::NPCsToProcess' has a wrong offset!");

// ScriptStruct OPP.RBBugReportInfo
// 0x0068 (0x0068 - 0x0000)
struct FRBBugReportInfo final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShortDesc;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildId;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StageName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocationStr;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerLogs;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Platforms;                                         // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBBugReportInfo) == 0x000008, "Wrong alignment on FRBBugReportInfo");
static_assert(sizeof(FRBBugReportInfo) == 0x000068, "Wrong size on FRBBugReportInfo");
static_assert(offsetof(FRBBugReportInfo, Timestamp) == 0x000000, "Member 'FRBBugReportInfo::Timestamp' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, ShortDesc) == 0x000010, "Member 'FRBBugReportInfo::ShortDesc' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, BuildId) == 0x000020, "Member 'FRBBugReportInfo::BuildId' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, StageName) == 0x000028, "Member 'FRBBugReportInfo::StageName' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, LocationStr) == 0x000038, "Member 'FRBBugReportInfo::LocationStr' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, ServerLogs) == 0x000048, "Member 'FRBBugReportInfo::ServerLogs' has a wrong offset!");
static_assert(offsetof(FRBBugReportInfo, Platforms) == 0x000058, "Member 'FRBBugReportInfo::Platforms' has a wrong offset!");

// ScriptStruct OPP.BoardPosition
// 0x0010 (0x0010 - 0x0000)
struct FBoardPosition final
{
public:
	TArray<struct FChessPieceData>                ChessPiecesData;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoardPosition) == 0x000008, "Wrong alignment on FBoardPosition");
static_assert(sizeof(FBoardPosition) == 0x000010, "Wrong size on FBoardPosition");
static_assert(offsetof(FBoardPosition, ChessPiecesData) == 0x000000, "Member 'FBoardPosition::ChessPiecesData' has a wrong offset!");

// ScriptStruct OPP.ChessClockData
// 0x0014 (0x0014 - 0x0000)
struct FChessClockData final
{
public:
	float                                         MatchTotalTime;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhiteTime;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhiteLastUpdateTimestamp;                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackTime;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackLastUpdateTimestamp;                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChessClockData) == 0x000004, "Wrong alignment on FChessClockData");
static_assert(sizeof(FChessClockData) == 0x000014, "Wrong size on FChessClockData");
static_assert(offsetof(FChessClockData, MatchTotalTime) == 0x000000, "Member 'FChessClockData::MatchTotalTime' has a wrong offset!");
static_assert(offsetof(FChessClockData, WhiteTime) == 0x000004, "Member 'FChessClockData::WhiteTime' has a wrong offset!");
static_assert(offsetof(FChessClockData, WhiteLastUpdateTimestamp) == 0x000008, "Member 'FChessClockData::WhiteLastUpdateTimestamp' has a wrong offset!");
static_assert(offsetof(FChessClockData, BlackTime) == 0x00000C, "Member 'FChessClockData::BlackTime' has a wrong offset!");
static_assert(offsetof(FChessClockData, BlackLastUpdateTimestamp) == 0x000010, "Member 'FChessClockData::BlackLastUpdateTimestamp' has a wrong offset!");

// ScriptStruct OPP.HiddenActorInfo
// 0x0028 (0x0028 - 0x0000)
struct FHiddenActorInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HiddenAttachedActors;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            HideShadowComponents;                              // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiddenActorInfo) == 0x000008, "Wrong alignment on FHiddenActorInfo");
static_assert(sizeof(FHiddenActorInfo) == 0x000028, "Wrong size on FHiddenActorInfo");
static_assert(offsetof(FHiddenActorInfo, Actor) == 0x000000, "Member 'FHiddenActorInfo::Actor' has a wrong offset!");
static_assert(offsetof(FHiddenActorInfo, HiddenAttachedActors) == 0x000008, "Member 'FHiddenActorInfo::HiddenAttachedActors' has a wrong offset!");
static_assert(offsetof(FHiddenActorInfo, HideShadowComponents) == 0x000018, "Member 'FHiddenActorInfo::HideShadowComponents' has a wrong offset!");

// ScriptStruct OPP.RBCollectibleDocumentGroupRow
// 0x0060 (0x0068 - 0x0008)
struct FRBCollectibleDocumentGroupRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Thumbnail;                                         // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBCollectibleDocumentGroupRow) == 0x000008, "Wrong alignment on FRBCollectibleDocumentGroupRow");
static_assert(sizeof(FRBCollectibleDocumentGroupRow) == 0x000068, "Wrong size on FRBCollectibleDocumentGroupRow");
static_assert(offsetof(FRBCollectibleDocumentGroupRow, ID) == 0x000008, "Member 'FRBCollectibleDocumentGroupRow::ID' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentGroupRow, Name) == 0x000010, "Member 'FRBCollectibleDocumentGroupRow::Name' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentGroupRow, Description) == 0x000028, "Member 'FRBCollectibleDocumentGroupRow::Description' has a wrong offset!");
static_assert(offsetof(FRBCollectibleDocumentGroupRow, Thumbnail) == 0x000040, "Member 'FRBCollectibleDocumentGroupRow::Thumbnail' has a wrong offset!");

// ScriptStruct OPP.RBPlayerCollectibleDocumentInfo
// 0x0018 (0x0018 - 0x0000)
struct FRBPlayerCollectibleDocumentInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProfileId                             ProfileId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerCollectibleDocumentInfo) == 0x000004, "Wrong alignment on FRBPlayerCollectibleDocumentInfo");
static_assert(sizeof(FRBPlayerCollectibleDocumentInfo) == 0x000018, "Wrong size on FRBPlayerCollectibleDocumentInfo");
static_assert(offsetof(FRBPlayerCollectibleDocumentInfo, ID) == 0x000000, "Member 'FRBPlayerCollectibleDocumentInfo::ID' has a wrong offset!");
static_assert(offsetof(FRBPlayerCollectibleDocumentInfo, ProfileId) == 0x000008, "Member 'FRBPlayerCollectibleDocumentInfo::ProfileId' has a wrong offset!");

// ScriptStruct OPP.ContainerSpawnedItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FContainerSpawnedItemInfo final
{
public:
	class ARBPickup*                              Item;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSpawnLocationIndex;                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContainerSpawnedItemInfo) == 0x000008, "Wrong alignment on FContainerSpawnedItemInfo");
static_assert(sizeof(FContainerSpawnedItemInfo) == 0x000010, "Wrong size on FContainerSpawnedItemInfo");
static_assert(offsetof(FContainerSpawnedItemInfo, Item) == 0x000000, "Member 'FContainerSpawnedItemInfo::Item' has a wrong offset!");
static_assert(offsetof(FContainerSpawnedItemInfo, SelectedSpawnLocationIndex) == 0x000008, "Member 'FContainerSpawnedItemInfo::SelectedSpawnLocationIndex' has a wrong offset!");

// ScriptStruct OPP.PlayerBreathData
// 0x0020 (0x0020 - 0x0000)
struct FPlayerBreathData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayerBreathStopFastEvent;                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerBreathData) == 0x000008, "Wrong alignment on FPlayerBreathData");
static_assert(sizeof(FPlayerBreathData) == 0x000020, "Wrong size on FPlayerBreathData");
static_assert(offsetof(FPlayerBreathData, PlayerBreathStopFastEvent) == 0x000018, "Member 'FPlayerBreathData::PlayerBreathStopFastEvent' has a wrong offset!");

// ScriptStruct OPP.PlayerDamagedData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerDamagedData final
{
public:
	class ARBPawn*                                Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialHealth;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTimestamp;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDamageTimestamp;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDamagedData) == 0x000008, "Wrong alignment on FPlayerDamagedData");
static_assert(sizeof(FPlayerDamagedData) == 0x000018, "Wrong size on FPlayerDamagedData");
static_assert(offsetof(FPlayerDamagedData, Player) == 0x000000, "Member 'FPlayerDamagedData::Player' has a wrong offset!");
static_assert(offsetof(FPlayerDamagedData, InitialHealth) == 0x000008, "Member 'FPlayerDamagedData::InitialHealth' has a wrong offset!");
static_assert(offsetof(FPlayerDamagedData, InitialTimestamp) == 0x00000C, "Member 'FPlayerDamagedData::InitialTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerDamagedData, LastDamageTimestamp) == 0x000010, "Member 'FPlayerDamagedData::LastDamageTimestamp' has a wrong offset!");

// ScriptStruct OPP.AreaOfEffectSettings
// 0x001C (0x001C - 0x0000)
struct FAreaOfEffectSettings final
{
public:
	bool                                          bDeduceDamageParameters;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeduceRangeParameters;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumDistanceToTarget;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumAngleToTarget;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumAngleToTarget;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeducePositionParameters;                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RelativeToBone;                                    // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaOfEffectSettings) == 0x000004, "Wrong alignment on FAreaOfEffectSettings");
static_assert(sizeof(FAreaOfEffectSettings) == 0x00001C, "Wrong size on FAreaOfEffectSettings");
static_assert(offsetof(FAreaOfEffectSettings, bDeduceDamageParameters) == 0x000000, "Member 'FAreaOfEffectSettings::bDeduceDamageParameters' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, DamageType) == 0x000001, "Member 'FAreaOfEffectSettings::DamageType' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, bDeduceRangeParameters) == 0x000002, "Member 'FAreaOfEffectSettings::bDeduceRangeParameters' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, MaximumDistanceToTarget) == 0x000004, "Member 'FAreaOfEffectSettings::MaximumDistanceToTarget' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, MinimumAngleToTarget) == 0x000008, "Member 'FAreaOfEffectSettings::MinimumAngleToTarget' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, MaximumAngleToTarget) == 0x00000C, "Member 'FAreaOfEffectSettings::MaximumAngleToTarget' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, bDeducePositionParameters) == 0x000010, "Member 'FAreaOfEffectSettings::bDeducePositionParameters' has a wrong offset!");
static_assert(offsetof(FAreaOfEffectSettings, RelativeToBone) == 0x000014, "Member 'FAreaOfEffectSettings::RelativeToBone' has a wrong offset!");

// ScriptStruct OPP.DoorInvestigationData
// 0x0004 (0x0004 - 0x0000)
struct FDoorInvestigationData final
{
public:
	bool                                          bFrontValid;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontValid_Wide;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackValid;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackValid_Wide;                                   // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorInvestigationData) == 0x000001, "Wrong alignment on FDoorInvestigationData");
static_assert(sizeof(FDoorInvestigationData) == 0x000004, "Wrong size on FDoorInvestigationData");
static_assert(offsetof(FDoorInvestigationData, bFrontValid) == 0x000000, "Member 'FDoorInvestigationData::bFrontValid' has a wrong offset!");
static_assert(offsetof(FDoorInvestigationData, bFrontValid_Wide) == 0x000001, "Member 'FDoorInvestigationData::bFrontValid_Wide' has a wrong offset!");
static_assert(offsetof(FDoorInvestigationData, bBackValid) == 0x000002, "Member 'FDoorInvestigationData::bBackValid' has a wrong offset!");
static_assert(offsetof(FDoorInvestigationData, bBackValid_Wide) == 0x000003, "Member 'FDoorInvestigationData::bBackValid_Wide' has a wrong offset!");

// ScriptStruct OPP.PlayerInEvalExitInfo
// 0x0010 (0x0010 - 0x0000)
struct FPlayerInEvalExitInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideTubeTimestamp;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimestamp;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInEvalExitInfo) == 0x000008, "Wrong alignment on FPlayerInEvalExitInfo");
static_assert(sizeof(FPlayerInEvalExitInfo) == 0x000010, "Wrong size on FPlayerInEvalExitInfo");
static_assert(offsetof(FPlayerInEvalExitInfo, Player) == 0x000000, "Member 'FPlayerInEvalExitInfo::Player' has a wrong offset!");
static_assert(offsetof(FPlayerInEvalExitInfo, InsideTubeTimestamp) == 0x000008, "Member 'FPlayerInEvalExitInfo::InsideTubeTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerInEvalExitInfo, TransitionTimestamp) == 0x00000C, "Member 'FPlayerInEvalExitInfo::TransitionTimestamp' has a wrong offset!");

// ScriptStruct OPP.RBFaceAnimTableMappingRow
// 0x0018 (0x0020 - 0x0008)
struct FRBFaceAnimTableMappingRow final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataTableName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Comments;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBFaceAnimTableMappingRow) == 0x000008, "Wrong alignment on FRBFaceAnimTableMappingRow");
static_assert(sizeof(FRBFaceAnimTableMappingRow) == 0x000020, "Wrong size on FRBFaceAnimTableMappingRow");
static_assert(offsetof(FRBFaceAnimTableMappingRow, Name) == 0x000008, "Member 'FRBFaceAnimTableMappingRow::Name' has a wrong offset!");
static_assert(offsetof(FRBFaceAnimTableMappingRow, DataTableName) == 0x000010, "Member 'FRBFaceAnimTableMappingRow::DataTableName' has a wrong offset!");
static_assert(offsetof(FRBFaceAnimTableMappingRow, Comments) == 0x000018, "Member 'FRBFaceAnimTableMappingRow::Comments' has a wrong offset!");

// ScriptStruct OPP.PPSList
// 0x0010 (0x0010 - 0x0000)
struct FPPSList final
{
public:
	TArray<class UMaterialInstanceDynamic*>       List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPSList) == 0x000008, "Wrong alignment on FPPSList");
static_assert(sizeof(FPPSList) == 0x000010, "Wrong size on FPPSList");
static_assert(offsetof(FPPSList, List) == 0x000000, "Member 'FPPSList::List' has a wrong offset!");

// ScriptStruct OPP.PostProcessParamData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FPostProcessParamData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessParamData) == 0x000004, "Wrong alignment on FPostProcessParamData");
static_assert(sizeof(FPostProcessParamData) == 0x000010, "Wrong size on FPostProcessParamData");

// ScriptStruct OPP.FXPostProcessSettings
// 0x0028 (0x0028 - 0x0000)
struct FFXPostProcessSettings final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Owner;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFXPostProcessSettings) == 0x000008, "Wrong alignment on FFXPostProcessSettings");
static_assert(sizeof(FFXPostProcessSettings) == 0x000028, "Wrong size on FFXPostProcessSettings");
static_assert(offsetof(FFXPostProcessSettings, Owner) == 0x000010, "Member 'FFXPostProcessSettings::Owner' has a wrong offset!");

// ScriptStruct OPP.PendingMatchDetails
// 0x00D8 (0x00D8 - 0x0000)
struct FPendingMatchDetails final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBLobbyPlayerState*                    Owner;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBLobbyPlayerState*>            Members;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingMatchDetails) == 0x000008, "Wrong alignment on FPendingMatchDetails");
static_assert(sizeof(FPendingMatchDetails) == 0x0000D8, "Wrong size on FPendingMatchDetails");
static_assert(offsetof(FPendingMatchDetails, Owner) == 0x000010, "Member 'FPendingMatchDetails::Owner' has a wrong offset!");
static_assert(offsetof(FPendingMatchDetails, Members) == 0x000018, "Member 'FPendingMatchDetails::Members' has a wrong offset!");

// ScriptStruct OPP.MainMenuProgressionDetails
// 0x0068 (0x0068 - 0x0000)
struct FMainMenuProgressionDetails final
{
public:
	TMap<ECurrencyType, int32>                    Currencies;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconOption;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerIconCustomizationOption*       PlayerIconBorderOption;                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseCount;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuProgressionDetails) == 0x000008, "Wrong alignment on FMainMenuProgressionDetails");
static_assert(sizeof(FMainMenuProgressionDetails) == 0x000068, "Wrong size on FMainMenuProgressionDetails");
static_assert(offsetof(FMainMenuProgressionDetails, Currencies) == 0x000000, "Member 'FMainMenuProgressionDetails::Currencies' has a wrong offset!");
static_assert(offsetof(FMainMenuProgressionDetails, PlayerIconOption) == 0x000050, "Member 'FMainMenuProgressionDetails::PlayerIconOption' has a wrong offset!");
static_assert(offsetof(FMainMenuProgressionDetails, PlayerIconBorderOption) == 0x000058, "Member 'FMainMenuProgressionDetails::PlayerIconBorderOption' has a wrong offset!");
static_assert(offsetof(FMainMenuProgressionDetails, PlayerLevel) == 0x000060, "Member 'FMainMenuProgressionDetails::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FMainMenuProgressionDetails, ReleaseCount) == 0x000064, "Member 'FMainMenuProgressionDetails::ReleaseCount' has a wrong offset!");

// ScriptStruct OPP.RBConfigurableGameplayAttributeModifier
// 0x00D0 (0x00D0 - 0x0000)
struct FRBConfigurableGameplayAttributeModifier final
{
public:
	EGameplayAttributeType                        AttributeType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAttributeModifierType                ModifierType;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     Value;                                             // 0x0008(0x00C8)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBConfigurableGameplayAttributeModifier) == 0x000008, "Wrong alignment on FRBConfigurableGameplayAttributeModifier");
static_assert(sizeof(FRBConfigurableGameplayAttributeModifier) == 0x0000D0, "Wrong size on FRBConfigurableGameplayAttributeModifier");
static_assert(offsetof(FRBConfigurableGameplayAttributeModifier, AttributeType) == 0x000000, "Member 'FRBConfigurableGameplayAttributeModifier::AttributeType' has a wrong offset!");
static_assert(offsetof(FRBConfigurableGameplayAttributeModifier, ModifierType) == 0x000001, "Member 'FRBConfigurableGameplayAttributeModifier::ModifierType' has a wrong offset!");
static_assert(offsetof(FRBConfigurableGameplayAttributeModifier, Value) == 0x000008, "Member 'FRBConfigurableGameplayAttributeModifier::Value' has a wrong offset!");

// ScriptStruct OPP.RBAttributeOwnerRuntimeInfo
// 0x0038 (0x0038 - 0x0000)
struct FRBAttributeOwnerRuntimeInfo final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URBGameplayAttributeManager*            ManagerOwner;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBAttributeOwnerRuntimeInfo) == 0x000008, "Wrong alignment on FRBAttributeOwnerRuntimeInfo");
static_assert(sizeof(FRBAttributeOwnerRuntimeInfo) == 0x000038, "Wrong size on FRBAttributeOwnerRuntimeInfo");
static_assert(offsetof(FRBAttributeOwnerRuntimeInfo, Owner) == 0x000000, "Member 'FRBAttributeOwnerRuntimeInfo::Owner' has a wrong offset!");
static_assert(offsetof(FRBAttributeOwnerRuntimeInfo, ManagerOwner) == 0x000028, "Member 'FRBAttributeOwnerRuntimeInfo::ManagerOwner' has a wrong offset!");

// ScriptStruct OPP.RBObstacleVariatorInfo
// 0x0018 (0x0018 - 0x0000)
struct FRBObstacleVariatorInfo final
{
public:
	TArray<class FName>                           LevelNames;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EObstacleVariatorType                         Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBObstacleVariatorInfo) == 0x000008, "Wrong alignment on FRBObstacleVariatorInfo");
static_assert(sizeof(FRBObstacleVariatorInfo) == 0x000018, "Wrong size on FRBObstacleVariatorInfo");
static_assert(offsetof(FRBObstacleVariatorInfo, LevelNames) == 0x000000, "Member 'FRBObstacleVariatorInfo::LevelNames' has a wrong offset!");
static_assert(offsetof(FRBObstacleVariatorInfo, Type) == 0x000010, "Member 'FRBObstacleVariatorInfo::Type' has a wrong offset!");

// ScriptStruct OPP.RBMainObjectiveInfo
// 0x0058 (0x0058 - 0x0000)
struct FRBMainObjectiveInfo final
{
public:
	class FName                                   ObjectiveID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LoreObjectiveName;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LoreObjectiveDescription;                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           ObjectiveSpecificLevels;                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EMainObjectiveType                            Type;                                              // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LevelName;                                         // 0x004C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBMainObjectiveInfo) == 0x000008, "Wrong alignment on FRBMainObjectiveInfo");
static_assert(sizeof(FRBMainObjectiveInfo) == 0x000058, "Wrong size on FRBMainObjectiveInfo");
static_assert(offsetof(FRBMainObjectiveInfo, ObjectiveID) == 0x000000, "Member 'FRBMainObjectiveInfo::ObjectiveID' has a wrong offset!");
static_assert(offsetof(FRBMainObjectiveInfo, LoreObjectiveName) == 0x000008, "Member 'FRBMainObjectiveInfo::LoreObjectiveName' has a wrong offset!");
static_assert(offsetof(FRBMainObjectiveInfo, LoreObjectiveDescription) == 0x000020, "Member 'FRBMainObjectiveInfo::LoreObjectiveDescription' has a wrong offset!");
static_assert(offsetof(FRBMainObjectiveInfo, ObjectiveSpecificLevels) == 0x000038, "Member 'FRBMainObjectiveInfo::ObjectiveSpecificLevels' has a wrong offset!");
static_assert(offsetof(FRBMainObjectiveInfo, Type) == 0x000048, "Member 'FRBMainObjectiveInfo::Type' has a wrong offset!");
static_assert(offsetof(FRBMainObjectiveInfo, LevelName) == 0x00004C, "Member 'FRBMainObjectiveInfo::LevelName' has a wrong offset!");

// ScriptStruct OPP.RBObjectiveGroupInfo
// 0x0028 (0x0028 - 0x0000)
struct FRBObjectiveGroupInfo final
{
public:
	class FName                                   GroupID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           GroupSpecificLevels;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRBMainObjectiveInfo>           MainObjectiveInfos;                                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBObjectiveGroupInfo) == 0x000008, "Wrong alignment on FRBObjectiveGroupInfo");
static_assert(sizeof(FRBObjectiveGroupInfo) == 0x000028, "Wrong size on FRBObjectiveGroupInfo");
static_assert(offsetof(FRBObjectiveGroupInfo, GroupID) == 0x000000, "Member 'FRBObjectiveGroupInfo::GroupID' has a wrong offset!");
static_assert(offsetof(FRBObjectiveGroupInfo, GroupSpecificLevels) == 0x000008, "Member 'FRBObjectiveGroupInfo::GroupSpecificLevels' has a wrong offset!");
static_assert(offsetof(FRBObjectiveGroupInfo, MainObjectiveInfos) == 0x000018, "Member 'FRBObjectiveGroupInfo::MainObjectiveInfos' has a wrong offset!");

// ScriptStruct OPP.RBMappingKeyPair
// 0x0040 (0x0040 - 0x0000)
struct FRBMappingKeyPair final
{
public:
	struct FKey                                   PrimaryKey;                                        // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimarySameAsDefault;                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   SecondaryKey;                                      // 0x0020(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSecondarySameAsDefault;                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBMappingKeyPair) == 0x000008, "Wrong alignment on FRBMappingKeyPair");
static_assert(sizeof(FRBMappingKeyPair) == 0x000040, "Wrong size on FRBMappingKeyPair");
static_assert(offsetof(FRBMappingKeyPair, PrimaryKey) == 0x000000, "Member 'FRBMappingKeyPair::PrimaryKey' has a wrong offset!");
static_assert(offsetof(FRBMappingKeyPair, bIsPrimarySameAsDefault) == 0x000018, "Member 'FRBMappingKeyPair::bIsPrimarySameAsDefault' has a wrong offset!");
static_assert(offsetof(FRBMappingKeyPair, SecondaryKey) == 0x000020, "Member 'FRBMappingKeyPair::SecondaryKey' has a wrong offset!");
static_assert(offsetof(FRBMappingKeyPair, bIsSecondarySameAsDefault) == 0x000038, "Member 'FRBMappingKeyPair::bIsSecondarySameAsDefault' has a wrong offset!");

// ScriptStruct OPP.RBAxisMappingInfo
// 0x000C (0x000C - 0x0000)
struct FRBAxisMappingInfo final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBAxisMappingInfo) == 0x000004, "Wrong alignment on FRBAxisMappingInfo");
static_assert(sizeof(FRBAxisMappingInfo) == 0x00000C, "Wrong size on FRBAxisMappingInfo");
static_assert(offsetof(FRBAxisMappingInfo, AxisName) == 0x000000, "Member 'FRBAxisMappingInfo::AxisName' has a wrong offset!");
static_assert(offsetof(FRBAxisMappingInfo, AxisScale) == 0x000008, "Member 'FRBAxisMappingInfo::AxisScale' has a wrong offset!");

// ScriptStruct OPP.PlayerGarageDoorInfo
// 0x0010 (0x0010 - 0x0000)
struct FPlayerGarageDoorInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerGarageDoorInfo) == 0x000008, "Wrong alignment on FPlayerGarageDoorInfo");
static_assert(sizeof(FPlayerGarageDoorInfo) == 0x000010, "Wrong size on FPlayerGarageDoorInfo");
static_assert(offsetof(FPlayerGarageDoorInfo, Player) == 0x000000, "Member 'FPlayerGarageDoorInfo::Player' has a wrong offset!");

// ScriptStruct OPP.LoadoutBrushes
// 0x0220 (0x0220 - 0x0000)
struct FLoadoutBrushes final
{
public:
	struct FSlateBrush                            BaseBrush;                                         // 0x0000(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SelectedBrush;                                     // 0x0088(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            AvailableBrush;                                    // 0x0110(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedBrush;                                       // 0x0198(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutBrushes) == 0x000008, "Wrong alignment on FLoadoutBrushes");
static_assert(sizeof(FLoadoutBrushes) == 0x000220, "Wrong size on FLoadoutBrushes");
static_assert(offsetof(FLoadoutBrushes, BaseBrush) == 0x000000, "Member 'FLoadoutBrushes::BaseBrush' has a wrong offset!");
static_assert(offsetof(FLoadoutBrushes, SelectedBrush) == 0x000088, "Member 'FLoadoutBrushes::SelectedBrush' has a wrong offset!");
static_assert(offsetof(FLoadoutBrushes, AvailableBrush) == 0x000110, "Member 'FLoadoutBrushes::AvailableBrush' has a wrong offset!");
static_assert(offsetof(FLoadoutBrushes, LockedBrush) == 0x000198, "Member 'FLoadoutBrushes::LockedBrush' has a wrong offset!");

// ScriptStruct OPP.TalkWheelSpliceData
// 0x0028 (0x0028 - 0x0000)
struct FTalkWheelSpliceData final
{
public:
	ETalkWheelAction                              SpliceAction;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpliceText;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             SpliceIcon;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkWheelSpliceData) == 0x000008, "Wrong alignment on FTalkWheelSpliceData");
static_assert(sizeof(FTalkWheelSpliceData) == 0x000028, "Wrong size on FTalkWheelSpliceData");
static_assert(offsetof(FTalkWheelSpliceData, SpliceAction) == 0x000000, "Member 'FTalkWheelSpliceData::SpliceAction' has a wrong offset!");
static_assert(offsetof(FTalkWheelSpliceData, SpliceText) == 0x000008, "Member 'FTalkWheelSpliceData::SpliceText' has a wrong offset!");
static_assert(offsetof(FTalkWheelSpliceData, SpliceIcon) == 0x000020, "Member 'FTalkWheelSpliceData::SpliceIcon' has a wrong offset!");

// ScriptStruct OPP.RBGameplayAttributeModifierEffectTextDetails
// 0x0020 (0x0020 - 0x0000)
struct FRBGameplayAttributeModifierEffectTextDetails final
{
public:
	EGameplayAttributeType                        AttributeType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAttributeModifierType                ModifierType;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBGameplayAttributeModifierEffectTextDetails) == 0x000008, "Wrong alignment on FRBGameplayAttributeModifierEffectTextDetails");
static_assert(sizeof(FRBGameplayAttributeModifierEffectTextDetails) == 0x000020, "Wrong size on FRBGameplayAttributeModifierEffectTextDetails");
static_assert(offsetof(FRBGameplayAttributeModifierEffectTextDetails, AttributeType) == 0x000000, "Member 'FRBGameplayAttributeModifierEffectTextDetails::AttributeType' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifierEffectTextDetails, ModifierType) == 0x000001, "Member 'FRBGameplayAttributeModifierEffectTextDetails::ModifierType' has a wrong offset!");
static_assert(offsetof(FRBGameplayAttributeModifierEffectTextDetails, Description) == 0x000008, "Member 'FRBGameplayAttributeModifierEffectTextDetails::Description' has a wrong offset!");

// ScriptStruct OPP.UIColors
// 0x0040 (0x0040 - 0x0000)
struct FUIColors final
{
public:
	struct FLinearColor                           PrimaryColor;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SecondaryColor;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TertiaryColor;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RibbonColor;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIColors) == 0x000004, "Wrong alignment on FUIColors");
static_assert(sizeof(FUIColors) == 0x000040, "Wrong size on FUIColors");
static_assert(offsetof(FUIColors, PrimaryColor) == 0x000000, "Member 'FUIColors::PrimaryColor' has a wrong offset!");
static_assert(offsetof(FUIColors, SecondaryColor) == 0x000010, "Member 'FUIColors::SecondaryColor' has a wrong offset!");
static_assert(offsetof(FUIColors, TertiaryColor) == 0x000020, "Member 'FUIColors::TertiaryColor' has a wrong offset!");
static_assert(offsetof(FUIColors, RibbonColor) == 0x000030, "Member 'FUIColors::RibbonColor' has a wrong offset!");

// ScriptStruct OPP.MetaNPCSettings
// 0x0088 (0x0088 - 0x0000)
struct FMetaNPCSettings final
{
public:
	class FText                                   JobTitle;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUIColors                              Colors;                                            // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaNPCSettings) == 0x000008, "Wrong alignment on FMetaNPCSettings");
static_assert(sizeof(FMetaNPCSettings) == 0x000088, "Wrong size on FMetaNPCSettings");
static_assert(offsetof(FMetaNPCSettings, JobTitle) == 0x000000, "Member 'FMetaNPCSettings::JobTitle' has a wrong offset!");
static_assert(offsetof(FMetaNPCSettings, Name) == 0x000018, "Member 'FMetaNPCSettings::Name' has a wrong offset!");
static_assert(offsetof(FMetaNPCSettings, Description) == 0x000030, "Member 'FMetaNPCSettings::Description' has a wrong offset!");
static_assert(offsetof(FMetaNPCSettings, Colors) == 0x000048, "Member 'FMetaNPCSettings::Colors' has a wrong offset!");

// ScriptStruct OPP.ObjectiveProgressionAudioEvents
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveProgressionAudioEvents final
{
public:
	class UAkAudioEvent*                          StartEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveProgressionAudioEvents) == 0x000008, "Wrong alignment on FObjectiveProgressionAudioEvents");
static_assert(sizeof(FObjectiveProgressionAudioEvents) == 0x000010, "Wrong size on FObjectiveProgressionAudioEvents");
static_assert(offsetof(FObjectiveProgressionAudioEvents, StartEvent) == 0x000000, "Member 'FObjectiveProgressionAudioEvents::StartEvent' has a wrong offset!");
static_assert(offsetof(FObjectiveProgressionAudioEvents, StopEvent) == 0x000008, "Member 'FObjectiveProgressionAudioEvents::StopEvent' has a wrong offset!");

// ScriptStruct OPP.PsychosisSpookData
// 0x0018 (0x0018 - 0x0000)
struct FPsychosisSpookData final
{
public:
	class ARBPlayer*                              TargetPlayer;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBNPC*                                 SpectreNPC;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPsychosisSpookData) == 0x000008, "Wrong alignment on FPsychosisSpookData");
static_assert(sizeof(FPsychosisSpookData) == 0x000018, "Wrong size on FPsychosisSpookData");
static_assert(offsetof(FPsychosisSpookData, TargetPlayer) == 0x000000, "Member 'FPsychosisSpookData::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FPsychosisSpookData, SpectreNPC) == 0x000008, "Member 'FPsychosisSpookData::SpectreNPC' has a wrong offset!");

// ScriptStruct OPP.PsychosisLevelData
// 0x0010 (0x0010 - 0x0000)
struct FPsychosisLevelData final
{
public:
	TArray<struct FHallucinationEffectData>       HallucinationEffectList;                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychosisLevelData) == 0x000008, "Wrong alignment on FPsychosisLevelData");
static_assert(sizeof(FPsychosisLevelData) == 0x000010, "Wrong size on FPsychosisLevelData");
static_assert(offsetof(FPsychosisLevelData, HallucinationEffectList) == 0x000000, "Member 'FPsychosisLevelData::HallucinationEffectList' has a wrong offset!");

// ScriptStruct OPP.HitNPCTargetInfo
// 0x0008 (0x0008 - 0x0000)
struct FHitNPCTargetInfo final
{
public:
	class ARBNPC*                                 NPC;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitNPCTargetInfo) == 0x000008, "Wrong alignment on FHitNPCTargetInfo");
static_assert(sizeof(FHitNPCTargetInfo) == 0x000008, "Wrong size on FHitNPCTargetInfo");
static_assert(offsetof(FHitNPCTargetInfo, NPC) == 0x000000, "Member 'FHitNPCTargetInfo::NPC' has a wrong offset!");

// ScriptStruct OPP.HitNPCTargetTypeSettings
// 0x0270 (0x0270 - 0x0000)
struct FHitNPCTargetTypeSettings final
{
public:
	TSubclassOf<class ARBNPC>                     PawnClass;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            ConfigAsset;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     BodyHitMeterIncrease;                              // 0x0010(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     HeadshotMeterIncrease;                             // 0x00D8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyCost;                                    // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableInt                       MinNumberToSpawn;                                  // 0x01A8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitNPCTargetTypeSettings) == 0x000008, "Wrong alignment on FHitNPCTargetTypeSettings");
static_assert(sizeof(FHitNPCTargetTypeSettings) == 0x000270, "Wrong size on FHitNPCTargetTypeSettings");
static_assert(offsetof(FHitNPCTargetTypeSettings, PawnClass) == 0x000000, "Member 'FHitNPCTargetTypeSettings::PawnClass' has a wrong offset!");
static_assert(offsetof(FHitNPCTargetTypeSettings, ConfigAsset) == 0x000008, "Member 'FHitNPCTargetTypeSettings::ConfigAsset' has a wrong offset!");
static_assert(offsetof(FHitNPCTargetTypeSettings, BodyHitMeterIncrease) == 0x000010, "Member 'FHitNPCTargetTypeSettings::BodyHitMeterIncrease' has a wrong offset!");
static_assert(offsetof(FHitNPCTargetTypeSettings, HeadshotMeterIncrease) == 0x0000D8, "Member 'FHitNPCTargetTypeSettings::HeadshotMeterIncrease' has a wrong offset!");
static_assert(offsetof(FHitNPCTargetTypeSettings, DifficultyCost) == 0x0001A0, "Member 'FHitNPCTargetTypeSettings::DifficultyCost' has a wrong offset!");
static_assert(offsetof(FHitNPCTargetTypeSettings, MinNumberToSpawn) == 0x0001A8, "Member 'FHitNPCTargetTypeSettings::MinNumberToSpawn' has a wrong offset!");

// ScriptStruct OPP.HotPotatoEnemyConfig
// 0x0268 (0x0268 - 0x0000)
struct FHotPotatoEnemyConfig final
{
public:
	TSubclassOf<class ARBNPC>                     EnemyClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            EnemyConfig;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       NumHotPotatoEnemies;                               // 0x0010(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     HeldPotatoDurationForSpawn;                        // 0x00D8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     IdealSpawnDistanceFromPotato;                      // 0x01A0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHotPotatoEnemyConfig) == 0x000008, "Wrong alignment on FHotPotatoEnemyConfig");
static_assert(sizeof(FHotPotatoEnemyConfig) == 0x000268, "Wrong size on FHotPotatoEnemyConfig");
static_assert(offsetof(FHotPotatoEnemyConfig, EnemyClass) == 0x000000, "Member 'FHotPotatoEnemyConfig::EnemyClass' has a wrong offset!");
static_assert(offsetof(FHotPotatoEnemyConfig, EnemyConfig) == 0x000008, "Member 'FHotPotatoEnemyConfig::EnemyConfig' has a wrong offset!");
static_assert(offsetof(FHotPotatoEnemyConfig, NumHotPotatoEnemies) == 0x000010, "Member 'FHotPotatoEnemyConfig::NumHotPotatoEnemies' has a wrong offset!");
static_assert(offsetof(FHotPotatoEnemyConfig, HeldPotatoDurationForSpawn) == 0x0000D8, "Member 'FHotPotatoEnemyConfig::HeldPotatoDurationForSpawn' has a wrong offset!");
static_assert(offsetof(FHotPotatoEnemyConfig, IdealSpawnDistanceFromPotato) == 0x0001A0, "Member 'FHotPotatoEnemyConfig::IdealSpawnDistanceFromPotato' has a wrong offset!");

// ScriptStruct OPP.RBTrialHudNotificationDetails
// 0x0014 (0x0014 - 0x0000)
struct FRBTrialHudNotificationDetails final
{
public:
	class FName                                   ProgramId;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTrialHudNotificationDetails) == 0x000004, "Wrong alignment on FRBTrialHudNotificationDetails");
static_assert(sizeof(FRBTrialHudNotificationDetails) == 0x000014, "Wrong size on FRBTrialHudNotificationDetails");
static_assert(offsetof(FRBTrialHudNotificationDetails, ProgramId) == 0x000000, "Member 'FRBTrialHudNotificationDetails::ProgramId' has a wrong offset!");
static_assert(offsetof(FRBTrialHudNotificationDetails, TrialId) == 0x000008, "Member 'FRBTrialHudNotificationDetails::TrialId' has a wrong offset!");
static_assert(offsetof(FRBTrialHudNotificationDetails, ProgramDifficulty) == 0x000010, "Member 'FRBTrialHudNotificationDetails::ProgramDifficulty' has a wrong offset!");

// ScriptStruct OPP.MessageData
// 0x0030 (0x0030 - 0x0000)
struct FMessageData final
{
public:
	class FName                                   MessageId;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessagePriority                              Priority;                                          // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGameMessageCategory                          GameMessageCategory;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timestamp;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessageData) == 0x000008, "Wrong alignment on FMessageData");
static_assert(sizeof(FMessageData) == 0x000030, "Wrong size on FMessageData");
static_assert(offsetof(FMessageData, MessageId) == 0x000000, "Member 'FMessageData::MessageId' has a wrong offset!");
static_assert(offsetof(FMessageData, Priority) == 0x000008, "Member 'FMessageData::Priority' has a wrong offset!");
static_assert(offsetof(FMessageData, Duration) == 0x00000C, "Member 'FMessageData::Duration' has a wrong offset!");
static_assert(offsetof(FMessageData, Text) == 0x000010, "Member 'FMessageData::Text' has a wrong offset!");
static_assert(offsetof(FMessageData, GameMessageCategory) == 0x000028, "Member 'FMessageData::GameMessageCategory' has a wrong offset!");
static_assert(offsetof(FMessageData, Timestamp) == 0x00002C, "Member 'FMessageData::Timestamp' has a wrong offset!");

// ScriptStruct OPP.CurrencyPackItem
// 0x0060 (0x0060 - 0x0000)
struct FCurrencyPackItem final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Currency;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayPrice;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyPackItem) == 0x000008, "Wrong alignment on FCurrencyPackItem");
static_assert(sizeof(FCurrencyPackItem) == 0x000060, "Wrong size on FCurrencyPackItem");
static_assert(offsetof(FCurrencyPackItem, Name) == 0x000000, "Member 'FCurrencyPackItem::Name' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, CurrencyType) == 0x000010, "Member 'FCurrencyPackItem::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, Quantity) == 0x000014, "Member 'FCurrencyPackItem::Quantity' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, Currency) == 0x000018, "Member 'FCurrencyPackItem::Currency' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, Price) == 0x000028, "Member 'FCurrencyPackItem::Price' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, DisplayPrice) == 0x000030, "Member 'FCurrencyPackItem::DisplayPrice' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, Title) == 0x000040, "Member 'FCurrencyPackItem::Title' has a wrong offset!");
static_assert(offsetof(FCurrencyPackItem, Description) == 0x000050, "Member 'FCurrencyPackItem::Description' has a wrong offset!");

// ScriptStruct OPP.InteractionSoundEvent
// 0x0020 (0x0020 - 0x0000)
struct FInteractionSoundEvent final
{
public:
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchGroup;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchState;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnInteractor;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriggeringStimulusType                       AIStimulusType;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuousNoise;                                  // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionSoundEvent) == 0x000008, "Wrong alignment on FInteractionSoundEvent");
static_assert(sizeof(FInteractionSoundEvent) == 0x000020, "Wrong size on FInteractionSoundEvent");
static_assert(offsetof(FInteractionSoundEvent, SoundEvent) == 0x000000, "Member 'FInteractionSoundEvent::SoundEvent' has a wrong offset!");
static_assert(offsetof(FInteractionSoundEvent, SwitchGroup) == 0x000008, "Member 'FInteractionSoundEvent::SwitchGroup' has a wrong offset!");
static_assert(offsetof(FInteractionSoundEvent, SwitchState) == 0x000010, "Member 'FInteractionSoundEvent::SwitchState' has a wrong offset!");
static_assert(offsetof(FInteractionSoundEvent, bPlayOnInteractor) == 0x000018, "Member 'FInteractionSoundEvent::bPlayOnInteractor' has a wrong offset!");
static_assert(offsetof(FInteractionSoundEvent, AIStimulusType) == 0x000019, "Member 'FInteractionSoundEvent::AIStimulusType' has a wrong offset!");
static_assert(offsetof(FInteractionSoundEvent, bContinuousNoise) == 0x00001A, "Member 'FInteractionSoundEvent::bContinuousNoise' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnimSetup
// 0x0058 (0x0058 - 0x0000)
struct FInvestigationAnimSetup final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeProbability;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnimation;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledWhenAware;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledWhenUnaware;                               // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  EnableOnlyForNPCTags;                              // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DisableForNPCTags;                                 // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvestigationAnimSetup) == 0x000008, "Wrong alignment on FInvestigationAnimSetup");
static_assert(sizeof(FInvestigationAnimSetup) == 0x000058, "Wrong size on FInvestigationAnimSetup");
static_assert(offsetof(FInvestigationAnimSetup, AnimSequence) == 0x000000, "Member 'FInvestigationAnimSetup::AnimSequence' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, RelativeProbability) == 0x000008, "Member 'FInvestigationAnimSetup::RelativeProbability' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, bLoopAnimation) == 0x00000C, "Member 'FInvestigationAnimSetup::bLoopAnimation' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, bEnabledWhenAware) == 0x00000D, "Member 'FInvestigationAnimSetup::bEnabledWhenAware' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, bEnabledWhenUnaware) == 0x00000E, "Member 'FInvestigationAnimSetup::bEnabledWhenUnaware' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, EnableOnlyForNPCTags) == 0x000010, "Member 'FInvestigationAnimSetup::EnableOnlyForNPCTags' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, DisableForNPCTags) == 0x000030, "Member 'FInvestigationAnimSetup::DisableForNPCTags' has a wrong offset!");
static_assert(offsetof(FInvestigationAnimSetup, WaitTime) == 0x000050, "Member 'FInvestigationAnimSetup::WaitTime' has a wrong offset!");

// ScriptStruct OPP.RBItemProgressionDataRow
// 0x0110 (0x0118 - 0x0008)
struct FRBItemProgressionDataRow final : public FTableRowBase
{
public:
	EItemProgressionCategory                      Category;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActiveSkillType                              AssociatedActiveSkillType;                         // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProfileUpgradeCategory                       ProfileUpgradeCategory;                            // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPerkCategory                                 PerkCategory;                                      // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysAcquired;                                   // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredLevel_Character;                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequiredItems;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrencyCost_MurkoffPoint;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyCost_EventToken;                           // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_BattlePassPremiumToken;                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattlePassId;                                      // 0x0084(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassPageIndex;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassPageItemIndex;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 BattlePassCurrencyType;                            // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BattlePassCurrencyCost;                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Effects;                                           // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayFeatureSwitch;                              // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardPoolId;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoolWeight;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardPoolId2;                                     // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoolWeight2;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardPoolId3;                                     // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoolWeight3;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrialChainingRewardWeight;                         // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrialChainingRewardWeightInSolo;                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TrialChainingRequiredItemIds;                      // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   LinkedEvent;                                       // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBItemProgressionDataRow) == 0x000008, "Wrong alignment on FRBItemProgressionDataRow");
static_assert(sizeof(FRBItemProgressionDataRow) == 0x000118, "Wrong size on FRBItemProgressionDataRow");
static_assert(offsetof(FRBItemProgressionDataRow, Category) == 0x000008, "Member 'FRBItemProgressionDataRow::Category' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Name) == 0x000010, "Member 'FRBItemProgressionDataRow::Name' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Description) == 0x000020, "Member 'FRBItemProgressionDataRow::Description' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Rank) == 0x000030, "Member 'FRBItemProgressionDataRow::Rank' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Order) == 0x000034, "Member 'FRBItemProgressionDataRow::Order' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, DisplayName) == 0x000038, "Member 'FRBItemProgressionDataRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Icon) == 0x000050, "Member 'FRBItemProgressionDataRow::Icon' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, AssociatedActiveSkillType) == 0x000058, "Member 'FRBItemProgressionDataRow::AssociatedActiveSkillType' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, ProfileUpgradeCategory) == 0x000059, "Member 'FRBItemProgressionDataRow::ProfileUpgradeCategory' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, PerkCategory) == 0x00005A, "Member 'FRBItemProgressionDataRow::PerkCategory' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, bAvailable) == 0x00005B, "Member 'FRBItemProgressionDataRow::bAvailable' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, bAlwaysAcquired) == 0x00005C, "Member 'FRBItemProgressionDataRow::bAlwaysAcquired' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RequiredLevel_Character) == 0x000060, "Member 'FRBItemProgressionDataRow::RequiredLevel_Character' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RequiredItems) == 0x000068, "Member 'FRBItemProgressionDataRow::RequiredItems' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, CurrencyCost_MurkoffPoint) == 0x000078, "Member 'FRBItemProgressionDataRow::CurrencyCost_MurkoffPoint' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, CurrencyCost_EventToken) == 0x00007C, "Member 'FRBItemProgressionDataRow::CurrencyCost_EventToken' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Currency_BattlePassPremiumToken) == 0x000080, "Member 'FRBItemProgressionDataRow::Currency_BattlePassPremiumToken' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, BattlePassId) == 0x000084, "Member 'FRBItemProgressionDataRow::BattlePassId' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, BattlePassPageIndex) == 0x00008C, "Member 'FRBItemProgressionDataRow::BattlePassPageIndex' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, BattlePassPageItemIndex) == 0x000090, "Member 'FRBItemProgressionDataRow::BattlePassPageItemIndex' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, BattlePassCurrencyType) == 0x000094, "Member 'FRBItemProgressionDataRow::BattlePassCurrencyType' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, BattlePassCurrencyCost) == 0x000098, "Member 'FRBItemProgressionDataRow::BattlePassCurrencyCost' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, Effects) == 0x0000A0, "Member 'FRBItemProgressionDataRow::Effects' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, FeatureSwitch) == 0x0000B0, "Member 'FRBItemProgressionDataRow::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, DisplayFeatureSwitch) == 0x0000C0, "Member 'FRBItemProgressionDataRow::DisplayFeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolId) == 0x0000D0, "Member 'FRBItemProgressionDataRow::RewardPoolId' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolWeight) == 0x0000D8, "Member 'FRBItemProgressionDataRow::RewardPoolWeight' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolId2) == 0x0000DC, "Member 'FRBItemProgressionDataRow::RewardPoolId2' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolWeight2) == 0x0000E4, "Member 'FRBItemProgressionDataRow::RewardPoolWeight2' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolId3) == 0x0000E8, "Member 'FRBItemProgressionDataRow::RewardPoolId3' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, RewardPoolWeight3) == 0x0000F0, "Member 'FRBItemProgressionDataRow::RewardPoolWeight3' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, TrialChainingRewardWeight) == 0x0000F4, "Member 'FRBItemProgressionDataRow::TrialChainingRewardWeight' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, TrialChainingRewardWeightInSolo) == 0x0000F8, "Member 'FRBItemProgressionDataRow::TrialChainingRewardWeightInSolo' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, TrialChainingRequiredItemIds) == 0x000100, "Member 'FRBItemProgressionDataRow::TrialChainingRequiredItemIds' has a wrong offset!");
static_assert(offsetof(FRBItemProgressionDataRow, LinkedEvent) == 0x000110, "Member 'FRBItemProgressionDataRow::LinkedEvent' has a wrong offset!");

// ScriptStruct OPP.ItemClassCacheEntry
// 0x0010 (0x0010 - 0x0000)
struct FItemClassCacheEntry final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARBPickup>                  AssociatedClass;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemClassCacheEntry) == 0x000008, "Wrong alignment on FItemClassCacheEntry");
static_assert(sizeof(FItemClassCacheEntry) == 0x000010, "Wrong size on FItemClassCacheEntry");
static_assert(offsetof(FItemClassCacheEntry, ItemType) == 0x000000, "Member 'FItemClassCacheEntry::ItemType' has a wrong offset!");
static_assert(offsetof(FItemClassCacheEntry, AssociatedClass) == 0x000008, "Member 'FItemClassCacheEntry::AssociatedClass' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningInfo
// 0x01F8 (0x01F8 - 0x0000)
struct FItemSpawningInfo final
{
public:
	struct FConfigurableInt                       MinNumberOfItems;                                  // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemLockType                                 LockType;                                          // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableBool                      CanSpawnInOpenSpace;                               // 0x00D0(0x0060)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MinDistanceBetweenItemOfSameType;                  // 0x0130(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawningInfo) == 0x000008, "Wrong alignment on FItemSpawningInfo");
static_assert(sizeof(FItemSpawningInfo) == 0x0001F8, "Wrong size on FItemSpawningInfo");
static_assert(offsetof(FItemSpawningInfo, MinNumberOfItems) == 0x000000, "Member 'FItemSpawningInfo::MinNumberOfItems' has a wrong offset!");
static_assert(offsetof(FItemSpawningInfo, ItemType) == 0x0000C8, "Member 'FItemSpawningInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FItemSpawningInfo, LockType) == 0x0000C9, "Member 'FItemSpawningInfo::LockType' has a wrong offset!");
static_assert(offsetof(FItemSpawningInfo, CanSpawnInOpenSpace) == 0x0000D0, "Member 'FItemSpawningInfo::CanSpawnInOpenSpace' has a wrong offset!");
static_assert(offsetof(FItemSpawningInfo, MinDistanceBetweenItemOfSameType) == 0x000130, "Member 'FItemSpawningInfo::MinDistanceBetweenItemOfSameType' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningManagerRuntimeInfo
// 0x02A8 (0x02A8 - 0x0000)
struct FItemSpawningManagerRuntimeInfo final
{
public:
	TArray<class ARBContainer*>                   ContainersUsed;                                    // 0x0000(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   ContainersAvailableForStage;                       // 0x0010(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	int32                                         NumberOfItemsRemainingInStage;                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberToLock;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalItems;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSectionSpawningOverrideRuntimeInfo> SectionOverrideInfos;                              // 0x0030(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	struct FItemSpawningInfo                      SpawningInfoCache;                                 // 0x0040(0x01F8)(RepSkip, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemSpawningManagerTypeStats          Stats;                                             // 0x0240(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawningManagerRuntimeInfo) == 0x000008, "Wrong alignment on FItemSpawningManagerRuntimeInfo");
static_assert(sizeof(FItemSpawningManagerRuntimeInfo) == 0x0002A8, "Wrong size on FItemSpawningManagerRuntimeInfo");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, ContainersUsed) == 0x000000, "Member 'FItemSpawningManagerRuntimeInfo::ContainersUsed' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, ContainersAvailableForStage) == 0x000010, "Member 'FItemSpawningManagerRuntimeInfo::ContainersAvailableForStage' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, NumberOfItemsRemainingInStage) == 0x000020, "Member 'FItemSpawningManagerRuntimeInfo::NumberOfItemsRemainingInStage' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, NumberToLock) == 0x000024, "Member 'FItemSpawningManagerRuntimeInfo::NumberToLock' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, AdditionalItems) == 0x000028, "Member 'FItemSpawningManagerRuntimeInfo::AdditionalItems' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, SectionOverrideInfos) == 0x000030, "Member 'FItemSpawningManagerRuntimeInfo::SectionOverrideInfos' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, SpawningInfoCache) == 0x000040, "Member 'FItemSpawningManagerRuntimeInfo::SpawningInfoCache' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, ItemType) == 0x000238, "Member 'FItemSpawningManagerRuntimeInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FItemSpawningManagerRuntimeInfo, Stats) == 0x000240, "Member 'FItemSpawningManagerRuntimeInfo::Stats' has a wrong offset!");

// ScriptStruct OPP.ReplacedContainerInfo
// 0x0120 (0x0120 - 0x0000)
struct alignas(0x10) FReplacedContainerInfo final
{
public:
	TSubclassOf<class AActor>                     ActorToReplaceClass;                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AActor>, float>        ForcedActorToDistance;                             // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARBContainer>               ContainerClass;                                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBRandomizableHelperComponent*> RandomHelpersToCheck;                              // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         PossibleActorsToReplace;                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsReplaced;                                    // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   SpawnedContainers;                                 // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplacedContainerInfo) == 0x000010, "Wrong alignment on FReplacedContainerInfo");
static_assert(sizeof(FReplacedContainerInfo) == 0x000120, "Wrong size on FReplacedContainerInfo");
static_assert(offsetof(FReplacedContainerInfo, ActorToReplaceClass) == 0x000000, "Member 'FReplacedContainerInfo::ActorToReplaceClass' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, ForcedActorToDistance) == 0x000008, "Member 'FReplacedContainerInfo::ForcedActorToDistance' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, ContainerClass) == 0x000078, "Member 'FReplacedContainerInfo::ContainerClass' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, RandomHelpersToCheck) == 0x0000D0, "Member 'FReplacedContainerInfo::RandomHelpersToCheck' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, PossibleActorsToReplace) == 0x0000E0, "Member 'FReplacedContainerInfo::PossibleActorsToReplace' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, ActorsReplaced) == 0x0000F0, "Member 'FReplacedContainerInfo::ActorsReplaced' has a wrong offset!");
static_assert(offsetof(FReplacedContainerInfo, SpawnedContainers) == 0x000100, "Member 'FReplacedContainerInfo::SpawnedContainers' has a wrong offset!");

// ScriptStruct OPP.CollectableContainerInfo
// 0x0048 (0x0048 - 0x0000)
struct FCollectableContainerInfo final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBPickup>                  CollectableClass;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBContainer*>                   PossibleContainers;                                // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARBContainer*>                   UsedContainers;                                    // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectableContainerInfo) == 0x000008, "Wrong alignment on FCollectableContainerInfo");
static_assert(sizeof(FCollectableContainerInfo) == 0x000048, "Wrong size on FCollectableContainerInfo");
static_assert(offsetof(FCollectableContainerInfo, Requester) == 0x000000, "Member 'FCollectableContainerInfo::Requester' has a wrong offset!");
static_assert(offsetof(FCollectableContainerInfo, CollectableClass) == 0x000008, "Member 'FCollectableContainerInfo::CollectableClass' has a wrong offset!");
static_assert(offsetof(FCollectableContainerInfo, PossibleContainers) == 0x000028, "Member 'FCollectableContainerInfo::PossibleContainers' has a wrong offset!");
static_assert(offsetof(FCollectableContainerInfo, UsedContainers) == 0x000038, "Member 'FCollectableContainerInfo::UsedContainers' has a wrong offset!");

// ScriptStruct OPP.LockedContainerToFillInfo
// 0x0018 (0x0018 - 0x0000)
struct FLockedContainerToFillInfo final
{
public:
	class ARBContainer*                           Container;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLockedContainerToFillInfo) == 0x000008, "Wrong alignment on FLockedContainerToFillInfo");
static_assert(sizeof(FLockedContainerToFillInfo) == 0x000018, "Wrong size on FLockedContainerToFillInfo");
static_assert(offsetof(FLockedContainerToFillInfo, Container) == 0x000000, "Member 'FLockedContainerToFillInfo::Container' has a wrong offset!");

// ScriptStruct OPP.ItemSpawningOverrideRule
// 0x0198 (0x0198 - 0x0000)
struct FItemSpawningOverrideRule final
{
public:
	bool                                          bAllowUnusedContainersForStage;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseItemsFromStagePool;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     PercentFromStageCount;                             // 0x0008(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       FixedCount;                                        // 0x00D0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawningOverrideRule) == 0x000008, "Wrong alignment on FItemSpawningOverrideRule");
static_assert(sizeof(FItemSpawningOverrideRule) == 0x000198, "Wrong size on FItemSpawningOverrideRule");
static_assert(offsetof(FItemSpawningOverrideRule, bAllowUnusedContainersForStage) == 0x000000, "Member 'FItemSpawningOverrideRule::bAllowUnusedContainersForStage' has a wrong offset!");
static_assert(offsetof(FItemSpawningOverrideRule, bUseItemsFromStagePool) == 0x000001, "Member 'FItemSpawningOverrideRule::bUseItemsFromStagePool' has a wrong offset!");
static_assert(offsetof(FItemSpawningOverrideRule, PercentFromStageCount) == 0x000008, "Member 'FItemSpawningOverrideRule::PercentFromStageCount' has a wrong offset!");
static_assert(offsetof(FItemSpawningOverrideRule, FixedCount) == 0x0000D0, "Member 'FItemSpawningOverrideRule::FixedCount' has a wrong offset!");

// ScriptStruct OPP.RBItemsSpawningConfig
// 0x0030 (0x0030 - 0x0000)
struct FRBItemsSpawningConfig final
{
public:
	TArray<struct FItemSpawningInfo>              RegularItemSpawningInfos;                          // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemSpawningInfo>              SuperItemSpawningInfos;                            // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemSpawningInfo>              CollectibleItemsSpawningInfos;                     // 0x0020(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBItemsSpawningConfig) == 0x000008, "Wrong alignment on FRBItemsSpawningConfig");
static_assert(sizeof(FRBItemsSpawningConfig) == 0x000030, "Wrong size on FRBItemsSpawningConfig");
static_assert(offsetof(FRBItemsSpawningConfig, RegularItemSpawningInfos) == 0x000000, "Member 'FRBItemsSpawningConfig::RegularItemSpawningInfos' has a wrong offset!");
static_assert(offsetof(FRBItemsSpawningConfig, SuperItemSpawningInfos) == 0x000010, "Member 'FRBItemsSpawningConfig::SuperItemSpawningInfos' has a wrong offset!");
static_assert(offsetof(FRBItemsSpawningConfig, CollectibleItemsSpawningInfos) == 0x000020, "Member 'FRBItemsSpawningConfig::CollectibleItemsSpawningInfos' has a wrong offset!");

// ScriptStruct OPP.ContainerLimitationRuntimeInfo
// 0x0020 (0x0020 - 0x0000)
struct FContainerLimitationRuntimeInfo final
{
public:
	int32                                         MaxNumber;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBContainer*>                   UsedContainers;                                    // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBContainer>               ContainerClass;                                    // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerLimitationRuntimeInfo) == 0x000008, "Wrong alignment on FContainerLimitationRuntimeInfo");
static_assert(sizeof(FContainerLimitationRuntimeInfo) == 0x000020, "Wrong size on FContainerLimitationRuntimeInfo");
static_assert(offsetof(FContainerLimitationRuntimeInfo, MaxNumber) == 0x000000, "Member 'FContainerLimitationRuntimeInfo::MaxNumber' has a wrong offset!");
static_assert(offsetof(FContainerLimitationRuntimeInfo, UsedContainers) == 0x000008, "Member 'FContainerLimitationRuntimeInfo::UsedContainers' has a wrong offset!");
static_assert(offsetof(FContainerLimitationRuntimeInfo, ContainerClass) == 0x000018, "Member 'FContainerLimitationRuntimeInfo::ContainerClass' has a wrong offset!");

// ScriptStruct OPP.ContainerLimitationInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FContainerLimitationInfo final
{
public:
	struct FConfigurableInt                       MaxNumber;                                         // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ContainerClassPath;                                // 0x00C8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerLimitationInfo) == 0x000008, "Wrong alignment on FContainerLimitationInfo");
static_assert(sizeof(FContainerLimitationInfo) == 0x0000E0, "Wrong size on FContainerLimitationInfo");
static_assert(offsetof(FContainerLimitationInfo, MaxNumber) == 0x000000, "Member 'FContainerLimitationInfo::MaxNumber' has a wrong offset!");
static_assert(offsetof(FContainerLimitationInfo, ContainerClassPath) == 0x0000C8, "Member 'FContainerLimitationInfo::ContainerClassPath' has a wrong offset!");

// ScriptStruct OPP.PlayedVOInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPlayedVOInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayedVOInfo) == 0x000008, "Wrong alignment on FPlayedVOInfo");
static_assert(sizeof(FPlayedVOInfo) == 0x000018, "Wrong size on FPlayedVOInfo");

// ScriptStruct OPP.KeyLockingDeviceDoor
// 0x0088 (0x0088 - 0x0000)
struct FKeyLockingDeviceDoor final
{
public:
	TSoftObjectPtr<class AActor>                  ReplacedDoor;                                      // 0x0000(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  LockingDevice;                                     // 0x0028(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          HintTVs;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  HintTV;                                            // 0x0060(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyLockingDeviceDoor) == 0x000008, "Wrong alignment on FKeyLockingDeviceDoor");
static_assert(sizeof(FKeyLockingDeviceDoor) == 0x000088, "Wrong size on FKeyLockingDeviceDoor");
static_assert(offsetof(FKeyLockingDeviceDoor, ReplacedDoor) == 0x000000, "Member 'FKeyLockingDeviceDoor::ReplacedDoor' has a wrong offset!");
static_assert(offsetof(FKeyLockingDeviceDoor, LockingDevice) == 0x000028, "Member 'FKeyLockingDeviceDoor::LockingDevice' has a wrong offset!");
static_assert(offsetof(FKeyLockingDeviceDoor, HintTVs) == 0x000050, "Member 'FKeyLockingDeviceDoor::HintTVs' has a wrong offset!");
static_assert(offsetof(FKeyLockingDeviceDoor, HintTV) == 0x000060, "Member 'FKeyLockingDeviceDoor::HintTV' has a wrong offset!");

// ScriptStruct OPP.KeyLockingActors
// 0x0060 (0x0060 - 0x0000)
struct FKeyLockingActors final
{
public:
	TArray<TSoftObjectPtr<class AActor>>          ActorsToMatchState;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorsToInverseMatchState;                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FKeyLockingDeviceDoor>          DeviceDoors;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorsScheduledNoKeyBait;                          // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          FinalRoomActors;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          InverseFinalRoomActors;                            // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyLockingActors) == 0x000008, "Wrong alignment on FKeyLockingActors");
static_assert(sizeof(FKeyLockingActors) == 0x000060, "Wrong size on FKeyLockingActors");
static_assert(offsetof(FKeyLockingActors, ActorsToMatchState) == 0x000000, "Member 'FKeyLockingActors::ActorsToMatchState' has a wrong offset!");
static_assert(offsetof(FKeyLockingActors, ActorsToInverseMatchState) == 0x000010, "Member 'FKeyLockingActors::ActorsToInverseMatchState' has a wrong offset!");
static_assert(offsetof(FKeyLockingActors, DeviceDoors) == 0x000020, "Member 'FKeyLockingActors::DeviceDoors' has a wrong offset!");
static_assert(offsetof(FKeyLockingActors, ActorsScheduledNoKeyBait) == 0x000030, "Member 'FKeyLockingActors::ActorsScheduledNoKeyBait' has a wrong offset!");
static_assert(offsetof(FKeyLockingActors, FinalRoomActors) == 0x000040, "Member 'FKeyLockingActors::FinalRoomActors' has a wrong offset!");
static_assert(offsetof(FKeyLockingActors, InverseFinalRoomActors) == 0x000050, "Member 'FKeyLockingActors::InverseFinalRoomActors' has a wrong offset!");

// ScriptStruct OPP.ContinuousSoundConfig
// 0x0018 (0x0018 - 0x0000)
struct FContinuousSoundConfig final
{
public:
	class UAkAudioEvent*                          SoundStart;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundStop;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFoley;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableUnaware;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableInInvestigate;                           // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableInChase;                                 // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContinuousSoundNPCState                      NPCState;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContinuousSoundConfig) == 0x000008, "Wrong alignment on FContinuousSoundConfig");
static_assert(sizeof(FContinuousSoundConfig) == 0x000018, "Wrong size on FContinuousSoundConfig");
static_assert(offsetof(FContinuousSoundConfig, SoundStart) == 0x000000, "Member 'FContinuousSoundConfig::SoundStart' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, SoundStop) == 0x000008, "Member 'FContinuousSoundConfig::SoundStop' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, bIsFoley) == 0x000010, "Member 'FContinuousSoundConfig::bIsFoley' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, bAvailableUnaware) == 0x000011, "Member 'FContinuousSoundConfig::bAvailableUnaware' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, bAvailableInInvestigate) == 0x000012, "Member 'FContinuousSoundConfig::bAvailableInInvestigate' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, bAvailableInChase) == 0x000013, "Member 'FContinuousSoundConfig::bAvailableInChase' has a wrong offset!");
static_assert(offsetof(FContinuousSoundConfig, NPCState) == 0x000014, "Member 'FContinuousSoundConfig::NPCState' has a wrong offset!");

// ScriptStruct OPP.KeyItemsInfo
// 0x0028 (0x0028 - 0x0000)
struct FKeyItemsInfo final
{
public:
	class AActor*                                 KeyLockedDevice;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Key;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KeySpawner;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBRoom*                                Room;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickedUpOnce;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyItemsInfo) == 0x000008, "Wrong alignment on FKeyItemsInfo");
static_assert(sizeof(FKeyItemsInfo) == 0x000028, "Wrong size on FKeyItemsInfo");
static_assert(offsetof(FKeyItemsInfo, KeyLockedDevice) == 0x000000, "Member 'FKeyItemsInfo::KeyLockedDevice' has a wrong offset!");
static_assert(offsetof(FKeyItemsInfo, Key) == 0x000008, "Member 'FKeyItemsInfo::Key' has a wrong offset!");
static_assert(offsetof(FKeyItemsInfo, KeySpawner) == 0x000010, "Member 'FKeyItemsInfo::KeySpawner' has a wrong offset!");
static_assert(offsetof(FKeyItemsInfo, Room) == 0x000018, "Member 'FKeyItemsInfo::Room' has a wrong offset!");
static_assert(offsetof(FKeyItemsInfo, bPickedUpOnce) == 0x000020, "Member 'FKeyItemsInfo::bPickedUpOnce' has a wrong offset!");

// ScriptStruct OPP.KeyInfo
// 0x0018 (0x0018 - 0x0000)
struct FKeyInfo final
{
public:
	class AActor*                                 KeyActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBPickup>                  KeyType;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KeySpawner;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyInfo) == 0x000008, "Wrong alignment on FKeyInfo");
static_assert(sizeof(FKeyInfo) == 0x000018, "Wrong size on FKeyInfo");
static_assert(offsetof(FKeyInfo, KeyActor) == 0x000000, "Member 'FKeyInfo::KeyActor' has a wrong offset!");
static_assert(offsetof(FKeyInfo, KeyType) == 0x000008, "Member 'FKeyInfo::KeyType' has a wrong offset!");
static_assert(offsetof(FKeyInfo, KeySpawner) == 0x000010, "Member 'FKeyInfo::KeySpawner' has a wrong offset!");

// ScriptStruct OPP.RBLevelRandomizer
// 0x0001 (0x0001 - 0x0000)
struct FRBLevelRandomizer final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBLevelRandomizer) == 0x000001, "Wrong alignment on FRBLevelRandomizer");
static_assert(sizeof(FRBLevelRandomizer) == 0x000001, "Wrong size on FRBLevelRandomizer");

// ScriptStruct OPP.LightAnimationData
// 0x0020 (0x0020 - 0x0000)
struct FLightAnimationData final
{
public:
	class UCurveFloat*                            OldAnimCurve;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AnimationCurve;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimationCurveLooping;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationCurveStartTime;                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationCurveIntensity;                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightAnimationData) == 0x000008, "Wrong alignment on FLightAnimationData");
static_assert(sizeof(FLightAnimationData) == 0x000020, "Wrong size on FLightAnimationData");
static_assert(offsetof(FLightAnimationData, OldAnimCurve) == 0x000000, "Member 'FLightAnimationData::OldAnimCurve' has a wrong offset!");
static_assert(offsetof(FLightAnimationData, AnimationCurve) == 0x000008, "Member 'FLightAnimationData::AnimationCurve' has a wrong offset!");
static_assert(offsetof(FLightAnimationData, AnimationCurveLooping) == 0x000010, "Member 'FLightAnimationData::AnimationCurveLooping' has a wrong offset!");
static_assert(offsetof(FLightAnimationData, AnimationCurveStartTime) == 0x000014, "Member 'FLightAnimationData::AnimationCurveStartTime' has a wrong offset!");
static_assert(offsetof(FLightAnimationData, AnimationCurveIntensity) == 0x000018, "Member 'FLightAnimationData::AnimationCurveIntensity' has a wrong offset!");

// ScriptStruct OPP.RBLoadingScreenHintRow
// 0x0018 (0x0020 - 0x0008)
struct FRBLoadingScreenHintRow final : public FTableRowBase
{
public:
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBLoadingScreenHintRow) == 0x000008, "Wrong alignment on FRBLoadingScreenHintRow");
static_assert(sizeof(FRBLoadingScreenHintRow) == 0x000020, "Wrong size on FRBLoadingScreenHintRow");
static_assert(offsetof(FRBLoadingScreenHintRow, Text) == 0x000008, "Member 'FRBLoadingScreenHintRow::Text' has a wrong offset!");

// ScriptStruct OPP.ContinuousSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FContinuousSoundInfo final
{
public:
	class UAkAudioEvent*                          SoundStart;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundStop;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContinuousSoundInfo) == 0x000008, "Wrong alignment on FContinuousSoundInfo");
static_assert(sizeof(FContinuousSoundInfo) == 0x000010, "Wrong size on FContinuousSoundInfo");
static_assert(offsetof(FContinuousSoundInfo, SoundStart) == 0x000000, "Member 'FContinuousSoundInfo::SoundStart' has a wrong offset!");
static_assert(offsetof(FContinuousSoundInfo, SoundStop) == 0x000008, "Member 'FContinuousSoundInfo::SoundStop' has a wrong offset!");

// ScriptStruct OPP.NPCStorylineFallbackPaths
// 0x0050 (0x0050 - 0x0000)
struct FNPCStorylineFallbackPaths final
{
public:
	TMap<class FString, struct FNPCStorylineFallbackPool> StoryLineFallbackPools;                            // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCStorylineFallbackPaths) == 0x000008, "Wrong alignment on FNPCStorylineFallbackPaths");
static_assert(sizeof(FNPCStorylineFallbackPaths) == 0x000050, "Wrong size on FNPCStorylineFallbackPaths");
static_assert(offsetof(FNPCStorylineFallbackPaths, StoryLineFallbackPools) == 0x000000, "Member 'FNPCStorylineFallbackPaths::StoryLineFallbackPools' has a wrong offset!");

// ScriptStruct OPP.NarrativeScreenAnimationData
// 0x0018 (0x0018 - 0x0000)
struct FNarrativeScreenAnimationData final
{
public:
	struct FDataTableRowHandle                    AnimationRow;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENarrativeScreenDataTableLogic                DataTableLogic;                                    // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenRows;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNarrativeScreenAnimationData) == 0x000008, "Wrong alignment on FNarrativeScreenAnimationData");
static_assert(sizeof(FNarrativeScreenAnimationData) == 0x000018, "Wrong size on FNarrativeScreenAnimationData");
static_assert(offsetof(FNarrativeScreenAnimationData, AnimationRow) == 0x000000, "Member 'FNarrativeScreenAnimationData::AnimationRow' has a wrong offset!");
static_assert(offsetof(FNarrativeScreenAnimationData, bLoop) == 0x000010, "Member 'FNarrativeScreenAnimationData::bLoop' has a wrong offset!");
static_assert(offsetof(FNarrativeScreenAnimationData, DataTableLogic) == 0x000011, "Member 'FNarrativeScreenAnimationData::DataTableLogic' has a wrong offset!");
static_assert(offsetof(FNarrativeScreenAnimationData, DelayBetweenRows) == 0x000014, "Member 'FNarrativeScreenAnimationData::DelayBetweenRows' has a wrong offset!");

// ScriptStruct OPP.EvaluationCorridorTVAnimations
// 0x0080 (0x0080 - 0x0000)
struct FEvaluationCorridorTVAnimations final
{
public:
	TMap<EPlayerTrialRating, struct FNarrativeScreenAnimationData> TrialOutcomeTVAnimations;                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FNarrativeScreenAnimationData          TutorialCompletedTVAnimation;                      // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FNarrativeScreenAnimationData          FallbackTVAnimations;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEvaluationCorridorTVAnimations) == 0x000008, "Wrong alignment on FEvaluationCorridorTVAnimations");
static_assert(sizeof(FEvaluationCorridorTVAnimations) == 0x000080, "Wrong size on FEvaluationCorridorTVAnimations");
static_assert(offsetof(FEvaluationCorridorTVAnimations, TrialOutcomeTVAnimations) == 0x000000, "Member 'FEvaluationCorridorTVAnimations::TrialOutcomeTVAnimations' has a wrong offset!");
static_assert(offsetof(FEvaluationCorridorTVAnimations, TutorialCompletedTVAnimation) == 0x000050, "Member 'FEvaluationCorridorTVAnimations::TutorialCompletedTVAnimation' has a wrong offset!");
static_assert(offsetof(FEvaluationCorridorTVAnimations, FallbackTVAnimations) == 0x000068, "Member 'FEvaluationCorridorTVAnimations::FallbackTVAnimations' has a wrong offset!");

// ScriptStruct OPP.WWWBotDebuggingData
// 0x0370 (0x0370 - 0x0000)
struct FWWWBotDebuggingData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBotDebugInfo                          BotDebugInfo;                                      // 0x0008(0x0358)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAnimSequence*                          MostRelevantAnim;                                  // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWBotDebuggingData) == 0x000008, "Wrong alignment on FWWWBotDebuggingData");
static_assert(sizeof(FWWWBotDebuggingData) == 0x000370, "Wrong size on FWWWBotDebuggingData");
static_assert(offsetof(FWWWBotDebuggingData, BotDebugInfo) == 0x000008, "Member 'FWWWBotDebuggingData::BotDebugInfo' has a wrong offset!");
static_assert(offsetof(FWWWBotDebuggingData, MostRelevantAnim) == 0x000360, "Member 'FWWWBotDebuggingData::MostRelevantAnim' has a wrong offset!");

// ScriptStruct OPP.WWWPawnRecord
// 0x0068 (0x0068 - 0x0000)
struct FWWWPawnRecord final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWWWBotDebuggingData>           BotDebuggingData;                                  // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FWWWPlayerDebuggingData>        PlayerDebuggingData;                               // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWPawnRecord) == 0x000008, "Wrong alignment on FWWWPawnRecord");
static_assert(sizeof(FWWWPawnRecord) == 0x000068, "Wrong size on FWWWPawnRecord");
static_assert(offsetof(FWWWPawnRecord, BotDebuggingData) == 0x000038, "Member 'FWWWPawnRecord::BotDebuggingData' has a wrong offset!");
static_assert(offsetof(FWWWPawnRecord, PlayerDebuggingData) == 0x000048, "Member 'FWWWPawnRecord::PlayerDebuggingData' has a wrong offset!");

// ScriptStruct OPP.WWWRecordingData
// 0x00D0 (0x00D0 - 0x0000)
struct FWWWRecordingData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FWWWObjectKey, struct FWWWPawnRecord> PawnRecords;                                       // 0x0010(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x70];                                      // 0x0060(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWWWRecordingData) == 0x000008, "Wrong alignment on FWWWRecordingData");
static_assert(sizeof(FWWWRecordingData) == 0x0000D0, "Wrong size on FWWWRecordingData");
static_assert(offsetof(FWWWRecordingData, PawnRecords) == 0x000010, "Member 'FWWWRecordingData::PawnRecords' has a wrong offset!");

// ScriptStruct OPP.DirectorVOs
// 0x0108 (0x0108 - 0x0000)
struct FDirectorVOs final
{
public:
	TMap<EMetaNPCType, class UAkAudioEvent*>      NPCUnlockedVOs;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EMetaNPCType, struct FHUDTutorialTextData> NPCUnlockedTutorialData;                           // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerTrialRating, class UAkAudioEvent*> TrialOutcomeVOs;                                   // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LevelUpVO;                                         // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          TutorialCompletedVO;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          NewReagentExplanation;                             // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectorVOs) == 0x000008, "Wrong alignment on FDirectorVOs");
static_assert(sizeof(FDirectorVOs) == 0x000108, "Wrong size on FDirectorVOs");
static_assert(offsetof(FDirectorVOs, NPCUnlockedVOs) == 0x000000, "Member 'FDirectorVOs::NPCUnlockedVOs' has a wrong offset!");
static_assert(offsetof(FDirectorVOs, NPCUnlockedTutorialData) == 0x000050, "Member 'FDirectorVOs::NPCUnlockedTutorialData' has a wrong offset!");
static_assert(offsetof(FDirectorVOs, TrialOutcomeVOs) == 0x0000A0, "Member 'FDirectorVOs::TrialOutcomeVOs' has a wrong offset!");
static_assert(offsetof(FDirectorVOs, LevelUpVO) == 0x0000F0, "Member 'FDirectorVOs::LevelUpVO' has a wrong offset!");
static_assert(offsetof(FDirectorVOs, TutorialCompletedVO) == 0x0000F8, "Member 'FDirectorVOs::TutorialCompletedVO' has a wrong offset!");
static_assert(offsetof(FDirectorVOs, NewReagentExplanation) == 0x000100, "Member 'FDirectorVOs::NewReagentExplanation' has a wrong offset!");

// ScriptStruct OPP.NPCLobbyInteractionData
// 0x0038 (0x0038 - 0x0000)
struct FNPCLobbyInteractionData final
{
public:
	class UAkAudioEvent*                          Approach;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ApproachLocked;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          InteractFirstTime;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Interact;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          InteractNewStuff;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PurchasedItem;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Exit;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCLobbyInteractionData) == 0x000008, "Wrong alignment on FNPCLobbyInteractionData");
static_assert(sizeof(FNPCLobbyInteractionData) == 0x000038, "Wrong size on FNPCLobbyInteractionData");
static_assert(offsetof(FNPCLobbyInteractionData, Approach) == 0x000000, "Member 'FNPCLobbyInteractionData::Approach' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, ApproachLocked) == 0x000008, "Member 'FNPCLobbyInteractionData::ApproachLocked' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, InteractFirstTime) == 0x000010, "Member 'FNPCLobbyInteractionData::InteractFirstTime' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, Interact) == 0x000018, "Member 'FNPCLobbyInteractionData::Interact' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, InteractNewStuff) == 0x000020, "Member 'FNPCLobbyInteractionData::InteractNewStuff' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, PurchasedItem) == 0x000028, "Member 'FNPCLobbyInteractionData::PurchasedItem' has a wrong offset!");
static_assert(offsetof(FNPCLobbyInteractionData, Exit) == 0x000030, "Member 'FNPCLobbyInteractionData::Exit' has a wrong offset!");

// ScriptStruct OPP.LobbyGamePlayer
// 0x0010 (0x0010 - 0x0000)
struct FLobbyGamePlayer final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyGameTeam                                Team;                                              // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyGamePlayer) == 0x000008, "Wrong alignment on FLobbyGamePlayer");
static_assert(sizeof(FLobbyGamePlayer) == 0x000010, "Wrong size on FLobbyGamePlayer");
static_assert(offsetof(FLobbyGamePlayer, Player) == 0x000000, "Member 'FLobbyGamePlayer::Player' has a wrong offset!");
static_assert(offsetof(FLobbyGamePlayer, Team) == 0x000008, "Member 'FLobbyGamePlayer::Team' has a wrong offset!");

// ScriptStruct OPP.RBLobbyStatBoardStatConfigEntry
// 0x000C (0x000C - 0x0000)
struct FRBLobbyStatBoardStatConfigEntry final
{
public:
	class FName                                   StatId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStatContextType                        ContextType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBLobbyStatBoardStatConfigEntry) == 0x000004, "Wrong alignment on FRBLobbyStatBoardStatConfigEntry");
static_assert(sizeof(FRBLobbyStatBoardStatConfigEntry) == 0x00000C, "Wrong size on FRBLobbyStatBoardStatConfigEntry");
static_assert(offsetof(FRBLobbyStatBoardStatConfigEntry, StatId) == 0x000000, "Member 'FRBLobbyStatBoardStatConfigEntry::StatId' has a wrong offset!");
static_assert(offsetof(FRBLobbyStatBoardStatConfigEntry, ContextType) == 0x000008, "Member 'FRBLobbyStatBoardStatConfigEntry::ContextType' has a wrong offset!");

// ScriptStruct OPP.GetNextStorylineCachedResult
// 0x0028 (0x0028 - 0x0000)
struct FGetNextStorylineCachedResult final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StorylineLevelPlayed;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFallbackVO;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FeatureSwitchPlayed;                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StorylineVO;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetNextStorylineCachedResult) == 0x000008, "Wrong alignment on FGetNextStorylineCachedResult");
static_assert(sizeof(FGetNextStorylineCachedResult) == 0x000028, "Wrong size on FGetNextStorylineCachedResult");
static_assert(offsetof(FGetNextStorylineCachedResult, StorylineLevelPlayed) == 0x000004, "Member 'FGetNextStorylineCachedResult::StorylineLevelPlayed' has a wrong offset!");
static_assert(offsetof(FGetNextStorylineCachedResult, bIsFallbackVO) == 0x000008, "Member 'FGetNextStorylineCachedResult::bIsFallbackVO' has a wrong offset!");
static_assert(offsetof(FGetNextStorylineCachedResult, FeatureSwitchPlayed) == 0x000010, "Member 'FGetNextStorylineCachedResult::FeatureSwitchPlayed' has a wrong offset!");
static_assert(offsetof(FGetNextStorylineCachedResult, StorylineVO) == 0x000020, "Member 'FGetNextStorylineCachedResult::StorylineVO' has a wrong offset!");

// ScriptStruct OPP.FeatureSwitchStorylineLevelPlayed
// 0x0050 (0x0050 - 0x0000)
struct FFeatureSwitchStorylineLevelPlayed final
{
public:
	TMap<class FString, int32>                    StorylineLevelPlayedPerFeatureSwitch;              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeatureSwitchStorylineLevelPlayed) == 0x000008, "Wrong alignment on FFeatureSwitchStorylineLevelPlayed");
static_assert(sizeof(FFeatureSwitchStorylineLevelPlayed) == 0x000050, "Wrong size on FFeatureSwitchStorylineLevelPlayed");
static_assert(offsetof(FFeatureSwitchStorylineLevelPlayed, StorylineLevelPlayedPerFeatureSwitch) == 0x000000, "Member 'FFeatureSwitchStorylineLevelPlayed::StorylineLevelPlayedPerFeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.LongJumpInfo
// 0x0028 (0x0028 - 0x0000)
struct FLongJumpInfo final
{
public:
	class ARBLedgeMarker*                         Marker1;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBLedgeMarker*                         Marker2;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPoint1;                                      // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPoint2;                                      // 0x001C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLongJumpInfo) == 0x000008, "Wrong alignment on FLongJumpInfo");
static_assert(sizeof(FLongJumpInfo) == 0x000028, "Wrong size on FLongJumpInfo");
static_assert(offsetof(FLongJumpInfo, Marker1) == 0x000000, "Member 'FLongJumpInfo::Marker1' has a wrong offset!");
static_assert(offsetof(FLongJumpInfo, Marker2) == 0x000008, "Member 'FLongJumpInfo::Marker2' has a wrong offset!");
static_assert(offsetof(FLongJumpInfo, CenterPoint1) == 0x000010, "Member 'FLongJumpInfo::CenterPoint1' has a wrong offset!");
static_assert(offsetof(FLongJumpInfo, CenterPoint2) == 0x00001C, "Member 'FLongJumpInfo::CenterPoint2' has a wrong offset!");

// ScriptStruct OPP.TrialEvaluationInfo
// 0x0008 (0x0008 - 0x0000)
struct FTrialEvaluationInfo final
{
public:
	float                                         PlayerScore;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLeveledUp;                                     // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasTutorialExperiment;                            // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasReagentReleaseTrial;                           // 0x0006(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucceeded;                                        // 0x0007(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialEvaluationInfo) == 0x000004, "Wrong alignment on FTrialEvaluationInfo");
static_assert(sizeof(FTrialEvaluationInfo) == 0x000008, "Wrong size on FTrialEvaluationInfo");
static_assert(offsetof(FTrialEvaluationInfo, PlayerScore) == 0x000000, "Member 'FTrialEvaluationInfo::PlayerScore' has a wrong offset!");
static_assert(offsetof(FTrialEvaluationInfo, bHasLeveledUp) == 0x000004, "Member 'FTrialEvaluationInfo::bHasLeveledUp' has a wrong offset!");
static_assert(offsetof(FTrialEvaluationInfo, bWasTutorialExperiment) == 0x000005, "Member 'FTrialEvaluationInfo::bWasTutorialExperiment' has a wrong offset!");
static_assert(offsetof(FTrialEvaluationInfo, bWasReagentReleaseTrial) == 0x000006, "Member 'FTrialEvaluationInfo::bWasReagentReleaseTrial' has a wrong offset!");
static_assert(offsetof(FTrialEvaluationInfo, bSucceeded) == 0x000007, "Member 'FTrialEvaluationInfo::bSucceeded' has a wrong offset!");

// ScriptStruct OPP.SubtitleData
// 0x0060 (0x0060 - 0x0000)
struct FSubtitleData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Speaker;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImplementsVisibilityInterface;                    // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoActor;                                          // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URBSoundComponent*                      SoundComponent;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtitleData) == 0x000008, "Wrong alignment on FSubtitleData");
static_assert(sizeof(FSubtitleData) == 0x000060, "Wrong size on FSubtitleData");
static_assert(offsetof(FSubtitleData, Speaker) == 0x000030, "Member 'FSubtitleData::Speaker' has a wrong offset!");
static_assert(offsetof(FSubtitleData, bImplementsVisibilityInterface) == 0x000038, "Member 'FSubtitleData::bImplementsVisibilityInterface' has a wrong offset!");
static_assert(offsetof(FSubtitleData, bNoActor) == 0x000039, "Member 'FSubtitleData::bNoActor' has a wrong offset!");
static_assert(offsetof(FSubtitleData, SoundComponent) == 0x000040, "Member 'FSubtitleData::SoundComponent' has a wrong offset!");
static_assert(offsetof(FSubtitleData, SoundEvent) == 0x000048, "Member 'FSubtitleData::SoundEvent' has a wrong offset!");

// ScriptStruct OPP.LanguageSubtitleSplittingInfo
// 0x0008 (0x0008 - 0x0000)
struct FLanguageSubtitleSplittingInfo final
{
public:
	int32                                         MaxCharactersPerLine;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsianSplitting;                                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLanguageSubtitleSplittingInfo) == 0x000004, "Wrong alignment on FLanguageSubtitleSplittingInfo");
static_assert(sizeof(FLanguageSubtitleSplittingInfo) == 0x000008, "Wrong size on FLanguageSubtitleSplittingInfo");
static_assert(offsetof(FLanguageSubtitleSplittingInfo, MaxCharactersPerLine) == 0x000000, "Member 'FLanguageSubtitleSplittingInfo::MaxCharactersPerLine' has a wrong offset!");
static_assert(offsetof(FLanguageSubtitleSplittingInfo, bAsianSplitting) == 0x000004, "Member 'FLanguageSubtitleSplittingInfo::bAsianSplitting' has a wrong offset!");

// ScriptStruct OPP.MinigameSectionConfig
// 0x00D8 (0x00D8 - 0x0000)
struct FMinigameSectionConfig final
{
public:
	struct FConfigurableInt                       MinimumRoomInSection;                              // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ARBRoom>>         Rooms;                                             // 0x00C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinigameSectionConfig) == 0x000008, "Wrong alignment on FMinigameSectionConfig");
static_assert(sizeof(FMinigameSectionConfig) == 0x0000D8, "Wrong size on FMinigameSectionConfig");
static_assert(offsetof(FMinigameSectionConfig, MinimumRoomInSection) == 0x000000, "Member 'FMinigameSectionConfig::MinimumRoomInSection' has a wrong offset!");
static_assert(offsetof(FMinigameSectionConfig, Rooms) == 0x0000C8, "Member 'FMinigameSectionConfig::Rooms' has a wrong offset!");

// ScriptStruct OPP.MolotovImpactData
// 0x0018 (0x0018 - 0x0000)
struct FMolotovImpactData final
{
public:
	struct FVector                                FireCenter;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireStartTimestamp;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropagationDataIndex;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDuration;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolotovImpactData) == 0x000004, "Wrong alignment on FMolotovImpactData");
static_assert(sizeof(FMolotovImpactData) == 0x000018, "Wrong size on FMolotovImpactData");
static_assert(offsetof(FMolotovImpactData, FireCenter) == 0x000000, "Member 'FMolotovImpactData::FireCenter' has a wrong offset!");
static_assert(offsetof(FMolotovImpactData, FireStartTimestamp) == 0x00000C, "Member 'FMolotovImpactData::FireStartTimestamp' has a wrong offset!");
static_assert(offsetof(FMolotovImpactData, PropagationDataIndex) == 0x000010, "Member 'FMolotovImpactData::PropagationDataIndex' has a wrong offset!");
static_assert(offsetof(FMolotovImpactData, FireDuration) == 0x000014, "Member 'FMolotovImpactData::FireDuration' has a wrong offset!");

// ScriptStruct OPP.MolotovPropagationData
// 0x0018 (0x0018 - 0x0000)
struct FMolotovPropagationData final
{
public:
	TArray<struct FVector>                        FirePoints;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EMolotovSize                                  MolotovSize;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMolotovPropagationData) == 0x000008, "Wrong alignment on FMolotovPropagationData");
static_assert(sizeof(FMolotovPropagationData) == 0x000018, "Wrong size on FMolotovPropagationData");
static_assert(offsetof(FMolotovPropagationData, FirePoints) == 0x000000, "Member 'FMolotovPropagationData::FirePoints' has a wrong offset!");
static_assert(offsetof(FMolotovPropagationData, MolotovSize) == 0x000010, "Member 'FMolotovPropagationData::MolotovSize' has a wrong offset!");

// ScriptStruct OPP.MolotovDamageSphereData
// 0x0010 (0x0010 - 0x0000)
struct FMolotovDamageSphereData final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolotovDamageSphereData) == 0x000004, "Wrong alignment on FMolotovDamageSphereData");
static_assert(sizeof(FMolotovDamageSphereData) == 0x000010, "Wrong size on FMolotovDamageSphereData");
static_assert(offsetof(FMolotovDamageSphereData, Radius) == 0x000000, "Member 'FMolotovDamageSphereData::Radius' has a wrong offset!");
static_assert(offsetof(FMolotovDamageSphereData, Location) == 0x000004, "Member 'FMolotovDamageSphereData::Location' has a wrong offset!");

// ScriptStruct OPP.NarrativeScreenPlayingData
// 0x0020 (0x0020 - 0x0000)
struct FNarrativeScreenPlayingData final
{
public:
	struct FNarrativeScreenAnimationData          AnimationData;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartTimeStamp;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNarrativeScreenPlayingData) == 0x000008, "Wrong alignment on FNarrativeScreenPlayingData");
static_assert(sizeof(FNarrativeScreenPlayingData) == 0x000020, "Wrong size on FNarrativeScreenPlayingData");
static_assert(offsetof(FNarrativeScreenPlayingData, AnimationData) == 0x000000, "Member 'FNarrativeScreenPlayingData::AnimationData' has a wrong offset!");
static_assert(offsetof(FNarrativeScreenPlayingData, StartTimeStamp) == 0x000018, "Member 'FNarrativeScreenPlayingData::StartTimeStamp' has a wrong offset!");

// ScriptStruct OPP.RBNavLinkObstacle
// 0x0020 (0x0020 - 0x0000)
struct FRBNavLinkObstacle final
{
public:
	TSubclassOf<class UNavArea>                   ObstacleAreaClass;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ObstacleExtent;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ObstacleOffset;                                    // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBNavLinkObstacle) == 0x000008, "Wrong alignment on FRBNavLinkObstacle");
static_assert(sizeof(FRBNavLinkObstacle) == 0x000020, "Wrong size on FRBNavLinkObstacle");
static_assert(offsetof(FRBNavLinkObstacle, ObstacleAreaClass) == 0x000000, "Member 'FRBNavLinkObstacle::ObstacleAreaClass' has a wrong offset!");
static_assert(offsetof(FRBNavLinkObstacle, ObstacleExtent) == 0x000008, "Member 'FRBNavLinkObstacle::ObstacleExtent' has a wrong offset!");
static_assert(offsetof(FRBNavLinkObstacle, ObstacleOffset) == 0x000014, "Member 'FRBNavLinkObstacle::ObstacleOffset' has a wrong offset!");

// ScriptStruct OPP.NetworkSoundActorSwitchStateData
// 0x0010 (0x0010 - 0x0000)
struct FNetworkSoundActorSwitchStateData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkSoundActorSwitchStateData) == 0x000004, "Wrong alignment on FNetworkSoundActorSwitchStateData");
static_assert(sizeof(FNetworkSoundActorSwitchStateData) == 0x000010, "Wrong size on FNetworkSoundActorSwitchStateData");
static_assert(offsetof(FNetworkSoundActorSwitchStateData, Name) == 0x000000, "Member 'FNetworkSoundActorSwitchStateData::Name' has a wrong offset!");
static_assert(offsetof(FNetworkSoundActorSwitchStateData, State) == 0x000008, "Member 'FNetworkSoundActorSwitchStateData::State' has a wrong offset!");

// ScriptStruct OPP.NetworkSoundComponentSwitchStateData
// 0x0010 (0x0010 - 0x0000)
struct FNetworkSoundComponentSwitchStateData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkSoundComponentSwitchStateData) == 0x000004, "Wrong alignment on FNetworkSoundComponentSwitchStateData");
static_assert(sizeof(FNetworkSoundComponentSwitchStateData) == 0x000010, "Wrong size on FNetworkSoundComponentSwitchStateData");
static_assert(offsetof(FNetworkSoundComponentSwitchStateData, Name) == 0x000000, "Member 'FNetworkSoundComponentSwitchStateData::Name' has a wrong offset!");
static_assert(offsetof(FNetworkSoundComponentSwitchStateData, State) == 0x000008, "Member 'FNetworkSoundComponentSwitchStateData::State' has a wrong offset!");

// ScriptStruct OPP.NetworkSoundComponentRTPCData
// 0x000C (0x000C - 0x0000)
struct FNetworkSoundComponentRTPCData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkSoundComponentRTPCData) == 0x000004, "Wrong alignment on FNetworkSoundComponentRTPCData");
static_assert(sizeof(FNetworkSoundComponentRTPCData) == 0x00000C, "Wrong size on FNetworkSoundComponentRTPCData");
static_assert(offsetof(FNetworkSoundComponentRTPCData, Name) == 0x000000, "Member 'FNetworkSoundComponentRTPCData::Name' has a wrong offset!");
static_assert(offsetof(FNetworkSoundComponentRTPCData, Value) == 0x000008, "Member 'FNetworkSoundComponentRTPCData::Value' has a wrong offset!");

// ScriptStruct OPP.NPCPathfindingCosts
// 0x0034 (0x0034 - 0x0000)
struct FNPCPathfindingCosts final
{
public:
	float                                         UnlockedDoorCost;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockedDoorCost;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenInvestigatedDoorCost;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnlockedInvestigatedDoorCost;                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockedInvestigatedDoorCost;                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyableDoorCostAware;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyableDoorCostUnaware;                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarricadeCostAware;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarricadeCostUnaware;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbLedgeCostAware;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbLedgeCostUnaware;                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchUnderCostAware;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchUnderCostUnaware;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCPathfindingCosts) == 0x000004, "Wrong alignment on FNPCPathfindingCosts");
static_assert(sizeof(FNPCPathfindingCosts) == 0x000034, "Wrong size on FNPCPathfindingCosts");
static_assert(offsetof(FNPCPathfindingCosts, UnlockedDoorCost) == 0x000000, "Member 'FNPCPathfindingCosts::UnlockedDoorCost' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, LockedDoorCost) == 0x000004, "Member 'FNPCPathfindingCosts::LockedDoorCost' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, OpenInvestigatedDoorCost) == 0x000008, "Member 'FNPCPathfindingCosts::OpenInvestigatedDoorCost' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, UnlockedInvestigatedDoorCost) == 0x00000C, "Member 'FNPCPathfindingCosts::UnlockedInvestigatedDoorCost' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, LockedInvestigatedDoorCost) == 0x000010, "Member 'FNPCPathfindingCosts::LockedInvestigatedDoorCost' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, DestroyableDoorCostAware) == 0x000014, "Member 'FNPCPathfindingCosts::DestroyableDoorCostAware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, DestroyableDoorCostUnaware) == 0x000018, "Member 'FNPCPathfindingCosts::DestroyableDoorCostUnaware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, BarricadeCostAware) == 0x00001C, "Member 'FNPCPathfindingCosts::BarricadeCostAware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, BarricadeCostUnaware) == 0x000020, "Member 'FNPCPathfindingCosts::BarricadeCostUnaware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, ClimbLedgeCostAware) == 0x000024, "Member 'FNPCPathfindingCosts::ClimbLedgeCostAware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, ClimbLedgeCostUnaware) == 0x000028, "Member 'FNPCPathfindingCosts::ClimbLedgeCostUnaware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, CrouchUnderCostAware) == 0x00002C, "Member 'FNPCPathfindingCosts::CrouchUnderCostAware' has a wrong offset!");
static_assert(offsetof(FNPCPathfindingCosts, CrouchUnderCostUnaware) == 0x000030, "Member 'FNPCPathfindingCosts::CrouchUnderCostUnaware' has a wrong offset!");

// ScriptStruct OPP.NPCInterruptAction
// 0x0028 (0x0028 - 0x0000)
struct FNPCInterruptAction final
{
public:
	class ARBPawn*                                Interrupter;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Weapon;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCInterruptActionType                       Type;                                              // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x17];                                      // 0x0011(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCInterruptAction) == 0x000008, "Wrong alignment on FNPCInterruptAction");
static_assert(sizeof(FNPCInterruptAction) == 0x000028, "Wrong size on FNPCInterruptAction");
static_assert(offsetof(FNPCInterruptAction, Interrupter) == 0x000000, "Member 'FNPCInterruptAction::Interrupter' has a wrong offset!");
static_assert(offsetof(FNPCInterruptAction, Weapon) == 0x000008, "Member 'FNPCInterruptAction::Weapon' has a wrong offset!");
static_assert(offsetof(FNPCInterruptAction, Type) == 0x000010, "Member 'FNPCInterruptAction::Type' has a wrong offset!");

// ScriptStruct OPP.NPCSpeedModifierData
// 0x0010 (0x0010 - 0x0000)
struct FNPCSpeedModifierData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpirationServerTime;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCSpeedModifierData) == 0x000004, "Wrong alignment on FNPCSpeedModifierData");
static_assert(sizeof(FNPCSpeedModifierData) == 0x000010, "Wrong size on FNPCSpeedModifierData");
static_assert(offsetof(FNPCSpeedModifierData, ID) == 0x000000, "Member 'FNPCSpeedModifierData::ID' has a wrong offset!");
static_assert(offsetof(FNPCSpeedModifierData, ExpirationServerTime) == 0x000008, "Member 'FNPCSpeedModifierData::ExpirationServerTime' has a wrong offset!");
static_assert(offsetof(FNPCSpeedModifierData, Modifier) == 0x00000C, "Member 'FNPCSpeedModifierData::Modifier' has a wrong offset!");

// ScriptStruct OPP.NPCWeaponVFXState
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FNPCWeaponVFXState final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCWeaponVFXState) == 0x000004, "Wrong alignment on FNPCWeaponVFXState");
static_assert(sizeof(FNPCWeaponVFXState) == 0x000014, "Wrong size on FNPCWeaponVFXState");

// ScriptStruct OPP.NPCWeaponVFXControlData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FNPCWeaponVFXControlData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCWeaponVFXControlData) == 0x000004, "Wrong alignment on FNPCWeaponVFXControlData");
static_assert(sizeof(FNPCWeaponVFXControlData) == 0x000018, "Wrong size on FNPCWeaponVFXControlData");

// ScriptStruct OPP.NPCDoorInteractionParams
// 0x0018 (0x0018 - 0x0000)
struct FNPCDoorInteractionParams final
{
public:
	class ARBDoor*                                Door;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorPassType                                 DoorPassType;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlertedStance;                                  // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraversalFrontToBack;                             // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorOpenInFront;                                  // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathedDistanceToDoor;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCDoorInteractionParams) == 0x000008, "Wrong alignment on FNPCDoorInteractionParams");
static_assert(sizeof(FNPCDoorInteractionParams) == 0x000018, "Wrong size on FNPCDoorInteractionParams");
static_assert(offsetof(FNPCDoorInteractionParams, Door) == 0x000000, "Member 'FNPCDoorInteractionParams::Door' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, DoorPassType) == 0x000008, "Member 'FNPCDoorInteractionParams::DoorPassType' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, bForced) == 0x000009, "Member 'FNPCDoorInteractionParams::bForced' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, bIsAlertedStance) == 0x00000A, "Member 'FNPCDoorInteractionParams::bIsAlertedStance' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, bTraversalFrontToBack) == 0x00000B, "Member 'FNPCDoorInteractionParams::bTraversalFrontToBack' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, bDoorOpenInFront) == 0x00000C, "Member 'FNPCDoorInteractionParams::bDoorOpenInFront' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionParams, PathedDistanceToDoor) == 0x000010, "Member 'FNPCDoorInteractionParams::PathedDistanceToDoor' has a wrong offset!");

// ScriptStruct OPP.NPCDoorInteractionData
// 0x00A8 (0x00A8 - 0x0000)
struct FNPCDoorInteractionData final
{
public:
	struct FNPCDoorInteractionParams              Params;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DoorInteractionAnim;                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStartTime;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimAnchorTime;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialYaw;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraversalDir;                                      // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnchorRefLocation;                                 // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustmentEndTargetPos;                            // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustmentEndTargetDir;                            // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SteeringPath;                                      // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AdjustmentsDuration;                               // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x34];                                      // 0x0074(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCDoorInteractionData) == 0x000008, "Wrong alignment on FNPCDoorInteractionData");
static_assert(sizeof(FNPCDoorInteractionData) == 0x0000A8, "Wrong size on FNPCDoorInteractionData");
static_assert(offsetof(FNPCDoorInteractionData, Params) == 0x000000, "Member 'FNPCDoorInteractionData::Params' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, DoorInteractionAnim) == 0x000018, "Member 'FNPCDoorInteractionData::DoorInteractionAnim' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AnimStartTime) == 0x000020, "Member 'FNPCDoorInteractionData::AnimStartTime' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AnimAnchorTime) == 0x000024, "Member 'FNPCDoorInteractionData::AnimAnchorTime' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, InitialYaw) == 0x000028, "Member 'FNPCDoorInteractionData::InitialYaw' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, TraversalDir) == 0x00002C, "Member 'FNPCDoorInteractionData::TraversalDir' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AnchorRefLocation) == 0x000038, "Member 'FNPCDoorInteractionData::AnchorRefLocation' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AdjustmentEndTargetPos) == 0x000044, "Member 'FNPCDoorInteractionData::AdjustmentEndTargetPos' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AdjustmentEndTargetDir) == 0x000050, "Member 'FNPCDoorInteractionData::AdjustmentEndTargetDir' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, SteeringPath) == 0x000060, "Member 'FNPCDoorInteractionData::SteeringPath' has a wrong offset!");
static_assert(offsetof(FNPCDoorInteractionData, AdjustmentsDuration) == 0x000070, "Member 'FNPCDoorInteractionData::AdjustmentsDuration' has a wrong offset!");

// ScriptStruct OPP.NPCStartleData
// 0x0038 (0x0038 - 0x0000)
struct FNPCStartleData final
{
public:
	struct FVector                                TargetPosition;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartleType                                  StartleType;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartleVariation                             StartleVariation;                                  // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartleSpeed                                 StartleSpeed;                                      // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetToTrack;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPosition;                                     // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDirection;                                    // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCStartleData) == 0x000008, "Wrong alignment on FNPCStartleData");
static_assert(sizeof(FNPCStartleData) == 0x000038, "Wrong size on FNPCStartleData");
static_assert(offsetof(FNPCStartleData, TargetPosition) == 0x000000, "Member 'FNPCStartleData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, StartleType) == 0x00000C, "Member 'FNPCStartleData::StartleType' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, StartleVariation) == 0x00000D, "Member 'FNPCStartleData::StartleVariation' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, StartleSpeed) == 0x00000E, "Member 'FNPCStartleData::StartleSpeed' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, TargetToTrack) == 0x000010, "Member 'FNPCStartleData::TargetToTrack' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, StartPosition) == 0x000018, "Member 'FNPCStartleData::StartPosition' has a wrong offset!");
static_assert(offsetof(FNPCStartleData, StartDirection) == 0x000024, "Member 'FNPCStartleData::StartDirection' has a wrong offset!");

// ScriptStruct OPP.NPCLoopingIdleData
// 0x0018 (0x0018 - 0x0000)
struct FNPCLoopingIdleData final
{
public:
	class UAnimSequence*                          AnimSeq;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundStart;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundStop;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCLoopingIdleData) == 0x000008, "Wrong alignment on FNPCLoopingIdleData");
static_assert(sizeof(FNPCLoopingIdleData) == 0x000018, "Wrong size on FNPCLoopingIdleData");
static_assert(offsetof(FNPCLoopingIdleData, AnimSeq) == 0x000000, "Member 'FNPCLoopingIdleData::AnimSeq' has a wrong offset!");
static_assert(offsetof(FNPCLoopingIdleData, SoundStart) == 0x000008, "Member 'FNPCLoopingIdleData::SoundStart' has a wrong offset!");
static_assert(offsetof(FNPCLoopingIdleData, SoundStop) == 0x000010, "Member 'FNPCLoopingIdleData::SoundStop' has a wrong offset!");

// ScriptStruct OPP.NPCWaypointData
// 0x0010 (0x0010 - 0x0000)
struct FNPCWaypointData final
{
public:
	class UAnimSequence*                          WaypointAnim;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnim;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCWaypointData) == 0x000008, "Wrong alignment on FNPCWaypointData");
static_assert(sizeof(FNPCWaypointData) == 0x000010, "Wrong size on FNPCWaypointData");
static_assert(offsetof(FNPCWaypointData, WaypointAnim) == 0x000000, "Member 'FNPCWaypointData::WaypointAnim' has a wrong offset!");
static_assert(offsetof(FNPCWaypointData, bLoopAnim) == 0x000008, "Member 'FNPCWaypointData::bLoopAnim' has a wrong offset!");

// ScriptStruct OPP.NPCWeaponRuntimeData
// 0x0002 (0x0002 - 0x0000)
struct FNPCWeaponRuntimeData final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCWeaponRuntimeData) == 0x000001, "Wrong alignment on FNPCWeaponRuntimeData");
static_assert(sizeof(FNPCWeaponRuntimeData) == 0x000002, "Wrong size on FNPCWeaponRuntimeData");

// ScriptStruct OPP.NPCProximityCollisionClearanceData
// 0x0014 (0x0014 - 0x0000)
struct FNPCProximityCollisionClearanceData final
{
public:
	float                                         LastTraceTime;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastTraceLocation;                                 // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollisionInProximity;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCProximityCollisionClearanceData) == 0x000004, "Wrong alignment on FNPCProximityCollisionClearanceData");
static_assert(sizeof(FNPCProximityCollisionClearanceData) == 0x000014, "Wrong size on FNPCProximityCollisionClearanceData");
static_assert(offsetof(FNPCProximityCollisionClearanceData, LastTraceTime) == 0x000000, "Member 'FNPCProximityCollisionClearanceData::LastTraceTime' has a wrong offset!");
static_assert(offsetof(FNPCProximityCollisionClearanceData, LastTraceLocation) == 0x000004, "Member 'FNPCProximityCollisionClearanceData::LastTraceLocation' has a wrong offset!");
static_assert(offsetof(FNPCProximityCollisionClearanceData, bCollisionInProximity) == 0x000010, "Member 'FNPCProximityCollisionClearanceData::bCollisionInProximity' has a wrong offset!");

// ScriptStruct OPP.NPCCeilingData
// 0x0018 (0x0018 - 0x0000)
struct FNPCCeilingData final
{
public:
	float                                         LastTraceTime;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastTraceLocation;                                 // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CeilingPercentage;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCeilingHeight;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCCeilingData) == 0x000004, "Wrong alignment on FNPCCeilingData");
static_assert(sizeof(FNPCCeilingData) == 0x000018, "Wrong size on FNPCCeilingData");
static_assert(offsetof(FNPCCeilingData, LastTraceTime) == 0x000000, "Member 'FNPCCeilingData::LastTraceTime' has a wrong offset!");
static_assert(offsetof(FNPCCeilingData, LastTraceLocation) == 0x000004, "Member 'FNPCCeilingData::LastTraceLocation' has a wrong offset!");
static_assert(offsetof(FNPCCeilingData, CeilingPercentage) == 0x000010, "Member 'FNPCCeilingData::CeilingPercentage' has a wrong offset!");
static_assert(offsetof(FNPCCeilingData, CurrentCeilingHeight) == 0x000014, "Member 'FNPCCeilingData::CurrentCeilingHeight' has a wrong offset!");

// ScriptStruct OPP.NPCJumpData
// 0x0044 (0x0044 - 0x0000)
struct FNPCJumpData final
{
public:
	struct FVector                                JumpStartPoint;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpDirection;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalDestination;                                  // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositionCorrection;                                // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallJump;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x13];                                      // 0x0031(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCJumpData) == 0x000004, "Wrong alignment on FNPCJumpData");
static_assert(sizeof(FNPCJumpData) == 0x000044, "Wrong size on FNPCJumpData");
static_assert(offsetof(FNPCJumpData, JumpStartPoint) == 0x000000, "Member 'FNPCJumpData::JumpStartPoint' has a wrong offset!");
static_assert(offsetof(FNPCJumpData, JumpDirection) == 0x00000C, "Member 'FNPCJumpData::JumpDirection' has a wrong offset!");
static_assert(offsetof(FNPCJumpData, FinalDestination) == 0x000018, "Member 'FNPCJumpData::FinalDestination' has a wrong offset!");
static_assert(offsetof(FNPCJumpData, PositionCorrection) == 0x000024, "Member 'FNPCJumpData::PositionCorrection' has a wrong offset!");
static_assert(offsetof(FNPCJumpData, bWallJump) == 0x000030, "Member 'FNPCJumpData::bWallJump' has a wrong offset!");

// ScriptStruct OPP.NPCInvestigationData
// 0x0028 (0x0028 - 0x0000)
struct FNPCInvestigationData final
{
public:
	class UAnimSequence*                          AnimToPlay;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopingAnimation;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovingTransition;                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AlignPos;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AlignDir;                                          // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnimLength;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCInvestigationData) == 0x000008, "Wrong alignment on FNPCInvestigationData");
static_assert(sizeof(FNPCInvestigationData) == 0x000028, "Wrong size on FNPCInvestigationData");
static_assert(offsetof(FNPCInvestigationData, AnimToPlay) == 0x000000, "Member 'FNPCInvestigationData::AnimToPlay' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationData, bLoopingAnimation) == 0x000008, "Member 'FNPCInvestigationData::bLoopingAnimation' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationData, bMovingTransition) == 0x000009, "Member 'FNPCInvestigationData::bMovingTransition' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationData, AlignPos) == 0x00000C, "Member 'FNPCInvestigationData::AlignPos' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationData, AlignDir) == 0x000018, "Member 'FNPCInvestigationData::AlignDir' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationData, MaxAnimLength) == 0x000024, "Member 'FNPCInvestigationData::MaxAnimLength' has a wrong offset!");

// ScriptStruct OPP.NPCAimingData
// 0x001C (0x001C - 0x0000)
struct FNPCAimingData final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeYaw;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativePitch;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x10];                                       // 0x000C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAimingData) == 0x000004, "Wrong alignment on FNPCAimingData");
static_assert(sizeof(FNPCAimingData) == 0x00001C, "Wrong size on FNPCAimingData");
static_assert(offsetof(FNPCAimingData, bEnabled) == 0x000000, "Member 'FNPCAimingData::bEnabled' has a wrong offset!");
static_assert(offsetof(FNPCAimingData, RelativeYaw) == 0x000004, "Member 'FNPCAimingData::RelativeYaw' has a wrong offset!");
static_assert(offsetof(FNPCAimingData, RelativePitch) == 0x000008, "Member 'FNPCAimingData::RelativePitch' has a wrong offset!");

// ScriptStruct OPP.NPCLookAtData
// 0x0048 (0x0048 - 0x0000)
struct FNPCLookAtData final
{
public:
	bool                                          bEnableLookAt;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanIntensity;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseRelativeYaw;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRelativeYaw;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativePitch;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationLookAt;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCLookAtData) == 0x000008, "Wrong alignment on FNPCLookAtData");
static_assert(sizeof(FNPCLookAtData) == 0x000048, "Wrong size on FNPCLookAtData");
static_assert(offsetof(FNPCLookAtData, bEnableLookAt) == 0x000000, "Member 'FNPCLookAtData::bEnableLookAt' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, LookAtAlpha) == 0x000004, "Member 'FNPCLookAtData::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, ScanIntensity) == 0x000008, "Member 'FNPCLookAtData::ScanIntensity' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, BaseRelativeYaw) == 0x00000C, "Member 'FNPCLookAtData::BaseRelativeYaw' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, FinalRelativeYaw) == 0x000010, "Member 'FNPCLookAtData::FinalRelativeYaw' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, RelativePitch) == 0x000014, "Member 'FNPCLookAtData::RelativePitch' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, bInvestigationLookAt) == 0x000018, "Member 'FNPCLookAtData::bInvestigationLookAt' has a wrong offset!");
static_assert(offsetof(FNPCLookAtData, TargetActor) == 0x000020, "Member 'FNPCLookAtData::TargetActor' has a wrong offset!");

// ScriptStruct OPP.NPCLookAtConfig
// 0x0020 (0x0020 - 0x0000)
struct FNPCLookAtConfig final
{
public:
	bool                                          bValidStateForLookAt;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtEnabled;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtScanEnabled;                                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationLookAt;                              // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLookAt;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FocusTarget;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FocusLocation;                                     // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCLookAtConfig) == 0x000008, "Wrong alignment on FNPCLookAtConfig");
static_assert(sizeof(FNPCLookAtConfig) == 0x000020, "Wrong size on FNPCLookAtConfig");
static_assert(offsetof(FNPCLookAtConfig, bValidStateForLookAt) == 0x000000, "Member 'FNPCLookAtConfig::bValidStateForLookAt' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, bLookAtEnabled) == 0x000001, "Member 'FNPCLookAtConfig::bLookAtEnabled' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, bLookAtScanEnabled) == 0x000002, "Member 'FNPCLookAtConfig::bLookAtScanEnabled' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, bInvestigationLookAt) == 0x000003, "Member 'FNPCLookAtConfig::bInvestigationLookAt' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, bForceLookAt) == 0x000004, "Member 'FNPCLookAtConfig::bForceLookAt' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, FocusTarget) == 0x000008, "Member 'FNPCLookAtConfig::FocusTarget' has a wrong offset!");
static_assert(offsetof(FNPCLookAtConfig, FocusLocation) == 0x000010, "Member 'FNPCLookAtConfig::FocusLocation' has a wrong offset!");

// ScriptStruct OPP.NPCReplicatedAmbientData
// 0x0010 (0x0010 - 0x0000)
struct FNPCReplicatedAmbientData final
{
public:
	class URBAmbientStationComponent*             AmbientStation;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveState;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCReplicatedAmbientData) == 0x000008, "Wrong alignment on FNPCReplicatedAmbientData");
static_assert(sizeof(FNPCReplicatedAmbientData) == 0x000010, "Wrong size on FNPCReplicatedAmbientData");
static_assert(offsetof(FNPCReplicatedAmbientData, AmbientStation) == 0x000000, "Member 'FNPCReplicatedAmbientData::AmbientStation' has a wrong offset!");
static_assert(offsetof(FNPCReplicatedAmbientData, bActiveState) == 0x000008, "Member 'FNPCReplicatedAmbientData::bActiveState' has a wrong offset!");

// ScriptStruct OPP.NPCAmbientData
// 0x0020 (0x0020 - 0x0000)
struct FNPCAmbientData final
{
public:
	bool                                          bValidLookAt;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothedRelativeYaw;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedRelativePitch;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRelativeYaw;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRelativePitch;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ExitAnim;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCAmbientData) == 0x000008, "Wrong alignment on FNPCAmbientData");
static_assert(sizeof(FNPCAmbientData) == 0x000020, "Wrong size on FNPCAmbientData");
static_assert(offsetof(FNPCAmbientData, bValidLookAt) == 0x000000, "Member 'FNPCAmbientData::bValidLookAt' has a wrong offset!");
static_assert(offsetof(FNPCAmbientData, SmoothedRelativeYaw) == 0x000004, "Member 'FNPCAmbientData::SmoothedRelativeYaw' has a wrong offset!");
static_assert(offsetof(FNPCAmbientData, SmoothedRelativePitch) == 0x000008, "Member 'FNPCAmbientData::SmoothedRelativePitch' has a wrong offset!");
static_assert(offsetof(FNPCAmbientData, TargetRelativeYaw) == 0x00000C, "Member 'FNPCAmbientData::TargetRelativeYaw' has a wrong offset!");
static_assert(offsetof(FNPCAmbientData, TargetRelativePitch) == 0x000010, "Member 'FNPCAmbientData::TargetRelativePitch' has a wrong offset!");
static_assert(offsetof(FNPCAmbientData, ExitAnim) == 0x000018, "Member 'FNPCAmbientData::ExitAnim' has a wrong offset!");

// ScriptStruct OPP.DelayedVO
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDelayedVO final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelayedVO) == 0x000004, "Wrong alignment on FDelayedVO");
static_assert(sizeof(FDelayedVO) == 0x00000C, "Wrong size on FDelayedVO");

// ScriptStruct OPP.SelectedGruntCustomizationMeshesInfo
// 0x0014 (0x0014 - 0x0000)
struct FSelectedGruntCustomizationMeshesInfo final
{
public:
	int32                                         HeadIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairIndex;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerBodyIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBodyIndex;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectedGruntCustomizationMeshesInfo) == 0x000004, "Wrong alignment on FSelectedGruntCustomizationMeshesInfo");
static_assert(sizeof(FSelectedGruntCustomizationMeshesInfo) == 0x000014, "Wrong size on FSelectedGruntCustomizationMeshesInfo");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, HeadIndex) == 0x000000, "Member 'FSelectedGruntCustomizationMeshesInfo::HeadIndex' has a wrong offset!");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, HairIndex) == 0x000004, "Member 'FSelectedGruntCustomizationMeshesInfo::HairIndex' has a wrong offset!");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, LowerBodyIndex) == 0x000008, "Member 'FSelectedGruntCustomizationMeshesInfo::LowerBodyIndex' has a wrong offset!");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, UpperBodyIndex) == 0x00000C, "Member 'FSelectedGruntCustomizationMeshesInfo::UpperBodyIndex' has a wrong offset!");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, bIsFemale) == 0x000010, "Member 'FSelectedGruntCustomizationMeshesInfo::bIsFemale' has a wrong offset!");
static_assert(offsetof(FSelectedGruntCustomizationMeshesInfo, NPCFlavor) == 0x000011, "Member 'FSelectedGruntCustomizationMeshesInfo::NPCFlavor' has a wrong offset!");

// ScriptStruct OPP.NPCCustomizationMesh
// 0x00D0 (0x00D0 - 0x0000)
struct FNPCCustomizationMesh final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   BodyMeshes;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UMaterialInstanceConstant>> MaterialOverrides;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         FoleyPriority;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoleySwitch;                                       // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceType;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              FacePoseAsset;                                     // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCCustomizationMesh) == 0x000008, "Wrong alignment on FNPCCustomizationMesh");
static_assert(sizeof(FNPCCustomizationMesh) == 0x0000D0, "Wrong size on FNPCCustomizationMesh");
static_assert(offsetof(FNPCCustomizationMesh, Mesh) == 0x000000, "Member 'FNPCCustomizationMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, BodyMeshes) == 0x000028, "Member 'FNPCCustomizationMesh::BodyMeshes' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, MaterialOverrides) == 0x000038, "Member 'FNPCCustomizationMesh::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, FoleyPriority) == 0x000088, "Member 'FNPCCustomizationMesh::FoleyPriority' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, FoleySwitch) == 0x00008C, "Member 'FNPCCustomizationMesh::FoleySwitch' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, VoiceType) == 0x000098, "Member 'FNPCCustomizationMesh::VoiceType' has a wrong offset!");
static_assert(offsetof(FNPCCustomizationMesh, FacePoseAsset) == 0x0000A8, "Member 'FNPCCustomizationMesh::FacePoseAsset' has a wrong offset!");

// ScriptStruct OPP.GruntCustomizationMeshes
// 0x0030 (0x0030 - 0x0000)
struct FGruntCustomizationMeshes final
{
public:
	TArray<struct FNPCCustomizationMesh>          Light;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FNPCCustomizationMesh>          Normal;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FNPCCustomizationMesh>          Heavy;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGruntCustomizationMeshes) == 0x000008, "Wrong alignment on FGruntCustomizationMeshes");
static_assert(sizeof(FGruntCustomizationMeshes) == 0x000030, "Wrong size on FGruntCustomizationMeshes");
static_assert(offsetof(FGruntCustomizationMeshes, Light) == 0x000000, "Member 'FGruntCustomizationMeshes::Light' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshes, Normal) == 0x000010, "Member 'FGruntCustomizationMeshes::Normal' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshes, Heavy) == 0x000020, "Member 'FGruntCustomizationMeshes::Heavy' has a wrong offset!");

// ScriptStruct OPP.GruntCustomizationMeshesConfig
// 0x0180 (0x0180 - 0x0000)
struct FGruntCustomizationMeshesConfig final
{
public:
	struct FGruntCustomizationMeshes              MaleHead;                                          // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              MaleHair;                                          // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              MaleUpperBody;                                     // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              MaleLowerBody;                                     // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              FemaleHead;                                        // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              FemaleHair;                                        // 0x00F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              FemaleUpperBody;                                   // 0x0120(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGruntCustomizationMeshes              FemaleLowerBody;                                   // 0x0150(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGruntCustomizationMeshesConfig) == 0x000008, "Wrong alignment on FGruntCustomizationMeshesConfig");
static_assert(sizeof(FGruntCustomizationMeshesConfig) == 0x000180, "Wrong size on FGruntCustomizationMeshesConfig");
static_assert(offsetof(FGruntCustomizationMeshesConfig, MaleHead) == 0x000000, "Member 'FGruntCustomizationMeshesConfig::MaleHead' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, MaleHair) == 0x000030, "Member 'FGruntCustomizationMeshesConfig::MaleHair' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, MaleUpperBody) == 0x000060, "Member 'FGruntCustomizationMeshesConfig::MaleUpperBody' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, MaleLowerBody) == 0x000090, "Member 'FGruntCustomizationMeshesConfig::MaleLowerBody' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, FemaleHead) == 0x0000C0, "Member 'FGruntCustomizationMeshesConfig::FemaleHead' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, FemaleHair) == 0x0000F0, "Member 'FGruntCustomizationMeshesConfig::FemaleHair' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, FemaleUpperBody) == 0x000120, "Member 'FGruntCustomizationMeshesConfig::FemaleUpperBody' has a wrong offset!");
static_assert(offsetof(FGruntCustomizationMeshesConfig, FemaleLowerBody) == 0x000150, "Member 'FGruntCustomizationMeshesConfig::FemaleLowerBody' has a wrong offset!");

// ScriptStruct OPP.AISpawningCheatInfo
// 0x0070 (0x0070 - 0x0000)
struct FAISpawningCheatInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      NPCType;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PawnClass;                                         // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URBAIConfig>             AIConfig;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraCheatOption;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISpawningCheatInfo) == 0x000008, "Wrong alignment on FAISpawningCheatInfo");
static_assert(sizeof(FAISpawningCheatInfo) == 0x000070, "Wrong size on FAISpawningCheatInfo");
static_assert(offsetof(FAISpawningCheatInfo, Name) == 0x000000, "Member 'FAISpawningCheatInfo::Name' has a wrong offset!");
static_assert(offsetof(FAISpawningCheatInfo, NPCType) == 0x000010, "Member 'FAISpawningCheatInfo::NPCType' has a wrong offset!");
static_assert(offsetof(FAISpawningCheatInfo, PawnClass) == 0x000018, "Member 'FAISpawningCheatInfo::PawnClass' has a wrong offset!");
static_assert(offsetof(FAISpawningCheatInfo, AIConfig) == 0x000040, "Member 'FAISpawningCheatInfo::AIConfig' has a wrong offset!");
static_assert(offsetof(FAISpawningCheatInfo, ExtraCheatOption) == 0x000068, "Member 'FAISpawningCheatInfo::ExtraCheatOption' has a wrong offset!");

// ScriptStruct OPP.RandomNPCArchetype
// 0x0038 (0x0038 - 0x0000)
struct FRandomNPCArchetype final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    Flavor;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PawnClassPtr;                                      // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            PawnConfig;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomNPCArchetype) == 0x000008, "Wrong alignment on FRandomNPCArchetype");
static_assert(sizeof(FRandomNPCArchetype) == 0x000038, "Wrong size on FRandomNPCArchetype");
static_assert(offsetof(FRandomNPCArchetype, NPCType) == 0x000000, "Member 'FRandomNPCArchetype::NPCType' has a wrong offset!");
static_assert(offsetof(FRandomNPCArchetype, Flavor) == 0x000001, "Member 'FRandomNPCArchetype::Flavor' has a wrong offset!");
static_assert(offsetof(FRandomNPCArchetype, PawnClassPtr) == 0x000008, "Member 'FRandomNPCArchetype::PawnClassPtr' has a wrong offset!");
static_assert(offsetof(FRandomNPCArchetype, PawnConfig) == 0x000030, "Member 'FRandomNPCArchetype::PawnConfig' has a wrong offset!");

// ScriptStruct OPP.ObjectiveRandomizationSetupData
// 0x05A8 (0x05A8 - 0x0000)
struct FObjectiveRandomizationSetupData final
{
public:
	struct FConfigurableInt                       DesiredCount;                                      // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomSettings                        DesiredStateCount;                                 // 0x00C8(0x0320)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bSplitByObjectiveType;                             // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRoomGroupsAsObjectiveType;                     // 0x03E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOtherCoordoActorsForDistance;                  // 0x03EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitOneObjectivePerRoom;                         // 0x03EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDistanceBetweenSameObjectives;            // 0x03EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     DistanceBetweenSameObjectives;                     // 0x03F0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDistanceBetweenDifferentObjectives;       // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     DistanceBetweenDifferentObjectives;                // 0x04C0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenSameObjectivesOverride;             // 0x0588(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenDifferentObjectivesOverride;        // 0x058C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        DesiredStateSetObjects;                            // 0x0598(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FObjectiveRandomizationSetupData) == 0x000008, "Wrong alignment on FObjectiveRandomizationSetupData");
static_assert(sizeof(FObjectiveRandomizationSetupData) == 0x0005A8, "Wrong size on FObjectiveRandomizationSetupData");
static_assert(offsetof(FObjectiveRandomizationSetupData, DesiredCount) == 0x000000, "Member 'FObjectiveRandomizationSetupData::DesiredCount' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DesiredStateCount) == 0x0000C8, "Member 'FObjectiveRandomizationSetupData::DesiredStateCount' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bSplitByObjectiveType) == 0x0003E8, "Member 'FObjectiveRandomizationSetupData::bSplitByObjectiveType' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bUseRoomGroupsAsObjectiveType) == 0x0003E9, "Member 'FObjectiveRandomizationSetupData::bUseRoomGroupsAsObjectiveType' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bUseOtherCoordoActorsForDistance) == 0x0003EA, "Member 'FObjectiveRandomizationSetupData::bUseOtherCoordoActorsForDistance' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bLimitOneObjectivePerRoom) == 0x0003EB, "Member 'FObjectiveRandomizationSetupData::bLimitOneObjectivePerRoom' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bOverrideDistanceBetweenSameObjectives) == 0x0003EC, "Member 'FObjectiveRandomizationSetupData::bOverrideDistanceBetweenSameObjectives' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DistanceBetweenSameObjectives) == 0x0003F0, "Member 'FObjectiveRandomizationSetupData::DistanceBetweenSameObjectives' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, bOverrideDistanceBetweenDifferentObjectives) == 0x0004B8, "Member 'FObjectiveRandomizationSetupData::bOverrideDistanceBetweenDifferentObjectives' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DistanceBetweenDifferentObjectives) == 0x0004C0, "Member 'FObjectiveRandomizationSetupData::DistanceBetweenDifferentObjectives' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DistanceBetweenSameObjectivesOverride) == 0x000588, "Member 'FObjectiveRandomizationSetupData::DistanceBetweenSameObjectivesOverride' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DistanceBetweenDifferentObjectivesOverride) == 0x00058C, "Member 'FObjectiveRandomizationSetupData::DistanceBetweenDifferentObjectivesOverride' has a wrong offset!");
static_assert(offsetof(FObjectiveRandomizationSetupData, DesiredStateSetObjects) == 0x000598, "Member 'FObjectiveRandomizationSetupData::DesiredStateSetObjects' has a wrong offset!");

// ScriptStruct OPP.RBActionNames
// 0x0010 (0x0010 - 0x0000)
struct FRBActionNames final
{
public:
	TArray<class FName>                           ActionNames;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBActionNames) == 0x000008, "Wrong alignment on FRBActionNames");
static_assert(sizeof(FRBActionNames) == 0x000010, "Wrong size on FRBActionNames");
static_assert(offsetof(FRBActionNames, ActionNames) == 0x000000, "Member 'FRBActionNames::ActionNames' has a wrong offset!");

// ScriptStruct OPP.RBControlSchemeEntry
// 0x0038 (0x0038 - 0x0000)
struct FRBControlSchemeEntry final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlSchemeActionType                      ActionType;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBControlSchemeEntry) == 0x000008, "Wrong alignment on FRBControlSchemeEntry");
static_assert(sizeof(FRBControlSchemeEntry) == 0x000038, "Wrong size on FRBControlSchemeEntry");
static_assert(offsetof(FRBControlSchemeEntry, Key) == 0x000000, "Member 'FRBControlSchemeEntry::Key' has a wrong offset!");
static_assert(offsetof(FRBControlSchemeEntry, ActionType) == 0x000018, "Member 'FRBControlSchemeEntry::ActionType' has a wrong offset!");
static_assert(offsetof(FRBControlSchemeEntry, Scale) == 0x00001C, "Member 'FRBControlSchemeEntry::Scale' has a wrong offset!");
static_assert(offsetof(FRBControlSchemeEntry, Description) == 0x000020, "Member 'FRBControlSchemeEntry::Description' has a wrong offset!");

// ScriptStruct OPP.RBControlScheme
// 0x0458 (0x0458 - 0x0000)
struct FRBControlScheme final
{
public:
	class FText                                   ControlSchemeTitle;                                // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  LeftTrigger;                                       // 0x0018(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  RightTrigger;                                      // 0x0050(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  LeftBumper;                                        // 0x0088(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  RightBumper;                                       // 0x00C0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  LeftStickClick;                                    // 0x00F8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  LeftStick;                                         // 0x0130(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  RightStick;                                        // 0x0168(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  RightStickClick;                                   // 0x01A0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  DpadUp;                                            // 0x01D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  DpadRight;                                         // 0x0210(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  DpadLeft;                                          // 0x0248(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  DpadDown;                                          // 0x0280(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  FaceButtonUp;                                      // 0x02B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  FaceButtonLeft;                                    // 0x02F0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  FaceButtonRight;                                   // 0x0328(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  FaceButtonDown;                                    // 0x0360(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  SpecialRight;                                      // 0x0398(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRBControlSchemeEntry                  SpecialLeft;                                       // 0x03D0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x50];                                     // 0x0408(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBControlScheme) == 0x000008, "Wrong alignment on FRBControlScheme");
static_assert(sizeof(FRBControlScheme) == 0x000458, "Wrong size on FRBControlScheme");
static_assert(offsetof(FRBControlScheme, ControlSchemeTitle) == 0x000000, "Member 'FRBControlScheme::ControlSchemeTitle' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, LeftTrigger) == 0x000018, "Member 'FRBControlScheme::LeftTrigger' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, RightTrigger) == 0x000050, "Member 'FRBControlScheme::RightTrigger' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, LeftBumper) == 0x000088, "Member 'FRBControlScheme::LeftBumper' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, RightBumper) == 0x0000C0, "Member 'FRBControlScheme::RightBumper' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, LeftStickClick) == 0x0000F8, "Member 'FRBControlScheme::LeftStickClick' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, LeftStick) == 0x000130, "Member 'FRBControlScheme::LeftStick' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, RightStick) == 0x000168, "Member 'FRBControlScheme::RightStick' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, RightStickClick) == 0x0001A0, "Member 'FRBControlScheme::RightStickClick' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, DpadUp) == 0x0001D8, "Member 'FRBControlScheme::DpadUp' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, DpadRight) == 0x000210, "Member 'FRBControlScheme::DpadRight' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, DpadLeft) == 0x000248, "Member 'FRBControlScheme::DpadLeft' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, DpadDown) == 0x000280, "Member 'FRBControlScheme::DpadDown' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, FaceButtonUp) == 0x0002B8, "Member 'FRBControlScheme::FaceButtonUp' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, FaceButtonLeft) == 0x0002F0, "Member 'FRBControlScheme::FaceButtonLeft' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, FaceButtonRight) == 0x000328, "Member 'FRBControlScheme::FaceButtonRight' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, FaceButtonDown) == 0x000360, "Member 'FRBControlScheme::FaceButtonDown' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, SpecialRight) == 0x000398, "Member 'FRBControlScheme::SpecialRight' has a wrong offset!");
static_assert(offsetof(FRBControlScheme, SpecialLeft) == 0x0003D0, "Member 'FRBControlScheme::SpecialLeft' has a wrong offset!");

// ScriptStruct OPP.RBOptionCategoryData
// 0x0028 (0x0028 - 0x0000)
struct FRBOptionCategoryData final
{
public:
	class FText                                   CategoryName;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOptionData>                    OptionsData;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBOptionCategoryData) == 0x000008, "Wrong alignment on FRBOptionCategoryData");
static_assert(sizeof(FRBOptionCategoryData) == 0x000028, "Wrong size on FRBOptionCategoryData");
static_assert(offsetof(FRBOptionCategoryData, CategoryName) == 0x000000, "Member 'FRBOptionCategoryData::CategoryName' has a wrong offset!");
static_assert(offsetof(FRBOptionCategoryData, OptionsData) == 0x000018, "Member 'FRBOptionCategoryData::OptionsData' has a wrong offset!");

// ScriptStruct OPP.RBOptionTabData
// 0x0030 (0x0030 - 0x0000)
struct FRBOptionTabData final
{
public:
	class FText                                   TabName;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EOptionsTabType                               TabType;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRBOptionCategoryData>          CategoriesData;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBOptionTabData) == 0x000008, "Wrong alignment on FRBOptionTabData");
static_assert(sizeof(FRBOptionTabData) == 0x000030, "Wrong size on FRBOptionTabData");
static_assert(offsetof(FRBOptionTabData, TabName) == 0x000000, "Member 'FRBOptionTabData::TabName' has a wrong offset!");
static_assert(offsetof(FRBOptionTabData, TabType) == 0x000018, "Member 'FRBOptionTabData::TabType' has a wrong offset!");
static_assert(offsetof(FRBOptionTabData, CategoriesData) == 0x000020, "Member 'FRBOptionTabData::CategoriesData' has a wrong offset!");

// ScriptStruct OPP.RBInterfacePresetData
// 0x0068 (0x0068 - 0x0000)
struct FRBInterfacePresetData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EOptionsMenuOption, int32>               PresetValues;                                      // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBInterfacePresetData) == 0x000008, "Wrong alignment on FRBInterfacePresetData");
static_assert(sizeof(FRBInterfacePresetData) == 0x000068, "Wrong size on FRBInterfacePresetData");
static_assert(offsetof(FRBInterfacePresetData, Title) == 0x000000, "Member 'FRBInterfacePresetData::Title' has a wrong offset!");
static_assert(offsetof(FRBInterfacePresetData, PresetValues) == 0x000018, "Member 'FRBInterfacePresetData::PresetValues' has a wrong offset!");

// ScriptStruct OPP.ScheduledBotSpawnAtMonserClosetData
// 0x0048 (0x0048 - 0x0000)
struct FScheduledBotSpawnAtMonserClosetData final
{
public:
	class ARBAISpawner*                           Spawner;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBNPC>                     NPCClass;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            ConfigAsset;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBPartialAIConfig*>             PartialConfigs;                                    // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x1];                                       // 0x0028(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EMonsterClosetSelectionMode                   RespawnClosetSelectionMode;                        // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      NPCType;                                           // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    NPCFlavor;                                         // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForRespawn;                                       // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnCloseToAPlayer;                            // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyToSpawn;                                     // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Debug_TimeAfterScheduled;                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x10];                                      // 0x0034(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRespawnDelay;                                   // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledBotSpawnAtMonserClosetData) == 0x000008, "Wrong alignment on FScheduledBotSpawnAtMonserClosetData");
static_assert(sizeof(FScheduledBotSpawnAtMonserClosetData) == 0x000048, "Wrong size on FScheduledBotSpawnAtMonserClosetData");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, Spawner) == 0x000000, "Member 'FScheduledBotSpawnAtMonserClosetData::Spawner' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, NPCClass) == 0x000008, "Member 'FScheduledBotSpawnAtMonserClosetData::NPCClass' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, ConfigAsset) == 0x000010, "Member 'FScheduledBotSpawnAtMonserClosetData::ConfigAsset' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, PartialConfigs) == 0x000018, "Member 'FScheduledBotSpawnAtMonserClosetData::PartialConfigs' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, RespawnClosetSelectionMode) == 0x000029, "Member 'FScheduledBotSpawnAtMonserClosetData::RespawnClosetSelectionMode' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, NPCType) == 0x00002A, "Member 'FScheduledBotSpawnAtMonserClosetData::NPCType' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, NPCFlavor) == 0x00002B, "Member 'FScheduledBotSpawnAtMonserClosetData::NPCFlavor' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, bForRespawn) == 0x00002C, "Member 'FScheduledBotSpawnAtMonserClosetData::bForRespawn' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, bRespawnCloseToAPlayer) == 0x00002D, "Member 'FScheduledBotSpawnAtMonserClosetData::bRespawnCloseToAPlayer' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, bReadyToSpawn) == 0x00002E, "Member 'FScheduledBotSpawnAtMonserClosetData::bReadyToSpawn' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, Debug_TimeAfterScheduled) == 0x000030, "Member 'FScheduledBotSpawnAtMonserClosetData::Debug_TimeAfterScheduled' has a wrong offset!");
static_assert(offsetof(FScheduledBotSpawnAtMonserClosetData, MinRespawnDelay) == 0x000044, "Member 'FScheduledBotSpawnAtMonserClosetData::MinRespawnDelay' has a wrong offset!");

// ScriptStruct OPP.OverseerPerBotInfo
// 0x0030 (0x0030 - 0x0000)
struct FOverseerPerBotInfo final
{
public:
	class ARBNPC*                                 NPC;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActivity                                   CurrentActivity;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        CurrentPath;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ConfigName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverseerPerBotInfo) == 0x000008, "Wrong alignment on FOverseerPerBotInfo");
static_assert(sizeof(FOverseerPerBotInfo) == 0x000030, "Wrong size on FOverseerPerBotInfo");
static_assert(offsetof(FOverseerPerBotInfo, NPC) == 0x000000, "Member 'FOverseerPerBotInfo::NPC' has a wrong offset!");
static_assert(offsetof(FOverseerPerBotInfo, CurrentActivity) == 0x000008, "Member 'FOverseerPerBotInfo::CurrentActivity' has a wrong offset!");
static_assert(offsetof(FOverseerPerBotInfo, bMoving) == 0x000009, "Member 'FOverseerPerBotInfo::bMoving' has a wrong offset!");
static_assert(offsetof(FOverseerPerBotInfo, CurrentPath) == 0x000010, "Member 'FOverseerPerBotInfo::CurrentPath' has a wrong offset!");
static_assert(offsetof(FOverseerPerBotInfo, ConfigName) == 0x000020, "Member 'FOverseerPerBotInfo::ConfigName' has a wrong offset!");

// ScriptStruct OPP.GameEvent
// 0x0050 (0x0050 - 0x0000)
struct FGameEvent final
{
public:
	EGameEvent                                    GameEvent;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EventTime;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameEventImportanceLevel                     Importance;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReferenceActor;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventDesc;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EventLocation;                                     // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventStageName;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameEvent) == 0x000008, "Wrong alignment on FGameEvent");
static_assert(sizeof(FGameEvent) == 0x000050, "Wrong size on FGameEvent");
static_assert(offsetof(FGameEvent, GameEvent) == 0x000000, "Member 'FGameEvent::GameEvent' has a wrong offset!");
static_assert(offsetof(FGameEvent, EventTime) == 0x000004, "Member 'FGameEvent::EventTime' has a wrong offset!");
static_assert(offsetof(FGameEvent, Importance) == 0x000008, "Member 'FGameEvent::Importance' has a wrong offset!");
static_assert(offsetof(FGameEvent, TargetActor) == 0x000010, "Member 'FGameEvent::TargetActor' has a wrong offset!");
static_assert(offsetof(FGameEvent, ReferenceActor) == 0x000018, "Member 'FGameEvent::ReferenceActor' has a wrong offset!");
static_assert(offsetof(FGameEvent, EventDesc) == 0x000020, "Member 'FGameEvent::EventDesc' has a wrong offset!");
static_assert(offsetof(FGameEvent, EventLocation) == 0x000030, "Member 'FGameEvent::EventLocation' has a wrong offset!");
static_assert(offsetof(FGameEvent, EventStageName) == 0x000040, "Member 'FGameEvent::EventStageName' has a wrong offset!");

// ScriptStruct OPP.OverseerInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FOverseerInfo final
{
public:
	int32                                         NumPlayersAlive;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersIncapacitated;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersDead;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScheduledBotSpawnAtMonserClosetData> ScheduledSpawns;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOverseerPerBotInfo>            BotInfos;                                          // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAIDirectorDebugInfo                   AIDirectorInfo;                                    // 0x0030(0x0060)(NativeAccessSpecifierPublic)
	TArray<struct FGameEvent>                     GameEvents;                                        // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 GameStateDesc;                                     // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatheringTime;                                     // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageStartedTime;                                  // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverseerInfo) == 0x000008, "Wrong alignment on FOverseerInfo");
static_assert(sizeof(FOverseerInfo) == 0x0000B8, "Wrong size on FOverseerInfo");
static_assert(offsetof(FOverseerInfo, NumPlayersAlive) == 0x000000, "Member 'FOverseerInfo::NumPlayersAlive' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, NumPlayersIncapacitated) == 0x000004, "Member 'FOverseerInfo::NumPlayersIncapacitated' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, NumPlayersDead) == 0x000008, "Member 'FOverseerInfo::NumPlayersDead' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, ScheduledSpawns) == 0x000010, "Member 'FOverseerInfo::ScheduledSpawns' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, BotInfos) == 0x000020, "Member 'FOverseerInfo::BotInfos' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, AIDirectorInfo) == 0x000030, "Member 'FOverseerInfo::AIDirectorInfo' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, GameEvents) == 0x000090, "Member 'FOverseerInfo::GameEvents' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, GameStateDesc) == 0x0000A0, "Member 'FOverseerInfo::GameStateDesc' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, GatheringTime) == 0x0000B0, "Member 'FOverseerInfo::GatheringTime' has a wrong offset!");
static_assert(offsetof(FOverseerInfo, StageStartedTime) == 0x0000B4, "Member 'FOverseerInfo::StageStartedTime' has a wrong offset!");

// ScriptStruct OPP.OverseerOrbitCamera
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FOverseerOrbitCamera final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverseerOrbitCamera) == 0x000004, "Wrong alignment on FOverseerOrbitCamera");
static_assert(sizeof(FOverseerOrbitCamera) == 0x00003C, "Wrong size on FOverseerOrbitCamera");

// ScriptStruct OPP.PictogramSet
// 0x0088 (0x0088 - 0x0000)
struct FPictogramSet final
{
public:
	class FName                                   OrderSetName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bAvailable;                                        // 0x0008(0x0060)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             MaterialsCopy;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPictogramSet) == 0x000008, "Wrong alignment on FPictogramSet");
static_assert(sizeof(FPictogramSet) == 0x000088, "Wrong size on FPictogramSet");
static_assert(offsetof(FPictogramSet, OrderSetName) == 0x000000, "Member 'FPictogramSet::OrderSetName' has a wrong offset!");
static_assert(offsetof(FPictogramSet, bAvailable) == 0x000008, "Member 'FPictogramSet::bAvailable' has a wrong offset!");
static_assert(offsetof(FPictogramSet, Materials) == 0x000068, "Member 'FPictogramSet::Materials' has a wrong offset!");
static_assert(offsetof(FPictogramSet, MaterialsCopy) == 0x000078, "Member 'FPictogramSet::MaterialsCopy' has a wrong offset!");

// ScriptStruct OPP.PasscodeDecalData
// 0x0010 (0x0010 - 0x0000)
struct FPasscodeDecalData final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Digit;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderSetIndex;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPasscodeDecalData) == 0x000004, "Wrong alignment on FPasscodeDecalData");
static_assert(sizeof(FPasscodeDecalData) == 0x000010, "Wrong size on FPasscodeDecalData");
static_assert(offsetof(FPasscodeDecalData, bActive) == 0x000000, "Member 'FPasscodeDecalData::bActive' has a wrong offset!");
static_assert(offsetof(FPasscodeDecalData, Digit) == 0x000004, "Member 'FPasscodeDecalData::Digit' has a wrong offset!");
static_assert(offsetof(FPasscodeDecalData, OrderSetIndex) == 0x000008, "Member 'FPasscodeDecalData::OrderSetIndex' has a wrong offset!");
static_assert(offsetof(FPasscodeDecalData, Order) == 0x00000C, "Member 'FPasscodeDecalData::Order' has a wrong offset!");

// ScriptStruct OPP.PasscodeOrderSet
// 0x00E0 (0x00E0 - 0x0000)
struct FPasscodeOrderSet final
{
public:
	class FName                                   OrderSetName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bAvailable;                                        // 0x0008(0x0060)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartAtFirst;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableBool                      bKeepSequential;                                   // 0x0070(0x0060)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPasscodeOrderSet) == 0x000008, "Wrong alignment on FPasscodeOrderSet");
static_assert(sizeof(FPasscodeOrderSet) == 0x0000E0, "Wrong size on FPasscodeOrderSet");
static_assert(offsetof(FPasscodeOrderSet, OrderSetName) == 0x000000, "Member 'FPasscodeOrderSet::OrderSetName' has a wrong offset!");
static_assert(offsetof(FPasscodeOrderSet, bAvailable) == 0x000008, "Member 'FPasscodeOrderSet::bAvailable' has a wrong offset!");
static_assert(offsetof(FPasscodeOrderSet, bStartAtFirst) == 0x000068, "Member 'FPasscodeOrderSet::bStartAtFirst' has a wrong offset!");
static_assert(offsetof(FPasscodeOrderSet, bKeepSequential) == 0x000070, "Member 'FPasscodeOrderSet::bKeepSequential' has a wrong offset!");
static_assert(offsetof(FPasscodeOrderSet, Materials) == 0x0000D0, "Member 'FPasscodeOrderSet::Materials' has a wrong offset!");

// ScriptStruct OPP.RBPasscodeNumberDecals
// 0x0010 (0x0010 - 0x0000)
struct FRBPasscodeNumberDecals final
{
public:
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPasscodeNumberDecals) == 0x000008, "Wrong alignment on FRBPasscodeNumberDecals");
static_assert(sizeof(FRBPasscodeNumberDecals) == 0x000010, "Wrong size on FRBPasscodeNumberDecals");
static_assert(offsetof(FRBPasscodeNumberDecals, Materials) == 0x000000, "Member 'FRBPasscodeNumberDecals::Materials' has a wrong offset!");

// ScriptStruct OPP.RBPathPoint
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FRBPathPoint final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPathPoint) == 0x000004, "Wrong alignment on FRBPathPoint");
static_assert(sizeof(FRBPathPoint) == 0x000038, "Wrong size on FRBPathPoint");

// ScriptStruct OPP.RBPawnCustomizationRequestInfo
// 0x0048 (0x0048 - 0x0000)
struct FRBPawnCustomizationRequestInfo final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ResourcesToLoad;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EPawnCustomizationRequestType                 RequestType;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x2F];                                      // 0x0019(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPawnCustomizationRequestInfo) == 0x000008, "Wrong alignment on FRBPawnCustomizationRequestInfo");
static_assert(sizeof(FRBPawnCustomizationRequestInfo) == 0x000048, "Wrong size on FRBPawnCustomizationRequestInfo");
static_assert(offsetof(FRBPawnCustomizationRequestInfo, Owner) == 0x000000, "Member 'FRBPawnCustomizationRequestInfo::Owner' has a wrong offset!");
static_assert(offsetof(FRBPawnCustomizationRequestInfo, ResourcesToLoad) == 0x000008, "Member 'FRBPawnCustomizationRequestInfo::ResourcesToLoad' has a wrong offset!");
static_assert(offsetof(FRBPawnCustomizationRequestInfo, RequestType) == 0x000018, "Member 'FRBPawnCustomizationRequestInfo::RequestType' has a wrong offset!");

// ScriptStruct OPP.RBPharmaSkillRuntimeInfo
// 0x0010 (0x0010 - 0x0000)
struct FRBPharmaSkillRuntimeInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLingeringActive;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LingeringTimeRemaining;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPharmaSkillRuntimeInfo) == 0x000008, "Wrong alignment on FRBPharmaSkillRuntimeInfo");
static_assert(sizeof(FRBPharmaSkillRuntimeInfo) == 0x000010, "Wrong size on FRBPharmaSkillRuntimeInfo");
static_assert(offsetof(FRBPharmaSkillRuntimeInfo, Player) == 0x000000, "Member 'FRBPharmaSkillRuntimeInfo::Player' has a wrong offset!");
static_assert(offsetof(FRBPharmaSkillRuntimeInfo, bLingeringActive) == 0x000008, "Member 'FRBPharmaSkillRuntimeInfo::bLingeringActive' has a wrong offset!");
static_assert(offsetof(FRBPharmaSkillRuntimeInfo, LingeringTimeRemaining) == 0x00000C, "Member 'FRBPharmaSkillRuntimeInfo::LingeringTimeRemaining' has a wrong offset!");

// ScriptStruct OPP.PickupObjectiveRuntimeData
// 0x0030 (0x0030 - 0x0000)
struct FPickupObjectiveRuntimeData final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBPlayer*                              Subject;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         SubjectPlayerState;                                // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              Instigator;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         InstigatorPlayerState;                             // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPickup*                              ObjectivePickup;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupObjectiveRuntimeData) == 0x000008, "Wrong alignment on FPickupObjectiveRuntimeData");
static_assert(sizeof(FPickupObjectiveRuntimeData) == 0x000030, "Wrong size on FPickupObjectiveRuntimeData");
static_assert(offsetof(FPickupObjectiveRuntimeData, ItemType) == 0x000000, "Member 'FPickupObjectiveRuntimeData::ItemType' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveRuntimeData, Subject) == 0x000008, "Member 'FPickupObjectiveRuntimeData::Subject' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveRuntimeData, SubjectPlayerState) == 0x000010, "Member 'FPickupObjectiveRuntimeData::SubjectPlayerState' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveRuntimeData, Instigator) == 0x000018, "Member 'FPickupObjectiveRuntimeData::Instigator' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveRuntimeData, InstigatorPlayerState) == 0x000020, "Member 'FPickupObjectiveRuntimeData::InstigatorPlayerState' has a wrong offset!");
static_assert(offsetof(FPickupObjectiveRuntimeData, ObjectivePickup) == 0x000028, "Member 'FPickupObjectiveRuntimeData::ObjectivePickup' has a wrong offset!");

// ScriptStruct OPP.PipeConnector
// 0x0040 (0x0040 - 0x0000)
struct FPipeConnector final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPipeConnector) == 0x000010, "Wrong alignment on FPipeConnector");
static_assert(sizeof(FPipeConnector) == 0x000040, "Wrong size on FPipeConnector");
static_assert(offsetof(FPipeConnector, Transform) == 0x000000, "Member 'FPipeConnector::Transform' has a wrong offset!");
static_assert(offsetof(FPipeConnector, StaticMesh) == 0x000030, "Member 'FPipeConnector::StaticMesh' has a wrong offset!");

// ScriptStruct OPP.DeadClearanceData
// 0x0044 (0x0044 - 0x0000)
struct alignas(0x04) FDeadClearanceData final
{
public:
	uint8                                         Pad_0[0x44];                                       // 0x0000(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeadClearanceData) == 0x000004, "Wrong alignment on FDeadClearanceData");
static_assert(sizeof(FDeadClearanceData) == 0x000044, "Wrong size on FDeadClearanceData");

// ScriptStruct OPP.LandingData
// 0x0008 (0x0008 - 0x0000)
struct FLandingData final
{
public:
	bool                                          bLandingQueued;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandingHeight;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandingData) == 0x000004, "Wrong alignment on FLandingData");
static_assert(sizeof(FLandingData) == 0x000008, "Wrong size on FLandingData");
static_assert(offsetof(FLandingData, bLandingQueued) == 0x000000, "Member 'FLandingData::bLandingQueued' has a wrong offset!");
static_assert(offsetof(FLandingData, LandingHeight) == 0x000004, "Member 'FLandingData::LandingHeight' has a wrong offset!");

// ScriptStruct OPP.DamageColumn
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDamageColumn final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageColumn) == 0x000004, "Wrong alignment on FDamageColumn");
static_assert(sizeof(FDamageColumn) == 0x000008, "Wrong size on FDamageColumn");

// ScriptStruct OPP.PlayerInputs
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x04) FPlayerInputs final
{
public:
	uint8                                         Pad_0[0x130];                                      // 0x0000(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInputs) == 0x000004, "Wrong alignment on FPlayerInputs");
static_assert(sizeof(FPlayerInputs) == 0x000130, "Wrong size on FPlayerInputs");

// ScriptStruct OPP.PlayerTeleportData
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FPlayerTeleportData final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerTeleportData) == 0x000004, "Wrong alignment on FPlayerTeleportData");
static_assert(sizeof(FPlayerTeleportData) == 0x000024, "Wrong size on FPlayerTeleportData");

// ScriptStruct OPP.TraversalPositionData
// 0x0040 (0x0040 - 0x0000)
struct FTraversalPositionData final
{
public:
	class ARBLedgeMarker*                         LedgeMarker;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraversalPositionData) == 0x000008, "Wrong alignment on FTraversalPositionData");
static_assert(sizeof(FTraversalPositionData) == 0x000040, "Wrong size on FTraversalPositionData");
static_assert(offsetof(FTraversalPositionData, LedgeMarker) == 0x000000, "Member 'FTraversalPositionData::LedgeMarker' has a wrong offset!");

// ScriptStruct OPP.CameraLookAtData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FCameraLookAtData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LookAtTarget;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraLookAtData) == 0x000010, "Wrong alignment on FCameraLookAtData");
static_assert(sizeof(FCameraLookAtData) == 0x000070, "Wrong size on FCameraLookAtData");
static_assert(offsetof(FCameraLookAtData, LookAtTarget) == 0x000028, "Member 'FCameraLookAtData::LookAtTarget' has a wrong offset!");

// ScriptStruct OPP.TargettedSmoothingLocationData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FTargettedSmoothingLocationData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargettedSmoothingLocationData) == 0x000004, "Wrong alignment on FTargettedSmoothingLocationData");
static_assert(sizeof(FTargettedSmoothingLocationData) == 0x000028, "Wrong size on FTargettedSmoothingLocationData");

// ScriptStruct OPP.TargettedSmoothingAngleData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FTargettedSmoothingAngleData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargettedSmoothingAngleData) == 0x000004, "Wrong alignment on FTargettedSmoothingAngleData");
static_assert(sizeof(FTargettedSmoothingAngleData) == 0x00001C, "Wrong size on FTargettedSmoothingAngleData");

// ScriptStruct OPP.CamSmoothingData
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FCamSmoothingData final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCamSmoothingData) == 0x000004, "Wrong alignment on FCamSmoothingData");
static_assert(sizeof(FCamSmoothingData) == 0x000024, "Wrong size on FCamSmoothingData");

// ScriptStruct OPP.ViewLimits
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FViewLimits final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FViewLimits) == 0x000004, "Wrong alignment on FViewLimits");
static_assert(sizeof(FViewLimits) == 0x000014, "Wrong size on FViewLimits");

// ScriptStruct OPP.CamView
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FCamView final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCamView) == 0x000004, "Wrong alignment on FCamView");
static_assert(sizeof(FCamView) == 0x000018, "Wrong size on FCamView");

// ScriptStruct OPP.RBPlayerCellSlotDefinition
// 0x0028 (0x0028 - 0x0000)
struct FRBPlayerCellSlotDefinition final
{
public:
	ECustomizationMenuCategory                    Slot;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Category;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerCellSlotDefinition) == 0x000008, "Wrong alignment on FRBPlayerCellSlotDefinition");
static_assert(sizeof(FRBPlayerCellSlotDefinition) == 0x000028, "Wrong size on FRBPlayerCellSlotDefinition");
static_assert(offsetof(FRBPlayerCellSlotDefinition, Slot) == 0x000000, "Member 'FRBPlayerCellSlotDefinition::Slot' has a wrong offset!");
static_assert(offsetof(FRBPlayerCellSlotDefinition, Category) == 0x000004, "Member 'FRBPlayerCellSlotDefinition::Category' has a wrong offset!");
static_assert(offsetof(FRBPlayerCellSlotDefinition, Name) == 0x000010, "Member 'FRBPlayerCellSlotDefinition::Name' has a wrong offset!");

// ScriptStruct OPP.RBPlayerCachedInfo
// 0x0070 (0x0070 - 0x0000)
struct FRBPlayerCachedInfo final
{
public:
	struct FProfileId                             ProfileId;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActiveSkillType                              ActiveSkillType;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerLevel;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseCount;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CustomizationOptions;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Outfit;                                            // 0x0034(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceOption;                                       // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerIcon;                                        // 0x0044(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerIconBorder;                                  // 0x004C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PodiumEmote;                                       // 0x0054(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalEmote;                                     // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HairColor;                                         // 0x0064(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerCachedInfo) == 0x000008, "Wrong alignment on FRBPlayerCachedInfo");
static_assert(sizeof(FRBPlayerCachedInfo) == 0x000070, "Wrong size on FRBPlayerCachedInfo");
static_assert(offsetof(FRBPlayerCachedInfo, ProfileId) == 0x000000, "Member 'FRBPlayerCachedInfo::ProfileId' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, ActiveSkillType) == 0x000010, "Member 'FRBPlayerCachedInfo::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, PlayerLevel) == 0x000014, "Member 'FRBPlayerCachedInfo::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, ReleaseCount) == 0x000018, "Member 'FRBPlayerCachedInfo::ReleaseCount' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, CustomizationOptions) == 0x000020, "Member 'FRBPlayerCachedInfo::CustomizationOptions' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, bIsFemale) == 0x000030, "Member 'FRBPlayerCachedInfo::bIsFemale' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, Outfit) == 0x000034, "Member 'FRBPlayerCachedInfo::Outfit' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, VoiceOption) == 0x00003C, "Member 'FRBPlayerCachedInfo::VoiceOption' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, PlayerIcon) == 0x000044, "Member 'FRBPlayerCachedInfo::PlayerIcon' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, PlayerIconBorder) == 0x00004C, "Member 'FRBPlayerCachedInfo::PlayerIconBorder' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, PodiumEmote) == 0x000054, "Member 'FRBPlayerCachedInfo::PodiumEmote' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, TerminalEmote) == 0x00005C, "Member 'FRBPlayerCachedInfo::TerminalEmote' has a wrong offset!");
static_assert(offsetof(FRBPlayerCachedInfo, HairColor) == 0x000064, "Member 'FRBPlayerCachedInfo::HairColor' has a wrong offset!");

// ScriptStruct OPP.RBDefaultCustomizationSlotInfo
// 0x0010 (0x0010 - 0x0000)
struct FRBDefaultCustomizationSlotInfo final
{
public:
	class URBPlayerCustomizationOption*           MaleDefaultOption;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBPlayerCustomizationOption*           FemaleDefaultOption;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBDefaultCustomizationSlotInfo) == 0x000008, "Wrong alignment on FRBDefaultCustomizationSlotInfo");
static_assert(sizeof(FRBDefaultCustomizationSlotInfo) == 0x000010, "Wrong size on FRBDefaultCustomizationSlotInfo");
static_assert(offsetof(FRBDefaultCustomizationSlotInfo, MaleDefaultOption) == 0x000000, "Member 'FRBDefaultCustomizationSlotInfo::MaleDefaultOption' has a wrong offset!");
static_assert(offsetof(FRBDefaultCustomizationSlotInfo, FemaleDefaultOption) == 0x000008, "Member 'FRBDefaultCustomizationSlotInfo::FemaleDefaultOption' has a wrong offset!");

// ScriptStruct OPP.RBDefaultCustomizationSlotInfoList
// 0x0010 (0x0010 - 0x0000)
struct FRBDefaultCustomizationSlotInfoList final
{
public:
	TArray<struct FRBDefaultCustomizationSlotInfo> CustomizationSlotInfos;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBDefaultCustomizationSlotInfoList) == 0x000008, "Wrong alignment on FRBDefaultCustomizationSlotInfoList");
static_assert(sizeof(FRBDefaultCustomizationSlotInfoList) == 0x000010, "Wrong size on FRBDefaultCustomizationSlotInfoList");
static_assert(offsetof(FRBDefaultCustomizationSlotInfoList, CustomizationSlotInfos) == 0x000000, "Member 'FRBDefaultCustomizationSlotInfoList::CustomizationSlotInfos' has a wrong offset!");

// ScriptStruct OPP.RBPlayerCustomizationMaterialOverride
// 0x0038 (0x0038 - 0x0000)
struct FRBPlayerCustomizationMaterialOverride final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstanceConstant> Material;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerCustomizationMaterialOverride) == 0x000008, "Wrong alignment on FRBPlayerCustomizationMaterialOverride");
static_assert(sizeof(FRBPlayerCustomizationMaterialOverride) == 0x000038, "Wrong size on FRBPlayerCustomizationMaterialOverride");
static_assert(offsetof(FRBPlayerCustomizationMaterialOverride, ID) == 0x000000, "Member 'FRBPlayerCustomizationMaterialOverride::ID' has a wrong offset!");
static_assert(offsetof(FRBPlayerCustomizationMaterialOverride, Material) == 0x000010, "Member 'FRBPlayerCustomizationMaterialOverride::Material' has a wrong offset!");

// ScriptStruct OPP.CustomizationRarityUIInfo
// 0x0068 (0x0068 - 0x0000)
struct FCustomizationRarityUIInfo final
{
public:
	struct FSlateColor                            PrimaryColor;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            SecondaryColor;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationRarityUIInfo) == 0x000008, "Wrong alignment on FCustomizationRarityUIInfo");
static_assert(sizeof(FCustomizationRarityUIInfo) == 0x000068, "Wrong size on FCustomizationRarityUIInfo");
static_assert(offsetof(FCustomizationRarityUIInfo, PrimaryColor) == 0x000000, "Member 'FCustomizationRarityUIInfo::PrimaryColor' has a wrong offset!");
static_assert(offsetof(FCustomizationRarityUIInfo, SecondaryColor) == 0x000028, "Member 'FCustomizationRarityUIInfo::SecondaryColor' has a wrong offset!");
static_assert(offsetof(FCustomizationRarityUIInfo, Name) == 0x000050, "Member 'FCustomizationRarityUIInfo::Name' has a wrong offset!");

// ScriptStruct OPP.CustomizationSlotUIInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FCustomizationSlotUIInfo final
{
public:
	struct FSlateBrush                            RewardBrush;                                       // 0x0000(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationSlotUIInfo) == 0x000008, "Wrong alignment on FCustomizationSlotUIInfo");
static_assert(sizeof(FCustomizationSlotUIInfo) == 0x0000A0, "Wrong size on FCustomizationSlotUIInfo");
static_assert(offsetof(FCustomizationSlotUIInfo, RewardBrush) == 0x000000, "Member 'FCustomizationSlotUIInfo::RewardBrush' has a wrong offset!");
static_assert(offsetof(FCustomizationSlotUIInfo, Name) == 0x000088, "Member 'FCustomizationSlotUIInfo::Name' has a wrong offset!");

// ScriptStruct OPP.IdleDetectionSettings
// 0x0010 (0x0010 - 0x0000)
struct FIdleDetectionSettings final
{
public:
	float                                         MaxYaw;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYaw;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIdleDetectionSettings) == 0x000004, "Wrong alignment on FIdleDetectionSettings");
static_assert(sizeof(FIdleDetectionSettings) == 0x000010, "Wrong size on FIdleDetectionSettings");
static_assert(offsetof(FIdleDetectionSettings, MaxYaw) == 0x000000, "Member 'FIdleDetectionSettings::MaxYaw' has a wrong offset!");
static_assert(offsetof(FIdleDetectionSettings, MinYaw) == 0x000004, "Member 'FIdleDetectionSettings::MinYaw' has a wrong offset!");
static_assert(offsetof(FIdleDetectionSettings, Pitch) == 0x000008, "Member 'FIdleDetectionSettings::Pitch' has a wrong offset!");
static_assert(offsetof(FIdleDetectionSettings, SpeedMultiplier) == 0x00000C, "Member 'FIdleDetectionSettings::SpeedMultiplier' has a wrong offset!");

// ScriptStruct OPP.AlertedStateActions
// 0x0020 (0x0020 - 0x0000)
struct FAlertedStateActions final
{
public:
	TArray<TSoftObjectPtr<class ARBTriggerable>>  ToTriggerOnAlerted;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ARBTriggerable>>  ToUntriggerOnAlerted;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAlertedStateActions) == 0x000008, "Wrong alignment on FAlertedStateActions");
static_assert(sizeof(FAlertedStateActions) == 0x000020, "Wrong size on FAlertedStateActions");
static_assert(offsetof(FAlertedStateActions, ToTriggerOnAlerted) == 0x000000, "Member 'FAlertedStateActions::ToTriggerOnAlerted' has a wrong offset!");
static_assert(offsetof(FAlertedStateActions, ToUntriggerOnAlerted) == 0x000010, "Member 'FAlertedStateActions::ToUntriggerOnAlerted' has a wrong offset!");

// ScriptStruct OPP.ImposterOverheadDetails
// 0x0030 (0x0030 - 0x0000)
struct FImposterOverheadDetails final
{
public:
	class FString                                 CopiedPlayerName;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CopiedPlayerLevel;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProfileId                             CopiedProfileId;                                   // 0x0014(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActiveSkillType                              CopiedActiveSkillType;                             // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomSeed;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImposterOverheadDetails) == 0x000008, "Wrong alignment on FImposterOverheadDetails");
static_assert(sizeof(FImposterOverheadDetails) == 0x000030, "Wrong size on FImposterOverheadDetails");
static_assert(offsetof(FImposterOverheadDetails, CopiedPlayerName) == 0x000000, "Member 'FImposterOverheadDetails::CopiedPlayerName' has a wrong offset!");
static_assert(offsetof(FImposterOverheadDetails, CopiedPlayerLevel) == 0x000010, "Member 'FImposterOverheadDetails::CopiedPlayerLevel' has a wrong offset!");
static_assert(offsetof(FImposterOverheadDetails, CopiedProfileId) == 0x000014, "Member 'FImposterOverheadDetails::CopiedProfileId' has a wrong offset!");
static_assert(offsetof(FImposterOverheadDetails, CopiedActiveSkillType) == 0x000024, "Member 'FImposterOverheadDetails::CopiedActiveSkillType' has a wrong offset!");
static_assert(offsetof(FImposterOverheadDetails, RandomSeed) == 0x000028, "Member 'FImposterOverheadDetails::RandomSeed' has a wrong offset!");

// ScriptStruct OPP.ImposterDisguiseData
// 0x0088 (0x0088 - 0x0000)
struct FImposterDisguiseData final
{
public:
	struct FImposterOverheadDetails               OverheadDetails;                                   // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FRBPlayerCustomizationInfo             CustomizationInfo;                                 // 0x0030(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         CopiedPlayerState;                                 // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImposterDisguiseData) == 0x000008, "Wrong alignment on FImposterDisguiseData");
static_assert(sizeof(FImposterDisguiseData) == 0x000088, "Wrong size on FImposterDisguiseData");
static_assert(offsetof(FImposterDisguiseData, OverheadDetails) == 0x000000, "Member 'FImposterDisguiseData::OverheadDetails' has a wrong offset!");
static_assert(offsetof(FImposterDisguiseData, CustomizationInfo) == 0x000030, "Member 'FImposterDisguiseData::CustomizationInfo' has a wrong offset!");
static_assert(offsetof(FImposterDisguiseData, CopiedPlayerState) == 0x000080, "Member 'FImposterDisguiseData::CopiedPlayerState' has a wrong offset!");

// ScriptStruct OPP.PlayerInputState
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FPlayerInputState final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInputState) == 0x000004, "Wrong alignment on FPlayerInputState");
static_assert(sizeof(FPlayerInputState) == 0x00000C, "Wrong size on FPlayerInputState");

// ScriptStruct OPP.RBPlayerLoadoutValidator
// 0x0018 (0x0018 - 0x0000)
struct FRBPlayerLoadoutValidator final
{
public:
	bool                                          bHasRequiredActiveSkill;                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EActiveSkillType>                      RequiredActiveSkillTypes;                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerLoadoutValidator) == 0x000008, "Wrong alignment on FRBPlayerLoadoutValidator");
static_assert(sizeof(FRBPlayerLoadoutValidator) == 0x000018, "Wrong size on FRBPlayerLoadoutValidator");
static_assert(offsetof(FRBPlayerLoadoutValidator, bHasRequiredActiveSkill) == 0x000000, "Member 'FRBPlayerLoadoutValidator::bHasRequiredActiveSkill' has a wrong offset!");
static_assert(offsetof(FRBPlayerLoadoutValidator, RequiredActiveSkillTypes) == 0x000008, "Member 'FRBPlayerLoadoutValidator::RequiredActiveSkillTypes' has a wrong offset!");

// ScriptStruct OPP.MenuUpgradeItemInfo
// 0x0190 (0x0190 - 0x0000)
struct FMenuUpgradeItemInfo final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuUpgradeItemState                         State;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBItemProgressionData                 ItemProgressionData;                               // 0x0010(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELoadoutElementType                           UpgradeType;                                       // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActiveSkillType                              ActiveSkillType;                                   // 0x0181(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPerkCategory                                 PerkCategory;                                      // 0x0182(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183[0x1];                                      // 0x0183(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelToReach;                                      // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuUpgradeItemInfo) == 0x000008, "Wrong alignment on FMenuUpgradeItemInfo");
static_assert(sizeof(FMenuUpgradeItemInfo) == 0x000190, "Wrong size on FMenuUpgradeItemInfo");
static_assert(offsetof(FMenuUpgradeItemInfo, ItemId) == 0x000000, "Member 'FMenuUpgradeItemInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, State) == 0x000008, "Member 'FMenuUpgradeItemInfo::State' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, ItemProgressionData) == 0x000010, "Member 'FMenuUpgradeItemInfo::ItemProgressionData' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, UpgradeType) == 0x000180, "Member 'FMenuUpgradeItemInfo::UpgradeType' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, ActiveSkillType) == 0x000181, "Member 'FMenuUpgradeItemInfo::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, PerkCategory) == 0x000182, "Member 'FMenuUpgradeItemInfo::PerkCategory' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, LevelToReach) == 0x000184, "Member 'FMenuUpgradeItemInfo::LevelToReach' has a wrong offset!");
static_assert(offsetof(FMenuUpgradeItemInfo, bIsNew) == 0x000188, "Member 'FMenuUpgradeItemInfo::bIsNew' has a wrong offset!");

// ScriptStruct OPP.RBPlayerProgressionReleaseData
// 0x000C (0x000C - 0x0000)
struct FRBPlayerProgressionReleaseData final
{
public:
	int32                                         ReleaseCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardDataId;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerProgressionReleaseData) == 0x000004, "Wrong alignment on FRBPlayerProgressionReleaseData");
static_assert(sizeof(FRBPlayerProgressionReleaseData) == 0x00000C, "Wrong size on FRBPlayerProgressionReleaseData");
static_assert(offsetof(FRBPlayerProgressionReleaseData, ReleaseCount) == 0x000000, "Member 'FRBPlayerProgressionReleaseData::ReleaseCount' has a wrong offset!");
static_assert(offsetof(FRBPlayerProgressionReleaseData, RewardDataId) == 0x000004, "Member 'FRBPlayerProgressionReleaseData::RewardDataId' has a wrong offset!");

// ScriptStruct OPP.RBPlayerProgressionReleaseDataRow
// 0x0010 (0x0018 - 0x0008)
struct FRBPlayerProgressionReleaseDataRow final : public FTableRowBase
{
public:
	int32                                         ReleaseCount;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardDataId;                                      // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerProgressionReleaseDataRow) == 0x000008, "Wrong alignment on FRBPlayerProgressionReleaseDataRow");
static_assert(sizeof(FRBPlayerProgressionReleaseDataRow) == 0x000018, "Wrong size on FRBPlayerProgressionReleaseDataRow");
static_assert(offsetof(FRBPlayerProgressionReleaseDataRow, ReleaseCount) == 0x000008, "Member 'FRBPlayerProgressionReleaseDataRow::ReleaseCount' has a wrong offset!");
static_assert(offsetof(FRBPlayerProgressionReleaseDataRow, RewardDataId) == 0x00000C, "Member 'FRBPlayerProgressionReleaseDataRow::RewardDataId' has a wrong offset!");

// ScriptStruct OPP.RBPlayerProgressionLevelDataRow
// 0x0010 (0x0018 - 0x0008)
struct FRBPlayerProgressionLevelDataRow final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredXp;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardDataId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerProgressionLevelDataRow) == 0x000008, "Wrong alignment on FRBPlayerProgressionLevelDataRow");
static_assert(sizeof(FRBPlayerProgressionLevelDataRow) == 0x000018, "Wrong size on FRBPlayerProgressionLevelDataRow");
static_assert(offsetof(FRBPlayerProgressionLevelDataRow, Level) == 0x000008, "Member 'FRBPlayerProgressionLevelDataRow::Level' has a wrong offset!");
static_assert(offsetof(FRBPlayerProgressionLevelDataRow, RequiredXp) == 0x00000C, "Member 'FRBPlayerProgressionLevelDataRow::RequiredXp' has a wrong offset!");
static_assert(offsetof(FRBPlayerProgressionLevelDataRow, RewardDataId) == 0x000010, "Member 'FRBPlayerProgressionLevelDataRow::RewardDataId' has a wrong offset!");

// ScriptStruct OPP.PlayerProgressionLevelData
// 0x0060 (0x0060 - 0x0000)
struct FPlayerProgressionLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredXp;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardDataId;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ERewardType, int32>                      ExtraUnlockedRewards;                              // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerProgressionLevelData) == 0x000008, "Wrong alignment on FPlayerProgressionLevelData");
static_assert(sizeof(FPlayerProgressionLevelData) == 0x000060, "Wrong size on FPlayerProgressionLevelData");
static_assert(offsetof(FPlayerProgressionLevelData, Level) == 0x000000, "Member 'FPlayerProgressionLevelData::Level' has a wrong offset!");
static_assert(offsetof(FPlayerProgressionLevelData, RequiredXp) == 0x000004, "Member 'FPlayerProgressionLevelData::RequiredXp' has a wrong offset!");
static_assert(offsetof(FPlayerProgressionLevelData, RewardDataId) == 0x000008, "Member 'FPlayerProgressionLevelData::RewardDataId' has a wrong offset!");
static_assert(offsetof(FPlayerProgressionLevelData, ExtraUnlockedRewards) == 0x000010, "Member 'FPlayerProgressionLevelData::ExtraUnlockedRewards' has a wrong offset!");

// ScriptStruct OPP.PlayerProgressionLevelingData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerProgressionLevelingData final
{
public:
	TArray<struct FPlayerProgressionLevelData>    Levels;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerProgressionLevelingData) == 0x000008, "Wrong alignment on FPlayerProgressionLevelingData");
static_assert(sizeof(FPlayerProgressionLevelingData) == 0x000010, "Wrong size on FPlayerProgressionLevelingData");
static_assert(offsetof(FPlayerProgressionLevelingData, Levels) == 0x000000, "Member 'FPlayerProgressionLevelingData::Levels' has a wrong offset!");

// ScriptStruct OPP.StartAction
// 0x0030 (0x0030 - 0x0000)
struct FStartAction final
{
public:
	TSoftObjectPtr<class AActor>                  ActionActor;                                       // 0x0000(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartAction) == 0x000008, "Wrong alignment on FStartAction");
static_assert(sizeof(FStartAction) == 0x000030, "Wrong size on FStartAction");
static_assert(offsetof(FStartAction, ActionActor) == 0x000000, "Member 'FStartAction::ActionActor' has a wrong offset!");

// ScriptStruct OPP.TrialChainingUpgradeChoiceItemData
// 0x0008 (0x0008 - 0x0000)
struct FTrialChainingUpgradeChoiceItemData final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingUpgradeChoiceItemData) == 0x000004, "Wrong alignment on FTrialChainingUpgradeChoiceItemData");
static_assert(sizeof(FTrialChainingUpgradeChoiceItemData) == 0x000008, "Wrong size on FTrialChainingUpgradeChoiceItemData");
static_assert(offsetof(FTrialChainingUpgradeChoiceItemData, ItemId) == 0x000000, "Member 'FTrialChainingUpgradeChoiceItemData::ItemId' has a wrong offset!");

// ScriptStruct OPP.RBPlayerBadgeRow
// 0x00A0 (0x00A8 - 0x0008)
struct FRBPlayerBadgeRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EPlayerStat>                           PlayerStats;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 PlayerStatsContext;                                // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Threshold;                                         // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatable;                                       // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStat                                   AwardedPlayerStat;                                 // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RewardItemId;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardId;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AchievementId;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerBadgeRow) == 0x000008, "Wrong alignment on FRBPlayerBadgeRow");
static_assert(sizeof(FRBPlayerBadgeRow) == 0x0000A8, "Wrong size on FRBPlayerBadgeRow");
static_assert(offsetof(FRBPlayerBadgeRow, ID) == 0x000008, "Member 'FRBPlayerBadgeRow::ID' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, Icon) == 0x000010, "Member 'FRBPlayerBadgeRow::Icon' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, Name) == 0x000028, "Member 'FRBPlayerBadgeRow::Name' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, Description) == 0x000040, "Member 'FRBPlayerBadgeRow::Description' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, PlayerStats) == 0x000058, "Member 'FRBPlayerBadgeRow::PlayerStats' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, PlayerStatsContext) == 0x000068, "Member 'FRBPlayerBadgeRow::PlayerStatsContext' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, Threshold) == 0x000078, "Member 'FRBPlayerBadgeRow::Threshold' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, bRepeatable) == 0x00007C, "Member 'FRBPlayerBadgeRow::bRepeatable' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, AwardedPlayerStat) == 0x00007D, "Member 'FRBPlayerBadgeRow::AwardedPlayerStat' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, RewardItemId) == 0x000080, "Member 'FRBPlayerBadgeRow::RewardItemId' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, RewardId) == 0x000088, "Member 'FRBPlayerBadgeRow::RewardId' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, AchievementId) == 0x000090, "Member 'FRBPlayerBadgeRow::AchievementId' has a wrong offset!");
static_assert(offsetof(FRBPlayerBadgeRow, FeatureSwitch) == 0x000098, "Member 'FRBPlayerBadgeRow::FeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.RBPlayerUpgradeEffectData
// 0x0098 (0x0098 - 0x0000)
struct FRBPlayerUpgradeEffectData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      SettingValues;                                     // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRBGameplayAttributeModifier>   Modifiers;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDisplay;                                          // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FeatureSwitch;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPlayerUpgradeEffectData) == 0x000008, "Wrong alignment on FRBPlayerUpgradeEffectData");
static_assert(sizeof(FRBPlayerUpgradeEffectData) == 0x000098, "Wrong size on FRBPlayerUpgradeEffectData");
static_assert(offsetof(FRBPlayerUpgradeEffectData, ID) == 0x000000, "Member 'FRBPlayerUpgradeEffectData::ID' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectData, Description) == 0x000008, "Member 'FRBPlayerUpgradeEffectData::Description' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectData, SettingValues) == 0x000020, "Member 'FRBPlayerUpgradeEffectData::SettingValues' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectData, Modifiers) == 0x000070, "Member 'FRBPlayerUpgradeEffectData::Modifiers' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectData, bDisplay) == 0x000080, "Member 'FRBPlayerUpgradeEffectData::bDisplay' has a wrong offset!");
static_assert(offsetof(FRBPlayerUpgradeEffectData, FeatureSwitch) == 0x000088, "Member 'FRBPlayerUpgradeEffectData::FeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.RBPosedDeadBodyCustomizationProxy
// 0x0008 (0x0008 - 0x0000)
struct FRBPosedDeadBodyCustomizationProxy final
{
public:
	class ARBPosedDeadBody*                       Owner;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBPosedDeadBodyCustomizationProxy) == 0x000008, "Wrong alignment on FRBPosedDeadBodyCustomizationProxy");
static_assert(sizeof(FRBPosedDeadBodyCustomizationProxy) == 0x000008, "Wrong size on FRBPosedDeadBodyCustomizationProxy");
static_assert(offsetof(FRBPosedDeadBodyCustomizationProxy, Owner) == 0x000000, "Member 'FRBPosedDeadBodyCustomizationProxy::Owner' has a wrong offset!");

// ScriptStruct OPP.RBVoiceChatInputDevice
// 0x0028 (0x0028 - 0x0000)
struct FRBVoiceChatInputDevice final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBVoiceChatInputDevice) == 0x000008, "Wrong alignment on FRBVoiceChatInputDevice");
static_assert(sizeof(FRBVoiceChatInputDevice) == 0x000028, "Wrong size on FRBVoiceChatInputDevice");
static_assert(offsetof(FRBVoiceChatInputDevice, Name) == 0x000000, "Member 'FRBVoiceChatInputDevice::Name' has a wrong offset!");
static_assert(offsetof(FRBVoiceChatInputDevice, ID) == 0x000010, "Member 'FRBVoiceChatInputDevice::ID' has a wrong offset!");
static_assert(offsetof(FRBVoiceChatInputDevice, bActive) == 0x000020, "Member 'FRBVoiceChatInputDevice::bActive' has a wrong offset!");

// ScriptStruct OPP.RBTrialRewardRow
// 0x0058 (0x0060 - 0x0008)
struct FRBTrialRewardRow final : public FTableRowBase
{
public:
	class FName                                   RewardType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPriority;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgramId;                                         // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrialId;                                           // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrialSizeTypeFilter                          SizeTypeFilter;                                    // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerTrialRating>                    ScoreFilter;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinimumTrialChainIndex;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumTrialChainIndex;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardDataId;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondaryObjectiveRewardDataId;                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialRewardRow) == 0x000008, "Wrong alignment on FRBTrialRewardRow");
static_assert(sizeof(FRBTrialRewardRow) == 0x000060, "Wrong size on FRBTrialRewardRow");
static_assert(offsetof(FRBTrialRewardRow, RewardType) == 0x000008, "Member 'FRBTrialRewardRow::RewardType' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, RewardPriority) == 0x000010, "Member 'FRBTrialRewardRow::RewardPriority' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, ProgramId) == 0x000014, "Member 'FRBTrialRewardRow::ProgramId' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, TrialId) == 0x00001C, "Member 'FRBTrialRewardRow::TrialId' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, ProgramDifficulty) == 0x000024, "Member 'FRBTrialRewardRow::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, SizeTypeFilter) == 0x000025, "Member 'FRBTrialRewardRow::SizeTypeFilter' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, ScoreFilter) == 0x000028, "Member 'FRBTrialRewardRow::ScoreFilter' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, MinimumTrialChainIndex) == 0x000038, "Member 'FRBTrialRewardRow::MinimumTrialChainIndex' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, MaximumTrialChainIndex) == 0x00003C, "Member 'FRBTrialRewardRow::MaximumTrialChainIndex' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, RewardDataId) == 0x000040, "Member 'FRBTrialRewardRow::RewardDataId' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, SecondaryObjectiveRewardDataId) == 0x000048, "Member 'FRBTrialRewardRow::SecondaryObjectiveRewardDataId' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardRow, FeatureSwitch) == 0x000050, "Member 'FRBTrialRewardRow::FeatureSwitch' has a wrong offset!");

// ScriptStruct OPP.RBRewardData
// 0x0088 (0x0088 - 0x0000)
struct FRBRewardData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Xp;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECurrencyType, int32>                    Currencies;                                        // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           Items;                                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           RandomRewardPoolIds;                               // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBRewardData) == 0x000008, "Wrong alignment on FRBRewardData");
static_assert(sizeof(FRBRewardData) == 0x000088, "Wrong size on FRBRewardData");
static_assert(offsetof(FRBRewardData, Xp) == 0x000010, "Member 'FRBRewardData::Xp' has a wrong offset!");
static_assert(offsetof(FRBRewardData, Currencies) == 0x000018, "Member 'FRBRewardData::Currencies' has a wrong offset!");
static_assert(offsetof(FRBRewardData, Items) == 0x000068, "Member 'FRBRewardData::Items' has a wrong offset!");
static_assert(offsetof(FRBRewardData, RandomRewardPoolIds) == 0x000078, "Member 'FRBRewardData::RandomRewardPoolIds' has a wrong offset!");

// ScriptStruct OPP.RBTrialRewardData
// 0x0220 (0x0220 - 0x0000)
struct FRBTrialRewardData final
{
public:
	struct FRBRewardData                          BaseReward;                                        // 0x0000(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRBRewardData                          SecondaryObjectiveReward;                          // 0x0088(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRBRewardData                          RatingReward;                                      // 0x0110(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRBRewardData                          TrialChainReward;                                  // 0x0198(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialRewardData) == 0x000008, "Wrong alignment on FRBTrialRewardData");
static_assert(sizeof(FRBTrialRewardData) == 0x000220, "Wrong size on FRBTrialRewardData");
static_assert(offsetof(FRBTrialRewardData, BaseReward) == 0x000000, "Member 'FRBTrialRewardData::BaseReward' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardData, SecondaryObjectiveReward) == 0x000088, "Member 'FRBTrialRewardData::SecondaryObjectiveReward' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardData, RatingReward) == 0x000110, "Member 'FRBTrialRewardData::RatingReward' has a wrong offset!");
static_assert(offsetof(FRBTrialRewardData, TrialChainReward) == 0x000198, "Member 'FRBTrialRewardData::TrialChainReward' has a wrong offset!");

// ScriptStruct OPP.ProjectileSettings
// 0x0008 (0x0008 - 0x0000)
struct FProjectileSettings final
{
public:
	float                                         PitchRotationSpeed;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileSettings) == 0x000004, "Wrong alignment on FProjectileSettings");
static_assert(sizeof(FProjectileSettings) == 0x000008, "Wrong size on FProjectileSettings");
static_assert(offsetof(FProjectileSettings, PitchRotationSpeed) == 0x000000, "Member 'FProjectileSettings::PitchRotationSpeed' has a wrong offset!");
static_assert(offsetof(FProjectileSettings, DamageAmount) == 0x000004, "Member 'FProjectileSettings::DamageAmount' has a wrong offset!");

// ScriptStruct OPP.ProjectionClueGroup
// 0x0010 (0x0010 - 0x0000)
struct FProjectionClueGroup final
{
public:
	TArray<class FName>                           ClueNames;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectionClueGroup) == 0x000008, "Wrong alignment on FProjectionClueGroup");
static_assert(sizeof(FProjectionClueGroup) == 0x000010, "Wrong size on FProjectionClueGroup");
static_assert(offsetof(FProjectionClueGroup, ClueNames) == 0x000000, "Member 'FProjectionClueGroup::ClueNames' has a wrong offset!");

// ScriptStruct OPP.DetectionClearancePoint
// 0x001C (0x001C - 0x0000)
struct FDetectionClearancePoint final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectionClearancePoint) == 0x000004, "Wrong alignment on FDetectionClearancePoint");
static_assert(sizeof(FDetectionClearancePoint) == 0x00001C, "Wrong size on FDetectionClearancePoint");
static_assert(offsetof(FDetectionClearancePoint, ComponentName) == 0x000000, "Member 'FDetectionClearancePoint::ComponentName' has a wrong offset!");
static_assert(offsetof(FDetectionClearancePoint, BoneName) == 0x000008, "Member 'FDetectionClearancePoint::BoneName' has a wrong offset!");
static_assert(offsetof(FDetectionClearancePoint, RelativeLocation) == 0x000010, "Member 'FDetectionClearancePoint::RelativeLocation' has a wrong offset!");

// ScriptStruct OPP.PushCartRollingGateReplacementInfo
// 0x0038 (0x0038 - 0x0000)
struct FPushCartRollingGateReplacementInfo final
{
public:
	class ARBPushCartSpawner*                     PathOwner;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathSplineIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBSplineMeshActor*                     SplineActor;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineActorOrderedDistanceOnRail;                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBTriggerableGate*                     RollingGate;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPushCartRailBlocker*                 SpawnedCartRailBlocker;                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushCartRollingGateReplacementInfo) == 0x000008, "Wrong alignment on FPushCartRollingGateReplacementInfo");
static_assert(sizeof(FPushCartRollingGateReplacementInfo) == 0x000038, "Wrong size on FPushCartRollingGateReplacementInfo");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, PathOwner) == 0x000000, "Member 'FPushCartRollingGateReplacementInfo::PathOwner' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, PathSplineIndex) == 0x000008, "Member 'FPushCartRollingGateReplacementInfo::PathSplineIndex' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, SplineActor) == 0x000010, "Member 'FPushCartRollingGateReplacementInfo::SplineActor' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, SplineActorOrderedDistanceOnRail) == 0x000018, "Member 'FPushCartRollingGateReplacementInfo::SplineActorOrderedDistanceOnRail' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, Actor) == 0x000020, "Member 'FPushCartRollingGateReplacementInfo::Actor' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, RollingGate) == 0x000028, "Member 'FPushCartRollingGateReplacementInfo::RollingGate' has a wrong offset!");
static_assert(offsetof(FPushCartRollingGateReplacementInfo, SpawnedCartRailBlocker) == 0x000030, "Member 'FPushCartRollingGateReplacementInfo::SpawnedCartRailBlocker' has a wrong offset!");

// ScriptStruct OPP.PushCartInfo
// 0x0020 (0x0020 - 0x0000)
struct FPushCartInfo final
{
public:
	class ARBPushCartSpawner*                     Spawner;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPushCartSpawner*                     Goal;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBBasePushable*                        SpawnedPushable;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathIdx;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRailCart;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPushCartInfo) == 0x000008, "Wrong alignment on FPushCartInfo");
static_assert(sizeof(FPushCartInfo) == 0x000020, "Wrong size on FPushCartInfo");
static_assert(offsetof(FPushCartInfo, Spawner) == 0x000000, "Member 'FPushCartInfo::Spawner' has a wrong offset!");
static_assert(offsetof(FPushCartInfo, Goal) == 0x000008, "Member 'FPushCartInfo::Goal' has a wrong offset!");
static_assert(offsetof(FPushCartInfo, SpawnedPushable) == 0x000010, "Member 'FPushCartInfo::SpawnedPushable' has a wrong offset!");
static_assert(offsetof(FPushCartInfo, PathIdx) == 0x000018, "Member 'FPushCartInfo::PathIdx' has a wrong offset!");
static_assert(offsetof(FPushCartInfo, bIsRailCart) == 0x00001C, "Member 'FPushCartInfo::bIsRailCart' has a wrong offset!");
static_assert(offsetof(FPushCartInfo, bCompleted) == 0x00001D, "Member 'FPushCartInfo::bCompleted' has a wrong offset!");

// ScriptStruct OPP.VORemapTable
// 0x0010 (0x0010 - 0x0000)
struct FVORemapTable final
{
public:
	TArray<struct FVORemapEntry>                  VORemaps;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVORemapTable) == 0x000008, "Wrong alignment on FVORemapTable");
static_assert(sizeof(FVORemapTable) == 0x000010, "Wrong size on FVORemapTable");
static_assert(offsetof(FVORemapTable, VORemaps) == 0x000000, "Member 'FVORemapTable::VORemaps' has a wrong offset!");

// ScriptStruct OPP.PushCartPath
// 0x00A8 (0x00A8 - 0x0000)
struct FPushCartPath final
{
public:
	TSubclassOf<class ARBBasePushable>            PushableClass;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPushCartSpawner*                     PathGoal;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBSplineMeshActor*>             OrderedSplines;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class ARBSplineMeshActor*>             OverlappingSplines;                                // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorToIgnoreCollision;                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DistanceAlongSpline;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  ActorReferenceForDistanceAlongSpline;              // 0x0048(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUseSinglePath;                               // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          ActorsToToggleWhenEnabled;                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorsToUnToggleWhenEnabled;                       // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	class ARBPushCartSpawner*                     PathOwner;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathIndex;                                         // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPushCartPath) == 0x000008, "Wrong alignment on FPushCartPath");
static_assert(sizeof(FPushCartPath) == 0x0000A8, "Wrong size on FPushCartPath");
static_assert(offsetof(FPushCartPath, PushableClass) == 0x000000, "Member 'FPushCartPath::PushableClass' has a wrong offset!");
static_assert(offsetof(FPushCartPath, PathGoal) == 0x000008, "Member 'FPushCartPath::PathGoal' has a wrong offset!");
static_assert(offsetof(FPushCartPath, OrderedSplines) == 0x000010, "Member 'FPushCartPath::OrderedSplines' has a wrong offset!");
static_assert(offsetof(FPushCartPath, OverlappingSplines) == 0x000020, "Member 'FPushCartPath::OverlappingSplines' has a wrong offset!");
static_assert(offsetof(FPushCartPath, ActorToIgnoreCollision) == 0x000030, "Member 'FPushCartPath::ActorToIgnoreCollision' has a wrong offset!");
static_assert(offsetof(FPushCartPath, DistanceAlongSpline) == 0x000040, "Member 'FPushCartPath::DistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(FPushCartPath, ActorReferenceForDistanceAlongSpline) == 0x000048, "Member 'FPushCartPath::ActorReferenceForDistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(FPushCartPath, bForceUseSinglePath) == 0x000070, "Member 'FPushCartPath::bForceUseSinglePath' has a wrong offset!");
static_assert(offsetof(FPushCartPath, ActorsToToggleWhenEnabled) == 0x000078, "Member 'FPushCartPath::ActorsToToggleWhenEnabled' has a wrong offset!");
static_assert(offsetof(FPushCartPath, ActorsToUnToggleWhenEnabled) == 0x000088, "Member 'FPushCartPath::ActorsToUnToggleWhenEnabled' has a wrong offset!");
static_assert(offsetof(FPushCartPath, PathOwner) == 0x000098, "Member 'FPushCartPath::PathOwner' has a wrong offset!");
static_assert(offsetof(FPushCartPath, PathIndex) == 0x0000A0, "Member 'FPushCartPath::PathIndex' has a wrong offset!");

// ScriptStruct OPP.QuestGiverAnimations
// 0x0050 (0x0050 - 0x0000)
struct FQuestGiverAnimations final
{
public:
	class UAnimSequenceBase*                      DefaultIdle;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      InMenuIdle;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FirstTimeEnterMenu;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      EnterMenu;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AccessTaskTab;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AcceptTask;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AccessUpgradeTab;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AccessShopTab;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      BuyUpgrade;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ExitMenu;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestGiverAnimations) == 0x000008, "Wrong alignment on FQuestGiverAnimations");
static_assert(sizeof(FQuestGiverAnimations) == 0x000050, "Wrong size on FQuestGiverAnimations");
static_assert(offsetof(FQuestGiverAnimations, DefaultIdle) == 0x000000, "Member 'FQuestGiverAnimations::DefaultIdle' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, InMenuIdle) == 0x000008, "Member 'FQuestGiverAnimations::InMenuIdle' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, FirstTimeEnterMenu) == 0x000010, "Member 'FQuestGiverAnimations::FirstTimeEnterMenu' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, EnterMenu) == 0x000018, "Member 'FQuestGiverAnimations::EnterMenu' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, AccessTaskTab) == 0x000020, "Member 'FQuestGiverAnimations::AccessTaskTab' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, AcceptTask) == 0x000028, "Member 'FQuestGiverAnimations::AcceptTask' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, AccessUpgradeTab) == 0x000030, "Member 'FQuestGiverAnimations::AccessUpgradeTab' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, AccessShopTab) == 0x000038, "Member 'FQuestGiverAnimations::AccessShopTab' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, BuyUpgrade) == 0x000040, "Member 'FQuestGiverAnimations::BuyUpgrade' has a wrong offset!");
static_assert(offsetof(FQuestGiverAnimations, ExitMenu) == 0x000048, "Member 'FQuestGiverAnimations::ExitMenu' has a wrong offset!");

// ScriptStruct OPP.RailSlider
// 0x0040 (0x0040 - 0x0000)
struct FRailSlider final
{
public:
	class ARBSplineActor*                         InitialMarker;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBSplineActor*                         DestinationMarker;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBSplineActor*>                 MarkerList;                                        // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRailSlider) == 0x000008, "Wrong alignment on FRailSlider");
static_assert(sizeof(FRailSlider) == 0x000040, "Wrong size on FRailSlider");
static_assert(offsetof(FRailSlider, InitialMarker) == 0x000000, "Member 'FRailSlider::InitialMarker' has a wrong offset!");
static_assert(offsetof(FRailSlider, DestinationMarker) == 0x000008, "Member 'FRailSlider::DestinationMarker' has a wrong offset!");
static_assert(offsetof(FRailSlider, MarkerList) == 0x000018, "Member 'FRailSlider::MarkerList' has a wrong offset!");

// ScriptStruct OPP.GlobalRandomValidationInfo
// 0x0050 (0x0050 - 0x0000)
struct FGlobalRandomValidationInfo final
{
public:
	TMap<class ARBAISpawner*, class FString>      AllAISpawners;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlobalRandomValidationInfo) == 0x000008, "Wrong alignment on FGlobalRandomValidationInfo");
static_assert(sizeof(FGlobalRandomValidationInfo) == 0x000050, "Wrong size on FGlobalRandomValidationInfo");
static_assert(offsetof(FGlobalRandomValidationInfo, AllAISpawners) == 0x000000, "Member 'FGlobalRandomValidationInfo::AllAISpawners' has a wrong offset!");

// ScriptStruct OPP.SoloPlayLot
// 0x0010 (0x0010 - 0x0000)
struct FSoloPlayLot final
{
public:
	TArray<TSoftObjectPtr<class AActor>>          SoloOnlyActors;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoloPlayLot) == 0x000008, "Wrong alignment on FSoloPlayLot");
static_assert(sizeof(FSoloPlayLot) == 0x000010, "Wrong size on FSoloPlayLot");
static_assert(offsetof(FSoloPlayLot, SoloOnlyActors) == 0x000000, "Member 'FSoloPlayLot::SoloOnlyActors' has a wrong offset!");

// ScriptStruct OPP.RandomDoorReplacement
// 0x0018 (0x0018 - 0x0000)
struct FRandomDoorReplacement final
{
public:
	float                                         Chance;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveDoorFrame;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ReplaceActorClass;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DoubleDoorReplaceActorClass;                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomDoorReplacement) == 0x000008, "Wrong alignment on FRandomDoorReplacement");
static_assert(sizeof(FRandomDoorReplacement) == 0x000018, "Wrong size on FRandomDoorReplacement");
static_assert(offsetof(FRandomDoorReplacement, Chance) == 0x000000, "Member 'FRandomDoorReplacement::Chance' has a wrong offset!");
static_assert(offsetof(FRandomDoorReplacement, bRemoveDoorFrame) == 0x000004, "Member 'FRandomDoorReplacement::bRemoveDoorFrame' has a wrong offset!");
static_assert(offsetof(FRandomDoorReplacement, ReplaceActorClass) == 0x000008, "Member 'FRandomDoorReplacement::ReplaceActorClass' has a wrong offset!");
static_assert(offsetof(FRandomDoorReplacement, DoubleDoorReplaceActorClass) == 0x000010, "Member 'FRandomDoorReplacement::DoubleDoorReplaceActorClass' has a wrong offset!");

// ScriptStruct OPP.RandomDoorLot
// 0x1628 (0x1628 - 0x0000)
struct FRandomDoorLot final
{
public:
	class FName                                   LotName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBlock : 1;                                        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplace : 1;                                      // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrap : 1;                                         // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Block : 1;                                         // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOpen : 1;                                         // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        RewardRoomCount;                                   // 0x0010(0x0320)(Edit, NativeAccessSpecifierPublic)
	struct FRandomSettings                        TrapRoomCount;                                     // 0x0330(0x0320)(Edit, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          Blockables;                                        // 0x0650(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRandomSettings                        BlockableCount;                                    // 0x0660(0x0320)(Edit, NativeAccessSpecifierPublic)
	struct FRandomSettings                        ReplaceableCount;                                  // 0x0980(0x0320)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FRandomDoorReplacement>         ReplacementsActors;                                // 0x0CA0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRandomSettings                        TrappedCount;                                      // 0x0CB0(0x0320)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBTrapTriggerable>         OverrideTrapLeftActorClass;                        // 0x0FD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBTrapTriggerable>         OverrideTrapRightActorClass;                       // 0x0FD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomSettings                        LockedCount;                                       // 0x0FE0(0x0320)(Edit, NativeAccessSpecifierPublic)
	struct FRandomSettings                        OpenedCount;                                       // 0x1300(0x0320)(Edit, NativeAccessSpecifierPublic)
	int32                                         RandomizerId;                                      // 0x1620(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1624[0x4];                                     // 0x1624(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomDoorLot) == 0x000008, "Wrong alignment on FRandomDoorLot");
static_assert(sizeof(FRandomDoorLot) == 0x001628, "Wrong size on FRandomDoorLot");
static_assert(offsetof(FRandomDoorLot, LotName) == 0x000000, "Member 'FRandomDoorLot::LotName' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, RewardRoomCount) == 0x000010, "Member 'FRandomDoorLot::RewardRoomCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, TrapRoomCount) == 0x000330, "Member 'FRandomDoorLot::TrapRoomCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, Blockables) == 0x000650, "Member 'FRandomDoorLot::Blockables' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, BlockableCount) == 0x000660, "Member 'FRandomDoorLot::BlockableCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, ReplaceableCount) == 0x000980, "Member 'FRandomDoorLot::ReplaceableCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, ReplacementsActors) == 0x000CA0, "Member 'FRandomDoorLot::ReplacementsActors' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, TrappedCount) == 0x000CB0, "Member 'FRandomDoorLot::TrappedCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, OverrideTrapLeftActorClass) == 0x000FD0, "Member 'FRandomDoorLot::OverrideTrapLeftActorClass' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, OverrideTrapRightActorClass) == 0x000FD8, "Member 'FRandomDoorLot::OverrideTrapRightActorClass' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, LockedCount) == 0x000FE0, "Member 'FRandomDoorLot::LockedCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, OpenedCount) == 0x001300, "Member 'FRandomDoorLot::OpenedCount' has a wrong offset!");
static_assert(offsetof(FRandomDoorLot, RandomizerId) == 0x001620, "Member 'FRandomDoorLot::RandomizerId' has a wrong offset!");

// ScriptStruct OPP.PendingRandomState
// 0x0010 (0x0010 - 0x0000)
struct FPendingRandomState final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomStateSetup                             State;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingRandomState) == 0x000008, "Wrong alignment on FPendingRandomState");
static_assert(sizeof(FPendingRandomState) == 0x000010, "Wrong size on FPendingRandomState");
static_assert(offsetof(FPendingRandomState, Actor) == 0x000000, "Member 'FPendingRandomState::Actor' has a wrong offset!");
static_assert(offsetof(FPendingRandomState, State) == 0x000008, "Member 'FPendingRandomState::State' has a wrong offset!");

// ScriptStruct OPP.RandomAIConfigOption
// 0x00E8 (0x00E8 - 0x0000)
struct FRandomAIConfigOption final
{
public:
	class URBAIConfig*                            ConfigAsset;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBPartialAIConfig*>             PartialConfigs;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     Ratio;                                             // 0x0018(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastOption;                                       // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomAIConfigOption) == 0x000008, "Wrong alignment on FRandomAIConfigOption");
static_assert(sizeof(FRandomAIConfigOption) == 0x0000E8, "Wrong size on FRandomAIConfigOption");
static_assert(offsetof(FRandomAIConfigOption, ConfigAsset) == 0x000000, "Member 'FRandomAIConfigOption::ConfigAsset' has a wrong offset!");
static_assert(offsetof(FRandomAIConfigOption, PartialConfigs) == 0x000008, "Member 'FRandomAIConfigOption::PartialConfigs' has a wrong offset!");
static_assert(offsetof(FRandomAIConfigOption, Ratio) == 0x000018, "Member 'FRandomAIConfigOption::Ratio' has a wrong offset!");
static_assert(offsetof(FRandomAIConfigOption, bLastOption) == 0x0000E0, "Member 'FRandomAIConfigOption::bLastOption' has a wrong offset!");

// ScriptStruct OPP.RandomAIScenario
// 0x0278 (0x0278 - 0x0000)
struct FRandomAIScenario final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MinimumCount;                                      // 0x0010(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MaximumCount;                                      // 0x00D8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRandomAIConfigOption>          ConfigOptions;                                     // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     RelativeProbability;                               // 0x01B0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomAIScenario) == 0x000008, "Wrong alignment on FRandomAIScenario");
static_assert(sizeof(FRandomAIScenario) == 0x000278, "Wrong size on FRandomAIScenario");
static_assert(offsetof(FRandomAIScenario, Description) == 0x000000, "Member 'FRandomAIScenario::Description' has a wrong offset!");
static_assert(offsetof(FRandomAIScenario, MinimumCount) == 0x000010, "Member 'FRandomAIScenario::MinimumCount' has a wrong offset!");
static_assert(offsetof(FRandomAIScenario, MaximumCount) == 0x0000D8, "Member 'FRandomAIScenario::MaximumCount' has a wrong offset!");
static_assert(offsetof(FRandomAIScenario, ConfigOptions) == 0x0001A0, "Member 'FRandomAIScenario::ConfigOptions' has a wrong offset!");
static_assert(offsetof(FRandomAIScenario, RelativeProbability) == 0x0001B0, "Member 'FRandomAIScenario::RelativeProbability' has a wrong offset!");

// ScriptStruct OPP.RandomAISetup
// 0x0050 (0x0050 - 0x0000)
struct FRandomAISetup final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          AISpawners;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FRandomAIScenario>              Scenarios;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RandomizerId;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NPCsToActivate;                                    // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomAISetup) == 0x000008, "Wrong alignment on FRandomAISetup");
static_assert(sizeof(FRandomAISetup) == 0x000050, "Wrong size on FRandomAISetup");
static_assert(offsetof(FRandomAISetup, Description) == 0x000000, "Member 'FRandomAISetup::Description' has a wrong offset!");
static_assert(offsetof(FRandomAISetup, bDisabled) == 0x000010, "Member 'FRandomAISetup::bDisabled' has a wrong offset!");
static_assert(offsetof(FRandomAISetup, AISpawners) == 0x000018, "Member 'FRandomAISetup::AISpawners' has a wrong offset!");
static_assert(offsetof(FRandomAISetup, Scenarios) == 0x000028, "Member 'FRandomAISetup::Scenarios' has a wrong offset!");
static_assert(offsetof(FRandomAISetup, RandomizerId) == 0x000038, "Member 'FRandomAISetup::RandomizerId' has a wrong offset!");
static_assert(offsetof(FRandomAISetup, NPCsToActivate) == 0x000040, "Member 'FRandomAISetup::NPCsToActivate' has a wrong offset!");

// ScriptStruct OPP.RandomizationLot
// 0x03C0 (0x03C0 - 0x0000)
struct FRandomizationLot final
{
public:
	class FName                                   LotName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  ConditionalActors;                                 // 0x0008(0x0028)(Edit, RepSkip, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomStateSetup                             ConditionalActorSetup;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          RandomActors;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           RandomActorClasses;                                // 0x0048(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ARBRoomGroup>>    RestrictedSections;                                // 0x0058(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDontChangeIgnoredActors;                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomStateSetup                             BaseState;                                         // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomStateSetup                             DesiredState;                                      // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     MinActivationRatio;                                // 0x0070(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     MaxActivationRatio;                                // 0x0138(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MinActivationCount;                                // 0x0200(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       MaxActivationCount;                                // 0x02C8(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceBetweenActors;                          // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceFromSAS;                                // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomizerId;                                      // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERandomStateSetup>                     RandomActorsStates_Server;                         // 0x03A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         RandomizedActors;                                  // 0x03B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomizationLot) == 0x000008, "Wrong alignment on FRandomizationLot");
static_assert(sizeof(FRandomizationLot) == 0x0003C0, "Wrong size on FRandomizationLot");
static_assert(offsetof(FRandomizationLot, LotName) == 0x000000, "Member 'FRandomizationLot::LotName' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, ConditionalActors) == 0x000008, "Member 'FRandomizationLot::ConditionalActors' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, ConditionalActorSetup) == 0x000030, "Member 'FRandomizationLot::ConditionalActorSetup' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RandomActors) == 0x000038, "Member 'FRandomizationLot::RandomActors' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RandomActorClasses) == 0x000048, "Member 'FRandomizationLot::RandomActorClasses' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RestrictedSections) == 0x000058, "Member 'FRandomizationLot::RestrictedSections' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, bDontChangeIgnoredActors) == 0x000068, "Member 'FRandomizationLot::bDontChangeIgnoredActors' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, BaseState) == 0x000069, "Member 'FRandomizationLot::BaseState' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, DesiredState) == 0x00006A, "Member 'FRandomizationLot::DesiredState' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MinActivationRatio) == 0x000070, "Member 'FRandomizationLot::MinActivationRatio' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MaxActivationRatio) == 0x000138, "Member 'FRandomizationLot::MaxActivationRatio' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MinActivationCount) == 0x000200, "Member 'FRandomizationLot::MinActivationCount' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MaxActivationCount) == 0x0002C8, "Member 'FRandomizationLot::MaxActivationCount' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MinDistanceBetweenActors) == 0x000390, "Member 'FRandomizationLot::MinDistanceBetweenActors' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, MinDistanceFromSAS) == 0x000394, "Member 'FRandomizationLot::MinDistanceFromSAS' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RandomizerId) == 0x000398, "Member 'FRandomizationLot::RandomizerId' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RandomActorsStates_Server) == 0x0003A0, "Member 'FRandomizationLot::RandomActorsStates_Server' has a wrong offset!");
static_assert(offsetof(FRandomizationLot, RandomizedActors) == 0x0003B0, "Member 'FRandomizationLot::RandomizedActors' has a wrong offset!");

// ScriptStruct OPP.RandomScenarioSetup
// 0x0030 (0x0030 - 0x0000)
struct FRandomScenarioSetup final
{
public:
	class FName                                   ScenarioName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestInGame;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEditorActive;                                     // 0x000A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERandomStateSetup>                     RandomActorsSetup;                                 // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ERandomStateSetup>                     RandomActorsStates_Server;                         // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomScenarioSetup) == 0x000008, "Wrong alignment on FRandomScenarioSetup");
static_assert(sizeof(FRandomScenarioSetup) == 0x000030, "Wrong size on FRandomScenarioSetup");
static_assert(offsetof(FRandomScenarioSetup, ScenarioName) == 0x000000, "Member 'FRandomScenarioSetup::ScenarioName' has a wrong offset!");
static_assert(offsetof(FRandomScenarioSetup, bTestInGame) == 0x000008, "Member 'FRandomScenarioSetup::bTestInGame' has a wrong offset!");
static_assert(offsetof(FRandomScenarioSetup, bDisabled) == 0x000009, "Member 'FRandomScenarioSetup::bDisabled' has a wrong offset!");
static_assert(offsetof(FRandomScenarioSetup, bEditorActive) == 0x00000A, "Member 'FRandomScenarioSetup::bEditorActive' has a wrong offset!");
static_assert(offsetof(FRandomScenarioSetup, RandomActorsSetup) == 0x000010, "Member 'FRandomScenarioSetup::RandomActorsSetup' has a wrong offset!");
static_assert(offsetof(FRandomScenarioSetup, RandomActorsStates_Server) == 0x000020, "Member 'FRandomScenarioSetup::RandomActorsStates_Server' has a wrong offset!");

// ScriptStruct OPP.RandomizationGroup
// 0x0050 (0x0050 - 0x0000)
struct FRandomizationGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ConditionalScenariosName;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          RandomActors;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FRandomScenarioSetup>           Scenarios;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActiveScenarioIdx_Server;                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveScenarioIdx_Client;                          // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Debug_ShowActor;                                   // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Debug_ShowActorTimestamp;                          // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomizerId;                                      // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomizationGroup) == 0x000008, "Wrong alignment on FRandomizationGroup");
static_assert(sizeof(FRandomizationGroup) == 0x000050, "Wrong size on FRandomizationGroup");
static_assert(offsetof(FRandomizationGroup, GroupName) == 0x000000, "Member 'FRandomizationGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, ConditionalScenariosName) == 0x000008, "Member 'FRandomizationGroup::ConditionalScenariosName' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, RandomActors) == 0x000018, "Member 'FRandomizationGroup::RandomActors' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, Scenarios) == 0x000028, "Member 'FRandomizationGroup::Scenarios' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, ActiveScenarioIdx_Server) == 0x000038, "Member 'FRandomizationGroup::ActiveScenarioIdx_Server' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, ActiveScenarioIdx_Client) == 0x00003C, "Member 'FRandomizationGroup::ActiveScenarioIdx_Client' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, Debug_ShowActor) == 0x000040, "Member 'FRandomizationGroup::Debug_ShowActor' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, Debug_ShowActorTimestamp) == 0x000048, "Member 'FRandomizationGroup::Debug_ShowActorTimestamp' has a wrong offset!");
static_assert(offsetof(FRandomizationGroup, RandomizerId) == 0x00004C, "Member 'FRandomizationGroup::RandomizerId' has a wrong offset!");

// ScriptStruct OPP.ConditionalScenarioSetup
// 0x0070 (0x0070 - 0x0000)
struct FConditionalScenarioSetup final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  ConditionActor;                                    // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIfStateA;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          RandomActors;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<ERandomStateSetup>                     RandomActorsSetup;                                 // 0x0048(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ERandomStateSetup>                     RandomActorsStates_Server;                         // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         RandomizerId;                                      // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionalScenarioSetup) == 0x000008, "Wrong alignment on FConditionalScenarioSetup");
static_assert(sizeof(FConditionalScenarioSetup) == 0x000070, "Wrong size on FConditionalScenarioSetup");
static_assert(offsetof(FConditionalScenarioSetup, bEnabled) == 0x000000, "Member 'FConditionalScenarioSetup::bEnabled' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, ConditionActor) == 0x000008, "Member 'FConditionalScenarioSetup::ConditionActor' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, bIfStateA) == 0x000030, "Member 'FConditionalScenarioSetup::bIfStateA' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, RandomActors) == 0x000038, "Member 'FConditionalScenarioSetup::RandomActors' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, RandomActorsSetup) == 0x000048, "Member 'FConditionalScenarioSetup::RandomActorsSetup' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, RandomActorsStates_Server) == 0x000058, "Member 'FConditionalScenarioSetup::RandomActorsStates_Server' has a wrong offset!");
static_assert(offsetof(FConditionalScenarioSetup, RandomizerId) == 0x000068, "Member 'FConditionalScenarioSetup::RandomizerId' has a wrong offset!");

// ScriptStruct OPP.RBRandomRewardEntry
// 0x0010 (0x0010 - 0x0000)
struct FRBRandomRewardEntry final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCustomizationRarity                    Rarity;                                            // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBRandomRewardEntry) == 0x000004, "Wrong alignment on FRBRandomRewardEntry");
static_assert(sizeof(FRBRandomRewardEntry) == 0x000010, "Wrong size on FRBRandomRewardEntry");
static_assert(offsetof(FRBRandomRewardEntry, Weight) == 0x000000, "Member 'FRBRandomRewardEntry::Weight' has a wrong offset!");
static_assert(offsetof(FRBRandomRewardEntry, ItemId) == 0x000004, "Member 'FRBRandomRewardEntry::ItemId' has a wrong offset!");
static_assert(offsetof(FRBRandomRewardEntry, Rarity) == 0x00000C, "Member 'FRBRandomRewardEntry::Rarity' has a wrong offset!");

// ScriptStruct OPP.RBRandomRewardPool
// 0x0018 (0x0018 - 0x0000)
struct FRBRandomRewardPool final
{
public:
	class FName                                   RewardPoolId;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRBRandomRewardEntry>           Entries;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBRandomRewardPool) == 0x000008, "Wrong alignment on FRBRandomRewardPool");
static_assert(sizeof(FRBRandomRewardPool) == 0x000018, "Wrong size on FRBRandomRewardPool");
static_assert(offsetof(FRBRandomRewardPool, RewardPoolId) == 0x000000, "Member 'FRBRandomRewardPool::RewardPoolId' has a wrong offset!");
static_assert(offsetof(FRBRandomRewardPool, Entries) == 0x000008, "Member 'FRBRandomRewardPool::Entries' has a wrong offset!");

// ScriptStruct OPP.RepulsionRule
// 0x0030 (0x0030 - 0x0000)
struct FRepulsionRule final
{
public:
	ERepulsionRuleType                            RuleType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RepulsionDirection;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardBlindSpotAngle;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVelocityOverLocation;                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RepulsionCenterRelativeOffset;                     // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERepulsionReactionType                        ReactionType;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERepulsionReactionFilter                      ReactionFilter;                                    // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargettedActors;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepulsionRule) == 0x000008, "Wrong alignment on FRepulsionRule");
static_assert(sizeof(FRepulsionRule) == 0x000030, "Wrong size on FRepulsionRule");
static_assert(offsetof(FRepulsionRule, RuleType) == 0x000000, "Member 'FRepulsionRule::RuleType' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, RepulsionDirection) == 0x000001, "Member 'FRepulsionRule::RepulsionDirection' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, ForwardBlindSpotAngle) == 0x000004, "Member 'FRepulsionRule::ForwardBlindSpotAngle' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, bUseVelocityOverLocation) == 0x000008, "Member 'FRepulsionRule::bUseVelocityOverLocation' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, RepulsionCenterRelativeOffset) == 0x00000C, "Member 'FRepulsionRule::RepulsionCenterRelativeOffset' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, ReactionType) == 0x000018, "Member 'FRepulsionRule::ReactionType' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, ReactionFilter) == 0x000019, "Member 'FRepulsionRule::ReactionFilter' has a wrong offset!");
static_assert(offsetof(FRepulsionRule, TargettedActors) == 0x000020, "Member 'FRepulsionRule::TargettedActors' has a wrong offset!");

// ScriptStruct OPP.RBRewardDataRow
// 0x0098 (0x00A0 - 0x0008)
struct FRBRewardDataRow final : public FTableRowBase
{
public:
	class FString                                 Type;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_murkoffpoint;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_releasetoken;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_EventToken;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_BattlePassToken;                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Currency_BattlePassPremiumToken;                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AcquiredItem1;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AcquiredItem2;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AcquiredItem3;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AcquiredItem4;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AcquiredItem5;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomRewardPoolId1;                               // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomRewardPoolId2;                               // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomRewardPoolId3;                               // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomRewardPoolId4;                               // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomRewardPoolId5;                               // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBRewardDataRow) == 0x000008, "Wrong alignment on FRBRewardDataRow");
static_assert(sizeof(FRBRewardDataRow) == 0x0000A0, "Wrong size on FRBRewardDataRow");
static_assert(offsetof(FRBRewardDataRow, Type) == 0x000008, "Member 'FRBRewardDataRow::Type' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Name) == 0x000018, "Member 'FRBRewardDataRow::Name' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, FeatureSwitch) == 0x000028, "Member 'FRBRewardDataRow::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Xp) == 0x000038, "Member 'FRBRewardDataRow::Xp' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Currency_murkoffpoint) == 0x00003C, "Member 'FRBRewardDataRow::Currency_murkoffpoint' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Currency_releasetoken) == 0x000040, "Member 'FRBRewardDataRow::Currency_releasetoken' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Currency_EventToken) == 0x000044, "Member 'FRBRewardDataRow::Currency_EventToken' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Currency_BattlePassToken) == 0x000048, "Member 'FRBRewardDataRow::Currency_BattlePassToken' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, Currency_BattlePassPremiumToken) == 0x00004C, "Member 'FRBRewardDataRow::Currency_BattlePassPremiumToken' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, AcquiredItem1) == 0x000050, "Member 'FRBRewardDataRow::AcquiredItem1' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, AcquiredItem2) == 0x000058, "Member 'FRBRewardDataRow::AcquiredItem2' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, AcquiredItem3) == 0x000060, "Member 'FRBRewardDataRow::AcquiredItem3' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, AcquiredItem4) == 0x000068, "Member 'FRBRewardDataRow::AcquiredItem4' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, AcquiredItem5) == 0x000070, "Member 'FRBRewardDataRow::AcquiredItem5' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, RandomRewardPoolId1) == 0x000078, "Member 'FRBRewardDataRow::RandomRewardPoolId1' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, RandomRewardPoolId2) == 0x000080, "Member 'FRBRewardDataRow::RandomRewardPoolId2' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, RandomRewardPoolId3) == 0x000088, "Member 'FRBRewardDataRow::RandomRewardPoolId3' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, RandomRewardPoolId4) == 0x000090, "Member 'FRBRewardDataRow::RandomRewardPoolId4' has a wrong offset!");
static_assert(offsetof(FRBRewardDataRow, RandomRewardPoolId5) == 0x000098, "Member 'FRBRewardDataRow::RandomRewardPoolId5' has a wrong offset!");

// ScriptStruct OPP.RoomDetourPathData
// 0x0010 (0x0010 - 0x0000)
struct FRoomDetourPathData final
{
public:
	TArray<class URBRoomConnectorComponent*>      DetourPath;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomDetourPathData) == 0x000008, "Wrong alignment on FRoomDetourPathData");
static_assert(sizeof(FRoomDetourPathData) == 0x000010, "Wrong size on FRoomDetourPathData");
static_assert(offsetof(FRoomDetourPathData, DetourPath) == 0x000000, "Member 'FRoomDetourPathData::DetourPath' has a wrong offset!");

// ScriptStruct OPP.RoomAssociationComponentList
// 0x0010 (0x0010 - 0x0000)
struct FRoomAssociationComponentList final
{
public:
	TArray<class URBRoomAssociationComponent*>    AssociatedComponents;                              // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomAssociationComponentList) == 0x000008, "Wrong alignment on FRoomAssociationComponentList");
static_assert(sizeof(FRoomAssociationComponentList) == 0x000010, "Wrong size on FRoomAssociationComponentList");
static_assert(offsetof(FRoomAssociationComponentList, AssociatedComponents) == 0x000000, "Member 'FRoomAssociationComponentList::AssociatedComponents' has a wrong offset!");

// ScriptStruct OPP.RoomConnection
// 0x0020 (0x0020 - 0x0000)
struct FRoomConnection final
{
public:
	class ARBRoom*                                RoomFrom;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBRoom*                                RoomTo;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBRoomConnectorComponent*              ConnectionComponent;                               // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomConnection) == 0x000008, "Wrong alignment on FRoomConnection");
static_assert(sizeof(FRoomConnection) == 0x000020, "Wrong size on FRoomConnection");
static_assert(offsetof(FRoomConnection, RoomFrom) == 0x000000, "Member 'FRoomConnection::RoomFrom' has a wrong offset!");
static_assert(offsetof(FRoomConnection, RoomTo) == 0x000008, "Member 'FRoomConnection::RoomTo' has a wrong offset!");
static_assert(offsetof(FRoomConnection, ConnectionComponent) == 0x000010, "Member 'FRoomConnection::ConnectionComponent' has a wrong offset!");

// ScriptStruct OPP.SectionAIConfigOverride
// 0x0010 (0x0010 - 0x0000)
struct FSectionAIConfigOverride final
{
public:
	ENPCType                                      NPCType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URBAIConfig*                            Config;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectionAIConfigOverride) == 0x000008, "Wrong alignment on FSectionAIConfigOverride");
static_assert(sizeof(FSectionAIConfigOverride) == 0x000010, "Wrong size on FSectionAIConfigOverride");
static_assert(offsetof(FSectionAIConfigOverride, NPCType) == 0x000000, "Member 'FSectionAIConfigOverride::NPCType' has a wrong offset!");
static_assert(offsetof(FSectionAIConfigOverride, Config) == 0x000008, "Member 'FSectionAIConfigOverride::Config' has a wrong offset!");

// ScriptStruct OPP.RoomGroupConnectionInfo
// 0x0018 (0x0018 - 0x0000)
struct FRoomGroupConnectionInfo final
{
public:
	class ARBRoomGroup*                           ConnectedRoomGroup;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URBRoomConnectorComponent*>      RoomConnectors;                                    // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomGroupConnectionInfo) == 0x000008, "Wrong alignment on FRoomGroupConnectionInfo");
static_assert(sizeof(FRoomGroupConnectionInfo) == 0x000018, "Wrong size on FRoomGroupConnectionInfo");
static_assert(offsetof(FRoomGroupConnectionInfo, ConnectedRoomGroup) == 0x000000, "Member 'FRoomGroupConnectionInfo::ConnectedRoomGroup' has a wrong offset!");
static_assert(offsetof(FRoomGroupConnectionInfo, RoomConnectors) == 0x000008, "Member 'FRoomGroupConnectionInfo::RoomConnectors' has a wrong offset!");

// ScriptStruct OPP.MissionTransitionDirection
// 0x0030 (0x0030 - 0x0000)
struct FMissionTransitionDirection final
{
public:
	ESASTransitionDirection                       TransitionDirection;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeEntrance;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeExit;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBMissionID                           MissionID;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTransitionDirection) == 0x000008, "Wrong alignment on FMissionTransitionDirection");
static_assert(sizeof(FMissionTransitionDirection) == 0x000030, "Wrong size on FMissionTransitionDirection");
static_assert(offsetof(FMissionTransitionDirection, TransitionDirection) == 0x000000, "Member 'FMissionTransitionDirection::TransitionDirection' has a wrong offset!");
static_assert(offsetof(FMissionTransitionDirection, bCanBeEntrance) == 0x000001, "Member 'FMissionTransitionDirection::bCanBeEntrance' has a wrong offset!");
static_assert(offsetof(FMissionTransitionDirection, bCanBeExit) == 0x000002, "Member 'FMissionTransitionDirection::bCanBeExit' has a wrong offset!");
static_assert(offsetof(FMissionTransitionDirection, MissionID) == 0x000008, "Member 'FMissionTransitionDirection::MissionID' has a wrong offset!");

// ScriptStruct OPP.SaveGameInfo
// 0x0030 (0x0030 - 0x0000)
struct FSaveGameInfo final
{
public:
	class URBSaveGameBase*                        SaveGame;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USaveGame>                  SaveGameClass;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameInfo) == 0x000008, "Wrong alignment on FSaveGameInfo");
static_assert(sizeof(FSaveGameInfo) == 0x000030, "Wrong size on FSaveGameInfo");
static_assert(offsetof(FSaveGameInfo, SaveGame) == 0x000000, "Member 'FSaveGameInfo::SaveGame' has a wrong offset!");
static_assert(offsetof(FSaveGameInfo, SaveGameClass) == 0x000008, "Member 'FSaveGameInfo::SaveGameClass' has a wrong offset!");

// ScriptStruct OPP.ScheduledSpawnerSpawnAIData
// 0x1518 (0x1518 - 0x0000)
struct FScheduledSpawnerSpawnAIData final
{
public:
	class ARBAISpawner*                           Spawner;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBNPC>                     PawnClass;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBAIConfig*                            ConfigAsset;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      NPCType;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCFlavor                                    Flavor;                                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBPartialAIConfig*>             AdditionalConfigs;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAIConfigData                          ConfigOverrides;                                   // 0x0030(0x14DC)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150C[0x4];                                     // 0x150C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URBVOMapping*                           VOMappingOverride;                                 // 0x1510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledSpawnerSpawnAIData) == 0x000008, "Wrong alignment on FScheduledSpawnerSpawnAIData");
static_assert(sizeof(FScheduledSpawnerSpawnAIData) == 0x001518, "Wrong size on FScheduledSpawnerSpawnAIData");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, Spawner) == 0x000000, "Member 'FScheduledSpawnerSpawnAIData::Spawner' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, PawnClass) == 0x000008, "Member 'FScheduledSpawnerSpawnAIData::PawnClass' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, ConfigAsset) == 0x000010, "Member 'FScheduledSpawnerSpawnAIData::ConfigAsset' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, NPCType) == 0x000018, "Member 'FScheduledSpawnerSpawnAIData::NPCType' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, Flavor) == 0x000019, "Member 'FScheduledSpawnerSpawnAIData::Flavor' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, AdditionalConfigs) == 0x000020, "Member 'FScheduledSpawnerSpawnAIData::AdditionalConfigs' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, ConfigOverrides) == 0x000030, "Member 'FScheduledSpawnerSpawnAIData::ConfigOverrides' has a wrong offset!");
static_assert(offsetof(FScheduledSpawnerSpawnAIData, VOMappingOverride) == 0x001510, "Member 'FScheduledSpawnerSpawnAIData::VOMappingOverride' has a wrong offset!");

// ScriptStruct OPP.ScheduledTransform
// 0x00C8 (0x0130 - 0x0068)
struct FScheduledTransform final : public FScheduledProperty
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialValue;                                      // 0x0070(0x0030)(Edit, BlueprintVisible, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LastValue;                                         // 0x00A0(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             CurrentValue;                                      // 0x00D0(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             DesiredValue;                                      // 0x0100(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledTransform) == 0x000010, "Wrong alignment on FScheduledTransform");
static_assert(sizeof(FScheduledTransform) == 0x000130, "Wrong size on FScheduledTransform");
static_assert(offsetof(FScheduledTransform, InitialValue) == 0x000070, "Member 'FScheduledTransform::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledTransform, LastValue) == 0x0000A0, "Member 'FScheduledTransform::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledTransform, CurrentValue) == 0x0000D0, "Member 'FScheduledTransform::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledTransform, DesiredValue) == 0x000100, "Member 'FScheduledTransform::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.ScheduledInt8
// 0x0008 (0x0070 - 0x0068)
struct FScheduledInt8 final : public FScheduledProperty
{
public:
	uint8                                         InitialValue;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastValue;                                         // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentValue;                                      // 0x006A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DesiredValue;                                      // 0x006B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledInt8) == 0x000008, "Wrong alignment on FScheduledInt8");
static_assert(sizeof(FScheduledInt8) == 0x000070, "Wrong size on FScheduledInt8");
static_assert(offsetof(FScheduledInt8, InitialValue) == 0x000068, "Member 'FScheduledInt8::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt8, LastValue) == 0x000069, "Member 'FScheduledInt8::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt8, CurrentValue) == 0x00006A, "Member 'FScheduledInt8::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt8, DesiredValue) == 0x00006B, "Member 'FScheduledInt8::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.ScheduledInt
// 0x0010 (0x0078 - 0x0068)
struct FScheduledInt final : public FScheduledProperty
{
public:
	int32                                         InitialValue;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastValue;                                         // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredValue;                                      // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduledInt) == 0x000008, "Wrong alignment on FScheduledInt");
static_assert(sizeof(FScheduledInt) == 0x000078, "Wrong size on FScheduledInt");
static_assert(offsetof(FScheduledInt, InitialValue) == 0x000068, "Member 'FScheduledInt::InitialValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt, LastValue) == 0x00006C, "Member 'FScheduledInt::LastValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt, CurrentValue) == 0x000070, "Member 'FScheduledInt::CurrentValue' has a wrong offset!");
static_assert(offsetof(FScheduledInt, DesiredValue) == 0x000074, "Member 'FScheduledInt::DesiredValue' has a wrong offset!");

// ScriptStruct OPP.ScoringTextValueMapping
// 0x0018 (0x0018 - 0x0000)
struct FScoringTextValueMapping final
{
public:
	float                                         Score;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           DisplayValues;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringTextValueMapping) == 0x000008, "Wrong alignment on FScoringTextValueMapping");
static_assert(sizeof(FScoringTextValueMapping) == 0x000018, "Wrong size on FScoringTextValueMapping");
static_assert(offsetof(FScoringTextValueMapping, Score) == 0x000000, "Member 'FScoringTextValueMapping::Score' has a wrong offset!");
static_assert(offsetof(FScoringTextValueMapping, DisplayValues) == 0x000008, "Member 'FScoringTextValueMapping::DisplayValues' has a wrong offset!");

// ScriptStruct OPP.ScoringDebugInfo
// 0x0010 (0x0010 - 0x0000)
struct FScoringDebugInfo final
{
public:
	TArray<struct FScoringPlayerDebugInfo>        ScoringPlayerDebugInfoList;                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringDebugInfo) == 0x000008, "Wrong alignment on FScoringDebugInfo");
static_assert(sizeof(FScoringDebugInfo) == 0x000010, "Wrong size on FScoringDebugInfo");
static_assert(offsetof(FScoringDebugInfo, ScoringPlayerDebugInfoList) == 0x000000, "Member 'FScoringDebugInfo::ScoringPlayerDebugInfoList' has a wrong offset!");

// ScriptStruct OPP.RBPlayerScoring
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FRBPlayerScoring final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBPlayerScoring) == 0x000008, "Wrong alignment on FRBPlayerScoring");
static_assert(sizeof(FRBPlayerScoring) == 0x000028, "Wrong size on FRBPlayerScoring");

// ScriptStruct OPP.RBScoringRuleRow
// 0x0050 (0x0058 - 0x0008)
struct FRBScoringRuleRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RuleName;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EPlayerEvent>                          PlayerEvents;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Xp;                                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MurkoffDollars;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCountedEvents;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAbsoluteScore;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAbsoluteXp;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAbsoluteMurkoffDollars;                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEventValue;                                    // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSolo;                                       // 0x0055(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayInReport;                                  // 0x0056(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBScoringRuleRow) == 0x000008, "Wrong alignment on FRBScoringRuleRow");
static_assert(sizeof(FRBScoringRuleRow) == 0x000058, "Wrong size on FRBScoringRuleRow");
static_assert(offsetof(FRBScoringRuleRow, ID) == 0x000008, "Member 'FRBScoringRuleRow::ID' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, RuleName) == 0x000010, "Member 'FRBScoringRuleRow::RuleName' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, PlayerEvents) == 0x000028, "Member 'FRBScoringRuleRow::PlayerEvents' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, Score) == 0x000038, "Member 'FRBScoringRuleRow::Score' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, Xp) == 0x00003C, "Member 'FRBScoringRuleRow::Xp' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, MurkoffDollars) == 0x000040, "Member 'FRBScoringRuleRow::MurkoffDollars' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, MaxCountedEvents) == 0x000044, "Member 'FRBScoringRuleRow::MaxCountedEvents' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, MaxAbsoluteScore) == 0x000048, "Member 'FRBScoringRuleRow::MaxAbsoluteScore' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, MaxAbsoluteXp) == 0x00004C, "Member 'FRBScoringRuleRow::MaxAbsoluteXp' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, MaxAbsoluteMurkoffDollars) == 0x000050, "Member 'FRBScoringRuleRow::MaxAbsoluteMurkoffDollars' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, bUseEventValue) == 0x000054, "Member 'FRBScoringRuleRow::bUseEventValue' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, bEnableSolo) == 0x000055, "Member 'FRBScoringRuleRow::bEnableSolo' has a wrong offset!");
static_assert(offsetof(FRBScoringRuleRow, bDisplayInReport) == 0x000056, "Member 'FRBScoringRuleRow::bDisplayInReport' has a wrong offset!");

// ScriptStruct OPP.ScoringStageConfig
// 0x0100 (0x0100 - 0x0000)
struct FScoringStageConfig final
{
public:
	struct FRBStageID                             StageID;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       DefaultTimeToCompleteSeconds;                      // 0x0028(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScoringMissionConfig>          MissionConfigs;                                    // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringStageConfig) == 0x000008, "Wrong alignment on FScoringStageConfig");
static_assert(sizeof(FScoringStageConfig) == 0x000100, "Wrong size on FScoringStageConfig");
static_assert(offsetof(FScoringStageConfig, StageID) == 0x000000, "Member 'FScoringStageConfig::StageID' has a wrong offset!");
static_assert(offsetof(FScoringStageConfig, DefaultTimeToCompleteSeconds) == 0x000028, "Member 'FScoringStageConfig::DefaultTimeToCompleteSeconds' has a wrong offset!");
static_assert(offsetof(FScoringStageConfig, MissionConfigs) == 0x0000F0, "Member 'FScoringStageConfig::MissionConfigs' has a wrong offset!");

// ScriptStruct OPP.AnimBudgetSettings
// 0x0030 (0x0030 - 0x0000)
struct FAnimBudgetSettings final
{
public:
	float                                         PawnAnimOptimCloseDistance;                        // 0x0000(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnAnimOptimMediumDistance;                       // 0x0004(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnAnimOptimFarDistance;                          // 0x0008(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BudgetNumPawnsVeryHigh;                            // 0x000C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BudgetNumPawnsHigh;                                // 0x0010(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowQualityLevelUpgrading;                       // 0x0014(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnAnimOptimHighTickRate;                         // 0x0018(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnAnimOptimMedTickRate;                          // 0x001C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnAnimOptimLowTickRate;                          // 0x0020(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnAnimOptimVeryLowTickRate;                      // 0x0024(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnAnimOptimHighInterpolates;                    // 0x0028(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnAnimOptimMediumInterpolates;                  // 0x0029(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnAnimOptimLowInterpolates;                     // 0x002A(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnAnimOptimVeryLowInterpolates;                 // 0x002B(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnAnimOptimVeryLowPositionUpdateInterval;        // 0x002C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimBudgetSettings) == 0x000004, "Wrong alignment on FAnimBudgetSettings");
static_assert(sizeof(FAnimBudgetSettings) == 0x000030, "Wrong size on FAnimBudgetSettings");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimCloseDistance) == 0x000000, "Member 'FAnimBudgetSettings::PawnAnimOptimCloseDistance' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimMediumDistance) == 0x000004, "Member 'FAnimBudgetSettings::PawnAnimOptimMediumDistance' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimFarDistance) == 0x000008, "Member 'FAnimBudgetSettings::PawnAnimOptimFarDistance' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, BudgetNumPawnsVeryHigh) == 0x00000C, "Member 'FAnimBudgetSettings::BudgetNumPawnsVeryHigh' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, BudgetNumPawnsHigh) == 0x000010, "Member 'FAnimBudgetSettings::BudgetNumPawnsHigh' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, bAllowQualityLevelUpgrading) == 0x000014, "Member 'FAnimBudgetSettings::bAllowQualityLevelUpgrading' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimHighTickRate) == 0x000018, "Member 'FAnimBudgetSettings::PawnAnimOptimHighTickRate' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimMedTickRate) == 0x00001C, "Member 'FAnimBudgetSettings::PawnAnimOptimMedTickRate' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimLowTickRate) == 0x000020, "Member 'FAnimBudgetSettings::PawnAnimOptimLowTickRate' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimVeryLowTickRate) == 0x000024, "Member 'FAnimBudgetSettings::PawnAnimOptimVeryLowTickRate' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, bPawnAnimOptimHighInterpolates) == 0x000028, "Member 'FAnimBudgetSettings::bPawnAnimOptimHighInterpolates' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, bPawnAnimOptimMediumInterpolates) == 0x000029, "Member 'FAnimBudgetSettings::bPawnAnimOptimMediumInterpolates' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, bPawnAnimOptimLowInterpolates) == 0x00002A, "Member 'FAnimBudgetSettings::bPawnAnimOptimLowInterpolates' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, bPawnAnimOptimVeryLowInterpolates) == 0x00002B, "Member 'FAnimBudgetSettings::bPawnAnimOptimVeryLowInterpolates' has a wrong offset!");
static_assert(offsetof(FAnimBudgetSettings, PawnAnimOptimVeryLowPositionUpdateInterval) == 0x00002C, "Member 'FAnimBudgetSettings::PawnAnimOptimVeryLowPositionUpdateInterval' has a wrong offset!");

// ScriptStruct OPP.InvestigationAnalysisSettings
// 0x0028 (0x0028 - 0x0000)
struct FInvestigationAnalysisSettings final
{
public:
	float                                         DistanceInterval;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryYawAngleInterval;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightClearanceAngleInterval;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimAnalysisTimeInterval;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLookRotationSpeed;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLookDuration;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNavClearanceTestDist;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSightClearanceTestDist;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightTraceZOffset;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDistanceIntervalsCount;                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationAnalysisSettings) == 0x000004, "Wrong alignment on FInvestigationAnalysisSettings");
static_assert(sizeof(FInvestigationAnalysisSettings) == 0x000028, "Wrong size on FInvestigationAnalysisSettings");
static_assert(offsetof(FInvestigationAnalysisSettings, DistanceInterval) == 0x000000, "Member 'FInvestigationAnalysisSettings::DistanceInterval' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, EntryYawAngleInterval) == 0x000004, "Member 'FInvestigationAnalysisSettings::EntryYawAngleInterval' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, SightClearanceAngleInterval) == 0x000008, "Member 'FInvestigationAnalysisSettings::SightClearanceAngleInterval' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, AnimAnalysisTimeInterval) == 0x00000C, "Member 'FInvestigationAnalysisSettings::AnimAnalysisTimeInterval' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, MaxLookRotationSpeed) == 0x000010, "Member 'FInvestigationAnalysisSettings::MaxLookRotationSpeed' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, MinimumLookDuration) == 0x000014, "Member 'FInvestigationAnalysisSettings::MinimumLookDuration' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, MaxNavClearanceTestDist) == 0x000018, "Member 'FInvestigationAnalysisSettings::MaxNavClearanceTestDist' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, MaxSightClearanceTestDist) == 0x00001C, "Member 'FInvestigationAnalysisSettings::MaxSightClearanceTestDist' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, SightTraceZOffset) == 0x000020, "Member 'FInvestigationAnalysisSettings::SightTraceZOffset' has a wrong offset!");
static_assert(offsetof(FInvestigationAnalysisSettings, MaxDistanceIntervalsCount) == 0x000024, "Member 'FInvestigationAnalysisSettings::MaxDistanceIntervalsCount' has a wrong offset!");

// ScriptStruct OPP.VoiceChatPlayerAudioEventNames
// 0x0090 (0x0090 - 0x0000)
struct FVoiceChatPlayerAudioEventNames final
{
public:
	class FString                                 StartTalking3DEventName;                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StopTalking3DEventName;                            // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartTalking2DEventName;                           // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StopTalking2DEventName;                            // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartWatchEventName;                               // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StopWatchEventName;                                // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WatchActivationRTPCName;                           // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WatchDistanceRTPCName;                             // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VolumeRTPCName;                                    // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoiceChatPlayerAudioEventNames) == 0x000008, "Wrong alignment on FVoiceChatPlayerAudioEventNames");
static_assert(sizeof(FVoiceChatPlayerAudioEventNames) == 0x000090, "Wrong size on FVoiceChatPlayerAudioEventNames");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StartTalking3DEventName) == 0x000000, "Member 'FVoiceChatPlayerAudioEventNames::StartTalking3DEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StopTalking3DEventName) == 0x000010, "Member 'FVoiceChatPlayerAudioEventNames::StopTalking3DEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StartTalking2DEventName) == 0x000020, "Member 'FVoiceChatPlayerAudioEventNames::StartTalking2DEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StopTalking2DEventName) == 0x000030, "Member 'FVoiceChatPlayerAudioEventNames::StopTalking2DEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StartWatchEventName) == 0x000040, "Member 'FVoiceChatPlayerAudioEventNames::StartWatchEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, StopWatchEventName) == 0x000050, "Member 'FVoiceChatPlayerAudioEventNames::StopWatchEventName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, WatchActivationRTPCName) == 0x000060, "Member 'FVoiceChatPlayerAudioEventNames::WatchActivationRTPCName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, WatchDistanceRTPCName) == 0x000070, "Member 'FVoiceChatPlayerAudioEventNames::WatchDistanceRTPCName' has a wrong offset!");
static_assert(offsetof(FVoiceChatPlayerAudioEventNames, VolumeRTPCName) == 0x000080, "Member 'FVoiceChatPlayerAudioEventNames::VolumeRTPCName' has a wrong offset!");

// ScriptStruct OPP.HazardEffectsConfig
// 0x0088 (0x0088 - 0x0000)
struct FHazardEffectsConfig
{
public:
	EPeriodicHazardType                           HazardType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HazardDelay;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SettingsName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPeriodicHazardPostProcessSettingData> PostProcessSettingsRefs;                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterial>>       PostProcessMaterialRefs;                           // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParamCollectionRef;                        // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MaterialParamCollection;                           // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPeriodicHazardPostProcessSettingData> PostProcessSettings;                               // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      PostProcessMaterials;                              // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHazardEffectsConfig) == 0x000008, "Wrong alignment on FHazardEffectsConfig");
static_assert(sizeof(FHazardEffectsConfig) == 0x000088, "Wrong size on FHazardEffectsConfig");
static_assert(offsetof(FHazardEffectsConfig, HazardType) == 0x000000, "Member 'FHazardEffectsConfig::HazardType' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, HazardDelay) == 0x000004, "Member 'FHazardEffectsConfig::HazardDelay' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, SettingsName) == 0x000008, "Member 'FHazardEffectsConfig::SettingsName' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, PostProcessSettingsRefs) == 0x000010, "Member 'FHazardEffectsConfig::PostProcessSettingsRefs' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, PostProcessMaterialRefs) == 0x000020, "Member 'FHazardEffectsConfig::PostProcessMaterialRefs' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, MaterialParamCollectionRef) == 0x000030, "Member 'FHazardEffectsConfig::MaterialParamCollectionRef' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, MaterialParamCollection) == 0x000060, "Member 'FHazardEffectsConfig::MaterialParamCollection' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, PostProcessSettings) == 0x000068, "Member 'FHazardEffectsConfig::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(FHazardEffectsConfig, PostProcessMaterials) == 0x000078, "Member 'FHazardEffectsConfig::PostProcessMaterials' has a wrong offset!");

// ScriptStruct OPP.FootStepSurfaceModiferData
// 0x0018 (0x0018 - 0x0000)
struct FFootStepSurfaceModiferData final
{
public:
	EFootStepModifierType                         FootstepModifierType;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ModifierName;                                      // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINoiseLoudness;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepLingeringCount;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootStepSurfaceModiferData) == 0x000004, "Wrong alignment on FFootStepSurfaceModiferData");
static_assert(sizeof(FFootStepSurfaceModiferData) == 0x000018, "Wrong size on FFootStepSurfaceModiferData");
static_assert(offsetof(FFootStepSurfaceModiferData, FootstepModifierType) == 0x000000, "Member 'FFootStepSurfaceModiferData::FootstepModifierType' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceModiferData, ModifierName) == 0x000004, "Member 'FFootStepSurfaceModiferData::ModifierName' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceModiferData, AINoiseLoudness) == 0x00000C, "Member 'FFootStepSurfaceModiferData::AINoiseLoudness' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceModiferData, StepLingeringCount) == 0x000010, "Member 'FFootStepSurfaceModiferData::StepLingeringCount' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceModiferData, DebugColor) == 0x000014, "Member 'FFootStepSurfaceModiferData::DebugColor' has a wrong offset!");

// ScriptStruct OPP.FootStepSurfaceData
// 0x0010 (0x0010 - 0x0000)
struct FFootStepSurfaceData final
{
public:
	class FName                                   SurfaceName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINoiseLoudness;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootStepSurfaceData) == 0x000004, "Wrong alignment on FFootStepSurfaceData");
static_assert(sizeof(FFootStepSurfaceData) == 0x000010, "Wrong size on FFootStepSurfaceData");
static_assert(offsetof(FFootStepSurfaceData, SurfaceName) == 0x000000, "Member 'FFootStepSurfaceData::SurfaceName' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceData, AINoiseLoudness) == 0x000008, "Member 'FFootStepSurfaceData::AINoiseLoudness' has a wrong offset!");
static_assert(offsetof(FFootStepSurfaceData, DebugColor) == 0x00000C, "Member 'FFootStepSurfaceData::DebugColor' has a wrong offset!");

// ScriptStruct OPP.HelpUpCameraLimit
// 0x001C (0x001C - 0x0000)
struct FHelpUpCameraLimit final
{
public:
	float                                         MinPitchStart;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchEnd;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYawStart;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawStart;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYawEnd;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawEnd;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelpUpCameraLimit) == 0x000004, "Wrong alignment on FHelpUpCameraLimit");
static_assert(sizeof(FHelpUpCameraLimit) == 0x00001C, "Wrong size on FHelpUpCameraLimit");
static_assert(offsetof(FHelpUpCameraLimit, MinPitchStart) == 0x000000, "Member 'FHelpUpCameraLimit::MinPitchStart' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MinPitchEnd) == 0x000004, "Member 'FHelpUpCameraLimit::MinPitchEnd' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MaxPitch) == 0x000008, "Member 'FHelpUpCameraLimit::MaxPitch' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MinYawStart) == 0x00000C, "Member 'FHelpUpCameraLimit::MinYawStart' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MaxYawStart) == 0x000010, "Member 'FHelpUpCameraLimit::MaxYawStart' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MinYawEnd) == 0x000014, "Member 'FHelpUpCameraLimit::MinYawEnd' has a wrong offset!");
static_assert(offsetof(FHelpUpCameraLimit, MaxYawEnd) == 0x000018, "Member 'FHelpUpCameraLimit::MaxYawEnd' has a wrong offset!");

// ScriptStruct OPP.DifficultyConfig
// 0x00E0 (0x00E0 - 0x0000)
struct FDifficultyConfig final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayNameCAPS;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGameDifficulty                               Difficulty;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Icon;                                              // 0x0050(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         RecommendedPlayerLevel;                            // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDifficultyConfig) == 0x000008, "Wrong alignment on FDifficultyConfig");
static_assert(sizeof(FDifficultyConfig) == 0x0000E0, "Wrong size on FDifficultyConfig");
static_assert(offsetof(FDifficultyConfig, DisplayName) == 0x000000, "Member 'FDifficultyConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(FDifficultyConfig, DisplayNameCAPS) == 0x000018, "Member 'FDifficultyConfig::DisplayNameCAPS' has a wrong offset!");
static_assert(offsetof(FDifficultyConfig, Description) == 0x000030, "Member 'FDifficultyConfig::Description' has a wrong offset!");
static_assert(offsetof(FDifficultyConfig, Difficulty) == 0x000048, "Member 'FDifficultyConfig::Difficulty' has a wrong offset!");
static_assert(offsetof(FDifficultyConfig, Icon) == 0x000050, "Member 'FDifficultyConfig::Icon' has a wrong offset!");
static_assert(offsetof(FDifficultyConfig, RecommendedPlayerLevel) == 0x0000D8, "Member 'FDifficultyConfig::RecommendedPlayerLevel' has a wrong offset!");

// ScriptStruct OPP.UnalterableBinding
// 0x0008 (0x0008 - 0x0000)
struct FUnalterableBinding final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnalterableBinding) == 0x000004, "Wrong alignment on FUnalterableBinding");
static_assert(sizeof(FUnalterableBinding) == 0x000008, "Wrong size on FUnalterableBinding");
static_assert(offsetof(FUnalterableBinding, ActionName) == 0x000000, "Member 'FUnalterableBinding::ActionName' has a wrong offset!");

// ScriptStruct OPP.TrialChainingItemConfig
// 0x00E0 (0x00E0 - 0x0000)
struct FTrialChainingItemConfig final
{
public:
	struct FSoftClassPath                         ItemClassPath;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableInt                       NumberOfItemsToSpawn;                              // 0x0018(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrialChainingItemConfig) == 0x000008, "Wrong alignment on FTrialChainingItemConfig");
static_assert(sizeof(FTrialChainingItemConfig) == 0x0000E0, "Wrong size on FTrialChainingItemConfig");
static_assert(offsetof(FTrialChainingItemConfig, ItemClassPath) == 0x000000, "Member 'FTrialChainingItemConfig::ItemClassPath' has a wrong offset!");
static_assert(offsetof(FTrialChainingItemConfig, NumberOfItemsToSpawn) == 0x000018, "Member 'FTrialChainingItemConfig::NumberOfItemsToSpawn' has a wrong offset!");

// ScriptStruct OPP.PlayerHitReactionSettings
// 0x0050 (0x0050 - 0x0000)
struct FPlayerHitReactionSettings final
{
public:
	TMap<EPlayerHitReactionType, float>           HitReactionsBasedOnAmountOfDamage;                 // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHitReactionSettings) == 0x000008, "Wrong alignment on FPlayerHitReactionSettings");
static_assert(sizeof(FPlayerHitReactionSettings) == 0x000050, "Wrong size on FPlayerHitReactionSettings");
static_assert(offsetof(FPlayerHitReactionSettings, HitReactionsBasedOnAmountOfDamage) == 0x000000, "Member 'FPlayerHitReactionSettings::HitReactionsBasedOnAmountOfDamage' has a wrong offset!");

// ScriptStruct OPP.PawnSpeedSettings
// 0x0030 (0x0030 - 0x0000)
struct FPawnSpeedSettings final
{
public:
	float                                         NormalWalkSpeed;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalRunSpeed;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeed;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchedSpeed;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockedDownSpeed;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargePickupWalkSpeed;                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargePickupRunSpeed;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargePickupSprintSpeed;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargePickupCrouchSpeed;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterMaxSlowDownRatio;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDepthMinSlowDownStart;                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDepthMaxSlowDownStart;                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnSpeedSettings) == 0x000004, "Wrong alignment on FPawnSpeedSettings");
static_assert(sizeof(FPawnSpeedSettings) == 0x000030, "Wrong size on FPawnSpeedSettings");
static_assert(offsetof(FPawnSpeedSettings, NormalWalkSpeed) == 0x000000, "Member 'FPawnSpeedSettings::NormalWalkSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, NormalRunSpeed) == 0x000004, "Member 'FPawnSpeedSettings::NormalRunSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, SprintSpeed) == 0x000008, "Member 'FPawnSpeedSettings::SprintSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, CrouchedSpeed) == 0x00000C, "Member 'FPawnSpeedSettings::CrouchedSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, KnockedDownSpeed) == 0x000010, "Member 'FPawnSpeedSettings::KnockedDownSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, LargePickupWalkSpeed) == 0x000014, "Member 'FPawnSpeedSettings::LargePickupWalkSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, LargePickupRunSpeed) == 0x000018, "Member 'FPawnSpeedSettings::LargePickupRunSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, LargePickupSprintSpeed) == 0x00001C, "Member 'FPawnSpeedSettings::LargePickupSprintSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, LargePickupCrouchSpeed) == 0x000020, "Member 'FPawnSpeedSettings::LargePickupCrouchSpeed' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, WaterMaxSlowDownRatio) == 0x000024, "Member 'FPawnSpeedSettings::WaterMaxSlowDownRatio' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, WaterDepthMinSlowDownStart) == 0x000028, "Member 'FPawnSpeedSettings::WaterDepthMinSlowDownStart' has a wrong offset!");
static_assert(offsetof(FPawnSpeedSettings, WaterDepthMaxSlowDownStart) == 0x00002C, "Member 'FPawnSpeedSettings::WaterDepthMaxSlowDownStart' has a wrong offset!");

// ScriptStruct OPP.ObjectiveZoneInfo
// 0x0040 (0x0040 - 0x0000)
struct FObjectiveZoneInfo final
{
public:
	class ARBZoneDefenceLocation*                 ZoneLocation;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentZoneCompletion;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInZoneInfo>              PlayersInZoneInfos;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CheckpointIndex;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x14];                                      // 0x0028(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTVTurnOn;                                         // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstInteractibleActivated;                       // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveZoneInfo) == 0x000008, "Wrong alignment on FObjectiveZoneInfo");
static_assert(sizeof(FObjectiveZoneInfo) == 0x000040, "Wrong size on FObjectiveZoneInfo");
static_assert(offsetof(FObjectiveZoneInfo, ZoneLocation) == 0x000000, "Member 'FObjectiveZoneInfo::ZoneLocation' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, CurrentZoneCompletion) == 0x000008, "Member 'FObjectiveZoneInfo::CurrentZoneCompletion' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, PlayersInZoneInfos) == 0x000010, "Member 'FObjectiveZoneInfo::PlayersInZoneInfos' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, bCompleted) == 0x000020, "Member 'FObjectiveZoneInfo::bCompleted' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, bActive) == 0x000021, "Member 'FObjectiveZoneInfo::bActive' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, CheckpointIndex) == 0x000024, "Member 'FObjectiveZoneInfo::CheckpointIndex' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, bTVTurnOn) == 0x00003C, "Member 'FObjectiveZoneInfo::bTVTurnOn' has a wrong offset!");
static_assert(offsetof(FObjectiveZoneInfo, bFirstInteractibleActivated) == 0x00003D, "Member 'FObjectiveZoneInfo::bFirstInteractibleActivated' has a wrong offset!");

// ScriptStruct OPP.ShimmerDisplaySettings
// 0x0034 (0x0034 - 0x0000)
struct FShimmerDisplaySettings final
{
public:
	float                                         MinViewAngle;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxViewAngle;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutOffDistance2D;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutOffStartDistance2D;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance2D;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance2D;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownMinDistanceZ;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownMaxDistanceZ;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpMinDistanceZ;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpMaxDistanceZ;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaApproachCoef;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotInFocusMultiplier;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CannotInteractMultiplier;                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShimmerDisplaySettings) == 0x000004, "Wrong alignment on FShimmerDisplaySettings");
static_assert(sizeof(FShimmerDisplaySettings) == 0x000034, "Wrong size on FShimmerDisplaySettings");
static_assert(offsetof(FShimmerDisplaySettings, MinViewAngle) == 0x000000, "Member 'FShimmerDisplaySettings::MinViewAngle' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, MaxViewAngle) == 0x000004, "Member 'FShimmerDisplaySettings::MaxViewAngle' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, CutOffDistance2D) == 0x000008, "Member 'FShimmerDisplaySettings::CutOffDistance2D' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, CutOffStartDistance2D) == 0x00000C, "Member 'FShimmerDisplaySettings::CutOffStartDistance2D' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, MinDistance2D) == 0x000010, "Member 'FShimmerDisplaySettings::MinDistance2D' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, MaxDistance2D) == 0x000014, "Member 'FShimmerDisplaySettings::MaxDistance2D' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, DownMinDistanceZ) == 0x000018, "Member 'FShimmerDisplaySettings::DownMinDistanceZ' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, DownMaxDistanceZ) == 0x00001C, "Member 'FShimmerDisplaySettings::DownMaxDistanceZ' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, UpMinDistanceZ) == 0x000020, "Member 'FShimmerDisplaySettings::UpMinDistanceZ' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, UpMaxDistanceZ) == 0x000024, "Member 'FShimmerDisplaySettings::UpMaxDistanceZ' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, AlphaApproachCoef) == 0x000028, "Member 'FShimmerDisplaySettings::AlphaApproachCoef' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, NotInFocusMultiplier) == 0x00002C, "Member 'FShimmerDisplaySettings::NotInFocusMultiplier' has a wrong offset!");
static_assert(offsetof(FShimmerDisplaySettings, CannotInteractMultiplier) == 0x000030, "Member 'FShimmerDisplaySettings::CannotInteractMultiplier' has a wrong offset!");

// ScriptStruct OPP.DestructibleMaterialDataSettings
// 0x000C (0x000C - 0x0000)
struct FDestructibleMaterialDataSettings final
{
public:
	int32                                         NumberOfWeakHitForDestruction;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfStrongHitForDestruction;                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiHitCount;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleMaterialDataSettings) == 0x000004, "Wrong alignment on FDestructibleMaterialDataSettings");
static_assert(sizeof(FDestructibleMaterialDataSettings) == 0x00000C, "Wrong size on FDestructibleMaterialDataSettings");
static_assert(offsetof(FDestructibleMaterialDataSettings, NumberOfWeakHitForDestruction) == 0x000000, "Member 'FDestructibleMaterialDataSettings::NumberOfWeakHitForDestruction' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialDataSettings, NumberOfStrongHitForDestruction) == 0x000004, "Member 'FDestructibleMaterialDataSettings::NumberOfStrongHitForDestruction' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialDataSettings, MultiHitCount) == 0x000008, "Member 'FDestructibleMaterialDataSettings::MultiHitCount' has a wrong offset!");

// ScriptStruct OPP.DestructibleMaterialSettings
// 0x0048 (0x0048 - 0x0000)
struct FDestructibleMaterialSettings final
{
public:
	struct FDestructibleMaterialDataSettings      PunchSettings;                                     // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialDataSettings      KickSettings;                                      // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialDataSettings      SlashSettings;                                     // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialDataSettings      ChopSettings;                                      // 0x0024(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialDataSettings      LightBluntSettings;                                // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialDataSettings      HeavyBluntSettings;                                // 0x003C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleMaterialSettings) == 0x000004, "Wrong alignment on FDestructibleMaterialSettings");
static_assert(sizeof(FDestructibleMaterialSettings) == 0x000048, "Wrong size on FDestructibleMaterialSettings");
static_assert(offsetof(FDestructibleMaterialSettings, PunchSettings) == 0x000000, "Member 'FDestructibleMaterialSettings::PunchSettings' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialSettings, KickSettings) == 0x00000C, "Member 'FDestructibleMaterialSettings::KickSettings' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialSettings, SlashSettings) == 0x000018, "Member 'FDestructibleMaterialSettings::SlashSettings' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialSettings, ChopSettings) == 0x000024, "Member 'FDestructibleMaterialSettings::ChopSettings' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialSettings, LightBluntSettings) == 0x000030, "Member 'FDestructibleMaterialSettings::LightBluntSettings' has a wrong offset!");
static_assert(offsetof(FDestructibleMaterialSettings, HeavyBluntSettings) == 0x00003C, "Member 'FDestructibleMaterialSettings::HeavyBluntSettings' has a wrong offset!");

// ScriptStruct OPP.DestructiblesSettings
// 0x0120 (0x0120 - 0x0000)
struct FDestructiblesSettings final
{
public:
	struct FDestructibleMaterialSettings          WoodMaterialSettings;                              // 0x0000(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialSettings          WoodenDoorMaterialSettings;                        // 0x0048(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialSettings          ConcreteMaterialSettings;                          // 0x0090(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDestructibleMaterialSettings          MannequinMaterialSettings;                         // 0x00D8(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructiblesSettings) == 0x000004, "Wrong alignment on FDestructiblesSettings");
static_assert(sizeof(FDestructiblesSettings) == 0x000120, "Wrong size on FDestructiblesSettings");
static_assert(offsetof(FDestructiblesSettings, WoodMaterialSettings) == 0x000000, "Member 'FDestructiblesSettings::WoodMaterialSettings' has a wrong offset!");
static_assert(offsetof(FDestructiblesSettings, WoodenDoorMaterialSettings) == 0x000048, "Member 'FDestructiblesSettings::WoodenDoorMaterialSettings' has a wrong offset!");
static_assert(offsetof(FDestructiblesSettings, ConcreteMaterialSettings) == 0x000090, "Member 'FDestructiblesSettings::ConcreteMaterialSettings' has a wrong offset!");
static_assert(offsetof(FDestructiblesSettings, MannequinMaterialSettings) == 0x0000D8, "Member 'FDestructiblesSettings::MannequinMaterialSettings' has a wrong offset!");

// ScriptStruct OPP.PresenceTexts
// 0x0138 (0x0138 - 0x0000)
struct FPresenceTexts final
{
public:
	class FText                                   OtherGame;                                         // 0x0000(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Unknown;                                           // 0x0018(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InMainMenu;                                        // 0x0030(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InTutorial;                                        // 0x0048(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InLobby;                                           // 0x0060(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PreparingExperiment;                               // 0x0078(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InExperiment;                                      // 0x0090(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InUnknownExperiment;                               // 0x00A8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ReturningToLobby;                                  // 0x00C0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FindingParty;                                      // 0x00D8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InSameLobby;                                       // 0x00F0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InSameExperiment;                                  // 0x0108(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InTrialChain;                                      // 0x0120(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresenceTexts) == 0x000008, "Wrong alignment on FPresenceTexts");
static_assert(sizeof(FPresenceTexts) == 0x000138, "Wrong size on FPresenceTexts");
static_assert(offsetof(FPresenceTexts, OtherGame) == 0x000000, "Member 'FPresenceTexts::OtherGame' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, Unknown) == 0x000018, "Member 'FPresenceTexts::Unknown' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InMainMenu) == 0x000030, "Member 'FPresenceTexts::InMainMenu' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InTutorial) == 0x000048, "Member 'FPresenceTexts::InTutorial' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InLobby) == 0x000060, "Member 'FPresenceTexts::InLobby' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, PreparingExperiment) == 0x000078, "Member 'FPresenceTexts::PreparingExperiment' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InExperiment) == 0x000090, "Member 'FPresenceTexts::InExperiment' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InUnknownExperiment) == 0x0000A8, "Member 'FPresenceTexts::InUnknownExperiment' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, ReturningToLobby) == 0x0000C0, "Member 'FPresenceTexts::ReturningToLobby' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, FindingParty) == 0x0000D8, "Member 'FPresenceTexts::FindingParty' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InSameLobby) == 0x0000F0, "Member 'FPresenceTexts::InSameLobby' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InSameExperiment) == 0x000108, "Member 'FPresenceTexts::InSameExperiment' has a wrong offset!");
static_assert(offsetof(FPresenceTexts, InTrialChain) == 0x000120, "Member 'FPresenceTexts::InTrialChain' has a wrong offset!");

// ScriptStruct OPP.OnlineErrorTexts
// 0x0AF0 (0x0AF0 - 0x0000)
struct FOnlineErrorTexts final
{
public:
	class FText                                   InitialConnectionFlowFailed;                       // 0x0000(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InitialConnectionFlowFailed_AgeRestrictionFailure; // 0x0018(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InitialConnectionFlowFailed_RequiredPatchAvailable; // 0x0030(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InitialConnectionFlowFailed_RequiredSystemUpdate;  // 0x0048(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InitialConnectionFlowFailed_OnlinePlayRestricted;  // 0x0060(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToJoinParty;                                 // 0x0078(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToJoinLobby;                                 // 0x0090(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToMigrateToNewLobby;                         // 0x00A8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedGameSessionMigration;                        // 0x00C0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToFindTutorialServer;                        // 0x00D8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToSearchGameSessions;                        // 0x00F0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToJoinGameSession;                           // 0x0108(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   UnableToJoinGameSessionGameNotFullyDownloaded;     // 0x0120(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SoloMode_UnableToJoinGroup;                        // 0x0138(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SoloMode_InviteIgnored;                            // 0x0150(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MatchCanceledDueToError;                           // 0x0168(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FindPartyCanceledDueToError;                       // 0x0180(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToCreateLobbyMatchmakingTicket;              // 0x0198(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedPlacementForParty;                           // 0x01B0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MatchmakingFailed;                                 // 0x01C8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToRequestContacts;                           // 0x01E0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToRequestFriendCode;                         // 0x01F8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToRequestPartyInformation;                   // 0x0210(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToUpdatePartyInformation;                    // 0x0228(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToRequestContactProfile;                     // 0x0240(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToPerformRequestedContactAction;             // 0x0258(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToSendFriendRequest;                         // 0x0270(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   KickedFromServer;                                  // 0x0288(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToGetPlayerData;                             // 0x02A0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MissingPlayPrivilege;                              // 0x02B8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToPurchaseUpgrade;                           // 0x02D0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToUpdatePlayerProgressionData;               // 0x02E8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToUpdatePlayerStatsData;                     // 0x0300(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToUpdateTasks;                               // 0x0318(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToRequestProducts;                           // 0x0330(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedToPurchaseProduct;                           // 0x0348(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PersistentConnectionLost;                          // 0x0360(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DefaultErrorText;                                  // 0x0378(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InitialServerConnectionTimeOutText;                // 0x0390(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionTimeOutText;                       // 0x03A8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionLostText;                          // 0x03C0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedVersionMismatchText;         // 0x03D8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedGameSessionFullText;         // 0x03F0(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedSoloGameSessionFullText;     // 0x0408(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedPlayerSessionRefusedText;    // 0x0420(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedPlayerSessionNotFoundText;   // 0x0438(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ServerConnectionFailedGameEndingText;              // 0x0450(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   IdleKickedErrorText;                               // 0x0468(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ViewLocationErrorKickedText;                       // 0x0480(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PlayerReportReasonsText[0x6];                      // 0x0498(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivilegeValidationError_Until;                    // 0x0528(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivilegeValidationError_Play_TermsOfServiceViolation; // 0x0540(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivilegeValidationError_Play_Unknown;             // 0x0558(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivilegeValidationError_VoiceChat_TermsOfServiceViolation; // 0x0570(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PrivilegeValidationError_VoiceChat_Unknown;        // 0x0588(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EMatchmakingErrorCodes, class FText>     MatchmakingErrorCodeTextMapping;                   // 0x05A0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EPlayerProgressionErrorCodes, class FText> PlayerProgressionErrorCodeTextMapping;             // 0x05F0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EStoreErrorCodes, class FText>           StoreErrorCodeTextMapping;                         // 0x0640(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EPartyErrorCodes, class FText>           PartyErrorCodeTextMapping;                         // 0x0690(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EOnlineCoreErrorCode, class FText>       CoreErrorCodeTextMapping;                          // 0x06E0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EPlatformErrorCodes, class FText>        CorePlatformErrorCodeTextMapping;                  // 0x0730(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EConfigurationErrorCodes, class FText>   CoreConfigurationErrorCodeTextMapping;             // 0x0780(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EAuthErrorCodes, class FText>            CoreAuthErrorCodeTextMapping;                      // 0x07D0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EEntityErrorCodes, class FText>          CoreEntityErrorCodeTextMapping;                    // 0x0820(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ECoreMatchmakingErrorCodes, class FText> CoreMatchmakingErrorCodeTextMapping;               // 0x0870(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EGameServerErrorCodes, class FText>      CoreGameServerErrorCodeTextMapping;                // 0x08C0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ECoreAnalyticsErrorCodes, class FText>   CoreAnalyticsErrorCodeTextMapping;                 // 0x0910(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EInventoryErrorCodes, class FText>       CoreInventoryErrorCodeTextMapping;                 // 0x0960(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ERTAErrorCodes, class FText>             CoreRTAErrorCodeTextMapping;                       // 0x09B0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ERelationshipErrorCodes, class FText>    CoreRelationshipErrorCodeTextMapping;              // 0x0A00(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ECorePartyErrorCodes, class FText>       CorePartyErrorCodeTextMapping;                     // 0x0A50(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ECorePresenceErrorCodes, class FText>    CorePresenceErrorCodeTextMapping;                  // 0x0AA0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOnlineErrorTexts) == 0x000008, "Wrong alignment on FOnlineErrorTexts");
static_assert(sizeof(FOnlineErrorTexts) == 0x000AF0, "Wrong size on FOnlineErrorTexts");
static_assert(offsetof(FOnlineErrorTexts, InitialConnectionFlowFailed) == 0x000000, "Member 'FOnlineErrorTexts::InitialConnectionFlowFailed' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, InitialConnectionFlowFailed_AgeRestrictionFailure) == 0x000018, "Member 'FOnlineErrorTexts::InitialConnectionFlowFailed_AgeRestrictionFailure' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, InitialConnectionFlowFailed_RequiredPatchAvailable) == 0x000030, "Member 'FOnlineErrorTexts::InitialConnectionFlowFailed_RequiredPatchAvailable' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, InitialConnectionFlowFailed_RequiredSystemUpdate) == 0x000048, "Member 'FOnlineErrorTexts::InitialConnectionFlowFailed_RequiredSystemUpdate' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, InitialConnectionFlowFailed_OnlinePlayRestricted) == 0x000060, "Member 'FOnlineErrorTexts::InitialConnectionFlowFailed_OnlinePlayRestricted' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToJoinParty) == 0x000078, "Member 'FOnlineErrorTexts::FailedToJoinParty' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToJoinLobby) == 0x000090, "Member 'FOnlineErrorTexts::FailedToJoinLobby' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToMigrateToNewLobby) == 0x0000A8, "Member 'FOnlineErrorTexts::FailedToMigrateToNewLobby' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedGameSessionMigration) == 0x0000C0, "Member 'FOnlineErrorTexts::FailedGameSessionMigration' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToFindTutorialServer) == 0x0000D8, "Member 'FOnlineErrorTexts::FailedToFindTutorialServer' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToSearchGameSessions) == 0x0000F0, "Member 'FOnlineErrorTexts::FailedToSearchGameSessions' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToJoinGameSession) == 0x000108, "Member 'FOnlineErrorTexts::FailedToJoinGameSession' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, UnableToJoinGameSessionGameNotFullyDownloaded) == 0x000120, "Member 'FOnlineErrorTexts::UnableToJoinGameSessionGameNotFullyDownloaded' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, SoloMode_UnableToJoinGroup) == 0x000138, "Member 'FOnlineErrorTexts::SoloMode_UnableToJoinGroup' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, SoloMode_InviteIgnored) == 0x000150, "Member 'FOnlineErrorTexts::SoloMode_InviteIgnored' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, MatchCanceledDueToError) == 0x000168, "Member 'FOnlineErrorTexts::MatchCanceledDueToError' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FindPartyCanceledDueToError) == 0x000180, "Member 'FOnlineErrorTexts::FindPartyCanceledDueToError' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToCreateLobbyMatchmakingTicket) == 0x000198, "Member 'FOnlineErrorTexts::FailedToCreateLobbyMatchmakingTicket' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedPlacementForParty) == 0x0001B0, "Member 'FOnlineErrorTexts::FailedPlacementForParty' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, MatchmakingFailed) == 0x0001C8, "Member 'FOnlineErrorTexts::MatchmakingFailed' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToRequestContacts) == 0x0001E0, "Member 'FOnlineErrorTexts::FailedToRequestContacts' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToRequestFriendCode) == 0x0001F8, "Member 'FOnlineErrorTexts::FailedToRequestFriendCode' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToRequestPartyInformation) == 0x000210, "Member 'FOnlineErrorTexts::FailedToRequestPartyInformation' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToUpdatePartyInformation) == 0x000228, "Member 'FOnlineErrorTexts::FailedToUpdatePartyInformation' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToRequestContactProfile) == 0x000240, "Member 'FOnlineErrorTexts::FailedToRequestContactProfile' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToPerformRequestedContactAction) == 0x000258, "Member 'FOnlineErrorTexts::FailedToPerformRequestedContactAction' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToSendFriendRequest) == 0x000270, "Member 'FOnlineErrorTexts::FailedToSendFriendRequest' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, KickedFromServer) == 0x000288, "Member 'FOnlineErrorTexts::KickedFromServer' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToGetPlayerData) == 0x0002A0, "Member 'FOnlineErrorTexts::FailedToGetPlayerData' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, MissingPlayPrivilege) == 0x0002B8, "Member 'FOnlineErrorTexts::MissingPlayPrivilege' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToPurchaseUpgrade) == 0x0002D0, "Member 'FOnlineErrorTexts::FailedToPurchaseUpgrade' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToUpdatePlayerProgressionData) == 0x0002E8, "Member 'FOnlineErrorTexts::FailedToUpdatePlayerProgressionData' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToUpdatePlayerStatsData) == 0x000300, "Member 'FOnlineErrorTexts::FailedToUpdatePlayerStatsData' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToUpdateTasks) == 0x000318, "Member 'FOnlineErrorTexts::FailedToUpdateTasks' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToRequestProducts) == 0x000330, "Member 'FOnlineErrorTexts::FailedToRequestProducts' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, FailedToPurchaseProduct) == 0x000348, "Member 'FOnlineErrorTexts::FailedToPurchaseProduct' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PersistentConnectionLost) == 0x000360, "Member 'FOnlineErrorTexts::PersistentConnectionLost' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, DefaultErrorText) == 0x000378, "Member 'FOnlineErrorTexts::DefaultErrorText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, InitialServerConnectionTimeOutText) == 0x000390, "Member 'FOnlineErrorTexts::InitialServerConnectionTimeOutText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionTimeOutText) == 0x0003A8, "Member 'FOnlineErrorTexts::ServerConnectionTimeOutText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionLostText) == 0x0003C0, "Member 'FOnlineErrorTexts::ServerConnectionLostText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedVersionMismatchText) == 0x0003D8, "Member 'FOnlineErrorTexts::ServerConnectionFailedVersionMismatchText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedGameSessionFullText) == 0x0003F0, "Member 'FOnlineErrorTexts::ServerConnectionFailedGameSessionFullText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedSoloGameSessionFullText) == 0x000408, "Member 'FOnlineErrorTexts::ServerConnectionFailedSoloGameSessionFullText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedPlayerSessionRefusedText) == 0x000420, "Member 'FOnlineErrorTexts::ServerConnectionFailedPlayerSessionRefusedText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedPlayerSessionNotFoundText) == 0x000438, "Member 'FOnlineErrorTexts::ServerConnectionFailedPlayerSessionNotFoundText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ServerConnectionFailedGameEndingText) == 0x000450, "Member 'FOnlineErrorTexts::ServerConnectionFailedGameEndingText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, IdleKickedErrorText) == 0x000468, "Member 'FOnlineErrorTexts::IdleKickedErrorText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, ViewLocationErrorKickedText) == 0x000480, "Member 'FOnlineErrorTexts::ViewLocationErrorKickedText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PlayerReportReasonsText) == 0x000498, "Member 'FOnlineErrorTexts::PlayerReportReasonsText' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PrivilegeValidationError_Until) == 0x000528, "Member 'FOnlineErrorTexts::PrivilegeValidationError_Until' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PrivilegeValidationError_Play_TermsOfServiceViolation) == 0x000540, "Member 'FOnlineErrorTexts::PrivilegeValidationError_Play_TermsOfServiceViolation' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PrivilegeValidationError_Play_Unknown) == 0x000558, "Member 'FOnlineErrorTexts::PrivilegeValidationError_Play_Unknown' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PrivilegeValidationError_VoiceChat_TermsOfServiceViolation) == 0x000570, "Member 'FOnlineErrorTexts::PrivilegeValidationError_VoiceChat_TermsOfServiceViolation' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PrivilegeValidationError_VoiceChat_Unknown) == 0x000588, "Member 'FOnlineErrorTexts::PrivilegeValidationError_VoiceChat_Unknown' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, MatchmakingErrorCodeTextMapping) == 0x0005A0, "Member 'FOnlineErrorTexts::MatchmakingErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PlayerProgressionErrorCodeTextMapping) == 0x0005F0, "Member 'FOnlineErrorTexts::PlayerProgressionErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, StoreErrorCodeTextMapping) == 0x000640, "Member 'FOnlineErrorTexts::StoreErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, PartyErrorCodeTextMapping) == 0x000690, "Member 'FOnlineErrorTexts::PartyErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreErrorCodeTextMapping) == 0x0006E0, "Member 'FOnlineErrorTexts::CoreErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CorePlatformErrorCodeTextMapping) == 0x000730, "Member 'FOnlineErrorTexts::CorePlatformErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreConfigurationErrorCodeTextMapping) == 0x000780, "Member 'FOnlineErrorTexts::CoreConfigurationErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreAuthErrorCodeTextMapping) == 0x0007D0, "Member 'FOnlineErrorTexts::CoreAuthErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreEntityErrorCodeTextMapping) == 0x000820, "Member 'FOnlineErrorTexts::CoreEntityErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreMatchmakingErrorCodeTextMapping) == 0x000870, "Member 'FOnlineErrorTexts::CoreMatchmakingErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreGameServerErrorCodeTextMapping) == 0x0008C0, "Member 'FOnlineErrorTexts::CoreGameServerErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreAnalyticsErrorCodeTextMapping) == 0x000910, "Member 'FOnlineErrorTexts::CoreAnalyticsErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreInventoryErrorCodeTextMapping) == 0x000960, "Member 'FOnlineErrorTexts::CoreInventoryErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreRTAErrorCodeTextMapping) == 0x0009B0, "Member 'FOnlineErrorTexts::CoreRTAErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CoreRelationshipErrorCodeTextMapping) == 0x000A00, "Member 'FOnlineErrorTexts::CoreRelationshipErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CorePartyErrorCodeTextMapping) == 0x000A50, "Member 'FOnlineErrorTexts::CorePartyErrorCodeTextMapping' has a wrong offset!");
static_assert(offsetof(FOnlineErrorTexts, CorePresenceErrorCodeTextMapping) == 0x000AA0, "Member 'FOnlineErrorTexts::CorePresenceErrorCodeTextMapping' has a wrong offset!");

// ScriptStruct OPP.PuzzleRoomSection
// 0x00E0 (0x00E0 - 0x0000)
struct FPuzzleRoomSection final
{
public:
	struct FConfigurableInt                       MinimumPuzzleRoomsInSection;                       // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ARBRoom>>         RoomsInSection;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ScheduledRoomsCount;                               // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomID;                                          // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPuzzleRoomSection) == 0x000008, "Wrong alignment on FPuzzleRoomSection");
static_assert(sizeof(FPuzzleRoomSection) == 0x0000E0, "Wrong size on FPuzzleRoomSection");
static_assert(offsetof(FPuzzleRoomSection, MinimumPuzzleRoomsInSection) == 0x000000, "Member 'FPuzzleRoomSection::MinimumPuzzleRoomsInSection' has a wrong offset!");
static_assert(offsetof(FPuzzleRoomSection, RoomsInSection) == 0x0000C8, "Member 'FPuzzleRoomSection::RoomsInSection' has a wrong offset!");
static_assert(offsetof(FPuzzleRoomSection, ScheduledRoomsCount) == 0x0000D8, "Member 'FPuzzleRoomSection::ScheduledRoomsCount' has a wrong offset!");
static_assert(offsetof(FPuzzleRoomSection, RandomID) == 0x0000DC, "Member 'FPuzzleRoomSection::RandomID' has a wrong offset!");

// ScriptStruct OPP.LoopingSoundInfo
// 0x0018 (0x0018 - 0x0000)
struct FLoopingSoundInfo final
{
public:
	class UAkAudioEvent*                          StartEvent;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoopingSoundInfo) == 0x000008, "Wrong alignment on FLoopingSoundInfo");
static_assert(sizeof(FLoopingSoundInfo) == 0x000018, "Wrong size on FLoopingSoundInfo");
static_assert(offsetof(FLoopingSoundInfo, StartEvent) == 0x000000, "Member 'FLoopingSoundInfo::StartEvent' has a wrong offset!");
static_assert(offsetof(FLoopingSoundInfo, StopEvent) == 0x000008, "Member 'FLoopingSoundInfo::StopEvent' has a wrong offset!");

// ScriptStruct OPP.RBWaypointGroupCustomizationProxy
// 0x0008 (0x0008 - 0x0000)
struct FRBWaypointGroupCustomizationProxy final
{
public:
	class ARBWaypointGroup*                       OwnerGroup;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBWaypointGroupCustomizationProxy) == 0x000008, "Wrong alignment on FRBWaypointGroupCustomizationProxy");
static_assert(sizeof(FRBWaypointGroupCustomizationProxy) == 0x000008, "Wrong size on FRBWaypointGroupCustomizationProxy");
static_assert(offsetof(FRBWaypointGroupCustomizationProxy, OwnerGroup) == 0x000000, "Member 'FRBWaypointGroupCustomizationProxy::OwnerGroup' has a wrong offset!");

// ScriptStruct OPP.VirtualizationNode
// 0x0018 (0x0018 - 0x0000)
struct FVirtualizationNode final
{
public:
	class URBSoundConnectorComponent*             Connector;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVirtualizationNode) == 0x000008, "Wrong alignment on FVirtualizationNode");
static_assert(sizeof(FVirtualizationNode) == 0x000018, "Wrong size on FVirtualizationNode");
static_assert(offsetof(FVirtualizationNode, Connector) == 0x000000, "Member 'FVirtualizationNode::Connector' has a wrong offset!");

// ScriptStruct OPP.EmitterDebugInfo
// 0x0090 (0x0090 - 0x0000)
struct FEmitterDebugInfo final
{
public:
	class UAkAuxBus*                              ReverbA;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAuxBus*                              ReverbB;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x68];                                      // 0x0018(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVirtualizationNode>            VirtualizationNodes;                               // 0x0080(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterDebugInfo) == 0x000008, "Wrong alignment on FEmitterDebugInfo");
static_assert(sizeof(FEmitterDebugInfo) == 0x000090, "Wrong size on FEmitterDebugInfo");
static_assert(offsetof(FEmitterDebugInfo, ReverbA) == 0x000000, "Member 'FEmitterDebugInfo::ReverbA' has a wrong offset!");
static_assert(offsetof(FEmitterDebugInfo, ReverbB) == 0x000010, "Member 'FEmitterDebugInfo::ReverbB' has a wrong offset!");
static_assert(offsetof(FEmitterDebugInfo, VirtualizationNodes) == 0x000080, "Member 'FEmitterDebugInfo::VirtualizationNodes' has a wrong offset!");

// ScriptStruct OPP.AuxBusInfo
// 0x0010 (0x0010 - 0x0000)
struct FAuxBusInfo final
{
public:
	class UAkAuxBus*                              Bus;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuxBusInfo) == 0x000008, "Wrong alignment on FAuxBusInfo");
static_assert(sizeof(FAuxBusInfo) == 0x000010, "Wrong size on FAuxBusInfo");
static_assert(offsetof(FAuxBusInfo, Bus) == 0x000000, "Member 'FAuxBusInfo::Bus' has a wrong offset!");

// ScriptStruct OPP.SoundVolumeData
// 0x0020 (0x0020 - 0x0000)
struct FSoundVolumeData final
{
public:
	class ARBSoundVolume*                         SoundVolume;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundVolumeData) == 0x000008, "Wrong alignment on FSoundVolumeData");
static_assert(sizeof(FSoundVolumeData) == 0x000020, "Wrong size on FSoundVolumeData");
static_assert(offsetof(FSoundVolumeData, SoundVolume) == 0x000000, "Member 'FSoundVolumeData::SoundVolume' has a wrong offset!");

// ScriptStruct OPP.RoomPathingSearchResults
// 0x0020 (0x0020 - 0x0000)
struct FRoomPathingSearchResults final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBRoomConnectorComponent*>      Connectors;                                        // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomPathingSearchResults) == 0x000008, "Wrong alignment on FRoomPathingSearchResults");
static_assert(sizeof(FRoomPathingSearchResults) == 0x000020, "Wrong size on FRoomPathingSearchResults");
static_assert(offsetof(FRoomPathingSearchResults, Connectors) == 0x000008, "Member 'FRoomPathingSearchResults::Connectors' has a wrong offset!");

// ScriptStruct OPP.RoomPathingSearchNode
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FRoomPathingSearchNode final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomPathingSearchNode) == 0x000008, "Wrong alignment on FRoomPathingSearchNode");
static_assert(sizeof(FRoomPathingSearchNode) == 0x000028, "Wrong size on FRoomPathingSearchNode");

// ScriptStruct OPP.RoomPathingNode
// 0x0030 (0x0030 - 0x0000)
struct FRoomPathingNode final
{
public:
	class URBRoomConnectorComponent*              Connector;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomPathingNode) == 0x000008, "Wrong alignment on FRoomPathingNode");
static_assert(sizeof(FRoomPathingNode) == 0x000030, "Wrong size on FRoomPathingNode");
static_assert(offsetof(FRoomPathingNode, Connector) == 0x000000, "Member 'FRoomPathingNode::Connector' has a wrong offset!");

// ScriptStruct OPP.RoomPathingConnection
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FRoomPathingConnection final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomPathingConnection) == 0x000008, "Wrong alignment on FRoomPathingConnection");
static_assert(sizeof(FRoomPathingConnection) == 0x000010, "Wrong size on FRoomPathingConnection");

// ScriptStruct OPP.RBTaggedVisionActorServerData
// 0x0010 (0x0010 - 0x0000)
struct FRBTaggedVisionActorServerData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveUntilServerTime;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTaggedVisionActorServerData) == 0x000008, "Wrong alignment on FRBTaggedVisionActorServerData");
static_assert(sizeof(FRBTaggedVisionActorServerData) == 0x000010, "Wrong size on FRBTaggedVisionActorServerData");
static_assert(offsetof(FRBTaggedVisionActorServerData, Actor) == 0x000000, "Member 'FRBTaggedVisionActorServerData::Actor' has a wrong offset!");
static_assert(offsetof(FRBTaggedVisionActorServerData, ActiveUntilServerTime) == 0x000008, "Member 'FRBTaggedVisionActorServerData::ActiveUntilServerTime' has a wrong offset!");

// ScriptStruct OPP.RBTaggedVisionSubMeshData
// 0x0020 (0x0020 - 0x0000)
struct FRBTaggedVisionSubMeshData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             PreviousMaterials;                                 // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UMeshComponent*                         SubMesh;                                           // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTaggedVisionSubMeshData) == 0x000008, "Wrong alignment on FRBTaggedVisionSubMeshData");
static_assert(sizeof(FRBTaggedVisionSubMeshData) == 0x000020, "Wrong size on FRBTaggedVisionSubMeshData");
static_assert(offsetof(FRBTaggedVisionSubMeshData, PreviousMaterials) == 0x000008, "Member 'FRBTaggedVisionSubMeshData::PreviousMaterials' has a wrong offset!");
static_assert(offsetof(FRBTaggedVisionSubMeshData, SubMesh) == 0x000018, "Member 'FRBTaggedVisionSubMeshData::SubMesh' has a wrong offset!");

// ScriptStruct OPP.RBTaggedVisionActorClientData
// 0x0048 (0x0048 - 0x0000)
struct FRBTaggedVisionActorClientData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MainMesh;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 AllActorMeshes;                                    // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FRBTaggedVisionSubMeshData>     OverridenActorMeshesData;                          // 0x0020(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTaggedVisionActorClientData) == 0x000008, "Wrong alignment on FRBTaggedVisionActorClientData");
static_assert(sizeof(FRBTaggedVisionActorClientData) == 0x000048, "Wrong size on FRBTaggedVisionActorClientData");
static_assert(offsetof(FRBTaggedVisionActorClientData, Actor) == 0x000000, "Member 'FRBTaggedVisionActorClientData::Actor' has a wrong offset!");
static_assert(offsetof(FRBTaggedVisionActorClientData, MainMesh) == 0x000008, "Member 'FRBTaggedVisionActorClientData::MainMesh' has a wrong offset!");
static_assert(offsetof(FRBTaggedVisionActorClientData, AllActorMeshes) == 0x000010, "Member 'FRBTaggedVisionActorClientData::AllActorMeshes' has a wrong offset!");
static_assert(offsetof(FRBTaggedVisionActorClientData, OverridenActorMeshesData) == 0x000020, "Member 'FRBTaggedVisionActorClientData::OverridenActorMeshesData' has a wrong offset!");

// ScriptStruct OPP.SplinePositionDescriptor
// 0x0010 (0x0010 - 0x0000)
struct FSplinePositionDescriptor final
{
public:
	class ARBSplineActor*                         SegmentStartMarker;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentRatio;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutsideOffset;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplinePositionDescriptor) == 0x000008, "Wrong alignment on FSplinePositionDescriptor");
static_assert(sizeof(FSplinePositionDescriptor) == 0x000010, "Wrong size on FSplinePositionDescriptor");
static_assert(offsetof(FSplinePositionDescriptor, SegmentStartMarker) == 0x000000, "Member 'FSplinePositionDescriptor::SegmentStartMarker' has a wrong offset!");
static_assert(offsetof(FSplinePositionDescriptor, SegmentRatio) == 0x000008, "Member 'FSplinePositionDescriptor::SegmentRatio' has a wrong offset!");
static_assert(offsetof(FSplinePositionDescriptor, OutsideOffset) == 0x00000C, "Member 'FSplinePositionDescriptor::OutsideOffset' has a wrong offset!");

// ScriptStruct OPP.RBObjectiveGroupID
// 0x0030 (0x0030 - 0x0000)
struct FRBObjectiveGroupID final
{
public:
	class FName                                   GroupID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBMissionID                           MissionID;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBObjectiveGroupID) == 0x000008, "Wrong alignment on FRBObjectiveGroupID");
static_assert(sizeof(FRBObjectiveGroupID) == 0x000030, "Wrong size on FRBObjectiveGroupID");
static_assert(offsetof(FRBObjectiveGroupID, GroupID) == 0x000000, "Member 'FRBObjectiveGroupID::GroupID' has a wrong offset!");
static_assert(offsetof(FRBObjectiveGroupID, MissionID) == 0x000008, "Member 'FRBObjectiveGroupID::MissionID' has a wrong offset!");

// ScriptStruct OPP.RBObjectiveID
// 0x0038 (0x0038 - 0x0000)
struct FRBObjectiveID final
{
public:
	class FName                                   ObjectivelID;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBObjectiveGroupID                    GroupID;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBObjectiveID) == 0x000008, "Wrong alignment on FRBObjectiveID");
static_assert(sizeof(FRBObjectiveID) == 0x000038, "Wrong size on FRBObjectiveID");
static_assert(offsetof(FRBObjectiveID, ObjectivelID) == 0x000000, "Member 'FRBObjectiveID::ObjectivelID' has a wrong offset!");
static_assert(offsetof(FRBObjectiveID, GroupID) == 0x000008, "Member 'FRBObjectiveID::GroupID' has a wrong offset!");

// ScriptStruct OPP.CustomizationMenuCategoryParams
// 0x0020 (0x0020 - 0x0000)
struct FCustomizationMenuCategoryParams final
{
public:
	class FText                                   CategoryName;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationMenuCategoryParams) == 0x000008, "Wrong alignment on FCustomizationMenuCategoryParams");
static_assert(sizeof(FCustomizationMenuCategoryParams) == 0x000020, "Wrong size on FCustomizationMenuCategoryParams");
static_assert(offsetof(FCustomizationMenuCategoryParams, CategoryName) == 0x000000, "Member 'FCustomizationMenuCategoryParams::CategoryName' has a wrong offset!");
static_assert(offsetof(FCustomizationMenuCategoryParams, Icon) == 0x000018, "Member 'FCustomizationMenuCategoryParams::Icon' has a wrong offset!");

// ScriptStruct OPP.StalkingPlayerInfo
// 0x0010 (0x0010 - 0x0000)
struct FStalkingPlayerInfo final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastStalkingTimestamp;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStalkingPlayerInfo) == 0x000008, "Wrong alignment on FStalkingPlayerInfo");
static_assert(sizeof(FStalkingPlayerInfo) == 0x000010, "Wrong size on FStalkingPlayerInfo");
static_assert(offsetof(FStalkingPlayerInfo, Player) == 0x000000, "Member 'FStalkingPlayerInfo::Player' has a wrong offset!");
static_assert(offsetof(FStalkingPlayerInfo, LastStalkingTimestamp) == 0x000008, "Member 'FStalkingPlayerInfo::LastStalkingTimestamp' has a wrong offset!");

// ScriptStruct OPP.StalkerTargetInfo
// 0x0028 (0x0028 - 0x0000)
struct FStalkerTargetInfo final
{
public:
	class ARBNPC*                                 NPC;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBAISpawner*                           Spawner;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStalkingPlayerInfo>            StalkingPlayers;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CompletionMeter;                                   // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStalkerTargetInfo) == 0x000008, "Wrong alignment on FStalkerTargetInfo");
static_assert(sizeof(FStalkerTargetInfo) == 0x000028, "Wrong size on FStalkerTargetInfo");
static_assert(offsetof(FStalkerTargetInfo, NPC) == 0x000000, "Member 'FStalkerTargetInfo::NPC' has a wrong offset!");
static_assert(offsetof(FStalkerTargetInfo, Spawner) == 0x000008, "Member 'FStalkerTargetInfo::Spawner' has a wrong offset!");
static_assert(offsetof(FStalkerTargetInfo, StalkingPlayers) == 0x000010, "Member 'FStalkerTargetInfo::StalkingPlayers' has a wrong offset!");
static_assert(offsetof(FStalkerTargetInfo, CompletionMeter) == 0x000020, "Member 'FStalkerTargetInfo::CompletionMeter' has a wrong offset!");

// ScriptStruct OPP.TargetStreamingState
// 0x0038 (0x0038 - 0x0000)
struct FTargetStreamingState final
{
public:
	TArray<class FName>                           PreloadingLevelNames;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ForcedLevelNames;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CommittedLevelNames;                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bWaitingForCommit;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForMapTransition;                          // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForWorldPopulate;                          // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerPopulated;                                  // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientCanPopulate;                                // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetStreamingState) == 0x000008, "Wrong alignment on FTargetStreamingState");
static_assert(sizeof(FTargetStreamingState) == 0x000038, "Wrong size on FTargetStreamingState");
static_assert(offsetof(FTargetStreamingState, PreloadingLevelNames) == 0x000000, "Member 'FTargetStreamingState::PreloadingLevelNames' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, ForcedLevelNames) == 0x000010, "Member 'FTargetStreamingState::ForcedLevelNames' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, CommittedLevelNames) == 0x000020, "Member 'FTargetStreamingState::CommittedLevelNames' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, bWaitingForCommit) == 0x000030, "Member 'FTargetStreamingState::bWaitingForCommit' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, bWaitingForMapTransition) == 0x000031, "Member 'FTargetStreamingState::bWaitingForMapTransition' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, bWaitingForWorldPopulate) == 0x000032, "Member 'FTargetStreamingState::bWaitingForWorldPopulate' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, bServerPopulated) == 0x000033, "Member 'FTargetStreamingState::bServerPopulated' has a wrong offset!");
static_assert(offsetof(FTargetStreamingState, bClientCanPopulate) == 0x000034, "Member 'FTargetStreamingState::bClientCanPopulate' has a wrong offset!");

// ScriptStruct OPP.SubLevelStreamingStatus
// 0x0020 (0x0020 - 0x0000)
struct FSubLevelStreamingStatus final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StreamingStatus;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentState;                                      // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TargetState;                                       // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFakePersistent;                                   // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUnloaded;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LoadPercentage;                                    // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReattachPercentage;                                // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadTime;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubLevelStreamingStatus) == 0x000008, "Wrong alignment on FSubLevelStreamingStatus");
static_assert(sizeof(FSubLevelStreamingStatus) == 0x000020, "Wrong size on FSubLevelStreamingStatus");
static_assert(offsetof(FSubLevelStreamingStatus, LevelName) == 0x000000, "Member 'FSubLevelStreamingStatus::LevelName' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, StreamingStatus) == 0x000010, "Member 'FSubLevelStreamingStatus::StreamingStatus' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, CurrentState) == 0x000011, "Member 'FSubLevelStreamingStatus::CurrentState' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, TargetState) == 0x000012, "Member 'FSubLevelStreamingStatus::TargetState' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, bFakePersistent) == 0x000013, "Member 'FSubLevelStreamingStatus::bFakePersistent' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, bForceUnloaded) == 0x000014, "Member 'FSubLevelStreamingStatus::bForceUnloaded' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, LoadPercentage) == 0x000015, "Member 'FSubLevelStreamingStatus::LoadPercentage' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, ReattachPercentage) == 0x000016, "Member 'FSubLevelStreamingStatus::ReattachPercentage' has a wrong offset!");
static_assert(offsetof(FSubLevelStreamingStatus, LoadTime) == 0x000018, "Member 'FSubLevelStreamingStatus::LoadTime' has a wrong offset!");

// ScriptStruct OPP.LevelStreamingInfo
// 0x0080 (0x0080 - 0x0000)
struct FLevelStreamingInfo final
{
public:
	struct FTargetStreamingState                  TargetStreamingState;                              // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	bool                                          bWasStreamingStable;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasStreamingReadyToCommit;                        // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasStreamingTargetStateReached;                   // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasWorldPopulatingDone;                           // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PersistentName;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSubLevelStreamingStatus>       StreamingStatus;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CPUTimePct;                                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        UsedPhysicalMemory;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PeakUsedPhysicalMemory;                            // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameTime;                                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelStreamingInfo) == 0x000008, "Wrong alignment on FLevelStreamingInfo");
static_assert(sizeof(FLevelStreamingInfo) == 0x000080, "Wrong size on FLevelStreamingInfo");
static_assert(offsetof(FLevelStreamingInfo, TargetStreamingState) == 0x000000, "Member 'FLevelStreamingInfo::TargetStreamingState' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, bWasStreamingStable) == 0x000038, "Member 'FLevelStreamingInfo::bWasStreamingStable' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, bWasStreamingReadyToCommit) == 0x000039, "Member 'FLevelStreamingInfo::bWasStreamingReadyToCommit' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, bWasStreamingTargetStateReached) == 0x00003A, "Member 'FLevelStreamingInfo::bWasStreamingTargetStateReached' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, bWasWorldPopulatingDone) == 0x00003B, "Member 'FLevelStreamingInfo::bWasWorldPopulatingDone' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, PersistentName) == 0x000040, "Member 'FLevelStreamingInfo::PersistentName' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, StreamingStatus) == 0x000050, "Member 'FLevelStreamingInfo::StreamingStatus' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, CPUTimePct) == 0x000060, "Member 'FLevelStreamingInfo::CPUTimePct' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, UsedPhysicalMemory) == 0x000068, "Member 'FLevelStreamingInfo::UsedPhysicalMemory' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, PeakUsedPhysicalMemory) == 0x000070, "Member 'FLevelStreamingInfo::PeakUsedPhysicalMemory' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, FrameTime) == 0x000078, "Member 'FLevelStreamingInfo::FrameTime' has a wrong offset!");

// ScriptStruct OPP.StroopPlayerMatchData
// 0x000C (0x000C - 0x0000)
struct FStroopPlayerMatchData final
{
public:
	int32                                         ToxicityLevel;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          QuestionAnswered;                                  // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastQuestionSuccess;                               // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Score;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStroopPlayerMatchData) == 0x000004, "Wrong alignment on FStroopPlayerMatchData");
static_assert(sizeof(FStroopPlayerMatchData) == 0x00000C, "Wrong size on FStroopPlayerMatchData");
static_assert(offsetof(FStroopPlayerMatchData, ToxicityLevel) == 0x000000, "Member 'FStroopPlayerMatchData::ToxicityLevel' has a wrong offset!");
static_assert(offsetof(FStroopPlayerMatchData, QuestionAnswered) == 0x000004, "Member 'FStroopPlayerMatchData::QuestionAnswered' has a wrong offset!");
static_assert(offsetof(FStroopPlayerMatchData, LastQuestionSuccess) == 0x000005, "Member 'FStroopPlayerMatchData::LastQuestionSuccess' has a wrong offset!");
static_assert(offsetof(FStroopPlayerMatchData, Score) == 0x000008, "Member 'FStroopPlayerMatchData::Score' has a wrong offset!");

// ScriptStruct OPP.StroopButtonData
// 0x0002 (0x0002 - 0x0000)
struct FStroopButtonData final
{
public:
	EStroopGameColor                              ColorName;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStroopGameColor                              FontColor;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStroopButtonData) == 0x000001, "Wrong alignment on FStroopButtonData");
static_assert(sizeof(FStroopButtonData) == 0x000002, "Wrong size on FStroopButtonData");
static_assert(offsetof(FStroopButtonData, ColorName) == 0x000000, "Member 'FStroopButtonData::ColorName' has a wrong offset!");
static_assert(offsetof(FStroopButtonData, FontColor) == 0x000001, "Member 'FStroopButtonData::FontColor' has a wrong offset!");

// ScriptStruct OPP.EndOfEventInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEndOfEventInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfEventInfo) == 0x000008, "Wrong alignment on FEndOfEventInfo");
static_assert(sizeof(FEndOfEventInfo) == 0x000010, "Wrong size on FEndOfEventInfo");

// ScriptStruct OPP.SwitchMatchLinkData
// 0x0008 (0x0008 - 0x0000)
struct FSwitchMatchLinkData final
{
public:
	int32                                         LinkerIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinkedIndex;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwitchMatchLinkData) == 0x000004, "Wrong alignment on FSwitchMatchLinkData");
static_assert(sizeof(FSwitchMatchLinkData) == 0x000008, "Wrong size on FSwitchMatchLinkData");
static_assert(offsetof(FSwitchMatchLinkData, LinkerIndex) == 0x000000, "Member 'FSwitchMatchLinkData::LinkerIndex' has a wrong offset!");
static_assert(offsetof(FSwitchMatchLinkData, LinkedIndex) == 0x000004, "Member 'FSwitchMatchLinkData::LinkedIndex' has a wrong offset!");

// ScriptStruct OPP.SwitchMatchPuzzleData
// 0x00B0 (0x00B0 - 0x0000)
struct FSwitchMatchPuzzleData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bAvailabilityPerDifficulty;                        // 0x0008(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSwitchMatchLinkData>           Links;                                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemovedSwitches;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 LockedSwitches;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InteractionOrder;                                  // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfInteraction;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwitchMatchPuzzleData) == 0x000008, "Wrong alignment on FSwitchMatchPuzzleData");
static_assert(sizeof(FSwitchMatchPuzzleData) == 0x0000B0, "Wrong size on FSwitchMatchPuzzleData");
static_assert(offsetof(FSwitchMatchPuzzleData, Name) == 0x000000, "Member 'FSwitchMatchPuzzleData::Name' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, bAvailabilityPerDifficulty) == 0x000008, "Member 'FSwitchMatchPuzzleData::bAvailabilityPerDifficulty' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, Links) == 0x000068, "Member 'FSwitchMatchPuzzleData::Links' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, RemovedSwitches) == 0x000078, "Member 'FSwitchMatchPuzzleData::RemovedSwitches' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, LockedSwitches) == 0x000088, "Member 'FSwitchMatchPuzzleData::LockedSwitches' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, InteractionOrder) == 0x000098, "Member 'FSwitchMatchPuzzleData::InteractionOrder' has a wrong offset!");
static_assert(offsetof(FSwitchMatchPuzzleData, MaxNumberOfInteraction) == 0x0000A8, "Member 'FSwitchMatchPuzzleData::MaxNumberOfInteraction' has a wrong offset!");

// ScriptStruct OPP.PlayerActiveTasks
// 0x0210 (0x0210 - 0x0000)
struct FPlayerActiveTasks final
{
public:
	TArray<class URBTaskTrackingEntry*>           ActiveTasks;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x200];                                     // 0x0010(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerActiveTasks) == 0x000008, "Wrong alignment on FPlayerActiveTasks");
static_assert(sizeof(FPlayerActiveTasks) == 0x000210, "Wrong size on FPlayerActiveTasks");
static_assert(offsetof(FPlayerActiveTasks, ActiveTasks) == 0x000000, "Member 'FPlayerActiveTasks::ActiveTasks' has a wrong offset!");

// ScriptStruct OPP.RBTaskMenuEntry
// 0x01F0 (0x01F0 - 0x0000)
struct FRBTaskMenuEntry final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRBTaskDataRow                         Data;                                              // 0x0010(0x01C0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRBTaskProgressionEntry                Progression;                                       // 0x01D0(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTaskMenuEntry) == 0x000008, "Wrong alignment on FRBTaskMenuEntry");
static_assert(sizeof(FRBTaskMenuEntry) == 0x0001F0, "Wrong size on FRBTaskMenuEntry");
static_assert(offsetof(FRBTaskMenuEntry, ID) == 0x000000, "Member 'FRBTaskMenuEntry::ID' has a wrong offset!");
static_assert(offsetof(FRBTaskMenuEntry, Seed) == 0x000008, "Member 'FRBTaskMenuEntry::Seed' has a wrong offset!");
static_assert(offsetof(FRBTaskMenuEntry, Data) == 0x000010, "Member 'FRBTaskMenuEntry::Data' has a wrong offset!");
static_assert(offsetof(FRBTaskMenuEntry, Progression) == 0x0001D0, "Member 'FRBTaskMenuEntry::Progression' has a wrong offset!");

// ScriptStruct OPP.ScheduledBallHit
// 0x0018 (0x0018 - 0x0000)
struct FScheduledBallHit final
{
public:
	class ARBPlayer*                              Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyGameTeam                                Team;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETennisHitType                                HitType;                                           // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldingTime;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitBallAtMove;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackSpin;                                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduledBallHit) == 0x000008, "Wrong alignment on FScheduledBallHit");
static_assert(sizeof(FScheduledBallHit) == 0x000018, "Wrong size on FScheduledBallHit");
static_assert(offsetof(FScheduledBallHit, Player) == 0x000000, "Member 'FScheduledBallHit::Player' has a wrong offset!");
static_assert(offsetof(FScheduledBallHit, Team) == 0x000008, "Member 'FScheduledBallHit::Team' has a wrong offset!");
static_assert(offsetof(FScheduledBallHit, HitType) == 0x000009, "Member 'FScheduledBallHit::HitType' has a wrong offset!");
static_assert(offsetof(FScheduledBallHit, HoldingTime) == 0x00000C, "Member 'FScheduledBallHit::HoldingTime' has a wrong offset!");
static_assert(offsetof(FScheduledBallHit, HitBallAtMove) == 0x000010, "Member 'FScheduledBallHit::HitBallAtMove' has a wrong offset!");
static_assert(offsetof(FScheduledBallHit, bBackSpin) == 0x000014, "Member 'FScheduledBallHit::bBackSpin' has a wrong offset!");

// ScriptStruct OPP.PlayerHitData
// 0x0014 (0x0014 - 0x0000)
struct FPlayerHitData final
{
public:
	bool                                          bIsHolding;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldingStartPawnTimestamp;                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldingStartServerTimestamp;                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastHitTimestamp;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETennisHitType                                HitType;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitData) == 0x000004, "Wrong alignment on FPlayerHitData");
static_assert(sizeof(FPlayerHitData) == 0x000014, "Wrong size on FPlayerHitData");
static_assert(offsetof(FPlayerHitData, bIsHolding) == 0x000000, "Member 'FPlayerHitData::bIsHolding' has a wrong offset!");
static_assert(offsetof(FPlayerHitData, HoldingStartPawnTimestamp) == 0x000004, "Member 'FPlayerHitData::HoldingStartPawnTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerHitData, HoldingStartServerTimestamp) == 0x000008, "Member 'FPlayerHitData::HoldingStartServerTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerHitData, LastHitTimestamp) == 0x00000C, "Member 'FPlayerHitData::LastHitTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerHitData, HitType) == 0x000010, "Member 'FPlayerHitData::HitType' has a wrong offset!");

// ScriptStruct OPP.BallData
// 0x0018 (0x0018 - 0x0000)
struct FBallData final
{
public:
	struct FVector2D                              Location;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Velocity;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimestamp;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBallData) == 0x000004, "Wrong alignment on FBallData");
static_assert(sizeof(FBallData) == 0x000018, "Wrong size on FBallData");
static_assert(offsetof(FBallData, Location) == 0x000000, "Member 'FBallData::Location' has a wrong offset!");
static_assert(offsetof(FBallData, Velocity) == 0x000008, "Member 'FBallData::Velocity' has a wrong offset!");
static_assert(offsetof(FBallData, Move) == 0x000010, "Member 'FBallData::Move' has a wrong offset!");
static_assert(offsetof(FBallData, ServerTimestamp) == 0x000014, "Member 'FBallData::ServerTimestamp' has a wrong offset!");

// ScriptStruct OPP.RBTextChatMessage
// 0x0040 (0x0040 - 0x0000)
struct FRBTextChatMessage final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayerState*                         Source;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERBTextChatType                               TextChatType;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Message;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MessageId;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTextChatMessage) == 0x000008, "Wrong alignment on FRBTextChatMessage");
static_assert(sizeof(FRBTextChatMessage) == 0x000040, "Wrong size on FRBTextChatMessage");
static_assert(offsetof(FRBTextChatMessage, PlayerName) == 0x000000, "Member 'FRBTextChatMessage::PlayerName' has a wrong offset!");
static_assert(offsetof(FRBTextChatMessage, Source) == 0x000010, "Member 'FRBTextChatMessage::Source' has a wrong offset!");
static_assert(offsetof(FRBTextChatMessage, TextChatType) == 0x000018, "Member 'FRBTextChatMessage::TextChatType' has a wrong offset!");
static_assert(offsetof(FRBTextChatMessage, Message) == 0x000020, "Member 'FRBTextChatMessage::Message' has a wrong offset!");
static_assert(offsetof(FRBTextChatMessage, MessageId) == 0x000038, "Member 'FRBTextChatMessage::MessageId' has a wrong offset!");

// ScriptStruct OPP.TortureRoomLinkedPanelInfo
// 0x0010 (0x0010 - 0x0000)
struct FTortureRoomLinkedPanelInfo final
{
public:
	class URBTorturePanelComponent*               Panel;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMeter;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTortureRoomLinkedPanelInfo) == 0x000008, "Wrong alignment on FTortureRoomLinkedPanelInfo");
static_assert(sizeof(FTortureRoomLinkedPanelInfo) == 0x000010, "Wrong size on FTortureRoomLinkedPanelInfo");
static_assert(offsetof(FTortureRoomLinkedPanelInfo, Panel) == 0x000000, "Member 'FTortureRoomLinkedPanelInfo::Panel' has a wrong offset!");
static_assert(offsetof(FTortureRoomLinkedPanelInfo, CurrentMeter) == 0x000008, "Member 'FTortureRoomLinkedPanelInfo::CurrentMeter' has a wrong offset!");
static_assert(offsetof(FTortureRoomLinkedPanelInfo, bCompleted) == 0x00000C, "Member 'FTortureRoomLinkedPanelInfo::bCompleted' has a wrong offset!");

// ScriptStruct OPP.RBTrapScenarioSetup
// 0x0028 (0x0028 - 0x0000)
struct FRBTrapScenarioSetup final
{
public:
	class FName                                   ScenarioName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETrapScenarioState>                    TrapsStates;                                       // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTestInGame;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTrapScenarioSetup) == 0x000008, "Wrong alignment on FRBTrapScenarioSetup");
static_assert(sizeof(FRBTrapScenarioSetup) == 0x000028, "Wrong size on FRBTrapScenarioSetup");
static_assert(offsetof(FRBTrapScenarioSetup, ScenarioName) == 0x000000, "Member 'FRBTrapScenarioSetup::ScenarioName' has a wrong offset!");
static_assert(offsetof(FRBTrapScenarioSetup, bDisabled) == 0x000008, "Member 'FRBTrapScenarioSetup::bDisabled' has a wrong offset!");
static_assert(offsetof(FRBTrapScenarioSetup, TrapsStates) == 0x000010, "Member 'FRBTrapScenarioSetup::TrapsStates' has a wrong offset!");
static_assert(offsetof(FRBTrapScenarioSetup, bTestInGame) == 0x000020, "Member 'FRBTrapScenarioSetup::bTestInGame' has a wrong offset!");

// ScriptStruct OPP.RBTrialChainInfoRow
// 0x0020 (0x0028 - 0x0008)
struct FRBTrialChainInfoRow final : public FTableRowBase
{
public:
	EProgramDifficulty                            ProgramDifficulty;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ForcedVariatorIds;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VariatorPoints;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumVariatorPointValue;                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialChainInfoRow) == 0x000008, "Wrong alignment on FRBTrialChainInfoRow");
static_assert(sizeof(FRBTrialChainInfoRow) == 0x000028, "Wrong size on FRBTrialChainInfoRow");
static_assert(offsetof(FRBTrialChainInfoRow, ProgramDifficulty) == 0x000008, "Member 'FRBTrialChainInfoRow::ProgramDifficulty' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfoRow, ForcedVariatorIds) == 0x000010, "Member 'FRBTrialChainInfoRow::ForcedVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfoRow, VariatorPoints) == 0x000020, "Member 'FRBTrialChainInfoRow::VariatorPoints' has a wrong offset!");
static_assert(offsetof(FRBTrialChainInfoRow, MinimumVariatorPointValue) == 0x000024, "Member 'FRBTrialChainInfoRow::MinimumVariatorPointValue' has a wrong offset!");

// ScriptStruct OPP.RBTrialInfoRow
// 0x00E0 (0x00E8 - 0x0008)
struct FRBTrialInfoRow final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMajor;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Poster;                                            // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Banner;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StageID;                                           // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionID;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayerCount;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VariatorIds;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BlacklistedVariatorIds;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 FeatureSwitch;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomTrialId;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBTrialInfoRow) == 0x000008, "Wrong alignment on FRBTrialInfoRow");
static_assert(sizeof(FRBTrialInfoRow) == 0x0000E8, "Wrong size on FRBTrialInfoRow");
static_assert(offsetof(FRBTrialInfoRow, ID) == 0x000008, "Member 'FRBTrialInfoRow::ID' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, bMajor) == 0x000010, "Member 'FRBTrialInfoRow::bMajor' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, DisplayName) == 0x000018, "Member 'FRBTrialInfoRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, Description) == 0x000030, "Member 'FRBTrialInfoRow::Description' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, Poster) == 0x000048, "Member 'FRBTrialInfoRow::Poster' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, Banner) == 0x000070, "Member 'FRBTrialInfoRow::Banner' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, StageID) == 0x000098, "Member 'FRBTrialInfoRow::StageID' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, MissionID) == 0x0000A0, "Member 'FRBTrialInfoRow::MissionID' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, MinPlayerCount) == 0x0000A8, "Member 'FRBTrialInfoRow::MinPlayerCount' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, VariatorIds) == 0x0000B0, "Member 'FRBTrialInfoRow::VariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, BlacklistedVariatorIds) == 0x0000C0, "Member 'FRBTrialInfoRow::BlacklistedVariatorIds' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, FeatureSwitch) == 0x0000D0, "Member 'FRBTrialInfoRow::FeatureSwitch' has a wrong offset!");
static_assert(offsetof(FRBTrialInfoRow, CustomTrialId) == 0x0000E0, "Member 'FRBTrialInfoRow::CustomTrialId' has a wrong offset!");

// ScriptStruct OPP.MazeSectionConfigData
// 0x1618 (0x1618 - 0x0000)
struct FMazeSectionConfigData final
{
public:
	struct FRandomSettings                        RollingGateRandomizationBlockedCount;              // 0x0000(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_RollingGateRandomizationBlockedCount : 1; // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DoorRandomizationBlockedCount;                     // 0x0328(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorRandomizationBlockedCount : 1;       // 0x0648(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        BlockableRandomizationBlockedCount;                // 0x0650(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_BlockableRandomizationBlockedCount : 1;  // 0x0970(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DoorRandomizationReplacedCount;                    // 0x0978(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorRandomizationReplacedCount : 1;      // 0x0C98(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C99[0x7];                                      // 0x0C99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DoorRandomizationTrappedCount;                     // 0x0CA0(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorRandomizationTrappedCount : 1;       // 0x0FC0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FC1[0x7];                                      // 0x0FC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DoorRandomizationLockedCount;                      // 0x0FC8(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorRandomizationLockedCount : 1;        // 0x12E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12E9[0x7];                                     // 0x12E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        DoorRandomizationOpenCount;                        // 0x12F0(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DoorRandomizationOpenCount : 1;          // 0x1610(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1611[0x7];                                     // 0x1611(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMazeSectionConfigData) == 0x000008, "Wrong alignment on FMazeSectionConfigData");
static_assert(sizeof(FMazeSectionConfigData) == 0x001618, "Wrong size on FMazeSectionConfigData");
static_assert(offsetof(FMazeSectionConfigData, RollingGateRandomizationBlockedCount) == 0x000000, "Member 'FMazeSectionConfigData::RollingGateRandomizationBlockedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, DoorRandomizationBlockedCount) == 0x000328, "Member 'FMazeSectionConfigData::DoorRandomizationBlockedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, BlockableRandomizationBlockedCount) == 0x000650, "Member 'FMazeSectionConfigData::BlockableRandomizationBlockedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, DoorRandomizationReplacedCount) == 0x000978, "Member 'FMazeSectionConfigData::DoorRandomizationReplacedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, DoorRandomizationTrappedCount) == 0x000CA0, "Member 'FMazeSectionConfigData::DoorRandomizationTrappedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, DoorRandomizationLockedCount) == 0x000FC8, "Member 'FMazeSectionConfigData::DoorRandomizationLockedCount' has a wrong offset!");
static_assert(offsetof(FMazeSectionConfigData, DoorRandomizationOpenCount) == 0x0012F0, "Member 'FMazeSectionConfigData::DoorRandomizationOpenCount' has a wrong offset!");

// ScriptStruct OPP.HidespotSectionConfigData
// 0x00D0 (0x00D0 - 0x0000)
struct FHidespotSectionConfigData final
{
public:
	struct FConfigurableFloat                     HidespotRandomization_DisabledRatio;               // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HidespotRandomization_DisabledRatio : 1; // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHidespotSectionConfigData) == 0x000008, "Wrong alignment on FHidespotSectionConfigData");
static_assert(sizeof(FHidespotSectionConfigData) == 0x0000D0, "Wrong size on FHidespotSectionConfigData");
static_assert(offsetof(FHidespotSectionConfigData, HidespotRandomization_DisabledRatio) == 0x000000, "Member 'FHidespotSectionConfigData::HidespotRandomization_DisabledRatio' has a wrong offset!");

// ScriptStruct OPP.TrapSpacingData
// 0x04E0 (0x04E0 - 0x0000)
struct FTrapSpacingData final
{
public:
	struct FConfigurableFloat                     TrapSpacingDistance;                               // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TrapSpacingDistance : 1;                 // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     SoundTrapToSoundTrapSpacingDistance;               // 0x00D0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SoundTrapToSoundTrapSpacingDistance : 1; // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     ExplosiveTrapToExplosiveTrapSpacingDistance;       // 0x01A0(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplosiveTrapToExplosiveTrapSpacingDistance : 1; // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     ElectricFloorTrapToElectricFloorTrapSpacingDistance; // 0x0270(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ElectricFloorTrapToElectricFloorTrapSpacingDistance : 1; // 0x0338(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     PsychosisMineTrapCountToPsychosisMineTrapCountSpacingDistance; // 0x0340(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PsychosisMineTrapCountToPsychosisMineTrapCountSpacingDistance : 1; // 0x0408(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     ExplosiveWireTrapsToExplosiveWireTrapsSpacingDistance; // 0x0410(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplosiveWireTrapsToExplosiveWireTrapsSpacingDistance : 1; // 0x04D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrapSpacingData) == 0x000008, "Wrong alignment on FTrapSpacingData");
static_assert(sizeof(FTrapSpacingData) == 0x0004E0, "Wrong size on FTrapSpacingData");
static_assert(offsetof(FTrapSpacingData, TrapSpacingDistance) == 0x000000, "Member 'FTrapSpacingData::TrapSpacingDistance' has a wrong offset!");
static_assert(offsetof(FTrapSpacingData, SoundTrapToSoundTrapSpacingDistance) == 0x0000D0, "Member 'FTrapSpacingData::SoundTrapToSoundTrapSpacingDistance' has a wrong offset!");
static_assert(offsetof(FTrapSpacingData, ExplosiveTrapToExplosiveTrapSpacingDistance) == 0x0001A0, "Member 'FTrapSpacingData::ExplosiveTrapToExplosiveTrapSpacingDistance' has a wrong offset!");
static_assert(offsetof(FTrapSpacingData, ElectricFloorTrapToElectricFloorTrapSpacingDistance) == 0x000270, "Member 'FTrapSpacingData::ElectricFloorTrapToElectricFloorTrapSpacingDistance' has a wrong offset!");
static_assert(offsetof(FTrapSpacingData, PsychosisMineTrapCountToPsychosisMineTrapCountSpacingDistance) == 0x000340, "Member 'FTrapSpacingData::PsychosisMineTrapCountToPsychosisMineTrapCountSpacingDistance' has a wrong offset!");
static_assert(offsetof(FTrapSpacingData, ExplosiveWireTrapsToExplosiveWireTrapsSpacingDistance) == 0x000410, "Member 'FTrapSpacingData::ExplosiveWireTrapsToExplosiveWireTrapsSpacingDistance' has a wrong offset!");

// ScriptStruct OPP.TrapSectionConfigData
// 0x17D8 (0x17D8 - 0x0000)
struct FTrapSectionConfigData final
{
public:
	struct FTrapSpacingData                       TrapSpacingData;                                   // 0x0000(0x04E0)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TrapSpacingData : 1;                     // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        TrapGroupCount;                                    // 0x04E8(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TrapGroupCount : 1;                      // 0x0808(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        SoundTrapCount;                                    // 0x0810(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_SoundTrapCount : 1;                      // 0x0B30(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B31[0x7];                                      // 0x0B31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        ExplosiveTrapCount;                                // 0x0B38(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplosiveTrapCount : 1;                  // 0x0E58(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bOnlyUseStagePrimeAssetRelatedTraps;               // 0x0E59(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_bOnlyUseStagePrimeAssetRelatedTraps : 1; // 0x0E5A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5B[0x5];                                      // 0x0E5B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        ElectricFloorTrapCount;                            // 0x0E60(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ElectricFloorTrapCount : 1;              // 0x1180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1181[0x7];                                     // 0x1181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        PsychosisMineTrapCount;                            // 0x1188(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PsychosisMineTrapCount : 1;              // 0x14A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14A9[0x7];                                     // 0x14A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomSettings                        ExplosiveWireTrapsCount;                           // 0x14B0(0x0320)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverride_ExplosiveWireTrapsCount : 1;             // 0x17D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D1[0x7];                                     // 0x17D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrapSectionConfigData) == 0x000008, "Wrong alignment on FTrapSectionConfigData");
static_assert(sizeof(FTrapSectionConfigData) == 0x0017D8, "Wrong size on FTrapSectionConfigData");
static_assert(offsetof(FTrapSectionConfigData, TrapSpacingData) == 0x000000, "Member 'FTrapSectionConfigData::TrapSpacingData' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, TrapGroupCount) == 0x0004E8, "Member 'FTrapSectionConfigData::TrapGroupCount' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, SoundTrapCount) == 0x000810, "Member 'FTrapSectionConfigData::SoundTrapCount' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, ExplosiveTrapCount) == 0x000B38, "Member 'FTrapSectionConfigData::ExplosiveTrapCount' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, bOnlyUseStagePrimeAssetRelatedTraps) == 0x000E59, "Member 'FTrapSectionConfigData::bOnlyUseStagePrimeAssetRelatedTraps' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, ElectricFloorTrapCount) == 0x000E60, "Member 'FTrapSectionConfigData::ElectricFloorTrapCount' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, PsychosisMineTrapCount) == 0x001188, "Member 'FTrapSectionConfigData::PsychosisMineTrapCount' has a wrong offset!");
static_assert(offsetof(FTrapSectionConfigData, ExplosiveWireTrapsCount) == 0x0014B0, "Member 'FTrapSectionConfigData::ExplosiveWireTrapsCount' has a wrong offset!");

// ScriptStruct OPP.RBTrialSectionConfigData
// 0x2EC0 (0x2EC0 - 0x0000)
struct FRBTrialSectionConfigData final
{
public:
	struct FMazeSectionConfigData                 MazeData;                                          // 0x0000(0x1618)(Edit, NativeAccessSpecifierPublic)
	struct FHidespotSectionConfigData             HidespotData;                                      // 0x1618(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FTrapSectionConfigData                 TrapData;                                          // 0x16E8(0x17D8)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRBTrialSectionConfigData) == 0x000008, "Wrong alignment on FRBTrialSectionConfigData");
static_assert(sizeof(FRBTrialSectionConfigData) == 0x002EC0, "Wrong size on FRBTrialSectionConfigData");
static_assert(offsetof(FRBTrialSectionConfigData, MazeData) == 0x000000, "Member 'FRBTrialSectionConfigData::MazeData' has a wrong offset!");
static_assert(offsetof(FRBTrialSectionConfigData, HidespotData) == 0x001618, "Member 'FRBTrialSectionConfigData::HidespotData' has a wrong offset!");
static_assert(offsetof(FRBTrialSectionConfigData, TrapData) == 0x0016E8, "Member 'FRBTrialSectionConfigData::TrapData' has a wrong offset!");

// ScriptStruct OPP.TriggerableSetting
// 0x0088 (0x0088 - 0x0000)
struct FTriggerableSetting final
{
public:
	class ARBOperatable*                          Operatable;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  RBOperatable;                                      // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRBComponentSelector                   LinkedOperatable;                                  // 0x0030(0x0040)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TriggerActivationRatio;                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOverrideOperatorAction                       OverrideOperationAction;                           // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OrGroup;                                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriggerableSetting) == 0x000008, "Wrong alignment on FTriggerableSetting");
static_assert(sizeof(FTriggerableSetting) == 0x000088, "Wrong size on FTriggerableSetting");
static_assert(offsetof(FTriggerableSetting, Operatable) == 0x000000, "Member 'FTriggerableSetting::Operatable' has a wrong offset!");
static_assert(offsetof(FTriggerableSetting, RBOperatable) == 0x000008, "Member 'FTriggerableSetting::RBOperatable' has a wrong offset!");
static_assert(offsetof(FTriggerableSetting, LinkedOperatable) == 0x000030, "Member 'FTriggerableSetting::LinkedOperatable' has a wrong offset!");
static_assert(offsetof(FTriggerableSetting, TriggerActivationRatio) == 0x000070, "Member 'FTriggerableSetting::TriggerActivationRatio' has a wrong offset!");
static_assert(offsetof(FTriggerableSetting, OverrideOperationAction) == 0x000074, "Member 'FTriggerableSetting::OverrideOperationAction' has a wrong offset!");
static_assert(offsetof(FTriggerableSetting, OrGroup) == 0x000078, "Member 'FTriggerableSetting::OrGroup' has a wrong offset!");

// ScriptStruct OPP.TriggerableSettingGroup
// 0x0010 (0x0010 - 0x0000)
struct FTriggerableSettingGroup final
{
public:
	TArray<struct FTriggerableSetting>            TriggerableSettingGroup;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerableSettingGroup) == 0x000008, "Wrong alignment on FTriggerableSettingGroup");
static_assert(sizeof(FTriggerableSettingGroup) == 0x000010, "Wrong size on FTriggerableSettingGroup");
static_assert(offsetof(FTriggerableSettingGroup, TriggerableSettingGroup) == 0x000000, "Member 'FTriggerableSettingGroup::TriggerableSettingGroup' has a wrong offset!");

// ScriptStruct OPP.TutorialTextData
// 0x0020 (0x0020 - 0x0000)
struct FTutorialTextData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ShowDuration;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialTextData) == 0x000008, "Wrong alignment on FTutorialTextData");
static_assert(sizeof(FTutorialTextData) == 0x000020, "Wrong size on FTutorialTextData");
static_assert(offsetof(FTutorialTextData, Text) == 0x000000, "Member 'FTutorialTextData::Text' has a wrong offset!");
static_assert(offsetof(FTutorialTextData, ShowDuration) == 0x000018, "Member 'FTutorialTextData::ShowDuration' has a wrong offset!");

// ScriptStruct OPP.TutorialRuntimeData
// 0x0020 (0x0020 - 0x0000)
struct FTutorialRuntimeData final
{
public:
	class FName                                   TutorialId;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTutorialTextData>              TutorialTextSequence;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ETutorialType                                 TutorialType;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessagePriority                              TutorialPriority;                                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialRuntimeData) == 0x000008, "Wrong alignment on FTutorialRuntimeData");
static_assert(sizeof(FTutorialRuntimeData) == 0x000020, "Wrong size on FTutorialRuntimeData");
static_assert(offsetof(FTutorialRuntimeData, TutorialId) == 0x000000, "Member 'FTutorialRuntimeData::TutorialId' has a wrong offset!");
static_assert(offsetof(FTutorialRuntimeData, TutorialTextSequence) == 0x000008, "Member 'FTutorialRuntimeData::TutorialTextSequence' has a wrong offset!");
static_assert(offsetof(FTutorialRuntimeData, TutorialType) == 0x000018, "Member 'FTutorialRuntimeData::TutorialType' has a wrong offset!");
static_assert(offsetof(FTutorialRuntimeData, TutorialPriority) == 0x000019, "Member 'FTutorialRuntimeData::TutorialPriority' has a wrong offset!");

// ScriptStruct OPP.TutorialProfileData
// 0x0018 (0x0018 - 0x0000)
struct FTutorialProfileData final
{
public:
	class FName                                   TutorialId;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfTimeDisplayed;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastDisplayedTime;                                 // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialProfileData) == 0x000008, "Wrong alignment on FTutorialProfileData");
static_assert(sizeof(FTutorialProfileData) == 0x000018, "Wrong size on FTutorialProfileData");
static_assert(offsetof(FTutorialProfileData, TutorialId) == 0x000000, "Member 'FTutorialProfileData::TutorialId' has a wrong offset!");
static_assert(offsetof(FTutorialProfileData, NumberOfTimeDisplayed) == 0x000008, "Member 'FTutorialProfileData::NumberOfTimeDisplayed' has a wrong offset!");
static_assert(offsetof(FTutorialProfileData, LastDisplayedTime) == 0x000010, "Member 'FTutorialProfileData::LastDisplayedTime' has a wrong offset!");

// ScriptStruct OPP.TutorialManagerProfileData
// 0x0058 (0x0058 - 0x0000)
struct FTutorialManagerProfileData final
{
public:
	struct FDateTime                              FirstTimePlayingGameTutorialDisplayedTime;         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FirstTimePickedUpAnyItemTutorialDisplayedTime;     // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FirstTimeEquippedAnyItemTutorialDisplayedTime;     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FirstTimeStartingAnyStageTutorialDisplayedTime;    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FirstTimePickedUpAnyLargeObjectTutorialDisplayedTime; // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTutorialProfileData>           DisplayedTutorialsData;                            // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTutorialProfileData>           DisplayedHUDTutorialsData;                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisplayedMenuTutorialsData;                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialManagerProfileData) == 0x000008, "Wrong alignment on FTutorialManagerProfileData");
static_assert(sizeof(FTutorialManagerProfileData) == 0x000058, "Wrong size on FTutorialManagerProfileData");
static_assert(offsetof(FTutorialManagerProfileData, FirstTimePlayingGameTutorialDisplayedTime) == 0x000000, "Member 'FTutorialManagerProfileData::FirstTimePlayingGameTutorialDisplayedTime' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, FirstTimePickedUpAnyItemTutorialDisplayedTime) == 0x000008, "Member 'FTutorialManagerProfileData::FirstTimePickedUpAnyItemTutorialDisplayedTime' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, FirstTimeEquippedAnyItemTutorialDisplayedTime) == 0x000010, "Member 'FTutorialManagerProfileData::FirstTimeEquippedAnyItemTutorialDisplayedTime' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, FirstTimeStartingAnyStageTutorialDisplayedTime) == 0x000018, "Member 'FTutorialManagerProfileData::FirstTimeStartingAnyStageTutorialDisplayedTime' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, FirstTimePickedUpAnyLargeObjectTutorialDisplayedTime) == 0x000020, "Member 'FTutorialManagerProfileData::FirstTimePickedUpAnyLargeObjectTutorialDisplayedTime' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, DisplayedTutorialsData) == 0x000028, "Member 'FTutorialManagerProfileData::DisplayedTutorialsData' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, DisplayedHUDTutorialsData) == 0x000038, "Member 'FTutorialManagerProfileData::DisplayedHUDTutorialsData' has a wrong offset!");
static_assert(offsetof(FTutorialManagerProfileData, DisplayedMenuTutorialsData) == 0x000048, "Member 'FTutorialManagerProfileData::DisplayedMenuTutorialsData' has a wrong offset!");

// ScriptStruct OPP.RBHackingRigSettingDataRow
// 0x0020 (0x0028 - 0x0008)
struct FRBHackingRigSettingDataRow final : public FTableRowBase
{
public:
	EHackClass                                    HackClass;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HackingDuration;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpgradedHackingDuration;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpgradedCooldown;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HackingDistance;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpgradedHackingDistance;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRBHackingRigSettingDataRow) == 0x000008, "Wrong alignment on FRBHackingRigSettingDataRow");
static_assert(sizeof(FRBHackingRigSettingDataRow) == 0x000028, "Wrong size on FRBHackingRigSettingDataRow");
static_assert(offsetof(FRBHackingRigSettingDataRow, HackClass) == 0x000008, "Member 'FRBHackingRigSettingDataRow::HackClass' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, HackingDuration) == 0x00000C, "Member 'FRBHackingRigSettingDataRow::HackingDuration' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, UpgradedHackingDuration) == 0x000010, "Member 'FRBHackingRigSettingDataRow::UpgradedHackingDuration' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, Cooldown) == 0x000014, "Member 'FRBHackingRigSettingDataRow::Cooldown' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, UpgradedCooldown) == 0x000018, "Member 'FRBHackingRigSettingDataRow::UpgradedCooldown' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, HackingDistance) == 0x00001C, "Member 'FRBHackingRigSettingDataRow::HackingDistance' has a wrong offset!");
static_assert(offsetof(FRBHackingRigSettingDataRow, UpgradedHackingDistance) == 0x000020, "Member 'FRBHackingRigSettingDataRow::UpgradedHackingDistance' has a wrong offset!");

// ScriptStruct OPP.PsychosisColorData
// 0x0060 (0x0060 - 0x0000)
struct FPsychosisColorData final
{
public:
	TMap<EPlayerBarState, struct FSlateColor>     PlayerBarPsychosisColors;                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           GasColor;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychosisColorData) == 0x000008, "Wrong alignment on FPsychosisColorData");
static_assert(sizeof(FPsychosisColorData) == 0x000060, "Wrong size on FPsychosisColorData");
static_assert(offsetof(FPsychosisColorData, PlayerBarPsychosisColors) == 0x000000, "Member 'FPsychosisColorData::PlayerBarPsychosisColors' has a wrong offset!");
static_assert(offsetof(FPsychosisColorData, GasColor) == 0x000050, "Member 'FPsychosisColorData::GasColor' has a wrong offset!");

// ScriptStruct OPP.ScreenFXSettings
// 0x000C (0x000C - 0x0000)
struct FScreenFXSettings final
{
public:
	float                                         NotAffectedRatio;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotAffectedPeekingRatio;                           // 0x0004(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRatio;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenFXSettings) == 0x000004, "Wrong alignment on FScreenFXSettings");
static_assert(sizeof(FScreenFXSettings) == 0x00000C, "Wrong size on FScreenFXSettings");
static_assert(offsetof(FScreenFXSettings, NotAffectedRatio) == 0x000000, "Member 'FScreenFXSettings::NotAffectedRatio' has a wrong offset!");
static_assert(offsetof(FScreenFXSettings, NotAffectedPeekingRatio) == 0x000004, "Member 'FScreenFXSettings::NotAffectedPeekingRatio' has a wrong offset!");
static_assert(offsetof(FScreenFXSettings, DamageRatio) == 0x000008, "Member 'FScreenFXSettings::DamageRatio' has a wrong offset!");

// ScriptStruct OPP.CustomizationCategoryCameras
// 0x0010 (0x0010 - 0x0000)
struct FCustomizationCategoryCameras final
{
public:
	TArray<class ACameraActor*>                   Cameras;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationCategoryCameras) == 0x000008, "Wrong alignment on FCustomizationCategoryCameras");
static_assert(sizeof(FCustomizationCategoryCameras) == 0x000010, "Wrong size on FCustomizationCategoryCameras");
static_assert(offsetof(FCustomizationCategoryCameras, Cameras) == 0x000000, "Member 'FCustomizationCategoryCameras::Cameras' has a wrong offset!");

// ScriptStruct OPP.GamepadStickInputConfig
// 0x0090 (0x0090 - 0x0000)
struct FGamepadStickInputConfig final
{
public:
	struct FRuntimeFloatCurve                     InputAxisCurve;                                    // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         InputAxisAngleDeadZone;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamepadStickInputConfig) == 0x000008, "Wrong alignment on FGamepadStickInputConfig");
static_assert(sizeof(FGamepadStickInputConfig) == 0x000090, "Wrong size on FGamepadStickInputConfig");
static_assert(offsetof(FGamepadStickInputConfig, InputAxisCurve) == 0x000000, "Member 'FGamepadStickInputConfig::InputAxisCurve' has a wrong offset!");
static_assert(offsetof(FGamepadStickInputConfig, InputAxisAngleDeadZone) == 0x000088, "Member 'FGamepadStickInputConfig::InputAxisAngleDeadZone' has a wrong offset!");

// ScriptStruct OPP.InputAxesConfig
// 0x0050 (0x0050 - 0x0000)
struct FInputAxesConfig final
{
public:
	TMap<EGamepadStick, struct FGamepadStickInputConfig> InputAxisCurvesMap;                                // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputAxesConfig) == 0x000008, "Wrong alignment on FInputAxesConfig");
static_assert(sizeof(FInputAxesConfig) == 0x000050, "Wrong size on FInputAxesConfig");
static_assert(offsetof(FInputAxesConfig, InputAxisCurvesMap) == 0x000000, "Member 'FInputAxesConfig::InputAxisCurvesMap' has a wrong offset!");

// ScriptStruct OPP.ForceFeedbackSource
// 0x0038 (0x0038 - 0x0000)
struct FForceFeedbackSource final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowForceFeedbackEnabled;                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMediumForceFeedbackEnabled;                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighForceFeedbackEnabled;                         // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DownZDistanceThreshold;                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpZDistanceThreshold;                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighDistanceThreshold;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumDistanceThreshold;                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowDistanceThreshold;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceFeedbackSource) == 0x000008, "Wrong alignment on FForceFeedbackSource");
static_assert(sizeof(FForceFeedbackSource) == 0x000038, "Wrong size on FForceFeedbackSource");
static_assert(offsetof(FForceFeedbackSource, Owner) == 0x000010, "Member 'FForceFeedbackSource::Owner' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, bLowForceFeedbackEnabled) == 0x000018, "Member 'FForceFeedbackSource::bLowForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, bMediumForceFeedbackEnabled) == 0x000019, "Member 'FForceFeedbackSource::bMediumForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, bHighForceFeedbackEnabled) == 0x00001A, "Member 'FForceFeedbackSource::bHighForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, DownZDistanceThreshold) == 0x00001C, "Member 'FForceFeedbackSource::DownZDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, UpZDistanceThreshold) == 0x000020, "Member 'FForceFeedbackSource::UpZDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, HighDistanceThreshold) == 0x000024, "Member 'FForceFeedbackSource::HighDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, MediumDistanceThreshold) == 0x000028, "Member 'FForceFeedbackSource::MediumDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FForceFeedbackSource, LowDistanceThreshold) == 0x00002C, "Member 'FForceFeedbackSource::LowDistanceThreshold' has a wrong offset!");

// ScriptStruct OPP.ObjectiveUISettings
// 0x0AD0 (0x0AD0 - 0x0000)
struct FObjectiveUISettings final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bNeedsToBeDiscovered;                              // 0x0008(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bIsIntermediateObjective;                          // 0x0068(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableBool                      bShouldUseDiscoveryExpansion;                      // 0x00C8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     DiscoveryRange;                                    // 0x0128(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     ZLimitDiscoveryRange;                              // 0x01F0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     DiscoveryLOSRange;                                 // 0x02B8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     ScaleDownDistanceStart;                            // 0x0380(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     ScaleDownDistanceEnd;                              // 0x0448(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     NearFadeOutDistanceStart;                          // 0x0510(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     NearFadeOutDistanceEnd;                            // 0x05D8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     FarFadeOutDistanceStart;                           // 0x06A0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     FarFadeOutDistanceEnd;                             // 0x0768(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     FarFadeOutLOSDistanceStart;                        // 0x0830(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfigurableFloat                     FarFadeOutLOSDistanceEnd;                          // 0x08F8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePrioritySystem;                                // 0x09C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C1[0x7];                                      // 0x09C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PingText;                                          // 0x09C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x09E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplayAdversarialData;                     // 0x09F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldNeverBeDisplayedToImposters;                // 0x09F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAlwaysBeDisplayedToImposters;               // 0x09FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FB[0x5];                                      // 0x09FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     ImposterFarFadeOutDistanceMultiplier;              // 0x0A00(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighlightIcon;                                     // 0x0AC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC9[0x7];                                      // 0x0AC9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveUISettings) == 0x000008, "Wrong alignment on FObjectiveUISettings");
static_assert(sizeof(FObjectiveUISettings) == 0x000AD0, "Wrong size on FObjectiveUISettings");
static_assert(offsetof(FObjectiveUISettings, Icon) == 0x000000, "Member 'FObjectiveUISettings::Icon' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bNeedsToBeDiscovered) == 0x000008, "Member 'FObjectiveUISettings::bNeedsToBeDiscovered' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bIsIntermediateObjective) == 0x000068, "Member 'FObjectiveUISettings::bIsIntermediateObjective' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bShouldUseDiscoveryExpansion) == 0x0000C8, "Member 'FObjectiveUISettings::bShouldUseDiscoveryExpansion' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, DiscoveryRange) == 0x000128, "Member 'FObjectiveUISettings::DiscoveryRange' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, ZLimitDiscoveryRange) == 0x0001F0, "Member 'FObjectiveUISettings::ZLimitDiscoveryRange' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, DiscoveryLOSRange) == 0x0002B8, "Member 'FObjectiveUISettings::DiscoveryLOSRange' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, ScaleDownDistanceStart) == 0x000380, "Member 'FObjectiveUISettings::ScaleDownDistanceStart' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, ScaleDownDistanceEnd) == 0x000448, "Member 'FObjectiveUISettings::ScaleDownDistanceEnd' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, NearFadeOutDistanceStart) == 0x000510, "Member 'FObjectiveUISettings::NearFadeOutDistanceStart' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, NearFadeOutDistanceEnd) == 0x0005D8, "Member 'FObjectiveUISettings::NearFadeOutDistanceEnd' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, FarFadeOutDistanceStart) == 0x0006A0, "Member 'FObjectiveUISettings::FarFadeOutDistanceStart' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, FarFadeOutDistanceEnd) == 0x000768, "Member 'FObjectiveUISettings::FarFadeOutDistanceEnd' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, FarFadeOutLOSDistanceStart) == 0x000830, "Member 'FObjectiveUISettings::FarFadeOutLOSDistanceStart' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, FarFadeOutLOSDistanceEnd) == 0x0008F8, "Member 'FObjectiveUISettings::FarFadeOutLOSDistanceEnd' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bUsePrioritySystem) == 0x0009C0, "Member 'FObjectiveUISettings::bUsePrioritySystem' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, PingText) == 0x0009C8, "Member 'FObjectiveUISettings::PingText' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, DisplayName) == 0x0009E0, "Member 'FObjectiveUISettings::DisplayName' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bShouldDisplayAdversarialData) == 0x0009F8, "Member 'FObjectiveUISettings::bShouldDisplayAdversarialData' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bShouldNeverBeDisplayedToImposters) == 0x0009F9, "Member 'FObjectiveUISettings::bShouldNeverBeDisplayedToImposters' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, bShouldAlwaysBeDisplayedToImposters) == 0x0009FA, "Member 'FObjectiveUISettings::bShouldAlwaysBeDisplayedToImposters' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, ImposterFarFadeOutDistanceMultiplier) == 0x000A00, "Member 'FObjectiveUISettings::ImposterFarFadeOutDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FObjectiveUISettings, HighlightIcon) == 0x000AC8, "Member 'FObjectiveUISettings::HighlightIcon' has a wrong offset!");

// ScriptStruct OPP.RegionLatency
// 0x0018 (0x0018 - 0x0000)
struct FRegionLatency final
{
public:
	class FString                                 RegionName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PingInMs;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegionLatency) == 0x000008, "Wrong alignment on FRegionLatency");
static_assert(sizeof(FRegionLatency) == 0x000018, "Wrong size on FRegionLatency");
static_assert(offsetof(FRegionLatency, RegionName) == 0x000000, "Member 'FRegionLatency::RegionName' has a wrong offset!");
static_assert(offsetof(FRegionLatency, PingInMs) == 0x000010, "Member 'FRegionLatency::PingInMs' has a wrong offset!");

// ScriptStruct OPP.NPCHitReactionSelectionParams
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FNPCHitReactionSelectionParams final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCHitReactionSelectionParams) == 0x000004, "Wrong alignment on FNPCHitReactionSelectionParams");
static_assert(sizeof(FNPCHitReactionSelectionParams) == 0x000008, "Wrong size on FNPCHitReactionSelectionParams");

// ScriptStruct OPP.StageMusicSystem
// 0x0050 (0x0050 - 0x0000)
struct FStageMusicSystem final
{
public:
	TSoftObjectPtr<class UAkAudioEvent>           MusicStart;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           MusicStop;                                         // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageMusicSystem) == 0x000008, "Wrong alignment on FStageMusicSystem");
static_assert(sizeof(FStageMusicSystem) == 0x000050, "Wrong size on FStageMusicSystem");
static_assert(offsetof(FStageMusicSystem, MusicStart) == 0x000000, "Member 'FStageMusicSystem::MusicStart' has a wrong offset!");
static_assert(offsetof(FStageMusicSystem, MusicStop) == 0x000028, "Member 'FStageMusicSystem::MusicStop' has a wrong offset!");

// ScriptStruct OPP.UILevelInfo
// 0x0010 (0x0010 - 0x0000)
struct FUILevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoicelinePlayed;                                  // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUILevelInfo) == 0x000004, "Wrong alignment on FUILevelInfo");
static_assert(sizeof(FUILevelInfo) == 0x000010, "Wrong size on FUILevelInfo");
static_assert(offsetof(FUILevelInfo, Level) == 0x000000, "Member 'FUILevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FUILevelInfo, ID) == 0x000004, "Member 'FUILevelInfo::ID' has a wrong offset!");
static_assert(offsetof(FUILevelInfo, bVoicelinePlayed) == 0x00000C, "Member 'FUILevelInfo::bVoicelinePlayed' has a wrong offset!");

// ScriptStruct OPP.BattlePassProgressionEntry
// 0x0010 (0x0010 - 0x0000)
struct FBattlePassProgressionEntry final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Xp;                                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePassProgressionEntry) == 0x000004, "Wrong alignment on FBattlePassProgressionEntry");
static_assert(sizeof(FBattlePassProgressionEntry) == 0x000010, "Wrong size on FBattlePassProgressionEntry");
static_assert(offsetof(FBattlePassProgressionEntry, ID) == 0x000000, "Member 'FBattlePassProgressionEntry::ID' has a wrong offset!");
static_assert(offsetof(FBattlePassProgressionEntry, Xp) == 0x000008, "Member 'FBattlePassProgressionEntry::Xp' has a wrong offset!");
static_assert(offsetof(FBattlePassProgressionEntry, Level) == 0x00000C, "Member 'FBattlePassProgressionEntry::Level' has a wrong offset!");

// ScriptStruct OPP.InvestigationPoint
// 0x00C0 (0x00C0 - 0x0000)
struct FInvestigationPoint final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARBInvestigationPoint*                  InvPoint;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBDoor*                                Door;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URBHidespotComponent*                   HidespotComponent;                                 // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBInteractible*                        Interactible;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvestigationPoint) == 0x000008, "Wrong alignment on FInvestigationPoint");
static_assert(sizeof(FInvestigationPoint) == 0x0000C0, "Wrong size on FInvestigationPoint");
static_assert(offsetof(FInvestigationPoint, InvPoint) == 0x000010, "Member 'FInvestigationPoint::InvPoint' has a wrong offset!");
static_assert(offsetof(FInvestigationPoint, Door) == 0x000018, "Member 'FInvestigationPoint::Door' has a wrong offset!");
static_assert(offsetof(FInvestigationPoint, HidespotComponent) == 0x000020, "Member 'FInvestigationPoint::HidespotComponent' has a wrong offset!");
static_assert(offsetof(FInvestigationPoint, Interactible) == 0x000028, "Member 'FInvestigationPoint::Interactible' has a wrong offset!");

// ScriptStruct OPP.StandardFatalityAnimData
// 0x0058 (0x0058 - 0x0000)
struct FStandardFatalityAnimData final
{
public:
	TSoftObjectPtr<class UAnimSequence>           AttackerAnimRef;                                   // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           VictimAnimRef;                                     // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimestamp;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasicDirection                               DebugDirection;                                    // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandardFatalityAnimData) == 0x000008, "Wrong alignment on FStandardFatalityAnimData");
static_assert(sizeof(FStandardFatalityAnimData) == 0x000058, "Wrong size on FStandardFatalityAnimData");
static_assert(offsetof(FStandardFatalityAnimData, AttackerAnimRef) == 0x000000, "Member 'FStandardFatalityAnimData::AttackerAnimRef' has a wrong offset!");
static_assert(offsetof(FStandardFatalityAnimData, VictimAnimRef) == 0x000028, "Member 'FStandardFatalityAnimData::VictimAnimRef' has a wrong offset!");
static_assert(offsetof(FStandardFatalityAnimData, ServerTimestamp) == 0x000050, "Member 'FStandardFatalityAnimData::ServerTimestamp' has a wrong offset!");
static_assert(offsetof(FStandardFatalityAnimData, DebugDirection) == 0x000054, "Member 'FStandardFatalityAnimData::DebugDirection' has a wrong offset!");

// ScriptStruct OPP.AudioPathInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAudioPathInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioPathInfo) == 0x000004, "Wrong alignment on FAudioPathInfo");
static_assert(sizeof(FAudioPathInfo) == 0x00000C, "Wrong size on FAudioPathInfo");

// ScriptStruct OPP.NPCDoorInvestigationParams
// 0x0030 (0x0030 - 0x0000)
struct FNPCDoorInvestigationParams final
{
public:
	class ARBDoor*                                Door;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorInvestigationType                        InvestigationType;                                 // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCDoorInvestigationParams) == 0x000008, "Wrong alignment on FNPCDoorInvestigationParams");
static_assert(sizeof(FNPCDoorInvestigationParams) == 0x000030, "Wrong size on FNPCDoorInvestigationParams");
static_assert(offsetof(FNPCDoorInvestigationParams, Door) == 0x000000, "Member 'FNPCDoorInvestigationParams::Door' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationParams, AnimSequence) == 0x000008, "Member 'FNPCDoorInvestigationParams::AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationParams, Position) == 0x000010, "Member 'FNPCDoorInvestigationParams::Position' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationParams, Direction) == 0x00001C, "Member 'FNPCDoorInvestigationParams::Direction' has a wrong offset!");
static_assert(offsetof(FNPCDoorInvestigationParams, InvestigationType) == 0x000028, "Member 'FNPCDoorInvestigationParams::InvestigationType' has a wrong offset!");

// ScriptStruct OPP.ActiveSkillCommonParams
// 0x0078 (0x0078 - 0x0000)
struct FActiveSkillCommonParams final
{
public:
	EActiveSkillType                              ActiveSkillType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnlineUnlockId;                                    // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             HUDIconTexture;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            PrimaryColor;                                      // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class ARBActiveSkill>             ActiveSkillActorClass;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveSkillCommonParams) == 0x000008, "Wrong alignment on FActiveSkillCommonParams");
static_assert(sizeof(FActiveSkillCommonParams) == 0x000078, "Wrong size on FActiveSkillCommonParams");
static_assert(offsetof(FActiveSkillCommonParams, ActiveSkillType) == 0x000000, "Member 'FActiveSkillCommonParams::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, OnlineUnlockId) == 0x000004, "Member 'FActiveSkillCommonParams::OnlineUnlockId' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, DisplayName) == 0x000010, "Member 'FActiveSkillCommonParams::DisplayName' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, Description) == 0x000028, "Member 'FActiveSkillCommonParams::Description' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, HUDIconTexture) == 0x000040, "Member 'FActiveSkillCommonParams::HUDIconTexture' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, PrimaryColor) == 0x000048, "Member 'FActiveSkillCommonParams::PrimaryColor' has a wrong offset!");
static_assert(offsetof(FActiveSkillCommonParams, ActiveSkillActorClass) == 0x000070, "Member 'FActiveSkillCommonParams::ActiveSkillActorClass' has a wrong offset!");

// ScriptStruct OPP.ObjectivePathData
// 0x0130 (0x0130 - 0x0000)
struct FObjectivePathData final
{
public:
	struct FWorldIconData                         WorldIconData;                                     // 0x0000(0x0100)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0100(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SplinePoints;                                      // 0x0110(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasValidPath;                                     // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0xF];                                      // 0x0121(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectivePathData) == 0x000010, "Wrong alignment on FObjectivePathData");
static_assert(sizeof(FObjectivePathData) == 0x000130, "Wrong size on FObjectivePathData");
static_assert(offsetof(FObjectivePathData, WorldIconData) == 0x000000, "Member 'FObjectivePathData::WorldIconData' has a wrong offset!");
static_assert(offsetof(FObjectivePathData, Location) == 0x000100, "Member 'FObjectivePathData::Location' has a wrong offset!");
static_assert(offsetof(FObjectivePathData, Distance) == 0x00010C, "Member 'FObjectivePathData::Distance' has a wrong offset!");
static_assert(offsetof(FObjectivePathData, SplinePoints) == 0x000110, "Member 'FObjectivePathData::SplinePoints' has a wrong offset!");
static_assert(offsetof(FObjectivePathData, bHasValidPath) == 0x000120, "Member 'FObjectivePathData::bHasValidPath' has a wrong offset!");

// ScriptStruct OPP.PlayerPingData
// 0x0030 (0x0030 - 0x0000)
struct FPlayerPingData final
{
public:
	class FText                                   TextChatMessage;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          VoiceAKEvent;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayVoiceAkEventOnActor;                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSilent;                                           // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPingData) == 0x000008, "Wrong alignment on FPlayerPingData");
static_assert(sizeof(FPlayerPingData) == 0x000030, "Wrong size on FPlayerPingData");
static_assert(offsetof(FPlayerPingData, TextChatMessage) == 0x000000, "Member 'FPlayerPingData::TextChatMessage' has a wrong offset!");
static_assert(offsetof(FPlayerPingData, VoiceAKEvent) == 0x000018, "Member 'FPlayerPingData::VoiceAKEvent' has a wrong offset!");
static_assert(offsetof(FPlayerPingData, bPlayVoiceAkEventOnActor) == 0x000020, "Member 'FPlayerPingData::bPlayVoiceAkEventOnActor' has a wrong offset!");
static_assert(offsetof(FPlayerPingData, bSilent) == 0x000021, "Member 'FPlayerPingData::bSilent' has a wrong offset!");
static_assert(offsetof(FPlayerPingData, Icon) == 0x000028, "Member 'FPlayerPingData::Icon' has a wrong offset!");

// ScriptStruct OPP.LobbyScriptedAnimStationData
// 0x0018 (0x0018 - 0x0000)
struct FLobbyScriptedAnimStationData final
{
public:
	TArray<class ARBScriptedAnimStation*>         StationList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ARBBot*                                 bot;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyScriptedAnimStationData) == 0x000008, "Wrong alignment on FLobbyScriptedAnimStationData");
static_assert(sizeof(FLobbyScriptedAnimStationData) == 0x000018, "Wrong size on FLobbyScriptedAnimStationData");
static_assert(offsetof(FLobbyScriptedAnimStationData, StationList) == 0x000000, "Member 'FLobbyScriptedAnimStationData::StationList' has a wrong offset!");
static_assert(offsetof(FLobbyScriptedAnimStationData, bot) == 0x000010, "Member 'FLobbyScriptedAnimStationData::bot' has a wrong offset!");

// ScriptStruct OPP.GameplayRandomizationDebugInfo
// 0x0108 (0x0108 - 0x0000)
struct FGameplayRandomizationDebugInfo final
{
public:
	int32                                         NumberOfRandomizedPuzzleRooms;                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRandomizedActivePuzzleRooms;               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRandomizedRewardRooms;                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRandomizedActiveRewardRooms;               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRandomizedTriggerableGates;                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfClosedTriggerableGates;                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDoors;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfBlockedDoors;                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfBlockableDoors;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfUnblockableBlockableDoors;                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRemovedDoors;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRemovedDoorsByRandomization;               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfReplacedDoors;                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfReplaceableDoors;                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPadLockedDoors;                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPadLockableDoors;                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DoorReplacementNames;                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DoorReplacementCountByNames;                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumberOfTrappedDoors;                              // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfLockedDoors;                               // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DoorLockNames;                                     // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DoorLockCountByNames;                              // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumberOfOpenDoors;                                 // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfClosedDoors;                               // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDoorCoopBash;                              // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfMiscBlockables;                            // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfBlockedMiscBlockables;                     // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfBlockableMiscBlockables;                   // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfUnblockableMiscBlockables;                 // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfHidespots;                                 // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDisableableHidespots;                      // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDisabledHidespots;                         // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARBGlassFloorTrap*>              GlassFloorTraps;                                   // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBSoundTrap*>                   SoundTraps;                                        // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARBExplosiveTrap*>               ExplosiveTraps;                                    // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class URBElectricFloorTrapComponent*>  ElectricTrapFloors;                                // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayRandomizationDebugInfo) == 0x000008, "Wrong alignment on FGameplayRandomizationDebugInfo");
static_assert(sizeof(FGameplayRandomizationDebugInfo) == 0x000108, "Wrong size on FGameplayRandomizationDebugInfo");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRandomizedPuzzleRooms) == 0x000000, "Member 'FGameplayRandomizationDebugInfo::NumberOfRandomizedPuzzleRooms' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRandomizedActivePuzzleRooms) == 0x000004, "Member 'FGameplayRandomizationDebugInfo::NumberOfRandomizedActivePuzzleRooms' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRandomizedRewardRooms) == 0x000008, "Member 'FGameplayRandomizationDebugInfo::NumberOfRandomizedRewardRooms' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRandomizedActiveRewardRooms) == 0x00000C, "Member 'FGameplayRandomizationDebugInfo::NumberOfRandomizedActiveRewardRooms' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRandomizedTriggerableGates) == 0x000010, "Member 'FGameplayRandomizationDebugInfo::NumberOfRandomizedTriggerableGates' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfClosedTriggerableGates) == 0x000014, "Member 'FGameplayRandomizationDebugInfo::NumberOfClosedTriggerableGates' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfDoors) == 0x000018, "Member 'FGameplayRandomizationDebugInfo::NumberOfDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfBlockedDoors) == 0x00001C, "Member 'FGameplayRandomizationDebugInfo::NumberOfBlockedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfBlockableDoors) == 0x000020, "Member 'FGameplayRandomizationDebugInfo::NumberOfBlockableDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfUnblockableBlockableDoors) == 0x000024, "Member 'FGameplayRandomizationDebugInfo::NumberOfUnblockableBlockableDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRemovedDoors) == 0x000028, "Member 'FGameplayRandomizationDebugInfo::NumberOfRemovedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfRemovedDoorsByRandomization) == 0x00002C, "Member 'FGameplayRandomizationDebugInfo::NumberOfRemovedDoorsByRandomization' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfReplacedDoors) == 0x000030, "Member 'FGameplayRandomizationDebugInfo::NumberOfReplacedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfReplaceableDoors) == 0x000034, "Member 'FGameplayRandomizationDebugInfo::NumberOfReplaceableDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfPadLockedDoors) == 0x000038, "Member 'FGameplayRandomizationDebugInfo::NumberOfPadLockedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfPadLockableDoors) == 0x00003C, "Member 'FGameplayRandomizationDebugInfo::NumberOfPadLockableDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, DoorReplacementNames) == 0x000040, "Member 'FGameplayRandomizationDebugInfo::DoorReplacementNames' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, DoorReplacementCountByNames) == 0x000050, "Member 'FGameplayRandomizationDebugInfo::DoorReplacementCountByNames' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfTrappedDoors) == 0x000060, "Member 'FGameplayRandomizationDebugInfo::NumberOfTrappedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfLockedDoors) == 0x000064, "Member 'FGameplayRandomizationDebugInfo::NumberOfLockedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, DoorLockNames) == 0x000068, "Member 'FGameplayRandomizationDebugInfo::DoorLockNames' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, DoorLockCountByNames) == 0x000078, "Member 'FGameplayRandomizationDebugInfo::DoorLockCountByNames' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfOpenDoors) == 0x000088, "Member 'FGameplayRandomizationDebugInfo::NumberOfOpenDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfClosedDoors) == 0x00008C, "Member 'FGameplayRandomizationDebugInfo::NumberOfClosedDoors' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfDoorCoopBash) == 0x000090, "Member 'FGameplayRandomizationDebugInfo::NumberOfDoorCoopBash' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfMiscBlockables) == 0x000094, "Member 'FGameplayRandomizationDebugInfo::NumberOfMiscBlockables' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfBlockedMiscBlockables) == 0x000098, "Member 'FGameplayRandomizationDebugInfo::NumberOfBlockedMiscBlockables' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfBlockableMiscBlockables) == 0x00009C, "Member 'FGameplayRandomizationDebugInfo::NumberOfBlockableMiscBlockables' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfUnblockableMiscBlockables) == 0x0000A0, "Member 'FGameplayRandomizationDebugInfo::NumberOfUnblockableMiscBlockables' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfHidespots) == 0x0000A4, "Member 'FGameplayRandomizationDebugInfo::NumberOfHidespots' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfDisableableHidespots) == 0x0000A8, "Member 'FGameplayRandomizationDebugInfo::NumberOfDisableableHidespots' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, NumberOfDisabledHidespots) == 0x0000AC, "Member 'FGameplayRandomizationDebugInfo::NumberOfDisabledHidespots' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, GlassFloorTraps) == 0x0000B0, "Member 'FGameplayRandomizationDebugInfo::GlassFloorTraps' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, SoundTraps) == 0x0000C8, "Member 'FGameplayRandomizationDebugInfo::SoundTraps' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, ExplosiveTraps) == 0x0000E0, "Member 'FGameplayRandomizationDebugInfo::ExplosiveTraps' has a wrong offset!");
static_assert(offsetof(FGameplayRandomizationDebugInfo, ElectricTrapFloors) == 0x0000F0, "Member 'FGameplayRandomizationDebugInfo::ElectricTrapFloors' has a wrong offset!");

// ScriptStruct OPP.MusicPlayerDebugInfo
// 0x0038 (0x0038 - 0x0000)
struct FMusicPlayerDebugInfo final
{
public:
	class FString                                 LocalPlayerName;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThreateningNPCName;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatLevel;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMusicStateChangeEvent>         StateChanges;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicPlayerDebugInfo) == 0x000008, "Wrong alignment on FMusicPlayerDebugInfo");
static_assert(sizeof(FMusicPlayerDebugInfo) == 0x000038, "Wrong size on FMusicPlayerDebugInfo");
static_assert(offsetof(FMusicPlayerDebugInfo, LocalPlayerName) == 0x000000, "Member 'FMusicPlayerDebugInfo::LocalPlayerName' has a wrong offset!");
static_assert(offsetof(FMusicPlayerDebugInfo, ThreateningNPCName) == 0x000010, "Member 'FMusicPlayerDebugInfo::ThreateningNPCName' has a wrong offset!");
static_assert(offsetof(FMusicPlayerDebugInfo, ThreatLevel) == 0x000020, "Member 'FMusicPlayerDebugInfo::ThreatLevel' has a wrong offset!");
static_assert(offsetof(FMusicPlayerDebugInfo, StateChanges) == 0x000028, "Member 'FMusicPlayerDebugInfo::StateChanges' has a wrong offset!");

// ScriptStruct OPP.MusicDebugInfo
// 0x0018 (0x0018 - 0x0000)
struct FMusicDebugInfo final
{
public:
	TArray<struct FMusicPlayerDebugInfo>          PlayerInfos;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GatheredTime;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMusicDebugInfo) == 0x000008, "Wrong alignment on FMusicDebugInfo");
static_assert(sizeof(FMusicDebugInfo) == 0x000018, "Wrong size on FMusicDebugInfo");
static_assert(offsetof(FMusicDebugInfo, PlayerInfos) == 0x000000, "Member 'FMusicDebugInfo::PlayerInfos' has a wrong offset!");
static_assert(offsetof(FMusicDebugInfo, GatheredTime) == 0x000010, "Member 'FMusicDebugInfo::GatheredTime' has a wrong offset!");

// ScriptStruct OPP.NPCAttackParams
// 0x0030 (0x0030 - 0x0000)
struct FNPCAttackParams final
{
public:
	EAttackType                                   AttackType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStationary;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackAnim;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackTarget;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAttackParams) == 0x000008, "Wrong alignment on FNPCAttackParams");
static_assert(sizeof(FNPCAttackParams) == 0x000030, "Wrong size on FNPCAttackParams");
static_assert(offsetof(FNPCAttackParams, AttackType) == 0x000000, "Member 'FNPCAttackParams::AttackType' has a wrong offset!");
static_assert(offsetof(FNPCAttackParams, bStationary) == 0x000001, "Member 'FNPCAttackParams::bStationary' has a wrong offset!");
static_assert(offsetof(FNPCAttackParams, PlayRate) == 0x000004, "Member 'FNPCAttackParams::PlayRate' has a wrong offset!");
static_assert(offsetof(FNPCAttackParams, AttackAnim) == 0x000008, "Member 'FNPCAttackParams::AttackAnim' has a wrong offset!");
static_assert(offsetof(FNPCAttackParams, AttackTarget) == 0x000010, "Member 'FNPCAttackParams::AttackTarget' has a wrong offset!");

// ScriptStruct OPP.SectionItemSpawningOverride
// 0x00D0 (0x00D0 - 0x0000)
struct FSectionItemSpawningOverride final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigurableFloat                     StageCountPercent;                                 // 0x0008(0x00C8)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectionItemSpawningOverride) == 0x000008, "Wrong alignment on FSectionItemSpawningOverride");
static_assert(sizeof(FSectionItemSpawningOverride) == 0x0000D0, "Wrong size on FSectionItemSpawningOverride");
static_assert(offsetof(FSectionItemSpawningOverride, ItemType) == 0x000000, "Member 'FSectionItemSpawningOverride::ItemType' has a wrong offset!");
static_assert(offsetof(FSectionItemSpawningOverride, StageCountPercent) == 0x000008, "Member 'FSectionItemSpawningOverride::StageCountPercent' has a wrong offset!");

// ScriptStruct OPP.PlayerCustomizationItemSettings
// 0x0020 (0x0020 - 0x0000)
struct FPlayerCustomizationItemSettings final
{
public:
	int32                                         RequiredXp;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationItemSettings) == 0x000008, "Wrong alignment on FPlayerCustomizationItemSettings");
static_assert(sizeof(FPlayerCustomizationItemSettings) == 0x000020, "Wrong size on FPlayerCustomizationItemSettings");
static_assert(offsetof(FPlayerCustomizationItemSettings, RequiredXp) == 0x000000, "Member 'FPlayerCustomizationItemSettings::RequiredXp' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemSettings, DisplayName) == 0x000008, "Member 'FPlayerCustomizationItemSettings::DisplayName' has a wrong offset!");

// ScriptStruct OPP.PlayerCustomizationSkeletalMesh
// 0x0078 (0x0080 - 0x0008)
struct FPlayerCustomizationSkeletalMesh final : public FTableRowBase
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UMaterialInstanceConstant*> Materials;                                         // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCustomizationItemSettings       ItemSettings;                                      // 0x0060(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationSkeletalMesh) == 0x000008, "Wrong alignment on FPlayerCustomizationSkeletalMesh");
static_assert(sizeof(FPlayerCustomizationSkeletalMesh) == 0x000080, "Wrong size on FPlayerCustomizationSkeletalMesh");
static_assert(offsetof(FPlayerCustomizationSkeletalMesh, Mesh) == 0x000008, "Member 'FPlayerCustomizationSkeletalMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationSkeletalMesh, Materials) == 0x000010, "Member 'FPlayerCustomizationSkeletalMesh::Materials' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationSkeletalMesh, ItemSettings) == 0x000060, "Member 'FPlayerCustomizationSkeletalMesh::ItemSettings' has a wrong offset!");

// ScriptStruct OPP.PlayerCustomizationStaticMesh
// 0x0078 (0x0080 - 0x0008)
struct FPlayerCustomizationStaticMesh final : public FTableRowBase
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UMaterialInstanceConstant*> Materials;                                         // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCustomizationItemSettings       ItemSettings;                                      // 0x0060(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationStaticMesh) == 0x000008, "Wrong alignment on FPlayerCustomizationStaticMesh");
static_assert(sizeof(FPlayerCustomizationStaticMesh) == 0x000080, "Wrong size on FPlayerCustomizationStaticMesh");
static_assert(offsetof(FPlayerCustomizationStaticMesh, Mesh) == 0x000008, "Member 'FPlayerCustomizationStaticMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationStaticMesh, Materials) == 0x000010, "Member 'FPlayerCustomizationStaticMesh::Materials' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationStaticMesh, ItemSettings) == 0x000060, "Member 'FPlayerCustomizationStaticMesh::ItemSettings' has a wrong offset!");

// ScriptStruct OPP.RotationRateLimitParams
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FRotationRateLimitParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRotationRateLimitParams) == 0x000004, "Wrong alignment on FRotationRateLimitParams");
static_assert(sizeof(FRotationRateLimitParams) == 0x000010, "Wrong size on FRotationRateLimitParams");

// ScriptStruct OPP.LocomotionModeParameters
// 0x0074 (0x0074 - 0x0000)
struct FLocomotionModeParameters final
{
public:
	struct FGameplayParams                        GP;                                                // 0x0000(0x0068)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         NeckOffsetSide;                                    // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeckOffsetFwd;                                     // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockNavmesh;                                     // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCameraRelativeRightHand;                     // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInteract;                                      // 0x0072(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x1];                                       // 0x0073(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionModeParameters) == 0x000004, "Wrong alignment on FLocomotionModeParameters");
static_assert(sizeof(FLocomotionModeParameters) == 0x000074, "Wrong size on FLocomotionModeParameters");
static_assert(offsetof(FLocomotionModeParameters, GP) == 0x000000, "Member 'FLocomotionModeParameters::GP' has a wrong offset!");
static_assert(offsetof(FLocomotionModeParameters, NeckOffsetSide) == 0x000068, "Member 'FLocomotionModeParameters::NeckOffsetSide' has a wrong offset!");
static_assert(offsetof(FLocomotionModeParameters, NeckOffsetFwd) == 0x00006C, "Member 'FLocomotionModeParameters::NeckOffsetFwd' has a wrong offset!");
static_assert(offsetof(FLocomotionModeParameters, bBlockNavmesh) == 0x000070, "Member 'FLocomotionModeParameters::bBlockNavmesh' has a wrong offset!");
static_assert(offsetof(FLocomotionModeParameters, bAllowCameraRelativeRightHand) == 0x000071, "Member 'FLocomotionModeParameters::bAllowCameraRelativeRightHand' has a wrong offset!");
static_assert(offsetof(FLocomotionModeParameters, bCanInteract) == 0x000072, "Member 'FLocomotionModeParameters::bCanInteract' has a wrong offset!");

// ScriptStruct OPP.NPCAimingConfig
// 0x0020 (0x0020 - 0x0000)
struct FNPCAimingConfig final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetedActor;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetedLocation;                                  // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAimingConfig) == 0x000008, "Wrong alignment on FNPCAimingConfig");
static_assert(sizeof(FNPCAimingConfig) == 0x000020, "Wrong size on FNPCAimingConfig");
static_assert(offsetof(FNPCAimingConfig, bEnabled) == 0x000000, "Member 'FNPCAimingConfig::bEnabled' has a wrong offset!");
static_assert(offsetof(FNPCAimingConfig, TargetedActor) == 0x000008, "Member 'FNPCAimingConfig::TargetedActor' has a wrong offset!");
static_assert(offsetof(FNPCAimingConfig, TargetedLocation) == 0x000010, "Member 'FNPCAimingConfig::TargetedLocation' has a wrong offset!");

// ScriptStruct OPP.NPCInvestigationSelectedAnimData
// 0x0030 (0x0030 - 0x0000)
struct FNPCInvestigationSelectedAnimData final
{
public:
	bool                                          bValid;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSequence;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCInvestigationAnimIntensity                Intensity;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCInvestigationAnimCategory                 Category;                                          // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterInMotion;                                    // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EntrySpeed;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryPhase;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URBNPCInterestPointComponent*>   InterestPoints;                                    // 0x0020(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCInvestigationSelectedAnimData) == 0x000008, "Wrong alignment on FNPCInvestigationSelectedAnimData");
static_assert(sizeof(FNPCInvestigationSelectedAnimData) == 0x000030, "Wrong size on FNPCInvestigationSelectedAnimData");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, bValid) == 0x000000, "Member 'FNPCInvestigationSelectedAnimData::bValid' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, AnimSequence) == 0x000008, "Member 'FNPCInvestigationSelectedAnimData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, Intensity) == 0x000010, "Member 'FNPCInvestigationSelectedAnimData::Intensity' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, Category) == 0x000011, "Member 'FNPCInvestigationSelectedAnimData::Category' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, bEnterInMotion) == 0x000012, "Member 'FNPCInvestigationSelectedAnimData::bEnterInMotion' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, EntrySpeed) == 0x000014, "Member 'FNPCInvestigationSelectedAnimData::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, EntryPhase) == 0x000018, "Member 'FNPCInvestigationSelectedAnimData::EntryPhase' has a wrong offset!");
static_assert(offsetof(FNPCInvestigationSelectedAnimData, InterestPoints) == 0x000020, "Member 'FNPCInvestigationSelectedAnimData::InterestPoints' has a wrong offset!");

// ScriptStruct OPP.NPCAnimatedStartData
// 0x0048 (0x0048 - 0x0000)
struct FNPCAnimatedStartData final
{
public:
	float                                         InitialTargetYaw;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpeed;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAggressiveStance;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartYaw;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSteeringYaw;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARBPlayer*                              TrackedTargetPlayer;                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCAnimatedStartData) == 0x000008, "Wrong alignment on FNPCAnimatedStartData");
static_assert(sizeof(FNPCAnimatedStartData) == 0x000048, "Wrong size on FNPCAnimatedStartData");
static_assert(offsetof(FNPCAnimatedStartData, InitialTargetYaw) == 0x000000, "Member 'FNPCAnimatedStartData::InitialTargetYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, TargetSpeed) == 0x000004, "Member 'FNPCAnimatedStartData::TargetSpeed' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, bAggressiveStance) == 0x000008, "Member 'FNPCAnimatedStartData::bAggressiveStance' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, StartLocation) == 0x00000C, "Member 'FNPCAnimatedStartData::StartLocation' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, StartYaw) == 0x000018, "Member 'FNPCAnimatedStartData::StartYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, StartingSteeringYaw) == 0x00001C, "Member 'FNPCAnimatedStartData::StartingSteeringYaw' has a wrong offset!");
static_assert(offsetof(FNPCAnimatedStartData, TrackedTargetPlayer) == 0x000020, "Member 'FNPCAnimatedStartData::TrackedTargetPlayer' has a wrong offset!");

// ScriptStruct OPP.PipeArrangement
// 0x0098 (0x0098 - 0x0000)
struct FPipeArrangement final
{
public:
	struct FConfigurableBool                      AllowedByDifficulty;                               // 0x0000(0x0060)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPipeJunction>                  PipeJunctions;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          VisibleActors;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          HiddenActors;                                      // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bWaterLeakFront;                                   // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaterLeakBack;                                    // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPipeArrangement) == 0x000008, "Wrong alignment on FPipeArrangement");
static_assert(sizeof(FPipeArrangement) == 0x000098, "Wrong size on FPipeArrangement");
static_assert(offsetof(FPipeArrangement, AllowedByDifficulty) == 0x000000, "Member 'FPipeArrangement::AllowedByDifficulty' has a wrong offset!");
static_assert(offsetof(FPipeArrangement, PipeJunctions) == 0x000060, "Member 'FPipeArrangement::PipeJunctions' has a wrong offset!");
static_assert(offsetof(FPipeArrangement, VisibleActors) == 0x000070, "Member 'FPipeArrangement::VisibleActors' has a wrong offset!");
static_assert(offsetof(FPipeArrangement, HiddenActors) == 0x000080, "Member 'FPipeArrangement::HiddenActors' has a wrong offset!");
static_assert(offsetof(FPipeArrangement, bWaterLeakFront) == 0x000090, "Member 'FPipeArrangement::bWaterLeakFront' has a wrong offset!");
static_assert(offsetof(FPipeArrangement, bWaterLeakBack) == 0x000091, "Member 'FPipeArrangement::bWaterLeakBack' has a wrong offset!");

// ScriptStruct OPP.HazardScreenEffectsConfig
// 0x0088 (0x0110 - 0x0088)
struct FHazardScreenEffectsConfig final : public FHazardEffectsConfig
{
public:
	class FName                                   AudioProgressRTPCName;                             // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScreenFXSettings                      ScreenFXNoNV;                                      // 0x0090(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenFXSettings                      ScreenFXWithNV;                                    // 0x009C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyPlayAudioState;                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           AudioStateStartRef;                                // 0x00B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AudioStateStopRef;                                 // 0x00D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioStateStart;                                   // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioStateStop;                                    // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHazardScreenEffectsConfig) == 0x000008, "Wrong alignment on FHazardScreenEffectsConfig");
static_assert(sizeof(FHazardScreenEffectsConfig) == 0x000110, "Wrong size on FHazardScreenEffectsConfig");
static_assert(offsetof(FHazardScreenEffectsConfig, AudioProgressRTPCName) == 0x000088, "Member 'FHazardScreenEffectsConfig::AudioProgressRTPCName' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, ScreenFXNoNV) == 0x000090, "Member 'FHazardScreenEffectsConfig::ScreenFXNoNV' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, ScreenFXWithNV) == 0x00009C, "Member 'FHazardScreenEffectsConfig::ScreenFXWithNV' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, bAutomaticallyPlayAudioState) == 0x0000A8, "Member 'FHazardScreenEffectsConfig::bAutomaticallyPlayAudioState' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, AudioStateStartRef) == 0x0000B0, "Member 'FHazardScreenEffectsConfig::AudioStateStartRef' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, AudioStateStopRef) == 0x0000D8, "Member 'FHazardScreenEffectsConfig::AudioStateStopRef' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, AudioStateStart) == 0x000100, "Member 'FHazardScreenEffectsConfig::AudioStateStart' has a wrong offset!");
static_assert(offsetof(FHazardScreenEffectsConfig, AudioStateStop) == 0x000108, "Member 'FHazardScreenEffectsConfig::AudioStateStop' has a wrong offset!");

// ScriptStruct OPP.VOEventData
// 0x0058 (0x0058 - 0x0000)
struct FVOEventData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Speaker;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x48];                                      // 0x0010(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVOEventData) == 0x000008, "Wrong alignment on FVOEventData");
static_assert(sizeof(FVOEventData) == 0x000058, "Wrong size on FVOEventData");
static_assert(offsetof(FVOEventData, Speaker) == 0x000008, "Member 'FVOEventData::Speaker' has a wrong offset!");

// ScriptStruct OPP.TalkerState
// 0x0028 (0x0028 - 0x0000)
struct FTalkerState final
{
public:
	class AActor*                                 Talker;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVOLine                                ActiveLine;                                        // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkerState) == 0x000008, "Wrong alignment on FTalkerState");
static_assert(sizeof(FTalkerState) == 0x000028, "Wrong size on FTalkerState");
static_assert(offsetof(FTalkerState, Talker) == 0x000000, "Member 'FTalkerState::Talker' has a wrong offset!");
static_assert(offsetof(FTalkerState, ActiveLine) == 0x000008, "Member 'FTalkerState::ActiveLine' has a wrong offset!");

// ScriptStruct OPP.WaterValveSectionGroupConfig
// 0x00D8 (0x00D8 - 0x0000)
struct FWaterValveSectionGroupConfig final
{
public:
	struct FConfigurableInt                       MinimumValveInSection;                             // 0x0000(0x00C8)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWaterValveSectionConfig>       Sections;                                          // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterValveSectionGroupConfig) == 0x000008, "Wrong alignment on FWaterValveSectionGroupConfig");
static_assert(sizeof(FWaterValveSectionGroupConfig) == 0x0000D8, "Wrong size on FWaterValveSectionGroupConfig");
static_assert(offsetof(FWaterValveSectionGroupConfig, MinimumValveInSection) == 0x000000, "Member 'FWaterValveSectionGroupConfig::MinimumValveInSection' has a wrong offset!");
static_assert(offsetof(FWaterValveSectionGroupConfig, Sections) == 0x0000C8, "Member 'FWaterValveSectionGroupConfig::Sections' has a wrong offset!");

// ScriptStruct OPP.CheckpointActionData
// 0x0010 (0x0010 - 0x0000)
struct FCheckpointActionData final
{
public:
	TArray<struct FTriggerableActionData>         ActionData;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCheckpointActionData) == 0x000008, "Wrong alignment on FCheckpointActionData");
static_assert(sizeof(FCheckpointActionData) == 0x000010, "Wrong size on FCheckpointActionData");
static_assert(offsetof(FCheckpointActionData, ActionData) == 0x000000, "Member 'FCheckpointActionData::ActionData' has a wrong offset!");

// ScriptStruct OPP.ZoneTimingTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FZoneTimingTargetInfo final
{
public:
	TArray<ETimingInputResultType>                NeedleResults;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         NeedleSpeed;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneTimingTargetInfo) == 0x000008, "Wrong alignment on FZoneTimingTargetInfo");
static_assert(sizeof(FZoneTimingTargetInfo) == 0x000018, "Wrong size on FZoneTimingTargetInfo");
static_assert(offsetof(FZoneTimingTargetInfo, NeedleResults) == 0x000000, "Member 'FZoneTimingTargetInfo::NeedleResults' has a wrong offset!");
static_assert(offsetof(FZoneTimingTargetInfo, NeedleSpeed) == 0x000010, "Member 'FZoneTimingTargetInfo::NeedleSpeed' has a wrong offset!");

}

