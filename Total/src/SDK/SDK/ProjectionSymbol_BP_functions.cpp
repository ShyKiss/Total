#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectionSymbol_BP

#include "Basic.hpp"

#include "ProjectionSymbol_BP_classes.hpp"
#include "ProjectionSymbol_BP_parameters.hpp"


namespace SDK
{

// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetAssociatedInvestigationComponent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URBPlayerInvestigationZoneComponent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class URBPlayerInvestigationZoneComponent* AProjectionSymbol_BP_C::GetAssociatedInvestigationComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetAssociatedInvestigationComponent");

	Params::ProjectionSymbol_BP_C_GetAssociatedInvestigationComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetClue
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FClueData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor)

struct FClueData AProjectionSymbol_BP_C::GetClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetClue");

	Params::ProjectionSymbol_BP_C_GetClue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.OnWorldPopulateFinishedTimeSliced
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::OnWorldPopulateFinishedTimeSliced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "OnWorldPopulateFinishedTimeSliced");

	Params::ProjectionSymbol_BP_C_OnWorldPopulateFinishedTimeSliced Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetStateName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           StateA                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString                           StateB                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::GetStateName(class FString* StateA, class FString* StateB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetStateName");

	Params::ProjectionSymbol_BP_C_GetStateName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (StateA != nullptr)
		*StateA = std::move(Parms.StateA);

	if (StateB != nullptr)
		*StateB = std::move(Parms.StateB);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.HideAllExcludedActors
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::HideAllExcludedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "HideAllExcludedActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetFullExcludeList
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<TSoftObjectPtr<class AActor>>    FullExcludeList                                        (Parm, OutParm)

void AProjectionSymbol_BP_C::GetFullExcludeList(TArray<TSoftObjectPtr<class AActor>>* FullExcludeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetFullExcludeList");

	Params::ProjectionSymbol_BP_C_GetFullExcludeList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FullExcludeList != nullptr)
		*FullExcludeList = std::move(Parms.FullExcludeList);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.FindFov
// (Public, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::FindFov()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "FindFov");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.FixUp
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::FixUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "FixUp");

	Params::ProjectionSymbol_BP_C_FixUp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.Set Gizmo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::Set_Gizmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "Set Gizmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.ForceActive
// (Public, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::ForceActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "ForceActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.ClearDebugProjectFlags
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::ClearDebugProjectFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "ClearDebugProjectFlags");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.ResetEditorTexture
// (Public, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::ResetEditorTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "ResetEditorTexture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.PreviousClue
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::PreviousClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "PreviousClue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.NextClue
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::NextClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "NextClue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.UpdateClueTexutre
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::UpdateClueTexutre()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "UpdateClueTexutre");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.SetMaterial
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AProjectionSymbol_BP_C::SetMaterial(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "SetMaterial");

	Params::ProjectionSymbol_BP_C_SetMaterial Parms{};

	Parms.Force = Force;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.getDepthTexture
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::GetDepthTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "getDepthTexture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.CaptureDepth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::CaptureDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "CaptureDepth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.OnLoaded_AB95D07B4D3F3F42212E9F9F4E4F3361
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AProjectionSymbol_BP_C::OnLoaded_AB95D07B4D3F3F42212E9F9F4E4F3361(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "OnLoaded_AB95D07B4D3F3F42212E9F9F4E4F3361");

	Params::ProjectionSymbol_BP_C_OnLoaded_AB95D07B4D3F3F42212E9F9F4E4F3361 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.PrepareState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStateA                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           RandomOwner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AProjectionSymbol_BP_C::PrepareState(bool bStateA, class AActor* RandomOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "PrepareState");

	Params::ProjectionSymbol_BP_C_PrepareState Parms{};

	Parms.bStateA = bStateA;
	Parms.RandomOwner = RandomOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.SetShouldBeIgnoredForLots
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AProjectionSymbol_BP_C::SetShouldBeIgnoredForLots(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "SetShouldBeIgnoredForLots");

	Params::ProjectionSymbol_BP_C_SetShouldBeIgnoredForLots Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.OnWorldPopulateFinished
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::OnWorldPopulateFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "OnWorldPopulateFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.SetClue
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FClueData                        ClueData                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)

void AProjectionSymbol_BP_C::SetClue(const struct FClueData& ClueData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "SetClue");

	Params::ProjectionSymbol_BP_C_SetClue Parms{};

	Parms.ClueData = std::move(ClueData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.loadTextureDepth
// (BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::LoadTextureDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "loadTextureDepth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.OnWorldFullyLoaded
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AProjectionSymbol_BP_C::OnWorldFullyLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "OnWorldFullyLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.SetState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStateA                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AProjectionSymbol_BP_C::SetState(bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "SetState");

	Params::ProjectionSymbol_BP_C_SetState Parms{};

	Parms.bStateA = bStateA;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.PostDuplicated
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           DuplicationParent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AProjectionSymbol_BP_C::PostDuplicated(class AActor* DuplicationParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "PostDuplicated");

	Params::ProjectionSymbol_BP_C_PostDuplicated Parms{};

	Parms.DuplicationParent = DuplicationParent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.OnEditorPostLoad
// (Event, Public, BlueprintEvent)

void AProjectionSymbol_BP_C::OnEditorPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "OnEditorPostLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.TestForceActive
// (Event, Public, BlueprintEvent)

void AProjectionSymbol_BP_C::TestForceActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "TestForceActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.TestForceNextClue
// (Event, Public, BlueprintEvent)

void AProjectionSymbol_BP_C::TestForceNextClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "TestForceNextClue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.TestForceInactive
// (Event, Public, BlueprintEvent)

void AProjectionSymbol_BP_C::TestForceInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "TestForceInactive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.ExecuteUbergraph_ProjectionSymbol_BP
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AProjectionSymbol_BP_C::ExecuteUbergraph_ProjectionSymbol_BP(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "ExecuteUbergraph_ProjectionSymbol_BP");

	Params::ProjectionSymbol_BP_C_ExecuteUbergraph_ProjectionSymbol_BP Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsRandomStateSet
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsRandomStateSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsRandomStateSet");

	Params::ProjectionSymbol_BP_C_IsRandomStateSet Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsStateA
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsStateA() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsStateA");

	Params::ProjectionSymbol_BP_C_IsStateA Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.ShouldBeIgnoredForLots
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::ShouldBeIgnoredForLots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "ShouldBeIgnoredForLots");

	Params::ProjectionSymbol_BP_C_ShouldBeIgnoredForLots Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetObjectiveTypeIndex
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 AProjectionSymbol_BP_C::GetObjectiveTypeIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetObjectiveTypeIndex");

	Params::ProjectionSymbol_BP_C_GetObjectiveTypeIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetPerfectPlayerLocation
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector AProjectionSymbol_BP_C::GetPerfectPlayerLocation(class ARBPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetPerfectPlayerLocation");

	Params::ProjectionSymbol_BP_C_GetPerfectPlayerLocation Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsDoorFullyClosed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBDoor*                          Door                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsDoorFullyClosed(class ARBDoor* Door) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsDoorFullyClosed");

	Params::ProjectionSymbol_BP_C_IsDoorFullyClosed Parms{};

	Parms.Door = Door;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsDoorFullyOpen
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBDoor*                          Door                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsDoorFullyOpen(class ARBDoor* Door) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsDoorFullyOpen");

	Params::ProjectionSymbol_BP_C_IsDoorFullyOpen Parms{};

	Parms.Door = Door;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.DoorAllowDecoding
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class ARBDoor*                          Door                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EProjectionSymbolExclusionState         Condition                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDecodingAvailable                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AProjectionSymbol_BP_C::DoorAllowDecoding(class ARBDoor* Door, EProjectionSymbolExclusionState Condition, bool* bDecodingAvailable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "DoorAllowDecoding");

	Params::ProjectionSymbol_BP_C_DoorAllowDecoding Parms{};

	Parms.Door = Door;
	Parms.Condition = Condition;

	UObject::ProcessEvent(Func, &Parms);

	if (bDecodingAvailable != nullptr)
		*bDecodingAvailable = Parms.bDecodingAvailable;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsFullyDecodable
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsFullyDecodable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsFullyDecodable");

	Params::ProjectionSymbol_BP_C_IsFullyDecodable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.IsDecodableEnabled
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AProjectionSymbol_BP_C::IsDecodableEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "IsDecodableEnabled");

	Params::ProjectionSymbol_BP_C_IsDecodableEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetProjectionForward
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          EyeLocation                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EyeForward                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector AProjectionSymbol_BP_C::GetProjectionForward(const struct FVector& EyeLocation, const struct FVector& EyeForward) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetProjectionForward");

	Params::ProjectionSymbol_BP_C_GetProjectionForward Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.EyeForward = std::move(EyeForward);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetProjectionOrigin
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          EyeLocation                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EyeForward                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector AProjectionSymbol_BP_C::GetProjectionOrigin(const struct FVector& EyeLocation, const struct FVector& EyeForward) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetProjectionOrigin");

	Params::ProjectionSymbol_BP_C_GetProjectionOrigin Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.EyeForward = std::move(EyeForward);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetCode
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 AProjectionSymbol_BP_C::GetCode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetCode");

	Params::ProjectionSymbol_BP_C_GetCode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectionSymbol_BP.ProjectionSymbol_BP_C.GetDecoderProximity
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDecoderProximityType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

EDecoderProximityType AProjectionSymbol_BP_C::GetDecoderProximity(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectionSymbol_BP_C", "GetDecoderProximity");

	Params::ProjectionSymbol_BP_C_GetDecoderProximity Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

