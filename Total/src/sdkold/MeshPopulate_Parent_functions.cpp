#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MeshPopulate_Parent

#include "Basic.hpp"

#include "MeshPopulate_Parent_classes.hpp"
#include "MeshPopulate_Parent_parameters.hpp"


namespace SDK
{

// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PresetMaterials
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInterface*>       TargetArray                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EGrayBoxMat_ENU                         Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PresetMaterials(const TArray<class UMaterialInterface*>& TargetArray, EGrayBoxMat_ENU Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PresetMaterials");

	Params::MeshPopulate_Parent_C_PresetMaterials Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SelectRandomMesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleAlternativeMeshData>ArrayMeshAlternatif                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UStaticMesh*                      _Mesh1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      Mesh                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MeshOffset                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SelectRandomMesh(TArray<struct FModuleAlternativeMeshData>& ArrayMeshAlternatif, class UStaticMesh* _Mesh1, class UStaticMesh** Mesh, struct FVector2D* MeshOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SelectRandomMesh");

	Params::MeshPopulate_Parent_C_SelectRandomMesh Parms{};

	Parms.ArrayMeshAlternatif = std::move(ArrayMeshAlternatif);
	Parms._Mesh1 = _Mesh1;

	UObject::ProcessEvent(Func, &Parms);

	ArrayMeshAlternatif = std::move(Parms.ArrayMeshAlternatif);

	if (Mesh != nullptr)
		*Mesh = Parms.Mesh;

	if (MeshOffset != nullptr)
		*MeshOffset = std::move(Parms.MeshOffset);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetStaticMeshSet
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      NewMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseOverwriteMaterial                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteLightmap                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   DrawDistance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetStaticMeshSet(class UStaticMeshComponent* Target, class UStaticMesh* NewMesh, bool UseOverwriteMaterial, bool UseOverwriteLightmap, float DrawDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetStaticMeshSet");

	Params::MeshPopulate_Parent_C_SetStaticMeshSet Parms{};

	Parms.Target = Target;
	Parms.NewMesh = NewMesh;
	Parms.UseOverwriteMaterial = UseOverwriteMaterial;
	Parms.UseOverwriteLightmap = UseOverwriteLightmap;
	Parms.DrawDistance = DrawDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PrintError
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::PrintError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PrintError");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.UseShadowMask
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ShadowMeshScale                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EMeshPopulateDirection                  Param_XY                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ShadowMeshLocation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::UseShadowMask(const struct FVector& ShadowMeshScale, EMeshPopulateDirection Param_XY, const struct FVector& ShadowMeshLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "UseShadowMask");

	Params::MeshPopulate_Parent_C_UseShadowMask Parms{};

	Parms.ShadowMeshScale = std::move(ShadowMeshScale);
	Parms.Param_XY = Param_XY;
	Parms.ShadowMeshLocation = std::move(ShadowMeshLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetMaterials
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetMaterials(class UPrimitiveComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetMaterials");

	Params::MeshPopulate_Parent_C_SetMaterials Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetGizmoLimit
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetGizmoLimit(EMeshPopulateDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetGizmoLimit");

	Params::MeshPopulate_Parent_C_SetGizmoLimit Parms{};

	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetGizmo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::SetGizmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetGizmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetScaleGroup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_Scale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NewSize                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetScaleGroup(struct FVector* Param_Scale, struct FVector* NewSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetScaleGroup");

	Params::MeshPopulate_Parent_C_SetScaleGroup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Scale != nullptr)
		*Param_Scale = std::move(Parms.Param_Scale);

	if (NewSize != nullptr)
		*NewSize = std::move(Parms.NewSize);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.MaximumGroupHeight
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshDataMinus02>   GroupArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AlphaMin                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AlphaMax                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BetaMin                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BetaMax                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::MaximumGroupHeight(TArray<struct FModuleMeshDataMinus02>& GroupArray, EMeshPopulateDirection Direction, float* AlphaMin, float* AlphaMax, float* BetaMin, float* BetaMax, struct FVector* Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "MaximumGroupHeight");

	Params::MeshPopulate_Parent_C_MaximumGroupHeight Parms{};

	Parms.GroupArray = std::move(GroupArray);
	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	GroupArray = std::move(Parms.GroupArray);

	if (AlphaMin != nullptr)
		*AlphaMin = Parms.AlphaMin;

	if (AlphaMax != nullptr)
		*AlphaMax = Parms.AlphaMax;

	if (BetaMin != nullptr)
		*BetaMin = Parms.BetaMin;

	if (BetaMax != nullptr)
		*BetaMax = Parms.BetaMax;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PopulateSurface
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshDataMinus02>   MeshesArray                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    UseMeshSecondSizeAdd                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   GapBetweenRow                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         OffsetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Param_Scale                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseXScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseYScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseZScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Inverted                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ZInverted                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ResetAlphaLocation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ResetBetaLocation                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    SwitchMeshOrientation                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteMaterial                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteLightmap                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   MaxNumberOfRow                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OverwriteBetaScale                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LastLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxSecondSize                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SecondScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FStaticmeshArray_Stuc>    AllStactimeshes                                        (Parm, OutParm, ContainsInstancedReference)
// int32                                   RowCount                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LastAlphaMeshSize                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AlphaScale                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PopulateSurface(TArray<struct FModuleMeshDataMinus02>& MeshesArray, bool UseMeshSecondSizeAdd, float GapBetweenRow, EMeshPopulateDirection Direction, const struct FVector& SizeLeft, const struct FVector& Offset, const struct FRotator& OffsetRotation, const struct FVector& Param_Scale, bool UseXScale, bool UseYScale, bool UseZScale, bool Inverted, bool ZInverted, bool ResetAlphaLocation, bool ResetBetaLocation, bool SwitchMeshOrientation, bool UseOverwriteMaterial, bool UseOverwriteLightmap, int32 MaxNumberOfRow, float OverwriteBetaScale, struct FVector* LastLocation, float* MaxSecondSize, float* SecondScale, TArray<struct FStaticmeshArray_Stuc>* AllStactimeshes, int32* RowCount, float* LastAlphaMeshSize, float* AlphaScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PopulateSurface");

	Params::MeshPopulate_Parent_C_PopulateSurface Parms{};

	Parms.MeshesArray = std::move(MeshesArray);
	Parms.UseMeshSecondSizeAdd = UseMeshSecondSizeAdd;
	Parms.GapBetweenRow = GapBetweenRow;
	Parms.Direction = Direction;
	Parms.SizeLeft = std::move(SizeLeft);
	Parms.Offset = std::move(Offset);
	Parms.OffsetRotation = std::move(OffsetRotation);
	Parms.Param_Scale = std::move(Param_Scale);
	Parms.UseXScale = UseXScale;
	Parms.UseYScale = UseYScale;
	Parms.UseZScale = UseZScale;
	Parms.Inverted = Inverted;
	Parms.ZInverted = ZInverted;
	Parms.ResetAlphaLocation = ResetAlphaLocation;
	Parms.ResetBetaLocation = ResetBetaLocation;
	Parms.SwitchMeshOrientation = SwitchMeshOrientation;
	Parms.UseOverwriteMaterial = UseOverwriteMaterial;
	Parms.UseOverwriteLightmap = UseOverwriteLightmap;
	Parms.MaxNumberOfRow = MaxNumberOfRow;
	Parms.OverwriteBetaScale = OverwriteBetaScale;

	UObject::ProcessEvent(Func, &Parms);

	MeshesArray = std::move(Parms.MeshesArray);

	if (LastLocation != nullptr)
		*LastLocation = std::move(Parms.LastLocation);

	if (MaxSecondSize != nullptr)
		*MaxSecondSize = Parms.MaxSecondSize;

	if (SecondScale != nullptr)
		*SecondScale = Parms.SecondScale;

	if (AllStactimeshes != nullptr)
		*AllStactimeshes = std::move(Parms.AllStactimeshes);

	if (RowCount != nullptr)
		*RowCount = Parms.RowCount;

	if (LastAlphaMeshSize != nullptr)
		*LastAlphaMeshSize = Parms.LastAlphaMeshSize;

	if (AlphaScale != nullptr)
		*AlphaScale = Parms.AlphaScale;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.MaximumHeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshData>          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   _MaxHeight1                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BiggestMeshSize                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SmallerMeshSize                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::MaximumHeight(TArray<struct FModuleMeshData>& Array, float _MaxHeight1, float* Height, float* BiggestMeshSize, float* SmallerMeshSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "MaximumHeight");

	Params::MeshPopulate_Parent_C_MaximumHeight Parms{};

	Parms.Array = std::move(Array);
	Parms._MaxHeight1 = _MaxHeight1;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Height != nullptr)
		*Height = Parms.Height;

	if (BiggestMeshSize != nullptr)
		*BiggestMeshSize = Parms.BiggestMeshSize;

	if (SmallerMeshSize != nullptr)
		*SmallerMeshSize = Parms.SmallerMeshSize;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PopulateRow
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMeshPopulateDirection                  Selection                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FModuleMeshData>          MeshArray                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   AlphaSizeLeft                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_Scale                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Inverted                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ZInverted                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseXScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseYScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseZScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ResetAlphaLocation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         OffsetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    SwitchMeshOrientation                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteMaterial                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteLightmap                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseScale                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BetaScale                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LastLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UStaticMeshComponent*>     StaticmeshComponents1                                  (Parm, OutParm, ContainsInstancedReference)
// float                                   LastAlphaMeshSize                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AlphaScale                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PopulateRow(EMeshPopulateDirection Selection, TArray<struct FModuleMeshData>& MeshArray, float AlphaSizeLeft, const struct FVector& Offset, const struct FVector& Param_Scale, bool Inverted, bool ZInverted, bool UseXScale, bool UseYScale, bool UseZScale, bool ResetAlphaLocation, const struct FRotator& OffsetRotation, bool SwitchMeshOrientation, bool UseOverwriteMaterial, bool UseOverwriteLightmap, bool UseScale, float BetaScale, struct FVector* LastLocation, TArray<class UStaticMeshComponent*>* StaticmeshComponents1, float* LastAlphaMeshSize, float* AlphaScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PopulateRow");

	Params::MeshPopulate_Parent_C_PopulateRow Parms{};

	Parms.Selection = Selection;
	Parms.MeshArray = std::move(MeshArray);
	Parms.AlphaSizeLeft = AlphaSizeLeft;
	Parms.Offset = std::move(Offset);
	Parms.Param_Scale = std::move(Param_Scale);
	Parms.Inverted = Inverted;
	Parms.ZInverted = ZInverted;
	Parms.UseXScale = UseXScale;
	Parms.UseYScale = UseYScale;
	Parms.UseZScale = UseZScale;
	Parms.ResetAlphaLocation = ResetAlphaLocation;
	Parms.OffsetRotation = std::move(OffsetRotation);
	Parms.SwitchMeshOrientation = SwitchMeshOrientation;
	Parms.UseOverwriteMaterial = UseOverwriteMaterial;
	Parms.UseOverwriteLightmap = UseOverwriteLightmap;
	Parms.UseScale = UseScale;
	Parms.BetaScale = BetaScale;

	UObject::ProcessEvent(Func, &Parms);

	MeshArray = std::move(Parms.MeshArray);

	if (LastLocation != nullptr)
		*LastLocation = std::move(Parms.LastLocation);

	if (StaticmeshComponents1 != nullptr)
		*StaticmeshComponents1 = std::move(Parms.StaticmeshComponents1);

	if (LastAlphaMeshSize != nullptr)
		*LastAlphaMeshSize = Parms.LastAlphaMeshSize;

	if (AlphaScale != nullptr)
		*AlphaScale = Parms.AlphaScale;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.NumOfMesh
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Param_MeshSize                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Num                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewSizeLeft                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::NumOfMesh(float Param_MeshSize, float SizeLeft, int32* Num, float* NewSizeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "NumOfMesh");

	Params::MeshPopulate_Parent_C_NumOfMesh Parms{};

	Parms.Param_MeshSize = Param_MeshSize;
	Parms.SizeLeft = SizeLeft;

	UObject::ProcessEvent(Func, &Parms);

	if (Num != nullptr)
		*Num = Parms.Num;

	if (NewSizeLeft != nullptr)
		*NewSizeLeft = Parms.NewSizeLeft;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PopulateStaticMesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FModuleMeshData                  Mesh01                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FRotator                         OffsetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Inverted                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    SwitchMeshOrientation                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteMaterial                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteLightmap                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Param_Location                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             OutputPin                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PopulateStaticMesh(EMeshPopulateDirection Direction, const struct FModuleMeshData& Mesh01, const struct FRotator& OffsetRotation, bool Inverted, bool SwitchMeshOrientation, bool UseOverwriteMaterial, bool UseOverwriteLightmap, float Param_Location, class UStaticMeshComponent** OutputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PopulateStaticMesh");

	Params::MeshPopulate_Parent_C_PopulateStaticMesh Parms{};

	Parms.Direction = Direction;
	Parms.Mesh01 = std::move(Mesh01);
	Parms.OffsetRotation = std::move(OffsetRotation);
	Parms.Inverted = Inverted;
	Parms.SwitchMeshOrientation = SwitchMeshOrientation;
	Parms.UseOverwriteMaterial = UseOverwriteMaterial;
	Parms.UseOverwriteLightmap = UseOverwriteLightmap;
	Parms.Param_Location = Param_Location;

	UObject::ProcessEvent(Func, &Parms);

	if (OutputPin != nullptr)
		*OutputPin = Parms.OutputPin;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshData>          MeshArray                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EMeshPopulateDirection                  Selection                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Size                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HeightDelete                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetScale(TArray<struct FModuleMeshData>& MeshArray, EMeshPopulateDirection Selection, const struct FVector& Size, float HeightDelete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetScale");

	Params::MeshPopulate_Parent_C_SetScale Parms{};

	Parms.MeshArray = std::move(MeshArray);
	Parms.Selection = Selection;
	Parms.Size = std::move(Size);
	Parms.HeightDelete = HeightDelete;

	UObject::ProcessEvent(Func, &Parms);

	MeshArray = std::move(Parms.MeshArray);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.BP_PrepareMapCheck
// (Event, Public, BlueprintEvent)

void AMeshPopulate_Parent_C::BP_PrepareMapCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "BP_PrepareMapCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.OnPostActorsPasted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   PastedActors                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AMeshPopulate_Parent_C::OnPostActorsPasted(const TArray<class AActor*>& PastedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "OnPostActorsPasted");

	Params::MeshPopulate_Parent_C_OnPostActorsPasted Parms{};

	Parms.PastedActors = std::move(PastedActors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PostAddedToLevel
// (Event, Public, BlueprintEvent)

void AMeshPopulate_Parent_C::PostAddedToLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PostAddedToLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PostDuplicated
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           DuplicationParent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PostDuplicated(class AActor* DuplicationParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PostDuplicated");

	Params::MeshPopulate_Parent_C_PostDuplicated Parms{};

	Parms.DuplicationParent = DuplicationParent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PostEditMove
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFinished                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMeshPopulate_Parent_C::PostEditMove(bool bFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PostEditMove");

	Params::MeshPopulate_Parent_C_PostEditMove Parms{};

	Parms.bFinished = bFinished;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.TickSelected
// (Event, Public, BlueprintEvent)

void AMeshPopulate_Parent_C::TickSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "TickSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PostEditChange
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             PropertyName                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PostEditChange(const class FName& PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PostEditChange");

	Params::MeshPopulate_Parent_C_PostEditChange Parms{};

	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.OnEditorPostLoad
// (Event, Public, BlueprintEvent)

void AMeshPopulate_Parent_C::OnEditorPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "OnEditorPostLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.ExecuteUbergraph_MeshPopulate_Parent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::ExecuteUbergraph_MeshPopulate_Parent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "ExecuteUbergraph_MeshPopulate_Parent");

	Params::MeshPopulate_Parent_C_ExecuteUbergraph_MeshPopulate_Parent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.BP_MapCheck
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMapCheckType                           CheckType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           OutErrorMsg                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AMeshPopulate_Parent_C::BP_MapCheck(EMapCheckType CheckType, class FString* OutErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "BP_MapCheck");

	Params::MeshPopulate_Parent_C_BP_MapCheck Parms{};

	Parms.CheckType = CheckType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutErrorMsg != nullptr)
		*OutErrorMsg = std::move(Parms.OutErrorMsg);

	return Parms.ReturnValue;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.FixUp
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AMeshPopulate_Parent_C::FixUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "FixUp");

	Params::MeshPopulate_Parent_C_FixUp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.HasStaticMeshCollision
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMeshPopulate_Parent_C::HasStaticMeshCollision(bool* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "HasStaticMeshCollision");

	Params::MeshPopulate_Parent_C_HasStaticMeshCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.CreateBoxCollisionForBounds3
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::CreateBoxCollisionForBounds3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "CreateBoxCollisionForBounds3");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.CreateBoxCollisionForBounds
// (Public, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::CreateBoxCollisionForBounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "CreateBoxCollisionForBounds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.GetCollisionOverride
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Default                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Override                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NewVector                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::GetCollisionOverride(const struct FVector& Default, const struct FVector& Override, struct FVector* NewVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "GetCollisionOverride");

	Params::MeshPopulate_Parent_C_GetCollisionOverride Parms{};

	Parms.Default = std::move(Default);
	Parms.Override = std::move(Override);

	UObject::ProcessEvent(Func, &Parms);

	if (NewVector != nullptr)
		*NewVector = std::move(Parms.NewVector);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.GetComponentBoundsVertices
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Extent                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Out_BoundingVertices                                   (Parm, OutParm)

void AMeshPopulate_Parent_C::GetComponentBoundsVertices(const struct FVector& Extent, TArray<struct FVector>* Out_BoundingVertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "GetComponentBoundsVertices");

	Params::MeshPopulate_Parent_C_GetComponentBoundsVertices Parms{};

	Parms.Extent = std::move(Extent);

	UObject::ProcessEvent(Func, &Parms);

	if (Out_BoundingVertices != nullptr)
		*Out_BoundingVertices = std::move(Parms.Out_BoundingVertices);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.GetCollisionBoxExtent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  BoundsVertices                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Out_Min                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Out_Max                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::GetCollisionBoxExtent(TArray<struct FVector>& BoundsVertices, struct FVector* Out_Min, struct FVector* Out_Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "GetCollisionBoxExtent");

	Params::MeshPopulate_Parent_C_GetCollisionBoxExtent Parms{};

	Parms.BoundsVertices = std::move(BoundsVertices);

	UObject::ProcessEvent(Func, &Parms);

	BoundsVertices = std::move(Parms.BoundsVertices);

	if (Out_Min != nullptr)
		*Out_Min = std::move(Parms.Out_Min);

	if (Out_Max != nullptr)
		*Out_Max = std::move(Parms.Out_Max);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetBoxCollisionSettings
// (Public, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::SetBoxCollisionSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetBoxCollisionSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PrintAllUsedMeshes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::PrintAllUsedMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PrintAllUsedMeshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.ApplyPhysicalMaterialToBoxComponent
// (Public, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::ApplyPhysicalMaterialToBoxComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "ApplyPhysicalMaterialToBoxComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetExcludedStaticMeshComponents
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UStaticMesh*>              StaticmeshComponents                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AMeshPopulate_Parent_C::SetExcludedStaticMeshComponents(TArray<class UStaticMesh*>& StaticmeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetExcludedStaticMeshComponents");

	Params::MeshPopulate_Parent_C_SetExcludedStaticMeshComponents Parms{};

	Parms.StaticmeshComponents = std::move(StaticmeshComponents);

	UObject::ProcessEvent(Func, &Parms);

	StaticmeshComponents = std::move(Parms.StaticmeshComponents);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetLoadedOnServerAndCollisions
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::SetLoadedOnServerAndCollisions(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetLoadedOnServerAndCollisions");

	Params::MeshPopulate_Parent_C_SetLoadedOnServerAndCollisions Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.GetHypothenuse
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Hypotenuse                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::GetHypothenuse(EMeshPopulateDirection Direction, float* Hypotenuse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "GetHypothenuse");

	Params::MeshPopulate_Parent_C_GetHypothenuse Parms{};

	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	if (Hypotenuse != nullptr)
		*Hypotenuse = Parms.Hypotenuse;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PushRandomSeed
// (Public, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::PushRandomSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PushRandomSeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.Warning
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::Warning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "Warning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SetSeed
// (Public, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::SetSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SetSeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.SnapGizmosOnGrid
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMeshPopulate_Parent_C::SnapGizmosOnGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "SnapGizmosOnGrid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.CheckSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Size                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SizeIsvalid                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMeshPopulate_Parent_C::CheckSize(const struct FVector& SizeLeft, EMeshPopulateDirection Direction, float Size, bool* SizeIsvalid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "CheckSize");

	Params::MeshPopulate_Parent_C_CheckSize Parms{};

	Parms.SizeLeft = std::move(SizeLeft);
	Parms.Direction = Direction;
	Parms.Size = Size;

	UObject::ProcessEvent(Func, &Parms);

	if (SizeIsvalid != nullptr)
		*SizeIsvalid = Parms.SizeIsvalid;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.Get Next Group
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshDataMinus02>   Aray                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewSizeLeft                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GroupSize                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::Get_Next_Group(TArray<struct FModuleMeshDataMinus02>& Aray, float SizeLeft, int32* Param_Index, float* NewSizeLeft, float* GroupSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "Get Next Group");

	Params::MeshPopulate_Parent_C_Get_Next_Group Parms{};

	Parms.Aray = std::move(Aray);
	Parms.SizeLeft = SizeLeft;

	UObject::ProcessEvent(Func, &Parms);

	Aray = std::move(Parms.Aray);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;

	if (NewSizeLeft != nullptr)
		*NewSizeLeft = Parms.NewSizeLeft;

	if (GroupSize != nullptr)
		*GroupSize = Parms.GroupSize;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.MinGroupSize
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshDataMinus02>   Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   SmallerGroupSize                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BiggestGroupSize                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::MinGroupSize(TArray<struct FModuleMeshDataMinus02>& Array, float* SmallerGroupSize, float* BiggestGroupSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "MinGroupSize");

	Params::MeshPopulate_Parent_C_MinGroupSize Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (SmallerGroupSize != nullptr)
		*SmallerGroupSize = Parms.SmallerGroupSize;

	if (BiggestGroupSize != nullptr)
		*BiggestGroupSize = Parms.BiggestGroupSize;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.Get Next Mesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshData>          Aray                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewSizeLeft                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param_MeshSize                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::Get_Next_Mesh(TArray<struct FModuleMeshData>& Aray, float SizeLeft, int32* Param_Index, float* NewSizeLeft, float* Param_MeshSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "Get Next Mesh");

	Params::MeshPopulate_Parent_C_Get_Next_Mesh Parms{};

	Parms.Aray = std::move(Aray);
	Parms.SizeLeft = SizeLeft;

	UObject::ProcessEvent(Func, &Parms);

	Aray = std::move(Parms.Aray);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;

	if (NewSizeLeft != nullptr)
		*NewSizeLeft = Parms.NewSizeLeft;

	if (Param_MeshSize != nullptr)
		*Param_MeshSize = Parms.Param_MeshSize;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.PushStaticMesh
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param_Location                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FModuleMeshData                  Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Inverted                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteMaterial                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseOverwriteLightmap                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UStaticMeshComponent*             StaticMeshComponant                                    (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::PushStaticMesh(EMeshPopulateDirection Direction, float Param_Location, const struct FModuleMeshData& Mesh, bool Inverted, bool UseOverwriteMaterial, bool UseOverwriteLightmap, class UStaticMeshComponent** StaticMeshComponant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "PushStaticMesh");

	Params::MeshPopulate_Parent_C_PushStaticMesh Parms{};

	Parms.Direction = Direction;
	Parms.Param_Location = Param_Location;
	Parms.Mesh = std::move(Mesh);
	Parms.Inverted = Inverted;
	Parms.UseOverwriteMaterial = UseOverwriteMaterial;
	Parms.UseOverwriteLightmap = UseOverwriteLightmap;

	UObject::ProcessEvent(Func, &Parms);

	if (StaticMeshComponant != nullptr)
		*StaticMeshComponant = Parms.StaticMeshComponant;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.MinMeshSize
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshData>          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   SmallerMeshSize                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::MinMeshSize(TArray<struct FModuleMeshData>& Array, float* SmallerMeshSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "MinMeshSize");

	Params::MeshPopulate_Parent_C_MinMeshSize Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (SmallerMeshSize != nullptr)
		*SmallerMeshSize = Parms.SmallerMeshSize;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.FindClosestMeshSize
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshData>          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   SizeLeft                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::FindClosestMeshSize(TArray<struct FModuleMeshData>& Array, float SizeLeft, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "FindClosestMeshSize");

	Params::MeshPopulate_Parent_C_FindClosestMeshSize Parms{};

	Parms.Array = std::move(Array);
	Parms.SizeLeft = SizeLeft;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function MeshPopulate_Parent.MeshPopulate_Parent_C.CheckMeshSize
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FModuleMeshDataMinus02>   Meshes                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EMeshPopulateDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMeshPopulate_Parent_C::CheckMeshSize(TArray<struct FModuleMeshDataMinus02>& Meshes, EMeshPopulateDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshPopulate_Parent_C", "CheckMeshSize");

	Params::MeshPopulate_Parent_C_CheckMeshSize Parms{};

	Parms.Meshes = std::move(Meshes);
	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	Meshes = std::move(Parms.Meshes);
}

}

