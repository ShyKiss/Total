#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OPP

#include "Basic.hpp"

#include "OPP_classes.hpp"
#include "OPP_parameters.hpp"


namespace SDK
{

// Function OPP.RBActiveSkill.Event_DisplayDebugInfo
// (Event, Public, BlueprintEvent)

void ARBActiveSkill::Event_DisplayDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_DisplayDebugInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBActiveSkill.Event_OnEnterSkillLimiterZone
// (Event, Public, BlueprintEvent)

void ARBActiveSkill::Event_OnEnterSkillLimiterZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnEnterSkillLimiterZone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBActiveSkill.Event_OnExitSkillLimiterZone
// (Event, Public, BlueprintEvent)

void ARBActiveSkill::Event_OnExitSkillLimiterZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnExitSkillLimiterZone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBActiveSkill.Event_OnForceDeactivatedEffectTriggered
// (Event, Public, BlueprintEvent)

void ARBActiveSkill::Event_OnForceDeactivatedEffectTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnForceDeactivatedEffectTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBActiveSkill.Event_OnIsActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkill::Event_OnIsActiveChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnIsActiveChanged");

	Params::RBActiveSkill_Event_OnIsActiveChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkill.Event_OnIsInCooldownChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsInCooldown                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkill::Event_OnIsInCooldownChanged(bool IsInCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnIsInCooldownChanged");

	Params::RBActiveSkill_Event_OnIsInCooldownChanged Parms{};

	Parms.IsInCooldown = IsInCooldown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkill.Event_OnPlayerInitReplicated
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkill::Event_OnPlayerInitReplicated(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "Event_OnPlayerInitReplicated");

	Params::RBActiveSkill_Event_OnPlayerInitReplicated Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkill.OnActiveSkillCooldownChanged
// (Final, Native, Private)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkill::OnActiveSkillCooldownChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "OnActiveSkillCooldownChanged");

	Params::RBActiveSkill_OnActiveSkillCooldownChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkill.OnRep_IsActive
// (Final, Native, Public)

void ARBActiveSkill::OnRep_IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "OnRep_IsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkill.OnRep_IsInCooldown
// (Final, Native, Public)

void ARBActiveSkill::OnRep_IsInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "OnRep_IsInCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkill.BP_CanUseSkillInLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBActiveSkill::BP_CanUseSkillInLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "BP_CanUseSkillInLocation");

	Params::RBActiveSkill_BP_CanUseSkillInLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.BP_GetEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBActiveSkill::BP_GetEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "BP_GetEffect");

	Params::RBActiveSkill_BP_GetEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.BP_GetEffectDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBActiveSkill::BP_GetEffectDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "BP_GetEffectDuration");

	Params::RBActiveSkill_BP_GetEffectDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.BP_GetTotalCooldownTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBActiveSkill::BP_GetTotalCooldownTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "BP_GetTotalCooldownTime");

	Params::RBActiveSkill_BP_GetTotalCooldownTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.BP_IsSkillUsageDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBActiveSkill::BP_IsSkillUsageDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "BP_IsSkillUsageDisabled");

	Params::RBActiveSkill_BP_IsSkillUsageDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.GetControllerItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBActiveSkillController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBActiveSkillController* ARBActiveSkill::GetControllerItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "GetControllerItem");

	Params::RBActiveSkill_GetControllerItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.GetCooldownRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBActiveSkill::GetCooldownRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "GetCooldownRatio");

	Params::RBActiveSkill_GetCooldownRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkill.GetCooldownTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBActiveSkill::GetCooldownTimeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkill", "GetCooldownTimeRemaining");

	Params::RBActiveSkill_GetCooldownTimeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUserWidget.AddToGameViewport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUserWidget::AddToGameViewport(int32 ZOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUserWidget", "AddToGameViewport");

	Params::RBUserWidget_AddToGameViewport Parms{};

	Parms.ZOrder = ZOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUserWidget.BP_SplitMessageToMultipleLines
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> URBUserWidget::BP_SplitMessageToMultipleLines(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUserWidget", "BP_SplitMessageToMultipleLines");

	Params::RBUserWidget_BP_SplitMessageToMultipleLines Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUserWidget.Event_InputSourceChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUserWidget::Event_InputSourceChanged(bool bIsGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUserWidget", "Event_InputSourceChanged");

	Params::RBUserWidget_Event_InputSourceChanged Parms{};

	Parms.bIsGamepad = bIsGamepad;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBUserWidget.RemoveFromGameViewport
// (Final, Native, Public, BlueprintCallable)

void URBUserWidget::RemoveFromGameViewport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUserWidget", "RemoveFromGameViewport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUserWidget.BP_IsUsingGamepad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUserWidget::BP_IsUsingGamepad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUserWidget", "BP_IsUsingGamepad");

	Params::RBUserWidget_BP_IsUsingGamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.Event_Refresh
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBOverheadVoiceChatWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBOverheadVoiceChatWidget.Init
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBOverheadVoiceChatWidget::Init(const struct FProfileId& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "Init");

	Params::RBOverheadVoiceChatWidget_Init Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOverheadVoiceChatWidget.OnMicrophoneVolumeChanged
// (Final, Native, Private)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBOverheadVoiceChatWidget::OnMicrophoneVolumeChanged(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "OnMicrophoneVolumeChanged");

	Params::RBOverheadVoiceChatWidget_OnMicrophoneVolumeChanged Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOverheadVoiceChatWidget.OnPlayerVoiceChatVolumeChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBOverheadVoiceChatWidget::OnPlayerVoiceChatVolumeChanged(const struct FProfileId& ProfileId, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "OnPlayerVoiceChatVolumeChanged");

	Params::RBOverheadVoiceChatWidget_OnPlayerVoiceChatVolumeChanged Parms{};

	Parms.ProfileId = std::move(ProfileId);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::HasVoiceChatEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "HasVoiceChatEnabled");

	Params::RBOverheadVoiceChatWidget_HasVoiceChatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatPrivilege
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::HasVoiceChatPrivilege() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "HasVoiceChatPrivilege");

	Params::RBOverheadVoiceChatWidget_HasVoiceChatPrivilege Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.IsBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "IsBlocked");

	Params::RBOverheadVoiceChatWidget_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.IsMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::IsMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "IsMuted");

	Params::RBOverheadVoiceChatWidget_IsMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.IsSpeaking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::IsSpeaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "IsSpeaking");

	Params::RBOverheadVoiceChatWidget_IsSpeaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOverheadVoiceChatWidget.IsVoiceChatConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOverheadVoiceChatWidget::IsVoiceChatConnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOverheadVoiceChatWidget", "IsVoiceChatConnected");

	Params::RBOverheadVoiceChatWidget_IsVoiceChatConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.AlignedWrapBox.AddChildWrapBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAlignedWrapBoxSlot*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAlignedWrapBoxSlot* UAlignedWrapBox::AddChildWrapBox(class UWidget* Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBox", "AddChildWrapBox");

	Params::AlignedWrapBox_AddChildWrapBox Parms{};

	Parms.Content = Content;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.AlignedWrapBox.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBox::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBox", "SetHorizontalAlignment");

	Params::AlignedWrapBox_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBox.SetInnerSlotPadding
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBox::SetInnerSlotPadding(const struct FVector2D& InPadding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBox", "SetInnerSlotPadding");

	Params::AlignedWrapBox_SetInnerSlotPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAudioManager.ExitAllVolumes
// (Final, Native, Public, BlueprintCallable)

void URBAudioManager::ExitAllVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAudioManager", "ExitAllVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBoxSlot.SetFillEmptySpace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbFillEmptySpace                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBoxSlot::SetFillEmptySpace(bool InbFillEmptySpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBoxSlot", "SetFillEmptySpace");

	Params::AlignedWrapBoxSlot_SetFillEmptySpace Parms{};

	Parms.InbFillEmptySpace = InbFillEmptySpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBoxSlot.SetFillSpanWhenLessThan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFillSpanWhenLessThan                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBoxSlot::SetFillSpanWhenLessThan(float InFillSpanWhenLessThan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBoxSlot", "SetFillSpanWhenLessThan");

	Params::AlignedWrapBoxSlot_SetFillSpanWhenLessThan Parms{};

	Parms.InFillSpanWhenLessThan = InFillSpanWhenLessThan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBoxSlot", "SetHorizontalAlignment");

	Params::AlignedWrapBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAlignedWrapBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBoxSlot", "SetPadding");

	Params::AlignedWrapBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.AlignedWrapBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlignedWrapBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlignedWrapBoxSlot", "SetVerticalAlignment");

	Params::AlignedWrapBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.BP_GetFocusedWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* URBMenuWidget::BP_GetFocusedWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_GetFocusedWidget");

	Params::RBMenuWidget_BP_GetFocusedWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuWidget.BP_MenuHidden
// (Final, Native, Public, BlueprintCallable)

void URBMenuWidget::BP_MenuHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_MenuHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.BP_Pop
// (Final, Native, Public, BlueprintCallable)

void URBMenuWidget::BP_Pop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_Pop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.BP_Push
// (Final, Native, Public, BlueprintCallable)

void URBMenuWidget::BP_Push()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_Push");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.BP_PushAndClearTransitionStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDoTransition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWidget::BP_PushAndClearTransitionStack(bool bDoTransition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_PushAndClearTransitionStack");

	Params::RBMenuWidget_BP_PushAndClearTransitionStack Parms{};

	Parms.bDoTransition = bDoTransition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.BP_SetFocusedWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          WidgetToFocus                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWidget::BP_SetFocusedWidget(class UWidget* WidgetToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "BP_SetFocusedWidget");

	Params::RBMenuWidget_BP_SetFocusedWidget Parms{};

	Parms.WidgetToFocus = WidgetToFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWidget.Event_MenuCancel_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuCancel_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuCancel_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_MenuConfirm_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuConfirm_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuConfirm_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_MenuLeftPage_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuLeftPage_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuLeftPage_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_MenuRightPage_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuRightPage_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuRightPage_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_MenuTabLeft_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuTabLeft_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuTabLeft_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_MenuTabRight_Pressed
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_MenuTabRight_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_MenuTabRight_Pressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnFocusMenu
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnFocusMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnFocusMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnHide
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnMenuSettingsModified
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnMenuSettingsModified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnMenuSettingsModified");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnMenuTutorialSeen
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnMenuTutorialSeen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnMenuTutorialSeen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnPop
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnPop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnPop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnPush
// (Event, Public, BlueprintEvent)

void URBMenuWidget::Event_OnPush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnPush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWidget.Event_OnUnfocusMenu
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldHide                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWidget::Event_OnUnfocusMenu(bool bShouldHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "Event_OnUnfocusMenu");

	Params::RBMenuWidget_Event_OnUnfocusMenu Parms{};

	Parms.bShouldHide = bShouldHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuWidget.IsMenuFocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuWidget::IsMenuFocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWidget", "IsMenuFocused");

	Params::RBMenuWidget_IsMenuFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAccountUpgradeMenuWidget.PlayMultiplayer
// (Final, Native, Public, BlueprintCallable)

void URBAccountUpgradeMenuWidget::PlayMultiplayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAccountUpgradeMenuWidget", "PlayMultiplayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAccountUpgradeMenuWidget.PlaySolo
// (Final, Native, Public, BlueprintCallable)

void URBAccountUpgradeMenuWidget::PlaySolo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAccountUpgradeMenuWidget", "PlaySolo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.BP_ExecuteTranstion
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSASTransitionZone::BP_ExecuteTranstion(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "BP_ExecuteTranstion");

	Params::RBSASTransitionZone_BP_ExecuteTranstion Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.BP_OnActivate
// (Event, Public, BlueprintEvent)

void ARBSASTransitionZone::BP_OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "BP_OnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTransitionZone.BP_OnDeactivate
// (Event, Public, BlueprintEvent)

void ARBSASTransitionZone::BP_OnDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "BP_OnDeactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTransitionZone.BP_SetActivated
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSASTransitionZone::BP_SetActivated(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "BP_SetActivated");

	Params::RBSASTransitionZone_BP_SetActivated Parms{};

	Parms.bActivated = bActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSASTransitionZone::BP_SetEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "BP_SetEnabled");

	Params::RBSASTransitionZone_BP_SetEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.Event_OnCurrentDirectionChanged
// (Event, Public, BlueprintEvent)

void ARBSASTransitionZone::Event_OnCurrentDirectionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "Event_OnCurrentDirectionChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTransitionZone.OnRep_CurrentTransitionDirection
// (Final, Native, Protected)

void ARBSASTransitionZone::OnRep_CurrentTransitionDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "OnRep_CurrentTransitionDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.OnRep_IsActive
// (Final, Native, Protected)

void ARBSASTransitionZone::OnRep_IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "OnRep_IsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTransitionZone.IsSASDoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSASTransitionZone::IsSASDoor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTransitionZone", "IsSASDoor");

	Params::RBSASTransitionZone_IsSASDoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASPlayerStartTransitionZone.BP_ExecuteTransitionOnPlayersInside
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AVolume*                          Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSASPlayerStartTransitionZone::BP_ExecuteTransitionOnPlayersInside(class AVolume* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASPlayerStartTransitionZone", "BP_ExecuteTransitionOnPlayersInside");

	Params::RBSASPlayerStartTransitionZone_BP_ExecuteTransitionOnPlayersInside Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.BP_OnConsumeItemAnimNotify
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::BP_OnConsumeItemAnimNotify(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_OnConsumeItemAnimNotify");

	Params::RBPickup_BP_OnConsumeItemAnimNotify Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.BP_OnDropItemToFloor
// (Event, Public, BlueprintEvent)

void ARBPickup::BP_OnDropItemToFloor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_OnDropItemToFloor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPickup.BP_OnInitializeRecycledItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPickup*                        OriginalItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::BP_OnInitializeRecycledItem(class ARBPickup* OriginalItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_OnInitializeRecycledItem");

	Params::RBPickup_BP_OnInitializeRecycledItem Parms{};

	Parms.OriginalItem = OriginalItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.BP_OnPlayItemAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::BP_OnPlayItemAnimation(class UAnimSequenceBase* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_OnPlayItemAnimation");

	Params::RBPickup_BP_OnPlayItemAnimation Parms{};

	Parms.Sequence = Sequence;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.BP_SetIsInteractible
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::BP_SetIsInteractible(bool Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_SetIsInteractible");

	Params::RBPickup_BP_SetIsInteractible Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.BP_TickItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::BP_TickItem(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_TickItem");

	Params::RBPickup_BP_TickItem Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.BP_UpdateDisplayMesh
// (Final, Native, Public, BlueprintCallable)

void ARBPickup::BP_UpdateDisplayMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_UpdateDisplayMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.Event_OnConsumeServer
// (Event, Public, BlueprintEvent)

void ARBPickup::Event_OnConsumeServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_OnConsumeServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPickup.Event_OnContainerChanged
// (Event, Protected, BlueprintEvent)

void ARBPickup::Event_OnContainerChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_OnContainerChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPickup.Event_OnItemHeldInHandChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bHeldInHand                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::Event_OnItemHeldInHandChanged(bool bHeldInHand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_OnItemHeldInHandChanged");

	Params::RBPickup_Event_OnItemHeldInHandChanged Parms{};

	Parms.bHeldInHand = bHeldInHand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.Event_OnPickedUp
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::Event_OnPickedUp(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_OnPickedUp");

	Params::RBPickup_Event_OnPickedUp Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.Event_OnUpdateVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldBeHidden                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::Event_OnUpdateVisibility(bool bShouldBeHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_OnUpdateVisibility");

	Params::RBPickup_Event_OnUpdateVisibility Parms{};

	Parms.bShouldBeHidden = bShouldBeHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.Event_SnapToState
// (Event, Public, BlueprintEvent)

void ARBPickup::Event_SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Event_SnapToState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPickup.Multicast_OnDropped
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::Multicast_OnDropped(class ARBPawn* Pawn, const struct FTransform& Transform, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "Multicast_OnDropped");

	Params::RBPickup_Multicast_OnDropped Parms{};

	Parms.Pawn = Pawn;
	Parms.Transform = std::move(Transform);
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnConsumeItemCancelledNotify
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnConsumeItemCancelledNotify(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnConsumeItemCancelledNotify");

	Params::RBPickup_OnConsumeItemCancelledNotify Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.OnConsumeItemNotify
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnConsumeItemNotify(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnConsumeItemNotify");

	Params::RBPickup_OnConsumeItemNotify Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.OnConsumeItemStartNotify
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnConsumeItemStartNotify(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnConsumeItemStartNotify");

	Params::RBPickup_OnConsumeItemStartNotify Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPickup.OnDoubleDoseUsedOnceChangedCallback
// (Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnDoubleDoseUsedOnceChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnDoubleDoseUsedOnceChangedCallback");

	Params::RBPickup_OnDoubleDoseUsedOnceChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnIsConsumedChangedCallback
// (Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnIsConsumedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnIsConsumedChangedCallback");

	Params::RBPickup_OnIsConsumedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnOwnerInventorySlotChangedCallback
// (Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnOwnerInventorySlotChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnOwnerInventorySlotChangedCallback");

	Params::RBPickup_OnOwnerInventorySlotChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnPawnOwnerChangedCallback
// (Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnPawnOwnerChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnPawnOwnerChangedCallback");

	Params::RBPickup_OnPawnOwnerChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnPickupTransformChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickup::OnPickupTransformChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnPickupTransformChangedCallback");

	Params::RBPickup_OnPickupTransformChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_ConsumeOutcomeProcessed
// (Final, Native, Protected)

void ARBPickup::OnRep_ConsumeOutcomeProcessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_ConsumeOutcomeProcessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_Container
// (Final, Native, Protected)

void ARBPickup::OnRep_Container()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_Container");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_ContainerPickupTransform
// (Final, Native, Protected)

void ARBPickup::OnRep_ContainerPickupTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_ContainerPickupTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_DoubleDoseUsedOnce
// (Final, Native, Protected)

void ARBPickup::OnRep_DoubleDoseUsedOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_DoubleDoseUsedOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_HasBeenPickedUp
// (Final, Native, Protected)

void ARBPickup::OnRep_HasBeenPickedUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_HasBeenPickedUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_IsConsumed
// (Final, Native, Protected)

void ARBPickup::OnRep_IsConsumed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_IsConsumed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_IsDuplicatedToPersistent
// (Final, Native, Protected)

void ARBPickup::OnRep_IsDuplicatedToPersistent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_IsDuplicatedToPersistent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_IsScheduledForDestroy
// (Final, Native, Protected)

void ARBPickup::OnRep_IsScheduledForDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_IsScheduledForDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_OwnerInventorySlot
// (Native, Protected)

void ARBPickup::OnRep_OwnerInventorySlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_OwnerInventorySlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_PawnOwner
// (Native, Protected)

void ARBPickup::OnRep_PawnOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_PawnOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.OnRep_PickupTransform
// (Final, Native, Protected)

void ARBPickup::OnRep_PickupTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "OnRep_PickupTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickup.BP_GetHoldConsumeActionProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPickup::BP_GetHoldConsumeActionProgress(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_GetHoldConsumeActionProgress");

	Params::RBPickup_BP_GetHoldConsumeActionProgress Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.BP_GetPlayerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* ARBPickup::BP_GetPlayerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_GetPlayerOwner");

	Params::RBPickup_BP_GetPlayerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.BP_IsCurrentlyEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::BP_IsCurrentlyEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_IsCurrentlyEquipped");

	Params::RBPickup_BP_IsCurrentlyEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.BP_IsPingedDisabled
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::BP_IsPingedDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "BP_IsPingedDisabled");

	Params::RBPickup_BP_IsPingedDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.CanSwapBetweenItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        OtherItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::CanSwapBetweenItem(class ARBPickup* OtherItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "CanSwapBetweenItem");

	Params::RBPickup_CanSwapBetweenItem Parms{};

	Parms.OtherItem = OtherItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.GetContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBContainer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBContainer* ARBPickup::GetContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "GetContainer");

	Params::RBPickup_GetContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.GetDisplayMesh
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* ARBPickup::GetDisplayMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "GetDisplayMesh");

	Params::RBPickup_GetDisplayMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPawn* ARBPickup::GetPawnOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "GetPawnOwner");

	Params::RBPickup_GetPawnOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.IsConsumed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::IsConsumed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "IsConsumed");

	Params::RBPickup_IsConsumed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPickup.IsItemHeldInHand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPickup::IsItemHeldInHand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickup", "IsItemHeldInHand");

	Params::RBPickup_IsItemHeldInHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActiveSkillController.Event_OnSkillActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkillController::Event_OnSkillActiveChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillController", "Event_OnSkillActiveChanged");

	Params::RBActiveSkillController_Event_OnSkillActiveChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkillController.IsSkillActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBActiveSkillController::IsSkillActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillController", "IsSkillActive");

	Params::RBActiveSkillController_IsSkillActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_CompleteSingleObjective
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::BP_CompleteSingleObjective(class ARBPawn* Player, class AActor* ObjectiveActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_CompleteSingleObjective");

	Params::RBBaseObjectiveCoordinator_BP_CompleteSingleObjective Parms{};

	Parms.Player = Player;
	Parms.ObjectiveActor = ObjectiveActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.CompleteCoordinator
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ForceCompletion                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::CompleteCoordinator(bool ForceCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "CompleteCoordinator");

	Params::RBBaseObjectiveCoordinator_CompleteCoordinator Parms{};

	Parms.ForceCompletion = ForceCompletion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.Editor_RebuildObjectiveMissionIndexes
// (Final, Native, Public)

void ARBBaseObjectiveCoordinator::Editor_RebuildObjectiveMissionIndexes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Editor_RebuildObjectiveMissionIndexes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.Event_OnCleanSingleObjectiveActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::Event_OnCleanSingleObjectiveActor(class AActor* ObjectiveActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Event_OnCleanSingleObjectiveActor");

	Params::RBBaseObjectiveCoordinator_Event_OnCleanSingleObjectiveActor Parms{};

	Parms.ObjectiveActor = ObjectiveActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBaseObjectiveCoordinator.Event_OnCoordinatorStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EObjectiveCoordinatorState              OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::Event_OnCoordinatorStateChanged(EObjectiveCoordinatorState OldState, EObjectiveCoordinatorState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Event_OnCoordinatorStateChanged");

	Params::RBBaseObjectiveCoordinator_Event_OnCoordinatorStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBaseObjectiveCoordinator.Event_OnSetupSingleObjectiveActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::Event_OnSetupSingleObjectiveActor(class AActor* ObjectiveActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Event_OnSetupSingleObjectiveActor");

	Params::RBBaseObjectiveCoordinator_Event_OnSetupSingleObjectiveActor Parms{};

	Parms.ObjectiveActor = ObjectiveActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBaseObjectiveCoordinator.FailCoordinator
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBaseObjectiveCoordinator::FailCoordinator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "FailCoordinator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.ForceRefreshObjectiveText
// (Native, Public, BlueprintCallable)

void ARBBaseObjectiveCoordinator::ForceRefreshObjectiveText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "ForceRefreshObjectiveText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleCompletedObjectiveReverted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReaddToRemainingList                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::Multicast_OnSingleCompletedObjectiveReverted(class AActor* ObjectiveActor, bool bReaddToRemainingList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Multicast_OnSingleCompletedObjectiveReverted");

	Params::RBBaseObjectiveCoordinator_Multicast_OnSingleCompletedObjectiveReverted Parms{};

	Parms.ObjectiveActor = ObjectiveActor;
	Parms.bReaddToRemainingList = bReaddToRemainingList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleObjectiveCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFinalObjective                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromRemainingList                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::Multicast_OnSingleObjectiveCompleted(class AActor* Player, class AActor* ObjectiveActor, bool IsFinalObjective, bool bRemoveFromRemainingList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "Multicast_OnSingleObjectiveCompleted");

	Params::RBBaseObjectiveCoordinator_Multicast_OnSingleObjectiveCompleted Parms{};

	Parms.Player = Player;
	Parms.ObjectiveActor = ObjectiveActor;
	Parms.IsFinalObjective = IsFinalObjective;
	Parms.bRemoveFromRemainingList = bRemoveFromRemainingList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnEndOfStage
// (Native, Protected, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsRestart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::OnEndOfStage(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool IsRestart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnEndOfStage");

	Params::RBBaseObjectiveCoordinator_OnEndOfStage Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.IsRestart = IsRestart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnFailConditionTimerElapsed
// (Final, Native, Protected)

void ARBBaseObjectiveCoordinator::OnFailConditionTimerElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnFailConditionTimerElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnRep_CoordinatorState
// (Native, Protected)
// Parameters:
// EObjectiveCoordinatorState              OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::OnRep_CoordinatorState(EObjectiveCoordinatorState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnRep_CoordinatorState");

	Params::RBBaseObjectiveCoordinator_OnRep_CoordinatorState Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnRep_CurrentObjectiveCount
// (Native, Protected)

void ARBBaseObjectiveCoordinator::OnRep_CurrentObjectiveCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnRep_CurrentObjectiveCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnRep_ObjectiveMaxCount
// (Final, Native, Protected)

void ARBBaseObjectiveCoordinator::OnRep_ObjectiveMaxCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnRep_ObjectiveMaxCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnRep_RemainingObjectives
// (Native, Protected)

void ARBBaseObjectiveCoordinator::OnRep_RemainingObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnRep_RemainingObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnRep_StartedTime
// (Final, Native, Protected)

void ARBBaseObjectiveCoordinator::OnRep_StartedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnRep_StartedTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.OnStageReady
// (Native, Protected, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "OnStageReady");

	Params::RBBaseObjectiveCoordinator_OnStageReady Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "SetEnabled");

	Params::RBBaseObjectiveCoordinator_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.StartCoordinator
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceSkipDelay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBaseObjectiveCoordinator::StartCoordinator(bool bForceSkipDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "StartCoordinator");

	Params::RBBaseObjectiveCoordinator_StartCoordinator Parms{};

	Parms.bForceSkipDelay = bForceSkipDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.StopCoordinator
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBaseObjectiveCoordinator::StopCoordinator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "StopCoordinator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_CalculateObjectiveActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_CalculateObjectiveActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_CalculateObjectiveActors");

	Params::RBBaseObjectiveCoordinator_BP_CalculateObjectiveActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetAllValidPrimaryObjectiveActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_GetAllValidPrimaryObjectiveActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetAllValidPrimaryObjectiveActors");

	Params::RBBaseObjectiveCoordinator_BP_GetAllValidPrimaryObjectiveActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetAllValidSecondaryObjectiveActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_GetAllValidSecondaryObjectiveActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetAllValidSecondaryObjectiveActors");

	Params::RBBaseObjectiveCoordinator_BP_GetAllValidSecondaryObjectiveActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetFailedSound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* ARBBaseObjectiveCoordinator::BP_GetFailedSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetFailedSound");

	Params::RBBaseObjectiveCoordinator_BP_GetFailedSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveLevelText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBBaseObjectiveCoordinator::BP_GetObjectiveLevelText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetObjectiveLevelText");

	Params::RBBaseObjectiveCoordinator_BP_GetObjectiveLevelText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::BP_GetObjectiveMaxCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetObjectiveMaxCount");

	Params::RBBaseObjectiveCoordinator_BP_GetObjectiveMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_GetRemainingObjectiveActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetRemainingObjectiveActors");

	Params::RBBaseObjectiveCoordinator_BP_GetRemainingObjectiveActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::BP_GetRemainingObjectiveCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_GetRemainingObjectiveCount");

	Params::RBBaseObjectiveCoordinator_BP_GetRemainingObjectiveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.BP_ShouldShowObjectiveInHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::BP_ShouldShowObjectiveInHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "BP_ShouldShowObjectiveInHUD");

	Params::RBBaseObjectiveCoordinator_BP_ShouldShowObjectiveInHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetCoordinatorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBBaseObjectiveCoordinator::GetCoordinatorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetCoordinatorName");

	Params::RBBaseObjectiveCoordinator_GetCoordinatorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetCurrentCompletedCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::GetCurrentCompletedCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetCurrentCompletedCount");

	Params::RBBaseObjectiveCoordinator_GetCurrentCompletedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetIntermediateObjectivesData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FIntermediateObjectiveData>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntermediateObjectiveData> ARBBaseObjectiveCoordinator::GetIntermediateObjectivesData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetIntermediateObjectivesData");

	Params::RBBaseObjectiveCoordinator_GetIntermediateObjectivesData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetMainObjectiveType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMainObjectiveType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMainObjectiveType ARBBaseObjectiveCoordinator::GetMainObjectiveType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetMainObjectiveType");

	Params::RBBaseObjectiveCoordinator_GetMainObjectiveType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetMaxCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::GetMaxCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetMaxCount");

	Params::RBBaseObjectiveCoordinator_GetMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetMaxPrimaryObjectiveCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::GetMaxPrimaryObjectiveCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetMaxPrimaryObjectiveCount");

	Params::RBBaseObjectiveCoordinator_GetMaxPrimaryObjectiveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetMaxSecondaryObjectiveCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBBaseObjectiveCoordinator::GetMaxSecondaryObjectiveCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetMaxSecondaryObjectiveCount");

	Params::RBBaseObjectiveCoordinator_GetMaxSecondaryObjectiveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.GetObjectiveWidgetIcon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ARBBaseObjectiveCoordinator::GetObjectiveWidgetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "GetObjectiveWidgetIcon");

	Params::RBBaseObjectiveCoordinator_GetObjectiveWidgetIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.HasIntermediateObjectiveText
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::HasIntermediateObjectiveText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "HasIntermediateObjectiveText");

	Params::RBBaseObjectiveCoordinator_HasIntermediateObjectiveText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "IsCompleted");

	Params::RBBaseObjectiveCoordinator_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.IsDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::IsDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "IsDisabled");

	Params::RBBaseObjectiveCoordinator_IsDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.IsFinalObjective
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::IsFinalObjective() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "IsFinalObjective");

	Params::RBBaseObjectiveCoordinator_IsFinalObjective Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.IsStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::IsStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "IsStarted");

	Params::RBBaseObjectiveCoordinator_IsStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBaseObjectiveCoordinator.IsUserFacing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBaseObjectiveCoordinator::IsUserFacing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBaseObjectiveCoordinator", "IsUserFacing");

	Params::RBBaseObjectiveCoordinator_IsUserFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveCoordinatorGroup.OnConcurrentCoordinatorStateChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBObjectiveCoordinatorGroup::OnConcurrentCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveCoordinatorGroup", "OnConcurrentCoordinatorStateChanged");

	Params::RBObjectiveCoordinatorGroup_OnConcurrentCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkillLimiterZone.OnActorEnterZone
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkillLimiterZone::OnActorEnterZone(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillLimiterZone", "OnActorEnterZone");

	Params::RBActiveSkillLimiterZone_OnActorEnterZone Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkillLimiterZone.OnActorExitZone
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkillLimiterZone::OnActorExitZone(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillLimiterZone", "OnActorExitZone");

	Params::RBActiveSkillLimiterZone_OnActorExitZone Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkillLimiterZone.OnRep_Enabled
// (Final, Native, Private)

void ARBActiveSkillLimiterZone::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillLimiterZone", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkillLimiterZone.SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBActiveSkillLimiterZone::SetEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillLimiterZone", "SetEnabled");

	Params::RBActiveSkillLimiterZone_SetEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActiveSkillVisionComponent.Event_OnActiveSkillChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActiveSkillVisionComponent::Event_OnActiveSkillChanged(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillVisionComponent", "Event_OnActiveSkillChanged");

	Params::RBActiveSkillVisionComponent_Event_OnActiveSkillChanged Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkillVisionComponent.Event_OnSeeThroughWallChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActiveSkillVisionComponent::Event_OnSeeThroughWallChanged(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillVisionComponent", "Event_OnSeeThroughWallChanged");

	Params::RBActiveSkillVisionComponent_Event_OnSeeThroughWallChanged Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActiveSkillVisionComponent.SetEnabled_Server
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActiveSkillVisionComponent::SetEnabled_Server(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActiveSkillVisionComponent", "SetEnabled_Server");

	Params::RBActiveSkillVisionComponent_SetEnabled_Server Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorGroup.AddSelectedActors
// (Final, Native, Public)

void ARBActorGroup::AddSelectedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorGroup", "AddSelectedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorGroup.CenterOnLinkedActors
// (Final, Native, Public)

void ARBActorGroup::CenterOnLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorGroup", "CenterOnLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorGroup.SelectLinkedActors
// (Final, Native, Public)

void ARBActorGroup::SelectLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorGroup", "SelectLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorGroup.GetActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AActor*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AActor*> ARBActorGroup::GetActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorGroup", "GetActors");

	Params::RBActorGroup_GetActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBActorPrevisComponent.BP_ForceUpdateVisibility
// (Final, Native, Public, BlueprintCallable)

void URBActorPrevisComponent::BP_ForceUpdateVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorPrevisComponent", "BP_ForceUpdateVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorPrevisComponent.BP_SpawnRuntimeChildActor
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBActorPrevisComponent::BP_SpawnRuntimeChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorPrevisComponent", "BP_SpawnRuntimeChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorPrevisComponent.OnRep_RuntimeChildActor
// (Final, Native, Public)

void URBActorPrevisComponent::OnRep_RuntimeChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorPrevisComponent", "OnRep_RuntimeChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBActorProximityDetectionComponent.ActorProximityDetectionComponentEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActorProximityDetectionComponent::ActorProximityDetectionComponentEvent__DelegateSignature(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorProximityDetectionComponent", "ActorProximityDetectionComponentEvent__DelegateSignature");

	Params::RBActorProximityDetectionComponent_ActorProximityDetectionComponentEvent__DelegateSignature Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActorProximityDetectionComponent.Event_OnActorEnterProximity
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActorProximityDetectionComponent::Event_OnActorEnterProximity(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorProximityDetectionComponent", "Event_OnActorEnterProximity");

	Params::RBActorProximityDetectionComponent_Event_OnActorEnterProximity Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActorProximityDetectionComponent.Event_OnActorExitProximity
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActorProximityDetectionComponent::Event_OnActorExitProximity(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorProximityDetectionComponent", "Event_OnActorExitProximity");

	Params::RBActorProximityDetectionComponent_Event_OnActorExitProximity Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBActorProximityDetectionComponent.OnPawnRegistered
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActorProximityDetectionComponent::OnPawnRegistered(class ARBPawn* RBPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorProximityDetectionComponent", "OnPawnRegistered");

	Params::RBActorProximityDetectionComponent_OnPawnRegistered Parms{};

	Parms.RBPawn = RBPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBActorProximityDetectionComponent.OnPawnUnregistered
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBActorProximityDetectionComponent::OnPawnUnregistered(class ARBPawn* RBPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBActorProximityDetectionComponent", "OnPawnUnregistered");

	Params::RBActorProximityDetectionComponent_OnPawnUnregistered Parms{};

	Parms.RBPawn = RBPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.Event_Done
// (Event, Public, BlueprintEvent)

void URBAddFriendWidget::Event_Done()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Event_Done");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAddFriendWidget.Event_Init
// (Event, Public, BlueprintEvent)

void URBAddFriendWidget::Event_Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Event_Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAddFriendWidget.Event_OnError
// (Event, Public, BlueprintEvent)

void URBAddFriendWidget::Event_OnError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Event_OnError");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAddFriendWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBAddFriendWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAddFriendWidget.Event_ResolveCompleted
// (Event, Public, BlueprintEvent)

void URBAddFriendWidget::Event_ResolveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Event_ResolveCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAddFriendWidget.Init
// (Final, Native, Public, BlueprintCallable)

void URBAddFriendWidget::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.ResolveProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendCode                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAddFriendWidget::ResolveProfile(const class FString& FriendCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "ResolveProfile");

	Params::RBAddFriendWidget_ResolveProfile Parms{};

	Parms.FriendCode = std::move(FriendCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.SendFriendRequest
// (Final, Native, Public, BlueprintCallable)

void URBAddFriendWidget::SendFriendRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "SendFriendRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.SendPlatformFriendRequest
// (Final, Native, Public, BlueprintCallable)

void URBAddFriendWidget::SendPlatformFriendRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "SendPlatformFriendRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.ShowProfile
// (Final, Native, Public, BlueprintCallable)

void URBAddFriendWidget::ShowProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "ShowProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.CanSendFriendRequest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::CanSendFriendRequest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "CanSendFriendRequest");

	Params::RBAddFriendWidget_CanSendFriendRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.CanSendPlatformFriendRequest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::CanSendPlatformFriendRequest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "CanSendPlatformFriendRequest");

	Params::RBAddFriendWidget_CanSendPlatformFriendRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.CanShowProfile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::CanShowProfile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "CanShowProfile");

	Params::RBAddFriendWidget_CanShowProfile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.CopyFriendCode
// (Final, Native, Public, BlueprintCallable, Const)

void URBAddFriendWidget::CopyFriendCode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "CopyFriendCode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAddFriendWidget.FilterFriendCodeInputText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           InputText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBAddFriendWidget::FilterFriendCodeInputText(const class FString& InputText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "FilterFriendCodeInputText");

	Params::RBAddFriendWidget_FilterFriendCodeInputText Parms{};

	Parms.InputText = std::move(InputText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.GetFriendCode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBAddFriendWidget::GetFriendCode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "GetFriendCode");

	Params::RBAddFriendWidget_GetFriendCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.GetName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBAddFriendWidget::GetName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "GetName");

	Params::RBAddFriendWidget_GetName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.GetProfilePlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfilePlatform                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfilePlatform URBAddFriendWidget::GetProfilePlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "GetProfilePlatform");

	Params::RBAddFriendWidget_GetProfilePlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.HasProfile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::HasProfile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "HasProfile");

	Params::RBAddFriendWidget_HasProfile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.IsInitialDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::IsInitialDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "IsInitialDataPending");

	Params::RBAddFriendWidget_IsInitialDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAddFriendWidget.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAddFriendWidget::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAddFriendWidget", "IsOperationPending");

	Params::RBAddFriendWidget_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeBase.RespawnPlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBController*                    RBController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerSpawnType                        SpawnType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameModeBase::RespawnPlayer(class ARBController* RBController, class AActor* StartSpot, EPlayerSpawnType SpawnType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeBase", "RespawnPlayer");

	Params::RBGameModeBase_RespawnPlayer Parms{};

	Parms.RBController = RBController;
	Parms.StartSpot = StartSpot;
	Parms.SpawnType = SpawnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeBase.GetExpectedPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBGameModeBase::GetExpectedPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeBase", "GetExpectedPlayerCount");

	Params::RBGameModeBase_GetExpectedPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractionZoneComponent.AddCompletedObjectiveRequirement
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             RequirementText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBInteractionZoneComponent::AddCompletedObjectiveRequirement(class ARBBaseObjectiveCoordinator* Coordinator, const class FText& RequirementText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "AddCompletedObjectiveRequirement");

	Params::RBInteractionZoneComponent_AddCompletedObjectiveRequirement Parms{};

	Parms.Coordinator = Coordinator;
	Parms.RequirementText = std::move(RequirementText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractionZoneComponent.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInteractible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractionZoneComponent::BP_SetEnabled(bool bInteractible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "BP_SetEnabled");

	Params::RBInteractionZoneComponent_BP_SetEnabled Parms{};

	Parms.bInteractible = bInteractible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractionZoneComponent.Event_OnEnabledChanged
// (Event, Public, BlueprintEvent)

void URBInteractionZoneComponent::Event_OnEnabledChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "Event_OnEnabledChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractionZoneComponent.GetInteractableSafe
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URBInteractionZoneComponent::GetInteractableSafe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "GetInteractableSafe");

	Params::RBInteractionZoneComponent_GetInteractableSafe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractionZoneComponent.NotifySpecialMoveCompleted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            CompletedMove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractionZoneComponent::NotifySpecialMoveCompleted(class ARBPawn* Pawn, ESpecialMove CompletedMove, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "NotifySpecialMoveCompleted");

	Params::RBInteractionZoneComponent_NotifySpecialMoveCompleted Parms{};

	Parms.Pawn = Pawn;
	Parms.CompletedMove = CompletedMove;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractionZoneComponent.OnRep_CurrentlyEnabled
// (Native, Protected)

void URBInteractionZoneComponent::OnRep_CurrentlyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "OnRep_CurrentlyEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractionZoneComponent.IsEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBInteractionZoneComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "IsEnabled");

	Params::RBInteractionZoneComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractionZoneComponent.MeetRequirements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Interactor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool URBInteractionZoneComponent::MeetRequirements(const class ARBPlayer* Interactor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractionZoneComponent", "MeetRequirements");

	Params::RBInteractionZoneComponent_MeetRequirements Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHidespotComponent.BP_DisableHidespot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBHidespotComponent::BP_DisableHidespot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "BP_DisableHidespot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.FixUpPouncer
// (Final, Native, Public)

void URBHidespotComponent::FixUpPouncer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "FixUpPouncer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.InitializeClearanceBoxes
// (Final, Native, Public, BlueprintCallable)

void URBHidespotComponent::InitializeClearanceBoxes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "InitializeClearanceBoxes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnPawnHiddenInsideChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHidespotComponent::OnPawnHiddenInsideChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnPawnHiddenInsideChangedCallback");

	Params::RBHidespotComponent_OnPawnHiddenInsideChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnPawnInteractingChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHidespotComponent::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnPawnInteractingChangedCallback");

	Params::RBHidespotComponent_OnPawnInteractingChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnRep_Disabled
// (Final, Native, Public)

void URBHidespotComponent::OnRep_Disabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnRep_Disabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnRep_PawnHiddenInside
// (Final, Native, Public)

void URBHidespotComponent::OnRep_PawnHiddenInside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnRep_PawnHiddenInside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnRep_PawnInteracting
// (Final, Native, Public)

void URBHidespotComponent::OnRep_PawnInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnRep_PawnInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.OnRep_PouncerEntered
// (Final, Native, Public)

void URBHidespotComponent::OnRep_PouncerEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "OnRep_PouncerEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHidespotComponent.IsHidespotEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHidespotComponent::IsHidespotEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHidespotComponent", "IsHidespotEnabled");

	Params::RBHidespotComponent_IsHidespotEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCondition_Blueprint.Event_EvaluateCondition
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerCondition_Blueprint::Event_EvaluateCondition(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCondition_Blueprint", "Event_EvaluateCondition");

	Params::RBPlayerCondition_Blueprint_Event_EvaluateCondition Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBBlacklightable.FadeInLightState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBlacklit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBBlacklightable::FadeInLightState(bool bBlacklit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlacklightable", "FadeInLightState");

	Params::RBBlacklightable_FadeInLightState Parms{};

	Parms.bBlacklit = bBlacklit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlacklightable.SetLightState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBlacklit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBBlacklightable::SetLightState(bool bBlacklit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlacklightable", "SetLightState");

	Params::RBBlacklightable_SetLightState Parms{};

	Parms.bBlacklit = bBlacklit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.BP_DestroyItemsInside
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBContainer::BP_DestroyItemsInside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "BP_DestroyItemsInside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.BP_ForceReset
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBContainer::BP_ForceReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "BP_ForceReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.BP_ForceSpawnForcedContent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::BP_ForceSpawnForcedContent(int32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "BP_ForceSpawnForcedContent");

	Params::RBContainer_BP_ForceSpawnForcedContent Parms{};

	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.BP_ForceSpawnItem
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBPickup>            ItemClass                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnLock                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::BP_ForceSpawnItem(const TSubclassOf<class ARBPickup>& ItemClass, bool bSpawnLock, int32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "BP_ForceSpawnItem");

	Params::RBContainer_BP_ForceSpawnItem Parms{};

	Parms.ItemClass = ItemClass;
	Parms.bSpawnLock = bSpawnLock;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Editor_AddEditorForcedItems
// (Final, Native, Public)

void ARBContainer::Editor_AddEditorForcedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Editor_AddEditorForcedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Editor_AddValidForcedItems
// (Final, Native, Public)

void ARBContainer::Editor_AddValidForcedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Editor_AddValidForcedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Editor_ClearForcedItems
// (Final, Native, Public)

void ARBContainer::Editor_ClearForcedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Editor_ClearForcedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Editor_CreateAllItemDisplayMeshes
// (Final, Native, Public)

void ARBContainer::Editor_CreateAllItemDisplayMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Editor_CreateAllItemDisplayMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Event_ItemAdded
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBContainerSpawnLocationComponent*Location                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::Event_ItemAdded(class ARBPickup* Item, int32 Param_Index, class URBContainerSpawnLocationComponent* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Event_ItemAdded");

	Params::RBContainer_Event_ItemAdded Parms{};

	Parms.Item = Item;
	Parms.Param_Index = Param_Index;
	Parms.Location = Location;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBContainer.Event_ItemPickedUp
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::Event_ItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Event_ItemPickedUp");

	Params::RBContainer_Event_ItemPickedUp Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBContainer.Event_ItemRemoved
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBContainerSpawnLocationComponent*Location                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::Event_ItemRemoved(class ARBPickup* Item, int32 Param_Index, class URBContainerSpawnLocationComponent* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Event_ItemRemoved");

	Params::RBContainer_Event_ItemRemoved Parms{};

	Parms.Item = Item;
	Parms.Param_Index = Param_Index;
	Parms.Location = Location;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBContainer.Event_PostWorldPopulated_Server
// (Event, Public, BlueprintEvent)

void ARBContainer::Event_PostWorldPopulated_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Event_PostWorldPopulated_Server");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBContainer.Event_SnapToState
// (Event, Public, BlueprintEvent)

void ARBContainer::Event_SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Event_SnapToState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBContainer.GetPickupInteractionLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBContainerSpawnLocationComponent*SpawnComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Out_location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Out_direction                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBContainer::GetPickupInteractionLocation(const class ARBPawn* Pawn, const class URBContainerSpawnLocationComponent* SpawnComponent, struct FVector* Out_location, struct FVector* Out_direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "GetPickupInteractionLocation");

	Params::RBContainer_GetPickupInteractionLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.SpawnComponent = SpawnComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_location != nullptr)
		*Out_location = std::move(Parms.Out_location);

	if (Out_direction != nullptr)
		*Out_direction = std::move(Parms.Out_direction);

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.InsideItemPickedUp
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::InsideItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "InsideItemPickedUp");

	Params::RBContainer_InsideItemPickedUp Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.Multicast_ItemPickedUp
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBContainer::Multicast_ItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "Multicast_ItemPickedUp");

	Params::RBContainer_Multicast_ItemPickedUp Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.OnRep_PopulatedState
// (Native, Protected)

void ARBContainer::OnRep_PopulatedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "OnRep_PopulatedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.OnRep_SpawnedItemInfos
// (Final, Native, Protected)

void ARBContainer::OnRep_SpawnedItemInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "OnRep_SpawnedItemInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainer.OnSpawnedItemInfosChanged
// (Event, Protected, BlueprintEvent)

void ARBContainer::OnSpawnedItemInfosChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "OnSpawnedItemInfosChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBContainer.GetItemFromSpawnLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBContainerSpawnLocationComponent*SpawnLocationComponent                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBContainer::GetItemFromSpawnLocation(const class URBContainerSpawnLocationComponent* SpawnLocationComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "GetItemFromSpawnLocation");

	Params::RBContainer_GetItemFromSpawnLocation Parms{};

	Parms.SpawnLocationComponent = SpawnLocationComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.GetItemSpawnLocationComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        ItemInContainer                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBContainerSpawnLocationComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBContainerSpawnLocationComponent* ARBContainer::GetItemSpawnLocationComponent(const class ARBPickup* ItemInContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "GetItemSpawnLocationComponent");

	Params::RBContainer_GetItemSpawnLocationComponent Parms{};

	Parms.ItemInContainer = ItemInContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.GetNumberOfSpawnedItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBContainer::GetNumberOfSpawnedItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "GetNumberOfSpawnedItems");

	Params::RBContainer_GetNumberOfSpawnedItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.GetPopulatedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EContainerPopulatedState                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EContainerPopulatedState ARBContainer::GetPopulatedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "GetPopulatedState");

	Params::RBContainer_GetPopulatedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.IsClosableContainer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBContainer::IsClosableContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "IsClosableContainer");

	Params::RBContainer_IsClosableContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.IsContainerEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBContainer::IsContainerEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "IsContainerEmpty");

	Params::RBContainer_IsContainerEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.IsLocked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBContainer::IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "IsLocked");

	Params::RBContainer_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContainer.IsOpen
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBContainer::IsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainer", "IsOpen");

	Params::RBContainer_IsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractibleContainer.Event_OnIsOpenedChanged
// (Event, Public, BlueprintEvent)

void ARBInteractibleContainer::Event_OnIsOpenedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "Event_OnIsOpenedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractibleContainer.Event_OnPanelUnlocked
// (Event, Public, BlueprintEvent)

void ARBInteractibleContainer::Event_OnPanelUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "Event_OnPanelUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractibleContainer.Event_SpawnLock
// (Event, Public, BlueprintEvent)

void ARBInteractibleContainer::Event_SpawnLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "Event_SpawnLock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractibleContainer.GivesFocusTo
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractionZoneComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBInteractionZoneComponent* ARBInteractibleContainer::GivesFocusTo(const class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "GivesFocusTo");

	Params::RBInteractibleContainer_GivesFocusTo Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractibleContainer.IsOpenedChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractibleContainer::IsOpenedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "IsOpenedChangedCallback");

	Params::RBInteractibleContainer_IsOpenedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnNumberOfProjectileHitsChanged
// (Final, Native, Public)
// Parameters:
// class URBDamageableComponent*           Damageable                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractibleContainer::OnNumberOfProjectileHitsChanged(class URBDamageableComponent* Damageable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnNumberOfProjectileHitsChanged");

	Params::RBInteractibleContainer_OnNumberOfProjectileHitsChanged Parms{};

	Parms.Damageable = Damageable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnPanelUnlocked
// (Final, Native, Public)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractibleContainer::OnPanelUnlocked(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnPanelUnlocked");

	Params::RBInteractibleContainer_OnPanelUnlocked Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnPawnInteractingChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractibleContainer::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnPawnInteractingChangedCallback");

	Params::RBInteractibleContainer_OnPawnInteractingChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnRep_IsOpened
// (Final, Native, Protected)

void ARBInteractibleContainer::OnRep_IsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnRep_IsOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnRep_LinkedLockingPanel
// (Final, Native, Protected)

void ARBInteractibleContainer::OnRep_LinkedLockingPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnRep_LinkedLockingPanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OnRep_PawnInteracting
// (Final, Native, Protected)

void ARBInteractibleContainer::OnRep_PawnInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OnRep_PawnInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.OpenContainer
// (Final, Native, Public, BlueprintCallable)

void ARBInteractibleContainer::OpenContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "OpenContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractibleContainer.SnapToState_Implementation
// (Native, Public)

void ARBInteractibleContainer::SnapToState_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractibleContainer", "SnapToState_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomizationOption.BP_GetCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<ECurrencyType, int32>              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<ECurrencyType, int32> URBCustomizationOption::BP_GetCost(const class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOption", "BP_GetCost");

	Params::RBCustomizationOption_BP_GetCost Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOption.IsAcquired
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   PlayerState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOption::IsAcquired(const class ARBPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOption", "IsAcquired");

	Params::RBCustomizationOption_IsAcquired Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOption.IsDevOption
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOption::IsDevOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOption", "IsDevOption");

	Params::RBCustomizationOption_IsDevOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOption.IsPartOfDLCContentPack
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOption::IsPartOfDLCContentPack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOption", "IsPartOfDLCContentPack");

	Params::RBCustomizationOption_IsPartOfDLCContentPack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOption.IsUnlocked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   PlayerState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOption::IsUnlocked(const class ARBPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOption", "IsUnlocked");

	Params::RBCustomizationOption_IsUnlocked Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.AddAdditionalDirectorConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBAIDirectorConfig*              DirectorConfig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::AddAdditionalDirectorConfig(class URBAIDirectorConfig* DirectorConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "AddAdditionalDirectorConfig");

	Params::RBAIBlueprintLibrary_AddAdditionalDirectorConfig Parms{};

	Parms.DirectorConfig = DirectorConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.AttachToScriptedAnimStation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ARBScriptedAnimStation*           Station                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshTarget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePlayers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                SpecificExitConditions                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::AttachToScriptedAnimStation(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, class ARBScriptedAnimStation* Station, class USkeletalMeshComponent* MeshTarget, bool bIgnorePlayers, const struct FRBAIConditionSet& SpecificExitConditions, float StartDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "AttachToScriptedAnimStation");

	Params::RBAIBlueprintLibrary_AttachToScriptedAnimStation Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Station = Station;
	Parms.MeshTarget = MeshTarget;
	Parms.bIgnorePlayers = bIgnorePlayers;
	Parms.SpecificExitConditions = std::move(SpecificExitConditions);
	Parms.StartDelay = StartDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.ClearLeash
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ClearLeash(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ClearLeash");

	Params::RBAIBlueprintLibrary_ClearLeash Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ClearScriptedCommands
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ClearScriptedCommands(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ClearScriptedCommands");

	Params::RBAIBlueprintLibrary_ClearScriptedCommands Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ClearSpecificTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ClearSpecificTarget(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ClearSpecificTarget");

	Params::RBAIBlueprintLibrary_ClearSpecificTarget Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ClearVOMapOverrides
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ClearVOMapOverrides(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ClearVOMapOverrides");

	Params::RBAIBlueprintLibrary_ClearVOMapOverrides Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.DetachFromScriptedAnimStation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::DetachFromScriptedAnimStation(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "DetachFromScriptedAnimStation");

	Params::RBAIBlueprintLibrary_DetachFromScriptedAnimStation Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.DisableAIDirector
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)

void URBAIBlueprintLibrary::DisableAIDirector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "DisableAIDirector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ExitHidingSpot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ExitHidingSpot(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ExitHidingSpot");

	Params::RBAIBlueprintLibrary_ExitHidingSpot Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ForceAttackSequence
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ForcedAnimSequence                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ForceAttackSequence(class ARBBot* bot, class UAnimSequence* ForcedAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ForceAttackSequence");

	Params::RBAIBlueprintLibrary_ForceAttackSequence Parms{};

	Parms.bot = bot;
	Parms.ForcedAnimSequence = ForcedAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ForceChaseUntilContact
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        TargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ForceChaseUntilContact(class ARBBot* bot, class ARBPlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ForceChaseUntilContact");

	Params::RBAIBlueprintLibrary_ForceChaseUntilContact Parms{};

	Parms.bot = bot;
	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ForceExecute
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ForceExecute(class ARBBot* bot, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ForceExecute");

	Params::RBAIBlueprintLibrary_ForceExecute Parms{};

	Parms.bot = bot;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ForceGasGroupAttack
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ForceGasGroupAttack(class ARBBot* bot, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ForceGasGroupAttack");

	Params::RBAIBlueprintLibrary_ForceGasGroupAttack Parms{};

	Parms.bot = bot;
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ForcePlayStartleAnimation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStartleType                            StartledType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStartleSpeed                           StartledSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WsYaw                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ForcePlayStartleAnimation(class ARBBot* bot, EStartleType StartledType, EStartleSpeed StartledSpeed, float WsYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ForcePlayStartleAnimation");

	Params::RBAIBlueprintLibrary_ForcePlayStartleAnimation Parms{};

	Parms.bot = bot;
	Parms.StartledType = StartledType;
	Parms.StartledSpeed = StartledSpeed;
	Parms.WsYaw = WsYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.GetAIDensityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAIDensityLevel                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIDensityLevel URBAIBlueprintLibrary::GetAIDensityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetAIDensityLevel");

	Params::RBAIBlueprintLibrary_GetAIDensityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetAllBots
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARBBot*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBBot*> URBAIBlueprintLibrary::GetAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetAllBots");

	Params::RBAIBlueprintLibrary_GetAllBots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetAnyBot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBBot*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBot* URBAIBlueprintLibrary::GetAnyBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetAnyBot");

	Params::RBAIBlueprintLibrary_GetAnyBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetBotByClass
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ARBNPC>               NPCClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBot* URBAIBlueprintLibrary::GetBotByClass(TSubclassOf<class ARBNPC> NPCClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetBotByClass");

	Params::RBAIBlueprintLibrary_GetBotByClass Parms{};

	Parms.NPCClass = NPCClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetBotByType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBot* URBAIBlueprintLibrary::GetBotByType(ENPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetBotByType");

	Params::RBAIBlueprintLibrary_GetBotByType Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetBotsByClass
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ARBNPC>               NPCClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBBot*>                   bots                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GetBotsByClass(TSubclassOf<class ARBNPC> NPCClass, TArray<class ARBBot*>* bots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetBotsByClass");

	Params::RBAIBlueprintLibrary_GetBotsByClass Parms{};

	Parms.NPCClass = NPCClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bots != nullptr)
		*bots = std::move(Parms.bots);
}


// Function OPP.RBAIBlueprintLibrary.GetBotsByType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBBot*>                   bots                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GetBotsByType(ENPCType NPCType, TArray<class ARBBot*>* bots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetBotsByType");

	Params::RBAIBlueprintLibrary_GetBotsByType Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bots != nullptr)
		*bots = std::move(Parms.bots);
}


// Function OPP.RBAIBlueprintLibrary.GetNPCByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ARBNPC>               NPCClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBNPC* URBAIBlueprintLibrary::GetNPCByClass(TSubclassOf<class ARBNPC> NPCClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNPCByClass");

	Params::RBAIBlueprintLibrary_GetNPCByClass Parms{};

	Parms.NPCClass = NPCClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetNPCByType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBNPC* URBAIBlueprintLibrary::GetNPCByType(ENPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNPCByType");

	Params::RBAIBlueprintLibrary_GetNPCByType Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetNumberOfBots
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBAIBlueprintLibrary::GetNumberOfBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNumberOfBots");

	Params::RBAIBlueprintLibrary_GetNumberOfBots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAround
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          ExcludedPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBAIBlueprintLibrary::GetNumberOfBotsAround(const struct FVector& Point, float Radius, class ARBPawn* ExcludedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNumberOfBotsAround");

	Params::RBAIBlueprintLibrary_GetNumberOfBotsAround Parms{};

	Parms.Point = std::move(Point);
	Parms.Radius = Radius;
	Parms.ExcludedPawn = ExcludedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAroundInActivity
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EAIActivity                             Activity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          ExcludedPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBAIBlueprintLibrary::GetNumberOfBotsAroundInActivity(EAIActivity Activity, const struct FVector& Point, float Radius, class ARBPawn* ExcludedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNumberOfBotsAroundInActivity");

	Params::RBAIBlueprintLibrary_GetNumberOfBotsAroundInActivity Parms{};

	Parms.Activity = Activity;
	Parms.Point = std::move(Point);
	Parms.Radius = Radius;
	Parms.ExcludedPawn = ExcludedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsByType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCFlavor                              NPCFlavor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBAIBlueprintLibrary::GetNumberOfBotsByType(ENPCType NPCType, ENPCFlavor NPCFlavor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GetNumberOfBotsByType");

	Params::RBAIBlueprintLibrary_GetNumberOfBotsByType Parms{};

	Parms.NPCType = NPCType;
	Parms.NPCFlavor = NPCFlavor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.GlobalIgnoreAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIgnoreAllPlayers                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GlobalIgnoreAllPlayers(bool bIgnoreAllPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GlobalIgnoreAllPlayers");

	Params::RBAIBlueprintLibrary_GlobalIgnoreAllPlayers Parms{};

	Parms.bIgnoreAllPlayers = bIgnoreAllPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.GoRetireInCloset
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBMonsterCloset*                 Closet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPriorityOverActiveBehaviors                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GoRetireInCloset(class ARBBot* bot, class ARBMonsterCloset* Closet, bool bPriorityOverActiveBehaviors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GoRetireInCloset");

	Params::RBAIBlueprintLibrary_GoRetireInCloset Parms{};

	Parms.bot = bot;
	Parms.Closet = Closet;
	Parms.bPriorityOverActiveBehaviors = bPriorityOverActiveBehaviors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.GotoAmbientMarker
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AmbientLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GotoAmbientMarker(class ARBBot* bot, class AActor* AmbientLocation, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GotoAmbientMarker");

	Params::RBAIBlueprintLibrary_GotoAmbientMarker Parms{};

	Parms.bot = bot;
	Parms.AmbientLocation = AmbientLocation;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.GotoHidingSpot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Hidespot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GotoHidingSpot(class ARBBot* bot, class AActor* Hidespot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GotoHidingSpot");

	Params::RBAIBlueprintLibrary_GotoHidingSpot Parms{};

	Parms.bot = bot;
	Parms.Hidespot = Hidespot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.GotoLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTurnToRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceBuffer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GotoLocation(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, class AActor* Destination, float OverrideSpeed, bool bTurnToRotation, float DistanceBuffer, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GotoLocation");

	Params::RBAIBlueprintLibrary_GotoLocation Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Destination = Destination;
	Parms.OverrideSpeed = OverrideSpeed;
	Parms.bTurnToRotation = bTurnToRotation;
	Parms.DistanceBuffer = DistanceBuffer;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.GotoSabotage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SabotageTarget                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::GotoSabotage(class ARBBot* bot, class AActor* SabotageTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "GotoSabotage");

	Params::RBAIBlueprintLibrary_GotoSabotage Parms{};

	Parms.bot = bot;
	Parms.SabotageTarget = SabotageTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.IgnoreAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBotIgnoreAllPlayers                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::IgnoreAllPlayers(class ARBBot* bot, bool bBotIgnoreAllPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "IgnoreAllPlayers");

	Params::RBAIBlueprintLibrary_IgnoreAllPlayers Parms{};

	Parms.bot = bot;
	Parms.bBotIgnoreAllPlayers = bBotIgnoreAllPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.Investigate
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::Investigate(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, bool bAware)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "Investigate");

	Params::RBAIBlueprintLibrary_Investigate Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bAware = bAware;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.InvestigateLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          InvestigationLoc                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::InvestigateLocation(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const struct FVector& InvestigationLoc, bool bAware, bool bContinueInvestigatingWhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "InvestigateLocation");

	Params::RBAIBlueprintLibrary_InvestigateLocation Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.InvestigationLoc = std::move(InvestigationLoc);
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.InvestigatePoint
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           InvestigationPoint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::InvestigatePoint(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, class AActor* InvestigationPoint, bool bAware, bool bContinueInvestigatingWhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "InvestigatePoint");

	Params::RBAIBlueprintLibrary_InvestigatePoint Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.InvestigationPoint = InvestigationPoint;
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.InvestigatePoints
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   PointList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EInvestigationPointSelectionMode        SelectionMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxNumberOfPoints                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlySpecifiedPoints                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::InvestigatePoints(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const TArray<class AActor*>& PointList, EInvestigationPointSelectionMode SelectionMode, bool bAware, bool bContinueInvestigatingWhenDone, int32 MaxNumberOfPoints, bool bOnlySpecifiedPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "InvestigatePoints");

	Params::RBAIBlueprintLibrary_InvestigatePoints Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.PointList = std::move(PointList);
	Parms.SelectionMode = SelectionMode;
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
	Parms.MaxNumberOfPoints = MaxNumberOfPoints;
	Parms.bOnlySpecifiedPoints = bOnlySpecifiedPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.IsAnyBotOfType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCFlavor                              NPCFlavor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAIBlueprintLibrary::IsAnyBotOfType(ENPCType NPCType, ENPCFlavor NPCFlavor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "IsAnyBotOfType");

	Params::RBAIBlueprintLibrary_IsAnyBotOfType Parms{};

	Parms.NPCType = NPCType;
	Parms.NPCFlavor = NPCFlavor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAIBlueprintLibrary.KillAllBots
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)

void URBAIBlueprintLibrary::KillAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "KillAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.KillBot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::KillBot(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "KillBot");

	Params::RBAIBlueprintLibrary_KillBot Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.OverrideBotAnims
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAnimReferences*                AnimRefsAsset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::OverrideBotAnims(class ARBBot* bot, class URBAnimReferences* AnimRefsAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "OverrideBotAnims");

	Params::RBAIBlueprintLibrary_OverrideBotAnims Parms{};

	Parms.bot = bot;
	Parms.AnimRefsAsset = AnimRefsAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.PauseBot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PauseBot(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PauseBot");

	Params::RBAIBlueprintLibrary_PauseBot Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.PlayContextualVO
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOContext                              Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PlayContextualVO(class ARBBot* bot, EVOContext Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PlayContextualVO");

	Params::RBAIBlueprintLibrary_PlayContextualVO Parms{};

	Parms.bot = bot;
	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.PlayHitReaction
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCHitReactionType                     ReactionType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactSourceLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayEffects                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PlayHitReaction(class ARBBot* bot, ENPCHitReactionType ReactionType, const struct FVector& ImpactSourceLocation, bool bPlayEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PlayHitReaction");

	Params::RBAIBlueprintLibrary_PlayHitReaction Parms{};

	Parms.bot = bot;
	Parms.ReactionType = ReactionType;
	Parms.ImpactSourceLocation = std::move(ImpactSourceLocation);
	Parms.bPlayEffects = bPlayEffects;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.PlayLoopingIdle
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequence*                    IdleAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePlayers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                SpecificExitConditions                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAnimSequence*                    SpecificExitAnim                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PlayLoopingIdle(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, class UAnimSequence* IdleAnim, bool bIgnorePlayers, const struct FRBAIConditionSet& SpecificExitConditions, class UAnimSequence* SpecificExitAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PlayLoopingIdle");

	Params::RBAIBlueprintLibrary_PlayLoopingIdle Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.IdleAnim = IdleAnim;
	Parms.bIgnorePlayers = bIgnorePlayers;
	Parms.SpecificExitConditions = std::move(SpecificExitConditions);
	Parms.SpecificExitAnim = SpecificExitAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.PlayScriptedVO
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AudioEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PlayScriptedVO(class ARBBot* bot, class UAkAudioEvent* AudioEvent, EVOPriority VOPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PlayScriptedVO");

	Params::RBAIBlueprintLibrary_PlayScriptedVO Parms{};

	Parms.bot = bot;
	Parms.AudioEvent = AudioEvent;
	Parms.VOPriority = VOPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.PlaySingleShotAnim
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::PlaySingleShotAnim(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, class UAnimSequence* AnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "PlaySingleShotAnim");

	Params::RBAIBlueprintLibrary_PlaySingleShotAnim Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.AnimSeq = AnimSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.RemoveAdditionalDirectorConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBAIDirectorConfig*              DirectorConfig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RemoveAdditionalDirectorConfig(class URBAIDirectorConfig* DirectorConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RemoveAdditionalDirectorConfig");

	Params::RBAIBlueprintLibrary_RemoveAdditionalDirectorConfig Parms{};

	Parms.DirectorConfig = DirectorConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestGoto
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTurnToRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceBuffer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestGoto(class ARBBot* bot, class AActor* Destination, float OverrideSpeed, bool bTurnToRotation, float DistanceBuffer, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestGoto");

	Params::RBAIBlueprintLibrary_RequestGoto Parms{};

	Parms.bot = bot;
	Parms.Destination = Destination;
	Parms.OverrideSpeed = OverrideSpeed;
	Parms.bTurnToRotation = bTurnToRotation;
	Parms.DistanceBuffer = DistanceBuffer;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestGotoAmbientMarker
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AmbientLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestGotoAmbientMarker(class ARBBot* bot, class AActor* AmbientLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestGotoAmbientMarker");

	Params::RBAIBlueprintLibrary_RequestGotoAmbientMarker Parms{};

	Parms.bot = bot;
	Parms.AmbientLocation = AmbientLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestInvestigate
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestInvestigate(class ARBBot* bot, bool bAware)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestInvestigate");

	Params::RBAIBlueprintLibrary_RequestInvestigate Parms{};

	Parms.bot = bot;
	Parms.bAware = bAware;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestInvestigateLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InvestigationLoc                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestInvestigateLocation(class ARBBot* bot, const struct FVector& InvestigationLoc, bool bAware, bool bContinueInvestigatingWhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestInvestigateLocation");

	Params::RBAIBlueprintLibrary_RequestInvestigateLocation Parms{};

	Parms.bot = bot;
	Parms.InvestigationLoc = std::move(InvestigationLoc);
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoint
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InvestigationPoint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestInvestigatePoint(class ARBBot* bot, class AActor* InvestigationPoint, bool bAware, bool bContinueInvestigatingWhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestInvestigatePoint");

	Params::RBAIBlueprintLibrary_RequestInvestigatePoint Parms{};

	Parms.bot = bot;
	Parms.InvestigationPoint = InvestigationPoint;
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoints
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   PointList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EInvestigationPointSelectionMode        SelectionMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAware                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueInvestigatingWhenDone                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxNumberOfPoints                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlySpecifiedPoints                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestInvestigatePoints(class ARBBot* bot, const TArray<class AActor*>& PointList, EInvestigationPointSelectionMode SelectionMode, bool bAware, bool bContinueInvestigatingWhenDone, int32 MaxNumberOfPoints, bool bOnlySpecifiedPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestInvestigatePoints");

	Params::RBAIBlueprintLibrary_RequestInvestigatePoints Parms{};

	Parms.bot = bot;
	Parms.PointList = std::move(PointList);
	Parms.SelectionMode = SelectionMode;
	Parms.bAware = bAware;
	Parms.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
	Parms.MaxNumberOfPoints = MaxNumberOfPoints;
	Parms.bOnlySpecifiedPoints = bOnlySpecifiedPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RequestPatrol
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBWaypoint*>              WaypointList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPatrolWaypointSelectionMode            Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RequestPatrol(class ARBBot* bot, const TArray<class ARBWaypoint*>& WaypointList, EPatrolWaypointSelectionMode Mode, float OverrideSpeed, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RequestPatrol");

	Params::RBAIBlueprintLibrary_RequestPatrol Parms{};

	Parms.bot = bot;
	Parms.WaypointList = std::move(WaypointList);
	Parms.Mode = Mode;
	Parms.OverrideSpeed = OverrideSpeed;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ResetAIConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ResetAIConfig(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ResetAIConfig");

	Params::RBAIBlueprintLibrary_ResetAIConfig Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ResumeBot
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ResumeBot(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ResumeBot");

	Params::RBAIBlueprintLibrary_ResumeBot Parms{};

	Parms.bot = bot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.RetirePouncersInVolumes
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AVolume*>                  AllowedVolumes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::RetirePouncersInVolumes(const TArray<class AVolume*>& AllowedVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "RetirePouncersInVolumes");

	Params::RBAIBlueprintLibrary_RetirePouncersInVolumes Parms{};

	Parms.AllowedVolumes = std::move(AllowedVolumes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SeekRetirement
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPriorityOverActiveBehaviors                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SeekRetirement(class ARBBot* bot, bool bPriorityOverActiveBehaviors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SeekRetirement");

	Params::RBAIBlueprintLibrary_SeekRetirement Parms{};

	Parms.bot = bot;
	Parms.bPriorityOverActiveBehaviors = bPriorityOverActiveBehaviors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetAIConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      ConfigAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URBPartialAIConfig*>       AdditionalConfigs                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAIConfigData                    ConfigOverrides                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSetAsDefault                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetAwarenessState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetAIConfig(class ARBBot* bot, class URBAIConfig* ConfigAsset, const TArray<class URBPartialAIConfig*>& AdditionalConfigs, const struct FAIConfigData& ConfigOverrides, bool bSetAsDefault, bool bResetAwarenessState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetAIConfig");

	Params::RBAIBlueprintLibrary_SetAIConfig Parms{};

	Parms.bot = bot;
	Parms.ConfigAsset = ConfigAsset;
	Parms.AdditionalConfigs = std::move(AdditionalConfigs);
	Parms.ConfigOverrides = std::move(ConfigOverrides);
	Parms.bSetAsDefault = bSetAsDefault;
	Parms.bResetAwarenessState = bResetAwarenessState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetAvailableAmbientActivityMarkers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBAmbientActivityMarker*> AmbientMarkers                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetAvailableAmbientActivityMarkers(class ARBBot* bot, const TArray<class ARBAmbientActivityMarker*>& AmbientMarkers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetAvailableAmbientActivityMarkers");

	Params::RBAIBlueprintLibrary_SetAvailableAmbientActivityMarkers Parms{};

	Parms.bot = bot;
	Parms.AmbientMarkers = std::move(AmbientMarkers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetConditionalAIConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                ConditionSet                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAIConfigData                    ConfigOverrides                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bStayActivated                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetConditionalAIConfig(class ARBBot* bot, const struct FRBAIConditionSet& ConditionSet, const struct FAIConfigData& ConfigOverrides, bool bStayActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetConditionalAIConfig");

	Params::RBAIBlueprintLibrary_SetConditionalAIConfig Parms{};

	Parms.bot = bot;
	Parms.ConditionSet = std::move(ConditionSet);
	Parms.ConfigOverrides = std::move(ConfigOverrides);
	Parms.bStayActivated = bStayActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetFixedAnimPose
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimToPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetFixedAnimPose(class ARBBot* bot, class UAnimSequence* AnimToPlay, float AnimTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetFixedAnimPose");

	Params::RBAIBlueprintLibrary_SetFixedAnimPose Parms{};

	Parms.bot = bot;
	Parms.AnimToPlay = AnimToPlay;
	Parms.AnimTime = AnimTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetGuard
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GuardAnchor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                ExitConditions                                         (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bCanAttack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LateralBlockingDistance                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetGuard(class ARBBot* bot, class AActor* GuardAnchor, const struct FRBAIConditionSet& ExitConditions, bool bCanAttack, float LateralBlockingDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetGuard");

	Params::RBAIBlueprintLibrary_SetGuard Parms{};

	Parms.bot = bot;
	Parms.GuardAnchor = GuardAnchor;
	Parms.ExitConditions = std::move(ExitConditions);
	Parms.bCanAttack = bCanAttack;
	Parms.LateralBlockingDistance = LateralBlockingDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetLeash
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLeashMarker*                   LeashMarker                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetLeash(class ARBBot* bot, class ARBLeashMarker* LeashMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetLeash");

	Params::RBAIBlueprintLibrary_SetLeash Parms{};

	Parms.bot = bot;
	Parms.LeashMarker = LeashMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetLeashByVolumeGroups
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class ARBVolumeGroup>>RestrictedVolumeGroups                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// class AActor*                           CustomLeashReturnRef                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetLeashByVolumeGroups(class ARBBot* bot, const TArray<TSoftObjectPtr<class ARBVolumeGroup>>& RestrictedVolumeGroups, class AActor* CustomLeashReturnRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetLeashByVolumeGroups");

	Params::RBAIBlueprintLibrary_SetLeashByVolumeGroups Parms{};

	Parms.bot = bot;
	Parms.RestrictedVolumeGroups = std::move(RestrictedVolumeGroups);
	Parms.CustomLeashReturnRef = CustomLeashReturnRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetLeashByVolumes
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AVolume*>                  RestrictedVolumes                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           CustomLeashReturnRef                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetLeashByVolumes(class ARBBot* bot, const TArray<class AVolume*>& RestrictedVolumes, class AActor* CustomLeashReturnRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetLeashByVolumes");

	Params::RBAIBlueprintLibrary_SetLeashByVolumes Parms{};

	Parms.bot = bot;
	Parms.RestrictedVolumes = std::move(RestrictedVolumes);
	Parms.CustomLeashReturnRef = CustomLeashReturnRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetLeashByVolumesSoft
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class AVolume>>   RestrictedVolumes                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// class AActor*                           CustomLeashReturnRef                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetLeashByVolumesSoft(class ARBBot* bot, const TArray<TSoftObjectPtr<class AVolume>>& RestrictedVolumes, class AActor* CustomLeashReturnRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetLeashByVolumesSoft");

	Params::RBAIBlueprintLibrary_SetLeashByVolumesSoft Parms{};

	Parms.bot = bot;
	Parms.RestrictedVolumes = std::move(RestrictedVolumes);
	Parms.CustomLeashReturnRef = CustomLeashReturnRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetLeashes
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBLeashMarker*>           LeashMarkers                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetLeashes(class ARBBot* bot, const TArray<class ARBLeashMarker*>& LeashMarkers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetLeashes");

	Params::RBAIBlueprintLibrary_SetLeashes Parms{};

	Parms.bot = bot;
	Parms.LeashMarkers = std::move(LeashMarkers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetSnipingSplines
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBSplineActor*>           SplineMarkers                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetSnipingSplines(class ARBBot* bot, const TArray<class ARBSplineActor*>& SplineMarkers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetSnipingSplines");

	Params::RBAIBlueprintLibrary_SetSnipingSplines Parms{};

	Parms.bot = bot;
	Parms.SplineMarkers = std::move(SplineMarkers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetSpecificTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        TargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetSpecificTarget(class ARBBot* bot, class ARBPlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetSpecificTarget");

	Params::RBAIBlueprintLibrary_SetSpecificTarget Parms{};

	Parms.bot = bot;
	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetupAIDirector
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBAIDirectorConfig*              DirectorConfig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetupAIDirector(class URBAIDirectorConfig* DirectorConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetupAIDirector");

	Params::RBAIBlueprintLibrary_SetupAIDirector Parms{};

	Parms.DirectorConfig = DirectorConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetupAIDirectorForOpenedSections
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBAIDirectorConfig*              DirectorConfig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetupAIDirectorForOpenedSections(class URBAIDirectorConfig* DirectorConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetupAIDirectorForOpenedSections");

	Params::RBAIBlueprintLibrary_SetupAIDirectorForOpenedSections Parms{};

	Parms.DirectorConfig = DirectorConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetupAmbush
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBHidespotComponent*             Hidespot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetupAmbush(class ARBBot* bot, class URBHidespotComponent* Hidespot, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetupAmbush");

	Params::RBAIBlueprintLibrary_SetupAmbush Parms{};

	Parms.bot = bot;
	Parms.Hidespot = Hidespot;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SetVOMapOverrides
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBVOMappingOverride*             VoOverrides                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SetVOMapOverrides(class ARBBot* bot, class URBVOMappingOverride* VoOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SetVOMapOverrides");

	Params::RBAIBlueprintLibrary_SetVOMapOverrides Parms{};

	Parms.bot = bot;
	Parms.VoOverrides = VoOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.SpawnAI
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBNPC>               PawnClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      ConfigAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIConfigData                    ConfigOverrides                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class URBPartialAIConfig*>       AdditionalConfigs                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class URBVOMapping*                     VOMappingOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           SpawnedBot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           SpawnedPawn                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SpawnAI(TSubclassOf<class ARBNPC> PawnClass, class URBAIConfig* ConfigAsset, const struct FAIConfigData& ConfigOverrides, const TArray<class URBPartialAIConfig*>& AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* SpawnPoint, class ARBBot** SpawnedBot, class ARBNPC** SpawnedPawn, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SpawnAI");

	Params::RBAIBlueprintLibrary_SpawnAI Parms{};

	Parms.PawnClass = PawnClass;
	Parms.ConfigAsset = ConfigAsset;
	Parms.ConfigOverrides = std::move(ConfigOverrides);
	Parms.AdditionalConfigs = std::move(AdditionalConfigs);
	Parms.VOMappingOverride = VOMappingOverride;
	Parms.SpawnPoint = SpawnPoint;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedBot != nullptr)
		*SpawnedBot = Parms.SpawnedBot;

	if (SpawnedPawn != nullptr)
		*SpawnedPawn = Parms.SpawnedPawn;
}


// Function OPP.RBAIBlueprintLibrary.SpawnAIArchetype
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCFlavor                              Flavor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIConfigData                    ConfigOverrides                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class URBPartialAIConfig*>       AdditionalConfigs                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class URBVOMapping*                     VOMappingOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           SpawnedBot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           SpawnedPawn                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SpawnAIArchetype(ENPCType NPCType, ENPCFlavor Flavor, const struct FAIConfigData& ConfigOverrides, const TArray<class URBPartialAIConfig*>& AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* SpawnPoint, class ARBBot** SpawnedBot, class ARBNPC** SpawnedPawn, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SpawnAIArchetype");

	Params::RBAIBlueprintLibrary_SpawnAIArchetype Parms{};

	Parms.NPCType = NPCType;
	Parms.Flavor = Flavor;
	Parms.ConfigOverrides = std::move(ConfigOverrides);
	Parms.AdditionalConfigs = std::move(AdditionalConfigs);
	Parms.VOMappingOverride = VOMappingOverride;
	Parms.SpawnPoint = SpawnPoint;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedBot != nullptr)
		*SpawnedBot = Parms.SpawnedBot;

	if (SpawnedPawn != nullptr)
		*SpawnedPawn = Parms.SpawnedPawn;
}


// Function OPP.RBAIBlueprintLibrary.SpawnAISync
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBNPC>               PawnClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      ConfigAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIConfigData                    ConfigOverrides                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class URBPartialAIConfig*>       AdditionalConfigs                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class URBVOMapping*                     VOMappingOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           SpawnedBot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           SpawnedPawn                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SpawnAISync(TSubclassOf<class ARBNPC> PawnClass, class URBAIConfig* ConfigAsset, const struct FAIConfigData& ConfigOverrides, const TArray<class URBPartialAIConfig*>& AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* SpawnPoint, class ARBBot** SpawnedBot, class ARBNPC** SpawnedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SpawnAISync");

	Params::RBAIBlueprintLibrary_SpawnAISync Parms{};

	Parms.PawnClass = PawnClass;
	Parms.ConfigAsset = ConfigAsset;
	Parms.ConfigOverrides = std::move(ConfigOverrides);
	Parms.AdditionalConfigs = std::move(AdditionalConfigs);
	Parms.VOMappingOverride = VOMappingOverride;
	Parms.SpawnPoint = SpawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedBot != nullptr)
		*SpawnedBot = Parms.SpawnedBot;

	if (SpawnedPawn != nullptr)
		*SpawnedPawn = Parms.SpawnedPawn;
}


// Function OPP.RBAIBlueprintLibrary.SpawnPouncer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Hidespot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      ConfigOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           SpawnedBot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           SpawnedPawn                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SpawnPouncer(class AActor* Hidespot, class URBAIConfig* ConfigOverride, class ARBBot** SpawnedBot, class ARBNPC** SpawnedPawn, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SpawnPouncer");

	Params::RBAIBlueprintLibrary_SpawnPouncer Parms{};

	Parms.Hidespot = Hidespot;
	Parms.ConfigOverride = ConfigOverride;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedBot != nullptr)
		*SpawnedBot = Parms.SpawnedBot;

	if (SpawnedPawn != nullptr)
		*SpawnedPawn = Parms.SpawnedPawn;
}


// Function OPP.RBAIBlueprintLibrary.SpawnPouncers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AVolume*>                  AllowedVolumes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MinPouncers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPouncers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      ConfigOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::SpawnPouncers(const TArray<class AVolume*>& AllowedVolumes, const struct FLatentActionInfo& LatentInfo, int32 MinPouncers, int32 MaxPouncers, class URBAIConfig* ConfigOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "SpawnPouncers");

	Params::RBAIBlueprintLibrary_SpawnPouncers Parms{};

	Parms.AllowedVolumes = std::move(AllowedVolumes);
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MinPouncers = MinPouncers;
	Parms.MaxPouncers = MaxPouncers;
	Parms.ConfigOverride = ConfigOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.StartPatrol
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class ARBWaypoint*>              WaypointList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPatrolWaypointSelectionMode            Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::StartPatrol(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const TArray<class ARBWaypoint*>& WaypointList, EPatrolWaypointSelectionMode Mode, float OverrideSpeed, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "StartPatrol");

	Params::RBAIBlueprintLibrary_StartPatrol Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.WaypointList = std::move(WaypointList);
	Parms.Mode = Mode;
	Parms.OverrideSpeed = OverrideSpeed;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigate
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AVolume*>                  RestrictedVolumes                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSetLeashWithVolumes                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::StartPatrolInvestigate(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const TArray<class AVolume*>& RestrictedVolumes, bool bSetLeashWithVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "StartPatrolInvestigate");

	Params::RBAIBlueprintLibrary_StartPatrolInvestigate Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.RestrictedVolumes = std::move(RestrictedVolumes);
	Parms.bSetLeashWithVolumes = bSetLeashWithVolumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateSoft
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class AVolume>>   RestrictedVolumes                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    bSetLeashWithVolumes                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::StartPatrolInvestigateSoft(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const TArray<TSoftObjectPtr<class AVolume>>& RestrictedVolumes, bool bSetLeashWithVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "StartPatrolInvestigateSoft");

	Params::RBAIBlueprintLibrary_StartPatrolInvestigateSoft Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.RestrictedVolumes = std::move(RestrictedVolumes);
	Parms.bSetLeashWithVolumes = bSetLeashWithVolumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateVolumeGroup
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICommandResult                        OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class ARBVolumeGroup>>RestrictedVolumeGroups                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    bSetLeashWithVolumes                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::StartPatrolInvestigateVolumeGroup(class ARBBot* bot, EAICommandResult* OperationResult, const struct FLatentActionInfo& LatentInfo, const TArray<TSoftObjectPtr<class ARBVolumeGroup>>& RestrictedVolumeGroups, bool bSetLeashWithVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "StartPatrolInvestigateVolumeGroup");

	Params::RBAIBlueprintLibrary_StartPatrolInvestigateVolumeGroup Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.RestrictedVolumeGroups = std::move(RestrictedVolumeGroups);
	Parms.bSetLeashWithVolumes = bSetLeashWithVolumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.TestAIConditions
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIBoolCommandResult                    OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                ConditionSet                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TestAIConditions(class ARBBot* bot, EAIBoolCommandResult* OperationResult, const struct FRBAIConditionSet& ConditionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TestAIConditions");

	Params::RBAIBlueprintLibrary_TestAIConditions Parms{};

	Parms.bot = bot;
	Parms.ConditionSet = std::move(ConditionSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulus
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NoiseLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FullLoudnessRange                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxBotDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerCustomHighPriorityStimulus(const struct FVector& NoiseLocation, class AActor* Source, float FullLoudnessRange, float MaxBotDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerCustomHighPriorityStimulus");

	Params::RBAIBlueprintLibrary_TriggerCustomHighPriorityStimulus Parms{};

	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.Source = Source;
	Parms.FullLoudnessRange = FullLoudnessRange;
	Parms.MaxBotDistance = MaxBotDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulusFromPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FullLoudnessRange                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHearingDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerCustomHighPriorityStimulusFromPlayer(class ARBPlayer* Player, float FullLoudnessRange, float MaxHearingDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerCustomHighPriorityStimulusFromPlayer");

	Params::RBAIBlueprintLibrary_TriggerCustomHighPriorityStimulusFromPlayer Parms{};

	Parms.Player = Player;
	Parms.FullLoudnessRange = FullLoudnessRange;
	Parms.MaxHearingDistance = MaxHearingDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulus
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ETriggeringStimulusType                 StimulusType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          baseLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetWS                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerDoubleSidedStimulus(ETriggeringStimulusType StimulusType, class AActor* SourceActor, const struct FVector& baseLocation, const struct FVector& OffsetWS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerDoubleSidedStimulus");

	Params::RBAIBlueprintLibrary_TriggerDoubleSidedStimulus Parms{};

	Parms.StimulusType = StimulusType;
	Parms.SourceActor = SourceActor;
	Parms.baseLocation = std::move(baseLocation);
	Parms.OffsetWS = std::move(OffsetWS);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulusFromPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ETriggeringStimulusType                 StimulusType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          baseLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetWS                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerDoubleSidedStimulusFromPlayer(ETriggeringStimulusType StimulusType, class ARBPlayer* Player, const struct FVector& baseLocation, const struct FVector& OffsetWS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerDoubleSidedStimulusFromPlayer");

	Params::RBAIBlueprintLibrary_TriggerDoubleSidedStimulusFromPlayer Parms{};

	Parms.StimulusType = StimulusType;
	Parms.Player = Player;
	Parms.baseLocation = std::move(baseLocation);
	Parms.OffsetWS = std::move(OffsetWS);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TriggerStimulus
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ETriggeringStimulusType                 StimulusType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerStimulus(ETriggeringStimulusType StimulusType, const struct FVector& Location, class AActor* SourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerStimulus");

	Params::RBAIBlueprintLibrary_TriggerStimulus Parms{};

	Parms.StimulusType = StimulusType;
	Parms.Location = std::move(Location);
	Parms.SourceActor = SourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TriggerStimulusFromPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETriggeringStimulusType                 StimulusType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TriggerStimulusFromPlayer(ETriggeringStimulusType StimulusType, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TriggerStimulusFromPlayer");

	Params::RBAIBlueprintLibrary_TriggerStimulusFromPlayer Parms{};

	Parms.StimulusType = StimulusType;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.TryPlayAttackType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::TryPlayAttackType(class ARBBot* bot, EAttackType AttackType, float MovementSpeed, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "TryPlayAttackType");

	Params::RBAIBlueprintLibrary_TryPlayAttackType Parms{};

	Parms.bot = bot;
	Parms.AttackType = AttackType;
	Parms.MovementSpeed = MovementSpeed;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.WaitForAIConditions
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                ConditionSet                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::WaitForAIConditions(class ARBBot* bot, const struct FLatentActionInfo& LatentInfo, const struct FRBAIConditionSet& ConditionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "WaitForAIConditions");

	Params::RBAIBlueprintLibrary_WaitForAIConditions Parms{};

	Parms.bot = bot;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ConditionSet = std::move(ConditionSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.WakeUp
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScream                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::WakeUp(class ARBBot* bot, bool bScream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "WakeUp");

	Params::RBAIBlueprintLibrary_WakeUp Parms{};

	Parms.bot = bot;
	Parms.bScream = bScream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAIBlueprintLibrary.ZoneDefense
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ZonePatrolPoints                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           FallbackLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBZoneDefenseMarker*             DefensiveSpline                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAIConditionSet                ExitConditions                                         (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bCanAttack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAIBlueprintLibrary::ZoneDefense(class ARBBot* bot, const TArray<class AActor*>& ZonePatrolPoints, class AActor* FallbackLocation, class ARBZoneDefenseMarker* DefensiveSpline, const struct FRBAIConditionSet& ExitConditions, bool bCanAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBAIBlueprintLibrary", "ZoneDefense");

	Params::RBAIBlueprintLibrary_ZoneDefense Parms{};

	Parms.bot = bot;
	Parms.ZonePatrolPoints = std::move(ZonePatrolPoints);
	Parms.FallbackLocation = FallbackLocation;
	Parms.DefensiveSpline = DefensiveSpline;
	Parms.ExitConditions = std::move(ExitConditions);
	Parms.bCanAttack = bCanAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerStatsConfig.GetPlayerStatConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerStat                             PlayerStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBPlayerStatConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerStatConfig URBPlayerStatsConfig::GetPlayerStatConfig(EPlayerStat PlayerStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsConfig", "GetPlayerStatConfig");

	Params::RBPlayerStatsConfig_GetPlayerStatConfig Parms{};

	Parms.PlayerStat = PlayerStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerStatsConfig.GetPlayerStatConfigById
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBPlayerStatConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerStatConfig URBPlayerStatsConfig::GetPlayerStatConfigById(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsConfig", "GetPlayerStatConfigById");

	Params::RBPlayerStatsConfig_GetPlayerStatConfigById Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameInstance.OnLoadingScreenStateUpdated
// (Final, Native, Private)
// Parameters:
// bool                                    bShowing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameInstance::OnLoadingScreenStateUpdated(bool bShowing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameInstance", "OnLoadingScreenStateUpdated");

	Params::RBGameInstance_OnLoadingScreenStateUpdated Parms{};

	Parms.bShowing = bShowing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPolicyDocumentMenuWidget.Accept
// (Final, Native, Public, BlueprintCallable)

void URBPolicyDocumentMenuWidget::Accept()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPolicyDocumentMenuWidget", "Accept");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPolicyDocumentMenuWidget.Event_Setup
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPolicyDocumentMenuWidget::Event_Setup(const class FString& Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPolicyDocumentMenuWidget", "Event_Setup");

	Params::RBPolicyDocumentMenuWidget_Event_Setup Parms{};

	Parms.Content = std::move(Content);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBRandomizableMeshActor.OnRep_Visible
// (Final, Native, Public)

void ARBRandomizableMeshActor::OnRep_Visible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableMeshActor", "OnRep_Visible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.BP_OnPawnInteractingChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ARBPawn*                          NewPawnInteracting                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractiblePanelComponent::BP_OnPawnInteractingChanged(class ARBPawn* NewPawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "BP_OnPawnInteractingChanged");

	Params::RBInteractiblePanelComponent_BP_OnPawnInteractingChanged Parms{};

	Parms.NewPawnInteracting = NewPawnInteracting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractiblePanelComponent.BP_PanelGameplayDone
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBInteractiblePanelComponent::BP_PanelGameplayDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "BP_PanelGameplayDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.NotifyInteractorReady_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractiblePanelComponent::NotifyInteractorReady_Server(class ARBPlayer* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "NotifyInteractorReady_Server");

	Params::RBInteractiblePanelComponent_NotifyInteractorReady_Server Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.OnPawnInteractingChangedCallback
// (Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractiblePanelComponent::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "OnPawnInteractingChangedCallback");

	Params::RBInteractiblePanelComponent_OnPawnInteractingChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.OnRep_PanelActive
// (Native, Protected)

void URBInteractiblePanelComponent::OnRep_PanelActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "OnRep_PanelActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.OnRep_PanelStarted
// (Final, Native, Protected)

void URBInteractiblePanelComponent::OnRep_PanelStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "OnRep_PanelStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.OnRep_PawnInteracting
// (Native, Protected)

void URBInteractiblePanelComponent::OnRep_PawnInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "OnRep_PawnInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.SetPanelInUse_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInPanelInUse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractiblePanelComponent::SetPanelInUse_Server(bool bInPanelInUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "SetPanelInUse_Server");

	Params::RBInteractiblePanelComponent_SetPanelInUse_Server Parms{};

	Parms.bInPanelInUse = bInPanelInUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.TryNotifyInteractorReady
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInteractiblePanelComponent::TryNotifyInteractorReady(class ARBPlayer* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "TryNotifyInteractorReady");

	Params::RBInteractiblePanelComponent_TryNotifyInteractorReady Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractiblePanelComponent.GetInteractionProgressRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBInteractiblePanelComponent::GetInteractionProgressRatio(const class ARBPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "GetInteractionProgressRatio");

	Params::RBInteractiblePanelComponent_GetInteractionProgressRatio Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractiblePanelComponent.GetPawnInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPawn* URBInteractiblePanelComponent::GetPawnInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "GetPawnInteracting");

	Params::RBInteractiblePanelComponent_GetPawnInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractiblePanelComponent.GetPlayerInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBInteractiblePanelComponent::GetPlayerInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "GetPlayerInteracting");

	Params::RBInteractiblePanelComponent_GetPlayerInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractiblePanelComponent.IsPanelActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBInteractiblePanelComponent::IsPanelActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "IsPanelActive");

	Params::RBInteractiblePanelComponent_IsPanelActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractiblePanelComponent.ShouldBPTick
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBInteractiblePanelComponent::ShouldBPTick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractiblePanelComponent", "ShouldBPTick");

	Params::RBInteractiblePanelComponent_ShouldBPTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.Debug_ForcePlayerExit
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBArmWreslingPanelComponent::Debug_ForcePlayerExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "Debug_ForcePlayerExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.Multicast_TauntEvent
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBArmWreslingPanelComponent::Multicast_TauntEvent(class ARBPlayer* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "Multicast_TauntEvent");

	Params::RBArmWreslingPanelComponent_Multicast_TauntEvent Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.OnLinkedTableChange
// (Event, Public, BlueprintEvent)

void URBArmWreslingPanelComponent::OnLinkedTableChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "OnLinkedTableChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBArmWreslingPanelComponent.OnRep_HitZoneIndex
// (Final, Native, Public)

void URBArmWreslingPanelComponent::OnRep_HitZoneIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "OnRep_HitZoneIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.OnRep_SuccessZoneOffset
// (Final, Native, Public)

void URBArmWreslingPanelComponent::OnRep_SuccessZoneOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "OnRep_SuccessZoneOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.UpdateEndZone
// (Final, Native, Public)

void URBArmWreslingPanelComponent::UpdateEndZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "UpdateEndZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.UpdatePlayerCameraLimits
// (Final, Native, Public)
// Parameters:
// class ARBArmWreslingTable*              Table                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBArmWreslingPanelComponent::UpdatePlayerCameraLimits(class ARBArmWreslingTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "UpdatePlayerCameraLimits");

	Params::RBArmWreslingPanelComponent_UpdatePlayerCameraLimits Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingPanelComponent.GetCursorPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBArmWreslingPanelComponent::GetCursorPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "GetCursorPosition");

	Params::RBArmWreslingPanelComponent_GetCursorPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.GetElapsedMatchTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBArmWreslingPanelComponent::GetElapsedMatchTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "GetElapsedMatchTime");

	Params::RBArmWreslingPanelComponent_GetElapsedMatchTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.GetInputStartPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBArmWreslingPanelComponent::GetInputStartPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "GetInputStartPosition");

	Params::RBArmWreslingPanelComponent_GetInputStartPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.GetIsInputInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::GetIsInputInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "GetIsInputInProgress");

	Params::RBArmWreslingPanelComponent_GetIsInputInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.IsArmWreslingRoundInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::IsArmWreslingRoundInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "IsArmWreslingRoundInProgress");

	Params::RBArmWreslingPanelComponent_IsArmWreslingRoundInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.IsArmWreslingTableCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::IsArmWreslingTableCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "IsArmWreslingTableCompleted");

	Params::RBArmWreslingPanelComponent_IsArmWreslingTableCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.IsPlayer1
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::IsPlayer1() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "IsPlayer1");

	Params::RBArmWreslingPanelComponent_IsPlayer1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.IsPlayerLeaving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::IsPlayerLeaving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "IsPlayerLeaving");

	Params::RBArmWreslingPanelComponent_IsPlayerLeaving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingPanelComponent.IsPredictedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBArmWreslingPanelComponent::IsPredictedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingPanelComponent", "IsPredictedPlayer");

	Params::RBArmWreslingPanelComponent_IsPredictedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAnnouncer.Multicast_PlayVO
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOBehavior                             Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrePlayQueueDelay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAnnouncer::Multicast_PlayVO(class UAkAudioEvent* AkEvent, EVOBehavior Behavior, float PrePlayQueueDelay, uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnnouncer", "Multicast_PlayVO");

	Params::RBAnnouncer_Multicast_PlayVO Parms{};

	Parms.AkEvent = AkEvent;
	Parms.Behavior = Behavior;
	Parms.PrePlayQueueDelay = PrePlayQueueDelay;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_GetInteractionMeshRelativeTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBInteractible>      InteractibleClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ARBInteractible::BP_GetInteractionMeshRelativeTransform(TSubclassOf<class ARBInteractible> InteractibleClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBInteractible", "BP_GetInteractionMeshRelativeTransform");

	Params::RBInteractible_BP_GetInteractionMeshRelativeTransform Parms{};

	Parms.InteractibleClass = InteractibleClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.ApplyDesiredInteractorPawns
// (Final, Native, Private)

void ARBInteractible::ApplyDesiredInteractorPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "ApplyDesiredInteractorPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_OnIsInteractibleChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInteractibleValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::BP_OnIsInteractibleChanged(bool bInteractibleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_OnIsInteractibleChanged");

	Params::RBInteractible_BP_OnIsInteractibleChanged Parms{};

	Parms.bInteractibleValue = bInteractibleValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractible.BP_ResetInteractible
// (Final, Native, Public, BlueprintCallable)

void ARBInteractible::BP_ResetInteractible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_ResetInteractible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_SetIsInteractible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInteractibleValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::BP_SetIsInteractible(bool bInteractibleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_SetIsInteractible");

	Params::RBInteractible_BP_SetIsInteractible Parms{};

	Parms.bInteractibleValue = bInteractibleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_SetShowInDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowInDebugValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::BP_SetShowInDebug(bool bShowInDebugValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_SetShowInDebug");

	Params::RBInteractible_BP_SetShowInDebug Parms{};

	Parms.bShowInDebugValue = bShowInDebugValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_StopAllCurrentInteractions
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBInteractible::BP_StopAllCurrentInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_StopAllCurrentInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.Event_DoAction
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::Event_DoAction(class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Event_DoAction");

	Params::RBInteractible_Event_DoAction Parms{};

	Parms.Interactor = Interactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractible.Event_OnInteract
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::Event_OnInteract(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Event_OnInteract");

	Params::RBInteractible_Event_OnInteract Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractible.Event_OnInteractorsChangedEvent
// (Event, Public, BlueprintEvent)

void ARBInteractible::Event_OnInteractorsChangedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Event_OnInteractorsChangedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractible.Event_SnapToState
// (Event, Public, BlueprintEvent)

void ARBInteractible::Event_SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Event_SnapToState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractible.IncrementNumberOfInteract
// (Final, Native, Public, BlueprintCallable)

void ARBInteractible::IncrementNumberOfInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "IncrementNumberOfInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.IsInteractiveChangedCallback
// (Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::IsInteractiveChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "IsInteractiveChangedCallback");

	Params::RBInteractible_IsInteractiveChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.Multicast_OnStartInteract
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::Multicast_OnStartInteract(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Multicast_OnStartInteract");

	Params::RBInteractible_Multicast_OnStartInteract Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.Multicast_OnStopInteract
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::Multicast_OnStopInteract(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "Multicast_OnStopInteract");

	Params::RBInteractible_Multicast_OnStopInteract Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.NotifySpecialMoveCompletedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::NotifySpecialMoveCompletedEvent(class ARBPawn* Pawn, ESpecialMove SpecialMove, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "NotifySpecialMoveCompletedEvent");

	Params::RBInteractible_NotifySpecialMoveCompletedEvent Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;
	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractible.NotifySpecialMoveStartedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractible::NotifySpecialMoveStartedEvent(class ARBPawn* Pawn, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "NotifySpecialMoveStartedEvent");

	Params::RBInteractible_NotifySpecialMoveStartedEvent Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBInteractible.OnRep_DesiredInteractorPawns
// (Final, Native, Private)

void ARBInteractible::OnRep_DesiredInteractorPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "OnRep_DesiredInteractorPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.OnRep_DesiredInteractorPawnTime
// (Final, Native, Private)

void ARBInteractible::OnRep_DesiredInteractorPawnTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "OnRep_DesiredInteractorPawnTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.OnRep_IsInteractive
// (Final, Native, Public)

void ARBInteractible::OnRep_IsInteractive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "OnRep_IsInteractive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.SnapToState_Implementation
// (Final, Native, Public)

void ARBInteractible::SnapToState_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "SnapToState_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractible.BP_GetInteractorPawns
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPawn*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPawn*> ARBInteractible::BP_GetInteractorPawns() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_GetInteractorPawns");

	Params::RBInteractible_BP_GetInteractorPawns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.BP_IsInteractible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBInteractible::BP_IsInteractible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "BP_IsInteractible");

	Params::RBInteractible_BP_IsInteractible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.GetAnimForward
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBInteractible::GetAnimForward(const class ARBPawn* InteractorPawn, ESpecialMove SpecialMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "GetAnimForward");

	Params::RBInteractible_GetAnimForward Parms{};

	Parms.InteractorPawn = InteractorPawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.GetAnimLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBInteractible::GetAnimLocation(const class ARBPawn* InteractorPawn, ESpecialMove SpecialMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "GetAnimLocation");

	Params::RBInteractible_GetAnimLocation Parms{};

	Parms.InteractorPawn = InteractorPawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.GetInteractionActionCollisionCheck
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBInteractible::GetInteractionActionCollisionCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "GetInteractionActionCollisionCheck");

	Params::RBInteractible_GetInteractionActionCollisionCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.GetNumberOfInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBInteractible::GetNumberOfInteract() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "GetNumberOfInteract");

	Params::RBInteractible_GetNumberOfInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.GetStartsInteractible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBInteractible::GetStartsInteractible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "GetStartsInteractible");

	Params::RBInteractible_GetStartsInteractible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractible.ShouldAlignToGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBInteractible::ShouldAlignToGround(const class ARBPawn* InteractorPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractible", "ShouldAlignToGround");

	Params::RBInteractible_ShouldAlignToGround Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.Event_Hide
// (Event, Public, BlueprintEvent)

void URBHUDElementWidget::Event_Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_Hide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDElementWidget.Event_OnHudModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHudMode                                NewHudMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::Event_OnHudModeChanged(EHudMode NewHudMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_OnHudModeChanged");

	Params::RBHUDElementWidget_Event_OnHudModeChanged Parms{};

	Parms.NewHudMode = NewHudMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDElementWidget.Event_OnLocalPlayerChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        OldLocalPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        NewLocalPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::Event_OnLocalPlayerChanged(class ARBPlayer* OldLocalPlayer, class ARBPlayer* NewLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_OnLocalPlayerChanged");

	Params::RBHUDElementWidget_Event_OnLocalPlayerChanged Parms{};

	Parms.OldLocalPlayer = OldLocalPlayer;
	Parms.NewLocalPlayer = NewLocalPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDElementWidget.Event_OnResetHud
// (Event, Public, BlueprintEvent)

void URBHUDElementWidget::Event_OnResetHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_OnResetHud");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDElementWidget.Event_OnSpectatedPlayerChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        NewSpectatedlPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::Event_OnSpectatedPlayerChanged(class ARBPlayer* NewSpectatedlPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_OnSpectatedPlayerChanged");

	Params::RBHUDElementWidget_Event_OnSpectatedPlayerChanged Parms{};

	Parms.NewSpectatedlPlayer = NewSpectatedlPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDElementWidget.Event_OnWatchedPlayerChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        OldPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::Event_OnWatchedPlayerChanged(class ARBPlayer* OldPlayer, class ARBPlayer* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_OnWatchedPlayerChanged");

	Params::RBHUDElementWidget_Event_OnWatchedPlayerChanged Parms{};

	Parms.OldPlayer = OldPlayer;
	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDElementWidget.Event_Show
// (Event, Public, BlueprintEvent)

void URBHUDElementWidget::Event_Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "Event_Show");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDElementWidget.ForceShowForDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::ForceShowForDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "ForceShowForDuration");

	Params::RBHUDElementWidget_ForceShowForDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDElementWidget.SetForcedShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ForcedShow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDElementWidget::SetForcedShow(bool ForcedShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "SetForcedShow");

	Params::RBHUDElementWidget_SetForcedShow Parms{};

	Parms.ForcedShow = ForcedShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDElementWidget.UpdateVisibility
// (Final, Native, Public, BlueprintCallable)

void URBHUDElementWidget::UpdateVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "UpdateVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDElementWidget.GetHUDOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBHUDElementWidget::GetHUDOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "GetHUDOpacity");

	Params::RBHUDElementWidget_GetHUDOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.GetWatchedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBHUDElementWidget::GetWatchedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "GetWatchedPlayer");

	Params::RBHUDElementWidget_GetWatchedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.IsInValidHudMode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDElementWidget::IsInValidHudMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "IsInValidHudMode");

	Params::RBHUDElementWidget_IsInValidHudMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.ShouldForceShow
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDElementWidget::ShouldForceShow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "ShouldForceShow");

	Params::RBHUDElementWidget_ShouldForceShow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.ShouldShow
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDElementWidget::ShouldShow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "ShouldShow");

	Params::RBHUDElementWidget_ShouldShow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDElementWidget.ShouldShowBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDElementWidget::ShouldShowBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDElementWidget", "ShouldShowBase");

	Params::RBHUDElementWidget_ShouldShowBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveWidgetBase.Event_Completed
// (Event, Protected, BlueprintEvent)

void URBObjectiveWidgetBase::Event_Completed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "Event_Completed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBObjectiveWidgetBase.Event_IsMakingPositiveProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsMakingPositiveProgress                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::Event_IsMakingPositiveProgress(bool IsMakingPositiveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "Event_IsMakingPositiveProgress");

	Params::RBObjectiveWidgetBase_Event_IsMakingPositiveProgress Parms{};

	Parms.IsMakingPositiveProgress = IsMakingPositiveProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBObjectiveWidgetBase.Event_ProgressChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPositiveProgress                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ObjectiveText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::Event_ProgressChanged(class ARBBaseObjectiveCoordinator* Coordinator, float Progress, bool IsPositiveProgress, const class FText& ObjectiveText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "Event_ProgressChanged");

	Params::RBObjectiveWidgetBase_Event_ProgressChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.Progress = Progress;
	Parms.IsPositiveProgress = IsPositiveProgress;
	Parms.ObjectiveText = std::move(ObjectiveText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBObjectiveWidgetBase.OnCompletionInProgressChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsProgressionInProgress                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCompletedByLocalPlayer                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::OnCompletionInProgressChanged(class ARBBaseObjectiveCoordinator* Coordinator, bool IsProgressionInProgress, bool IsCompletedByLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "OnCompletionInProgressChanged");

	Params::RBObjectiveWidgetBase_OnCompletionInProgressChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.IsProgressionInProgress = IsProgressionInProgress;
	Parms.IsCompletedByLocalPlayer = IsCompletedByLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStarted
// (Final, Native, Private)

void URBObjectiveWidgetBase::OnObjectiveCoordinatorStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "OnObjectiveCoordinatorStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStateChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "OnObjectiveCoordinatorStateChanged");

	Params::RBObjectiveWidgetBase_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveWidgetBase.OnSingleObjectiveCompleted
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::OnSingleObjectiveCompleted(class ARBBaseObjectiveCoordinator* Coordinator, class AActor* Player, class AActor* Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "OnSingleObjectiveCompleted");

	Params::RBObjectiveWidgetBase_OnSingleObjectiveCompleted Parms{};

	Parms.Coordinator = Coordinator;
	Parms.Player = Player;
	Parms.Objective = Objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveWidgetBase.SetObjectiveCoordinator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveWidgetBase::SetObjectiveCoordinator(class ARBBaseObjectiveCoordinator* Coordinator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveWidgetBase", "SetObjectiveCoordinator");

	Params::RBObjectiveWidgetBase_SetObjectiveCoordinator Parms{};

	Parms.Coordinator = Coordinator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBackgroundDoor.Event_CloseDoor
// (Event, Public, BlueprintEvent)

void ARBBackgroundDoor::Event_CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackgroundDoor", "Event_CloseDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBackgroundDoor.Event_OpenDoor
// (Event, Public, BlueprintEvent)

void ARBBackgroundDoor::Event_OpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackgroundDoor", "Event_OpenDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAICondition_Blueprint.Event_EvaluateCondition
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAICondition_Blueprint::Event_EvaluateCondition(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAICondition_Blueprint", "Event_EvaluateCondition");

	Params::RBAICondition_Blueprint_Event_EvaluateCondition Parms{};

	Parms.bot = bot;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBOperatable.BP_CancelTimedReset
// (Final, Native, Public, BlueprintCallable)

void ARBOperatable::BP_CancelTimedReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_CancelTimedReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_ForceCompletion
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBOperatable::BP_ForceCompletion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_ForceCompletion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_ForceDesiredProgression
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DesiredProgression                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProgressionSpeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::BP_ForceDesiredProgression(float DesiredProgression, float ProgressionSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_ForceDesiredProgression");

	Params::RBOperatable_BP_ForceDesiredProgression Parms{};

	Parms.DesiredProgression = DesiredProgression;
	Parms.ProgressionSpeed = ProgressionSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_ForceInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBypassCompletion                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::BP_ForceInteraction(bool bBypassCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_ForceInteraction");

	Params::RBOperatable_BP_ForceInteraction Parms{};

	Parms.bBypassCompletion = bBypassCompletion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_ForceState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForcedState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::BP_ForceState(bool bForcedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_ForceState");

	Params::RBOperatable_BP_ForceState Parms{};

	Parms.bForcedState = bForcedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_ResetCompletedState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBOperatable::BP_ResetCompletedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_ResetCompletedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_SetIsDenyInteraction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDeny                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::BP_SetIsDenyInteraction(bool bDeny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_SetIsDenyInteraction");

	Params::RBOperatable_BP_SetIsDenyInteraction Parms{};

	Parms.bDeny = bDeny;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Event_OnCompletedOperation
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class ARBPawn*>                  Pawns                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnCompletedOperation(const TArray<class ARBPawn*>& Pawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnCompletedOperation");

	Params::RBOperatable_Event_OnCompletedOperation Parms{};

	Parms.Pawns = std::move(Pawns);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnIsDenyInteractionChanged
// (Event, Public, BlueprintEvent)

void ARBOperatable::Event_OnIsDenyInteractionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnIsDenyInteractionChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBOperatable.Event_OnOperationProgressChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentProgressRatio                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnOperationProgressChanged(float CurrentProgressRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnOperationProgressChanged");

	Params::RBOperatable_Event_OnOperationProgressChanged Parms{};

	Parms.CurrentProgressRatio = CurrentProgressRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnResetCompletedState
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   OldProgression                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnResetCompletedState(float OldProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnResetCompletedState");

	Params::RBOperatable_Event_OnResetCompletedState Parms{};

	Parms.OldProgression = OldProgression;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnStartOperating
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnStartOperating(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnStartOperating");

	Params::RBOperatable_Event_OnStartOperating Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnStateOnChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bStateOn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnStateOnChanged(bool bStateOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnStateOnChanged");

	Params::RBOperatable_Event_OnStateOnChanged Parms{};

	Parms.bStateOn = bStateOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnStopOperating
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnStopOperating(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnStopOperating");

	Params::RBOperatable_Event_OnStopOperating Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnTimedReset
// (Event, Public, BlueprintEvent)

void ARBOperatable::Event_OnTimedReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnTimedReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBOperatable.Event_OnTriggerableActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnTriggerableActivated(class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnTriggerableActivated");

	Params::RBOperatable_Event_OnTriggerableActivated Parms{};

	Parms.Triggerable = Triggerable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Event_OnTriggerableDeactivated
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Event_OnTriggerableDeactivated(class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Event_OnTriggerableDeactivated");

	Params::RBOperatable_Event_OnTriggerableDeactivated Parms{};

	Parms.Triggerable = Triggerable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBOperatable.Multicast_ForceCompletion
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBOperatable::Multicast_ForceCompletion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_ForceCompletion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Multicast_ForceState
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   OldProgression                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForcedState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Multicast_ForceState(float OldProgression, bool bForcedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_ForceState");

	Params::RBOperatable_Multicast_ForceState Parms{};

	Parms.OldProgression = OldProgression;
	Parms.bForcedState = bForcedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Multicast_OnCompletedOperation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   OldProgression                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBPawn*>                  CompletedByPawnListValue                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBOperatable::Multicast_OnCompletedOperation(float OldProgression, const TArray<class ARBPawn*>& CompletedByPawnListValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_OnCompletedOperation");

	Params::RBOperatable_Multicast_OnCompletedOperation Parms{};

	Parms.OldProgression = OldProgression;
	Parms.CompletedByPawnListValue = std::move(CompletedByPawnListValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Multicast_OnStopInteractOperatable
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Server_CurrentOperateOnStop                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Multicast_OnStopInteractOperatable(class ARBPawn* Pawn, float Server_CurrentOperateOnStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_OnStopInteractOperatable");

	Params::RBOperatable_Multicast_OnStopInteractOperatable Parms{};

	Parms.Pawn = Pawn;
	Parms.Server_CurrentOperateOnStop = Server_CurrentOperateOnStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Multicast_OnTimedReset
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBOperatable::Multicast_OnTimedReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_OnTimedReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.Multicast_ResetCompletedState
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   OldProgression                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatable::Multicast_ResetCompletedState(float OldProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "Multicast_ResetCompletedState");

	Params::RBOperatable_Multicast_ResetCompletedState Parms{};

	Parms.OldProgression = OldProgression;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_bStateOn
// (Final, Native, Public)

void ARBOperatable::OnRep_bStateOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_bStateOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_bStateOn_Callback
// (Final, Native, Public)

void ARBOperatable::OnRep_bStateOn_Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_bStateOn_Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_Completed
// (Final, Native, Public)

void ARBOperatable::OnRep_Completed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_Completed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_Completed_Callback
// (Final, Native, Public)

void ARBOperatable::OnRep_Completed_Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_Completed_Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_CurrentOperateTime
// (Final, Native, Public)

void ARBOperatable::OnRep_CurrentOperateTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_CurrentOperateTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_CurrentOperateTime_Callback
// (Final, Native, Public)

void ARBOperatable::OnRep_CurrentOperateTime_Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_CurrentOperateTime_Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_ForceDesiredOperateTime
// (Final, Native, Private)

void ARBOperatable::OnRep_ForceDesiredOperateTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_ForceDesiredOperateTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.OnRep_IsDenyInteraction
// (Final, Native, Public)

void ARBOperatable::OnRep_IsDenyInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "OnRep_IsDenyInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatable.BP_CanOperateWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBOperatable::BP_CanOperateWith(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_CanOperateWith");

	Params::RBOperatable_BP_CanOperateWith Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatable.BP_GetCurrentProgressionRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBOperatable::BP_GetCurrentProgressionRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "BP_GetCurrentProgressionRatio");

	Params::RBOperatable_BP_GetCurrentProgressionRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatable.DefaultTestPhysicsClearance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBOperatable::DefaultTestPhysicsClearance(const class ARBPawn* InteractorPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "DefaultTestPhysicsClearance");

	Params::RBOperatable_DefaultTestPhysicsClearance Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatable.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBOperatable::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "IsCompleted");

	Params::RBOperatable_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatable.IsCurrentlyBeingOperated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBOperatable::IsCurrentlyBeingOperated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatable", "IsCurrentlyBeingOperated");

	Params::RBOperatable_IsCurrentlyBeingOperated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.ApplyDoorframeOffsetToTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsAddonInFront                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplySideOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ARBDoor::ApplyDoorframeOffsetToTransform(struct FTransform& Transform, bool IsAddonInFront, const struct FVector& OffsetDirection, bool bApplySideOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "ApplyDoorframeOffsetToTransform");

	Params::RBDoor_ApplyDoorframeOffsetToTransform Parms{};

	Parms.Transform = std::move(Transform);
	Parms.IsAddonInFront = IsAddonInFront;
	Parms.OffsetDirection = std::move(OffsetDirection);
	Parms.bApplySideOffset = bApplySideOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Transform = std::move(Parms.Transform);

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_ActivateBars
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_ActivateBars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_ActivateBars");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_ActivateSlowOpenTutorial
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_ActivateSlowOpenTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_ActivateSlowOpenTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_Close
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_DeactivateBars
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_DeactivateBars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_DeactivateBars");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_OnActorAttachedToDoor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnActorAttachedToDoor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnActorAttachedToDoor");

	Params::RBDoor_BP_OnActorAttachedToDoor Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnDoorBarsLockingEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bLocking                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnDoorBarsLockingEvent(bool bLocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorBarsLockingEvent");

	Params::RBDoor_BP_OnDoorBarsLockingEvent Parms{};

	Parms.bLocking = bLocking;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnDoorBashEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyVisualDoorDamage                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBashDoorType                           bashType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnDoorBashEvent(class ARBPawn* Pawn, bool bSuccess, bool bApplyVisualDoorDamage, EBashDoorType bashType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorBashEvent");

	Params::RBDoor_BP_OnDoorBashEvent Parms{};

	Parms.Pawn = Pawn;
	Parms.bSuccess = bSuccess;
	Parms.bApplyVisualDoorDamage = bApplyVisualDoorDamage;
	Parms.bashType = bashType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnDoorInteract
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnDoorInteract(class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorInteract");

	Params::RBDoor_BP_OnDoorInteract Parms{};

	Parms.Interactor = Interactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnDoorTrapActivated
// (Event, Public, BlueprintEvent)

void ARBDoor::BP_OnDoorTrapActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorTrapActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDoor.BP_OnDoorTrapDisarmed
// (Event, Public, BlueprintEvent)

void ARBDoor::BP_OnDoorTrapDisarmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorTrapDisarmed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDoor.BP_OnDoorTrappedStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bTrapped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromFront                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnDoorTrappedStateChanged(bool bTrapped, bool bFromFront)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnDoorTrappedStateChanged");

	Params::RBDoor_BP_OnDoorTrappedStateChanged Parms{};

	Parms.bTrapped = bTrapped;
	Parms.bFromFront = bFromFront;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnLockPanelsReplicated
// (Event, Public, BlueprintEvent)

void ARBDoor::BP_OnLockPanelsReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnLockPanelsReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDoor.BP_OnLockPanelUnlocked
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBInteractiblePanelComponent*    LockPanel                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnLockPanelUnlocked(class URBInteractiblePanelComponent* LockPanel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnLockPanelUnlocked");

	Params::RBDoor_BP_OnLockPanelUnlocked Parms{};

	Parms.LockPanel = LockPanel;
	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnNumberOfRewardUnlockActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Param_NumberOfRewardUnlockActive                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_OnNumberOfRewardUnlockActiveChanged(int32 Param_NumberOfRewardUnlockActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnNumberOfRewardUnlockActiveChanged");

	Params::RBDoor_BP_OnNumberOfRewardUnlockActiveChanged Parms{};

	Parms.Param_NumberOfRewardUnlockActive = Param_NumberOfRewardUnlockActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDoor.BP_OnRewardDoorInitialization
// (Event, Public, BlueprintEvent)

void ARBDoor::BP_OnRewardDoorInitialization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_OnRewardDoorInitialization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDoor.BP_Open
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFrontSide                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedRatio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_Open(bool bFrontSide, float SpeedRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_Open");

	Params::RBDoor_BP_Open Parms{};

	Parms.bFrontSide = bFrontSide;
	Parms.SpeedRatio = SpeedRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_RebuildInternalData
// (Final, Native, Private, BlueprintCallable)

void ARBDoor::BP_RebuildInternalData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_RebuildInternalData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_Reset
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bApplyForceRandomization                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::BP_Reset(bool bApplyForceRandomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_Reset");

	Params::RBDoor_BP_Reset Parms{};

	Parms.bApplyForceRandomization = bApplyForceRandomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_Server_Lock
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_Server_Lock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_Server_Lock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_Server_Unlock
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDoor::BP_Server_Unlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_Server_Unlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_SetDynamicReplacement
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ReplacementClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldRemoveDoorFrame                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBDoor::BP_SetDynamicReplacement(TSubclassOf<class AActor> ReplacementClass, bool bShouldRemoveDoorFrame, int32 RandomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_SetDynamicReplacement");

	Params::RBDoor_BP_SetDynamicReplacement Parms{};

	Parms.ReplacementClass = ReplacementClass;
	Parms.bShouldRemoveDoorFrame = bShouldRemoveDoorFrame;
	Parms.RandomID = RandomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_SetDynamicReplacementFixed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ReplacementClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldRemoveDoorFrame                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInverseDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBDoor::BP_SetDynamicReplacementFixed(TSubclassOf<class AActor> ReplacementClass, bool bShouldRemoveDoorFrame, bool bInverseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_SetDynamicReplacementFixed");

	Params::RBDoor_BP_SetDynamicReplacementFixed Parms{};

	Parms.ReplacementClass = ReplacementClass;
	Parms.bShouldRemoveDoorFrame = bShouldRemoveDoorFrame;
	Parms.bInverseDirection = bInverseDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.Editor_OnDeselected
// (Final, Native, Private)

void ARBDoor::Editor_OnDeselected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "Editor_OnDeselected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.Editor_OnSelected
// (Final, Native, Private)

void ARBDoor::Editor_OnSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "Editor_OnSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.Flip
// (Final, Native, Public)

void ARBDoor::Flip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "Flip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.GetSoundComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBSoundComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSoundComponent* ARBDoor::GetSoundComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "GetSoundComponent");

	Params::RBDoor_GetSoundComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.LockBars_Server
// (Final, Native, Public)
// Parameters:
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::LockBars_Server(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "LockBars_Server");

	Params::RBDoor_LockBars_Server Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.LockingPanelActiveChanged
// (Final, Native, Private)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::LockingPanelActiveChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "LockingPanelActiveChanged");

	Params::RBDoor_LockingPanelActiveChanged Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.Multicast_OnDoorInteract
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   NewDoorDesiredAngle                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDoorAngleSpeedRatio                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::Multicast_OnDoorInteract(float NewDoorDesiredAngle, float NewDoorAngleSpeedRatio, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "Multicast_OnDoorInteract");

	Params::RBDoor_Multicast_OnDoorInteract Parms{};

	Parms.NewDoorDesiredAngle = NewDoorDesiredAngle;
	Parms.NewDoorAngleSpeedRatio = NewDoorAngleSpeedRatio;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.Multicast_OnRewardDoorUnlocked
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBDoor::Multicast_OnRewardDoorUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "Multicast_OnRewardDoorUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnCoopOperatableOperatingFinishedEvent
// (Final, Native, Private)
// Parameters:
// class URBOperatableComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnCoopOperatableOperatingFinishedEvent(class URBOperatableComponent* Component, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnCoopOperatableOperatingFinishedEvent");

	Params::RBDoor_OnCoopOperatableOperatingFinishedEvent Parms{};

	Parms.Component = Component;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnCoopOperatableOperatingStartedEvent
// (Final, Native, Private)
// Parameters:
// class URBOperatableComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnCoopOperatableOperatingStartedEvent(class URBOperatableComponent* Component, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnCoopOperatableOperatingStartedEvent");

	Params::RBDoor_OnCoopOperatableOperatingStartedEvent Parms{};

	Parms.Component = Component;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnDesiredDoorAngleChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnDesiredDoorAngleChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnDesiredDoorAngleChangedCallback");

	Params::RBDoor_OnDesiredDoorAngleChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnDoorRepulsionDone
// (Final, Native, Public)
// Parameters:
// class URBRepulsionComponent*            RepulsionComponentDone                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnDoorRepulsionDone(class URBRepulsionComponent* RepulsionComponentDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnDoorRepulsionDone");

	Params::RBDoor_OnDoorRepulsionDone Parms{};

	Parms.RepulsionComponentDone = RepulsionComponentDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnLockPanelUnlocked
// (Final, Native, Private)
// Parameters:
// class URBInteractiblePanelComponent*    LockPanel                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnLockPanelUnlocked(class URBInteractiblePanelComponent* LockPanel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnLockPanelUnlocked");

	Params::RBDoor_OnLockPanelUnlocked Parms{};

	Parms.LockPanel = LockPanel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_BarLocked
// (Final, Native, Private)

void ARBDoor::OnRep_BarLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_BarLocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_BlockingActors
// (Final, Native, Private)

void ARBDoor::OnRep_BlockingActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_BlockingActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_DesiredDoorAngle
// (Final, Native, Private)

void ARBDoor::OnRep_DesiredDoorAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_DesiredDoorAngle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_DynamicallyReplaced
// (Final, Native, Private)

void ARBDoor::OnRep_DynamicallyReplaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_DynamicallyReplaced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_LockPanel
// (Final, Native, Private)

void ARBDoor::OnRep_LockPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_LockPanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_NumberOfRewardUnlockActive
// (Final, Native, Private)

void ARBDoor::OnRep_NumberOfRewardUnlockActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_NumberOfRewardUnlockActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_RandomStaticBlockingActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           OldActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::OnRep_RandomStaticBlockingActor(class AActor* OldActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_RandomStaticBlockingActor");

	Params::RBDoor_OnRep_RandomStaticBlockingActor Parms{};

	Parms.OldActor = OldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_RewardLockingOperatables
// (Final, Native, Private)

void ARBDoor::OnRep_RewardLockingOperatables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_RewardLockingOperatables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.OnRep_SpawnedTrap
// (Final, Native, Private)

void ARBDoor::OnRep_SpawnedTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "OnRep_SpawnedTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.SetLinkedDoubleDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBDoor*                          LinkedDoor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::SetLinkedDoubleDoor(class ARBDoor* LinkedDoor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "SetLinkedDoubleDoor");

	Params::RBDoor_SetLinkedDoubleDoor Parms{};

	Parms.LinkedDoor = LinkedDoor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.SetupDynamicActorVisibilityId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::SetupDynamicActorVisibilityId(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "SetupDynamicActorVisibilityId");

	Params::RBDoor_SetupDynamicActorVisibilityId Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.SetupDynamicComponentVisibilityId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::SetupDynamicComponentVisibilityId(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "SetupDynamicComponentVisibilityId");

	Params::RBDoor_SetupDynamicComponentVisibilityId Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.SlamClosed_Server
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ERepulsionDirectionFlags                Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBPawn*>                  SpecificPawnsPushed                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBDoor::SlamClosed_Server(ERepulsionDirectionFlags Direction, const TArray<class ARBPawn*>& SpecificPawnsPushed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "SlamClosed_Server");

	Params::RBDoor_SlamClosed_Server Parms{};

	Parms.Direction = Direction;
	Parms.SpecificPawnsPushed = std::move(SpecificPawnsPushed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.SlamClosedRepulsionDone
// (Final, Native, Public)
// Parameters:
// class URBRepulsionComponent*            RepulsionComponentDone                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoor::SlamClosedRepulsionDone(class URBRepulsionComponent* RepulsionComponentDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "SlamClosedRepulsionDone");

	Params::RBDoor_SlamClosedRepulsionDone Parms{};

	Parms.RepulsionComponentDone = RepulsionComponentDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoor.BP_GetReplacementActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBDoor::BP_GetReplacementActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_GetReplacementActor");

	Params::RBDoor_BP_GetReplacementActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsActorInFront
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsActorInFront(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsActorInFront");

	Params::RBDoor_BP_IsActorInFront Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsBlockedOnAnySide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsBlockedOnAnySide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsBlockedOnAnySide");

	Params::RBDoor_BP_IsBlockedOnAnySide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsClosed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsClosed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsClosed");

	Params::RBDoor_BP_IsClosed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsClosing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsClosing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsClosing");

	Params::RBDoor_BP_IsClosing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsFullyOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsFullyOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsFullyOpen");

	Params::RBDoor_BP_IsFullyOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsFullyOpenInBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsFullyOpenInBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsFullyOpenInBack");

	Params::RBDoor_BP_IsFullyOpenInBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsFullyOpenInFront
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsFullyOpenInFront() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsFullyOpenInFront");

	Params::RBDoor_BP_IsFullyOpenInFront Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsIdle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsIdle");

	Params::RBDoor_BP_IsIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsLinkedTrapArmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsLinkedTrapArmed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsLinkedTrapArmed");

	Params::RBDoor_BP_IsLinkedTrapArmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsLinkedTrapTriggered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsLinkedTrapTriggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsLinkedTrapTriggered");

	Params::RBDoor_BP_IsLinkedTrapTriggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsMoving");

	Params::RBDoor_BP_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsOpen");

	Params::RBDoor_BP_IsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsOpening
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsOpening() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsOpening");

	Params::RBDoor_BP_IsOpening Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.BP_IsReplaced
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDoor::BP_IsReplaced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "BP_IsReplaced");

	Params::RBDoor_BP_IsReplaced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoor.GetBlockableState
// (Native, Public, Const)
// Parameters:
// EBlockableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlockableState ARBDoor::GetBlockableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoor", "GetBlockableState");

	Params::RBDoor_GetBlockableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBackgroundCharacter.SnapToStartPosition
// (Final, Native, Public, BlueprintCallable)

void ARBBackgroundCharacter::SnapToStartPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackgroundCharacter", "SnapToStartPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPingableObject.GetPingEnabled
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        PingOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    OutIsEnabled                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBPingableObject::GetPingEnabled(class ARBPlayer* PingOwner, const struct FHitResult& HitResult, bool* OutIsEnabled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingableObject", "GetPingEnabled");

	Params::RBPingableObject_GetPingEnabled Parms{};

	Parms.PingOwner = PingOwner;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsEnabled != nullptr)
		*OutIsEnabled = Parms.OutIsEnabled;

	return Parms.ReturnValue;
}


// Function OPP.RBPingableObject.GetPingItemName
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             OutName                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBPingableObject::GetPingItemName(class FText* OutName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingableObject", "GetPingItemName");

	Params::RBPingableObject_GetPingItemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = std::move(Parms.OutName);

	return Parms.ReturnValue;
}


// Function OPP.RBPingableObject.GetPlayerPingData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        PingOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FPlayerPingData                  OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBPingableObject::GetPlayerPingData(class ARBPlayer* PingOwner, const struct FHitResult& HitResult, struct FPlayerPingData* OutData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingableObject", "GetPlayerPingData");

	Params::RBPingableObject_GetPlayerPingData Parms{};

	Parms.PingOwner = PingOwner;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function OPP.RBPingableObject.GetPlayerPingWorldLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        PingOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBPingableObject::GetPlayerPingWorldLocation(class ARBPlayer* PingOwner, const struct FHitResult& HitResult, struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingableObject", "GetPlayerPingWorldLocation");

	Params::RBPingableObject_GetPlayerPingWorldLocation Parms{};

	Parms.PingOwner = PingOwner;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function OPP.RBBareBonesInteractionComponent.OnRep_PawnInteracting
// (Native, Public)

void URBBareBonesInteractionComponent::OnRep_PawnInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBareBonesInteractionComponent", "OnRep_PawnInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabWidget.Event_OnParentFocused
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::Event_OnParentFocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "Event_OnParentFocused");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabWidget.Event_OnParentPopped
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::Event_OnParentPopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "Event_OnParentPopped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabWidget.Event_OnParentUnfocused
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::Event_OnParentUnfocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "Event_OnParentUnfocused");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabWidget.Event_OnTabSelected
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::Event_OnTabSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "Event_OnTabSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabWidget.Event_OnTabUnselected
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::Event_OnTabUnselected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "Event_OnTabUnselected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabWidget.GetMenuWithTabsParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBMenuWithTabsWidget*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuWithTabsWidget* URBMenuTabWidget::GetMenuWithTabsParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "GetMenuWithTabsParent");

	Params::RBMenuTabWidget_GetMenuWithTabsParent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuTabWidget.GetPageSpecificButtons
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UUserWidget*>              OutButtons                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBMenuTabWidget::GetPageSpecificButtons(TArray<class UUserWidget*>* OutButtons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "GetPageSpecificButtons");

	Params::RBMenuTabWidget_GetPageSpecificButtons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutButtons != nullptr)
		*OutButtons = std::move(Parms.OutButtons);
}


// Function OPP.RBMenuTabWidget.IsReadyToClose
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuTabWidget::IsReadyToClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "IsReadyToClose");

	Params::RBMenuTabWidget_IsReadyToClose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuTabWidget.OnBackRequested
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuTabWidget::OnBackRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "OnBackRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabWidget.OnButtonClicked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      buttonClicked                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuTabWidget::OnButtonClicked(class UUserWidget* buttonClicked, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "OnButtonClicked");

	Params::RBMenuTabWidget_OnButtonClicked Parms{};

	Parms.buttonClicked = buttonClicked;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabWidget.OnButtonReleased
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      buttonClicked                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuTabWidget::OnButtonReleased(class UUserWidget* buttonClicked, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "OnButtonReleased");

	Params::RBMenuTabWidget_OnButtonReleased Parms{};

	Parms.buttonClicked = buttonClicked;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabWidget.OnNavigationChanged
// (Final, Native, Public, BlueprintCallable)

void URBMenuTabWidget::OnNavigationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "OnNavigationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabWidget.RequestNavigationBack
// (Final, Native, Public, BlueprintCallable)

void URBMenuTabWidget::RequestNavigationBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabWidget", "RequestNavigationBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBarcodeComponent.OnRep_Barcode
// (Final, Native, Public)

void URBBarcodeComponent::OnRep_Barcode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBarcodeComponent", "OnRep_Barcode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBarcodeComponent.OnRep_BarcodePrefix
// (Final, Native, Public)

void URBBarcodeComponent::OnRep_BarcodePrefix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBarcodeComponent", "OnRep_BarcodePrefix");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.BP_SetEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerTriggerVolume::BP_SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "BP_SetEnabled");

	Params::RBPlayerTriggerVolume_BP_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.OnPlayerEnteredEventBypass
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerTriggerVolume::OnPlayerEnteredEventBypass(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "OnPlayerEnteredEventBypass");

	Params::RBPlayerTriggerVolume_OnPlayerEnteredEventBypass Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.OnPlayerExitedEventBypass
// (Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerTriggerVolume::OnPlayerExitedEventBypass(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "OnPlayerExitedEventBypass");

	Params::RBPlayerTriggerVolume_OnPlayerExitedEventBypass Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.OnTriggeredEventBypass
// (Final, Native, Public)
// Parameters:
// class URBPlayerTriggerComponent*        Trigger                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerTriggerVolume::OnTriggeredEventBypass(class URBPlayerTriggerComponent* Trigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "OnTriggeredEventBypass");

	Params::RBPlayerTriggerVolume_OnTriggeredEventBypass Parms{};

	Parms.Trigger = Trigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.OnUntriggeredEventBypass
// (Final, Native, Public)
// Parameters:
// class URBPlayerTriggerComponent*        Trigger                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerTriggerVolume::OnUntriggeredEventBypass(class URBPlayerTriggerComponent* Trigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "OnUntriggeredEventBypass");

	Params::RBPlayerTriggerVolume_OnUntriggeredEventBypass Parms{};

	Parms.Trigger = Trigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerVolume.IsEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerTriggerVolume::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerVolume", "IsEnabled");

	Params::RBPlayerTriggerVolume_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetAssignedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBLobbyPlayerController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLobbyPlayerController* ARBPlayerCell::GetAssignedPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetAssignedPlayer");

	Params::RBPlayerCell_GetAssignedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedPlayerStarts
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AActor*> ARBPlayerCell::GetLinkedPlayerStarts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedPlayerStarts");

	Params::RBPlayerCell_GetLinkedPlayerStarts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.Multicast_MarkReflectionCaptureDirty
// (Net, Native, Event, NetMulticast, Public)

void ARBPlayerCell::Multicast_MarkReflectionCaptureDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "Multicast_MarkReflectionCaptureDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.OnAllowedPawnsUpdated
// (Final, Native, Private)

void ARBPlayerCell::OnAllowedPawnsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "OnAllowedPawnsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.OnAssignedPlayerStateUpdated
// (Final, Native, Private)

void ARBPlayerCell::OnAssignedPlayerStateUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "OnAssignedPlayerStateUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.OnPlayerCellCustomizationUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRBPlayerCellCustomizationEntry>PlayerCellCustomization                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBPlayerCell::OnPlayerCellCustomizationUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const TArray<struct FRBPlayerCellCustomizationEntry>& PlayerCellCustomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "OnPlayerCellCustomizationUpdated");

	Params::RBPlayerCell_OnPlayerCellCustomizationUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.PlayerCellCustomization = std::move(PlayerCellCustomization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.OnPlayerEnteredReflectionCaptureTrigger
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerCell::OnPlayerEnteredReflectionCaptureTrigger(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "OnPlayerEnteredReflectionCaptureTrigger");

	Params::RBPlayerCell_OnPlayerEnteredReflectionCaptureTrigger Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.PreviewCustomization
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// ECustomizationMenuCategory              Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCellItemDefinition*      ItemDefinition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerCell::PreviewCustomization(ECustomizationMenuCategory Slot, class URBPlayerCellItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "PreviewCustomization");

	Params::RBPlayerCell_PreviewCustomization Parms{};

	Parms.Slot = Slot;
	Parms.ItemDefinition = ItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.RefreshCustomization
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FRBPlayerCellCustomizationEntry>PlayerCellCustomization                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBPlayerCell::RefreshCustomization(const TArray<struct FRBPlayerCellCustomizationEntry>& PlayerCellCustomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "RefreshCustomization");

	Params::RBPlayerCell_RefreshCustomization Parms{};

	Parms.PlayerCellCustomization = std::move(PlayerCellCustomization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCell.GetCellCustomizationCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBPlayerCell::GetCellCustomizationCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetCellCustomizationCamera");

	Params::RBPlayerCell_GetCellCustomizationCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetCellMenuCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBPlayerCell::GetCellMenuCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetCellMenuCharacter");

	Params::RBPlayerCell_GetCellMenuCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedBlockingVolumes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBBlockingVolume*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBBlockingVolume*> ARBPlayerCell::GetLinkedBlockingVolumes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedBlockingVolumes");

	Params::RBPlayerCell_GetLinkedBlockingVolumes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedCellItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPlayerCellItem*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPlayerCellItem*> ARBPlayerCell::GetLinkedCellItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedCellItems");

	Params::RBPlayerCell_GetLinkedCellItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedCollectibleDisplays
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBCollectibleDisplay*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBCollectibleDisplay*> ARBPlayerCell::GetLinkedCollectibleDisplays() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedCollectibleDisplays");

	Params::RBPlayerCell_GetLinkedCollectibleDisplays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedCustomizationInterfaces
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBCustomizationInterface*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBCustomizationInterface*> ARBPlayerCell::GetLinkedCustomizationInterfaces() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedCustomizationInterfaces");

	Params::RBPlayerCell_GetLinkedCustomizationInterfaces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedDoors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBDoor*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBDoor*> ARBPlayerCell::GetLinkedDoors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedDoors");

	Params::RBPlayerCell_GetLinkedDoors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCell.GetLinkedInteractibles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBInteractible*>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBInteractible*> ARBPlayerCell::GetLinkedInteractibles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCell", "GetLinkedInteractibles");

	Params::RBPlayerCell_GetLinkedInteractibles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTriggerable.BP_AddOperatableToComplete
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTriggerableSetting              TriggerSetting                                         (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_AddOperatableToComplete(const struct FTriggerableSetting& TriggerSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_AddOperatableToComplete");

	Params::RBTriggerable_BP_AddOperatableToComplete Parms{};

	Parms.TriggerSetting = std::move(TriggerSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_ForceState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTrigger                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_ForceState(bool bTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_ForceState");

	Params::RBTriggerable_BP_ForceState Parms{};

	Parms.bTrigger = bTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_ForceTrigger
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBTriggerable::BP_ForceTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_ForceTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_ForceUntrigger
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBTriggerable::BP_ForceUntrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_ForceUntrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_OnTriggerSequenceCompleted
// (Final, Native, Public, BlueprintCallable)

void ARBTriggerable::BP_OnTriggerSequenceCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_OnTriggerSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_OnUntriggerSequenceCompleted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBTriggerable::BP_OnUntriggerSequenceCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_OnUntriggerSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_RefreshLinkedLedges
// (Final, Native, Protected, BlueprintCallable)

void ARBTriggerable::BP_RefreshLinkedLedges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_RefreshLinkedLedges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_RemoveOperatableToComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_RemoveOperatableToComplete(class UObject* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_RemoveOperatableToComplete");

	Params::RBTriggerable_BP_RemoveOperatableToComplete Parms{};

	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_SetOverrideOperatable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_SetOverrideOperatable(class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_SetOverrideOperatable");

	Params::RBTriggerable_BP_SetOverrideOperatable Parms{};

	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_SetShowInDebug
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bShowInDebugValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_SetShowInDebug(bool bShowInDebugValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_SetShowInDebug");

	Params::RBTriggerable_BP_SetShowInDebug Parms{};

	Parms.bShowInDebugValue = bShowInDebugValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_SetStartsTriggered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTriggered                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_SetStartsTriggered(bool bTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_SetStartsTriggered");

	Params::RBTriggerable_BP_SetStartsTriggered Parms{};

	Parms.bTriggered = bTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_SnapToTriggeredState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Triggered                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::BP_SnapToTriggeredState(bool Triggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_SnapToTriggeredState");

	Params::RBTriggerable_BP_SnapToTriggeredState Parms{};

	Parms.Triggered = Triggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.Event_OnOperatableCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// class UObject*                          Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::Event_OnOperatableCompleted(class UObject* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnOperatableCompleted");

	Params::RBTriggerable_Event_OnOperatableCompleted Parms{};

	Parms.Operatable = Operatable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTriggerable.Event_OnOperatableProgressChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class UObject*                          Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnap                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::Event_OnOperatableProgressChanged(class UObject* Operatable, float OldProgress, float CurrentProgress, bool bSnap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnOperatableProgressChanged");

	Params::RBTriggerable_Event_OnOperatableProgressChanged Parms{};

	Parms.Operatable = Operatable;
	Parms.OldProgress = OldProgress;
	Parms.CurrentProgress = CurrentProgress;
	Parms.bSnap = bSnap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTriggerable.Event_OnOperatableUncompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// class UObject*                          Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerable::Event_OnOperatableUncompleted(class UObject* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnOperatableUncompleted");

	Params::RBTriggerable_Event_OnOperatableUncompleted Parms{};

	Parms.Operatable = Operatable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTriggerable.Event_OnTriggered
// (Event, Public, BlueprintEvent)

void ARBTriggerable::Event_OnTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerable.Event_OnTriggerSequenceStarted
// (Event, Public, BlueprintEvent)

void ARBTriggerable::Event_OnTriggerSequenceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnTriggerSequenceStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerable.Event_OnUntriggered
// (Event, Public, BlueprintEvent)

void ARBTriggerable::Event_OnUntriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnUntriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerable.Event_OnUntriggerSequenceStarted
// (Event, Public, BlueprintEvent)

void ARBTriggerable::Event_OnUntriggerSequenceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_OnUntriggerSequenceStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerable.Event_SnapToState
// (Event, Public, BlueprintEvent)

void ARBTriggerable::Event_SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Event_SnapToState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerable.Multicast_StartTriggerSequence
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBTriggerable::Multicast_StartTriggerSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Multicast_StartTriggerSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.Multicast_StartUntriggerSequence
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBTriggerable::Multicast_StartUntriggerSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "Multicast_StartUntriggerSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.OnRep_Triggered
// (Final, Native, Private)

void ARBTriggerable::OnRep_Triggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "OnRep_Triggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.OnRep_TriggeredCallback
// (Final, Native, Private)

void ARBTriggerable::OnRep_TriggeredCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "OnRep_TriggeredCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.RebuildGroupedOperatable
// (Final, Native, Public, BlueprintCallable)

void ARBTriggerable::RebuildGroupedOperatable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "RebuildGroupedOperatable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.SnapToState
// (Final, Native, Public)

void ARBTriggerable::SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "SnapToState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerable.BP_AreAllOperatablesCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTriggerable::BP_AreAllOperatablesCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "BP_AreAllOperatablesCompleted");

	Params::RBTriggerable_BP_AreAllOperatablesCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTriggerable.ShouldBPTick
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTriggerable::ShouldBPTick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerable", "ShouldBPTick");

	Params::RBTriggerable_ShouldBPTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBasePushable.BP_ClearCustomPush_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBasePushable::BP_ClearCustomPush_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_ClearCustomPush_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_ClearCustomUninteractableText_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBasePushable::BP_ClearCustomUninteractableText_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_ClearCustomUninteractableText_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_PostMove
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          DeltaLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::BP_PostMove(const struct FVector& DeltaLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_PostMove");

	Params::RBBasePushable_BP_PostMove Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBasePushable.BP_SetCanBePushed_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::BP_SetCanBePushed_Server(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_SetCanBePushed_Server");

	Params::RBBasePushable_BP_SetCanBePushed_Server Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_SetCustomPushSpeed_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   WalkSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RunSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::BP_SetCustomPushSpeed_Server(float WalkSpeed, float RunSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_SetCustomPushSpeed_Server");

	Params::RBBasePushable_BP_SetCustomPushSpeed_Server Parms{};

	Parms.WalkSpeed = WalkSpeed;
	Parms.RunSpeed = RunSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_SetCustomUninteractableText_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)

void ARBBasePushable::BP_SetCustomUninteractableText_Server(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_SetCustomUninteractableText_Server");

	Params::RBBasePushable_BP_SetCustomUninteractableText_Server Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_SetKeepTickingWithNoPushingPawns
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bKeepTicking                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::BP_SetKeepTickingWithNoPushingPawns(bool bKeepTicking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_SetKeepTickingWithNoPushingPawns");

	Params::RBBasePushable_BP_SetKeepTickingWithNoPushingPawns Parms{};

	Parms.bKeepTicking = bKeepTicking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.Event_OnAssociatedCoordoCompleted
// (Event, Public, BlueprintEvent)

void ARBBasePushable::Event_OnAssociatedCoordoCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Event_OnAssociatedCoordoCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBasePushable.Event_OnCanBePushedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    CanBePushed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::Event_OnCanBePushedChanged(bool CanBePushed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Event_OnCanBePushedChanged");

	Params::RBBasePushable_Event_OnCanBePushedChanged Parms{};

	Parms.CanBePushed = CanBePushed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBasePushable.Event_OnPawnPushingChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBPushableComponent*             PushableComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::Event_OnPawnPushingChanged(class URBPushableComponent* PushableComponent, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Event_OnPawnPushingChanged");

	Params::RBBasePushable_Event_OnPawnPushingChanged Parms{};

	Parms.PushableComponent = PushableComponent;
	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBasePushable.Event_ShakePushable
// (Event, Public, BlueprintEvent)

void ARBBasePushable::Event_ShakePushable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Event_ShakePushable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBasePushable.Multicast_PushableStuck
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bFromCollision                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::Multicast_PushableStuck(bool bFromCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Multicast_PushableStuck");

	Params::RBBasePushable_Multicast_PushableStuck Parms{};

	Parms.bFromCollision = bFromCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.Multicast_ShakePushable
// (Net, Native, Event, NetMulticast, Public)

void ARBBasePushable::Multicast_ShakePushable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Multicast_ShakePushable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.OnRep_CanBePushed
// (Final, Native, Private)

void ARBBasePushable::OnRep_CanBePushed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "OnRep_CanBePushed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.OnRep_KeepTickingWithNoPushingPawns
// (Final, Native, Private)

void ARBBasePushable::OnRep_KeepTickingWithNoPushingPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "OnRep_KeepTickingWithNoPushingPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.OnRep_PushableInitialReplication
// (Final, Native, Private)

void ARBBasePushable::OnRep_PushableInitialReplication()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "OnRep_PushableInitialReplication");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.SetInteractionsEnabled_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::SetInteractionsEnabled_Server(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "SetInteractionsEnabled_Server");

	Params::RBBasePushable_SetInteractionsEnabled_Server Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.SetIsHardToPush
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHardToPushValue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::SetIsHardToPush(bool bHardToPushValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "SetIsHardToPush");

	Params::RBBasePushable_SetIsHardToPush Parms{};

	Parms.bHardToPushValue = bHardToPushValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.Tick_NonPushable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::Tick_NonPushable(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Tick_NonPushable");

	Params::RBBasePushable_Tick_NonPushable Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.Tick_Pushable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBasePushable::Tick_Pushable(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "Tick_Pushable");

	Params::RBBasePushable_Tick_Pushable Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBasePushable.BP_GetPawnsPushing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBPawn*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBPawn*> ARBBasePushable::BP_GetPawnsPushing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "BP_GetPawnsPushing");

	Params::RBBasePushable_BP_GetPawnsPushing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBasePushable.GetLedgeMarkerClosestTo
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLedgeMarker*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLedgeMarker* ARBBasePushable::GetLedgeMarkerClosestTo(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "GetLedgeMarkerClosestTo");

	Params::RBBasePushable_GetLedgeMarkerClosestTo Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBasePushable.IsConsideredMoving
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBasePushable::IsConsideredMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "IsConsideredMoving");

	Params::RBBasePushable_IsConsideredMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBasePushable.IsMoving
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBasePushable::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBasePushable", "IsMoving");

	Params::RBBasePushable_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDisplayMessageZoneComponent.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInteractible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDisplayMessageZoneComponent::BP_SetEnabled(bool bInteractible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDisplayMessageZoneComponent", "BP_SetEnabled");

	Params::RBDisplayMessageZoneComponent_BP_SetEnabled Parms{};

	Parms.bInteractible = bInteractible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDisplayMessageZoneComponent.OnRep_CurrentlyEnabled
// (Native, Protected)

void URBDisplayMessageZoneComponent::OnRep_CurrentlyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDisplayMessageZoneComponent", "OnRep_CurrentlyEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDisplayMessageZoneComponent.IsEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBDisplayMessageZoneComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDisplayMessageZoneComponent", "IsEnabled");

	Params::RBDisplayMessageZoneComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerInvestigationZoneComponent.BP_AddSlave_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class URBPlayerInvestigationZoneComponent*NewSlave                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerInvestigationZoneComponent::BP_AddSlave_Server(class URBPlayerInvestigationZoneComponent* NewSlave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerInvestigationZoneComponent", "BP_AddSlave_Server");

	Params::RBPlayerInvestigationZoneComponent_BP_AddSlave_Server Parms{};

	Parms.NewSlave = NewSlave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerInvestigationZoneComponent.Multicast_OnInvestigationDone
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Investigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerInvestigationZoneComponent::Multicast_OnInvestigationDone(class ARBPlayer* Investigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerInvestigationZoneComponent", "Multicast_OnInvestigationDone");

	Params::RBPlayerInvestigationZoneComponent_Multicast_OnInvestigationDone Parms{};

	Parms.Investigator = Investigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAISpawner.BP_SpawnBot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBBot*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBot* ARBAISpawner::BP_SpawnBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAISpawner", "BP_SpawnBot");

	Params::RBAISpawner_BP_SpawnBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAISpawner.BP_SpawnBotAsync
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBBot*                           Param_bot                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           SpawnedPawn                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ARBAISpawner::BP_SpawnBotAsync(class ARBBot** Param_bot, class ARBNPC** SpawnedPawn, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAISpawner", "BP_SpawnBotAsync");

	Params::RBAISpawner_BP_SpawnBotAsync Parms{};

	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_bot != nullptr)
		*Param_bot = Parms.Param_bot;

	if (SpawnedPawn != nullptr)
		*SpawnedPawn = Parms.SpawnedPawn;
}


// Function OPP.RBAISpawner.BP_SpawnBotSpecific
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBNPC>               SpecificPawnClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAIConfig*                      SpecificConfig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBot* ARBAISpawner::BP_SpawnBotSpecific(TSubclassOf<class ARBNPC> SpecificPawnClass, class URBAIConfig* SpecificConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAISpawner", "BP_SpawnBotSpecific");

	Params::RBAISpawner_BP_SpawnBotSpecific Parms{};

	Parms.SpecificPawnClass = SpecificPawnClass;
	Parms.SpecificConfig = SpecificConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCharacterSheetMenuTabWidget::HandleMenuTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "HandleMenuTabLeft");

	Params::RBCharacterSheetMenuTabWidget_HandleMenuTabLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCharacterSheetMenuTabWidget::HandleMenuTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "HandleMenuTabRight");

	Params::RBCharacterSheetMenuTabWidget_HandleMenuTabRight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.GetNavigationOverrideWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* URBCharacterSheetMenuTabWidget::GetNavigationOverrideWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "GetNavigationOverrideWidget");

	Params::RBCharacterSheetMenuTabWidget_GetNavigationOverrideWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.GetPageSubtitle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBCharacterSheetMenuTabWidget::GetPageSubtitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "GetPageSubtitle");

	Params::RBCharacterSheetMenuTabWidget_GetPageSubtitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.GetPageTitle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBCharacterSheetMenuTabWidget::GetPageTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "GetPageTitle");

	Params::RBCharacterSheetMenuTabWidget_GetPageTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowNavigation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCharacterSheetMenuTabWidget::ShouldShowNavigation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "ShouldShowNavigation");

	Params::RBCharacterSheetMenuTabWidget_ShouldShowNavigation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowPageTitle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCharacterSheetMenuTabWidget::ShouldShowPageTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterSheetMenuTabWidget", "ShouldShowPageTitle");

	Params::RBCharacterSheetMenuTabWidget_ShouldShowPageTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBadgesTabWidget.ClaimBadgeReward
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBadgesTabWidget::ClaimBadgeReward(const class FName& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "ClaimBadgeReward");

	Params::RBBadgesTabWidget_ClaimBadgeReward Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBadgesTabWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBBadgesTabWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBadgesTabWidget.OnPlayerStatsDataAvailable
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FRBStatContext>           Stats                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRBUIReleasedCharacterDetails>ReleasedCharacterDetailsList                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBBadgesTabWidget::OnPlayerStatsDataAvailable(const TArray<struct FRBStatContext>& Stats, const TArray<struct FRBUIReleasedCharacterDetails>& ReleasedCharacterDetailsList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "OnPlayerStatsDataAvailable");

	Params::RBBadgesTabWidget_OnPlayerStatsDataAvailable Parms{};

	Parms.Stats = std::move(Stats);
	Parms.ReleasedCharacterDetailsList = std::move(ReleasedCharacterDetailsList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBadgesTabWidget.CanClaimBadgeReward
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBadgesTabWidget::CanClaimBadgeReward(const class FName& BadgeId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "CanClaimBadgeReward");

	Params::RBBadgesTabWidget_CanClaimBadgeReward Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBadgesTabWidget.GetBadgeProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBadgesTabWidget::GetBadgeProgress(const class FName& BadgeId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "GetBadgeProgress");

	Params::RBBadgesTabWidget_GetBadgeProgress Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBadgesTabWidget.GetBadgeUnlockCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBadgesTabWidget::GetBadgeUnlockCount(const class FName& BadgeId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "GetBadgeUnlockCount");

	Params::RBBadgesTabWidget_GetBadgeUnlockCount Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBadgesTabWidget.HasClaimableBadgeReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBadgesTabWidget::HasClaimableBadgeReward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "HasClaimableBadgeReward");

	Params::RBBadgesTabWidget_HasClaimableBadgeReward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBadgesTabWidget.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBadgesTabWidget::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBadgesTabWidget", "IsDataPending");

	Params::RBBadgesTabWidget_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHurtVolume.OnPawnOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBHurtVolume::OnPawnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHurtVolume", "OnPawnOverlap");

	Params::RBHurtVolume_OnPawnOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHurtVolume.OnRep_CurrentlyEnabled
// (Final, Native, Public)

void ARBHurtVolume::OnRep_CurrentlyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHurtVolume", "OnRep_CurrentlyEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHurtVolume.Toggle
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHurtVolume::Toggle(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHurtVolume", "Toggle");

	Params::RBHurtVolume_Toggle Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHurtVolume.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHurtVolume::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHurtVolume", "IsEnabled");

	Params::RBHurtVolume_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAlarmDoorComponent.BP_OnAlerted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsAlerted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAlarmDoorComponent::BP_OnAlerted(bool bIsAlerted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAlarmDoorComponent", "BP_OnAlerted");

	Params::RBAlarmDoorComponent_BP_OnAlerted Parms{};

	Parms.bIsAlerted = bIsAlerted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBAlarmDoorComponent.OnDoorOpened
// (Final, Native, Private)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAlarmDoorComponent::OnDoorOpened(class ARBDoor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAlarmDoorComponent", "OnDoorOpened");

	Params::RBAlarmDoorComponent_OnDoorOpened Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAlarmDoorComponent.OnRep_Alerted
// (Final, Native, Private)

void URBAlarmDoorComponent::OnRep_Alerted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAlarmDoorComponent", "OnRep_Alerted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAmbientActivityMarker.Event_OnLeft
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAmbientActivityMarker::Event_OnLeft(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAmbientActivityMarker", "Event_OnLeft");

	Params::RBAmbientActivityMarker_Event_OnLeft Parms{};

	Parms.bot = bot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBAmbientActivityMarker.Event_OnReached
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAmbientActivityMarker::Event_OnReached(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAmbientActivityMarker", "Event_OnReached");

	Params::RBAmbientActivityMarker_Event_OnReached Parms{};

	Parms.bot = bot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBAmbientSound.StartAmbientSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void ARBAmbientSound::StartAmbientSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAmbientSound", "StartAmbientSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAmbientSound.StopAmbientSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void ARBAmbientSound::StopAmbientSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAmbientSound", "StopAmbientSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomsCoordinator.OnDeviceUnlocked
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBKeyLockedRoomsCoordinator::OnDeviceUnlocked(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomsCoordinator", "OnDeviceUnlocked");

	Params::RBKeyLockedRoomsCoordinator_OnDeviceUnlocked Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomsCoordinator.OnFirstDeviceUnlocked
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBKeyLockedRoomsCoordinator::OnFirstDeviceUnlocked(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomsCoordinator", "OnFirstDeviceUnlocked");

	Params::RBKeyLockedRoomsCoordinator_OnFirstDeviceUnlocked Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomsCoordinator.OnPanelInteractionCompletedChanged
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBKeyLockedRoomsCoordinator::OnPanelInteractionCompletedChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomsCoordinator", "OnPanelInteractionCompletedChanged");

	Params::RBKeyLockedRoomsCoordinator_OnPanelInteractionCompletedChanged Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomsCoordinator.OnRep_KeyItemsInfo
// (Final, Native, Protected)

void ARBKeyLockedRoomsCoordinator::OnRep_KeyItemsInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomsCoordinator", "OnRep_KeyItemsInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomsCoordinator.GetClueObjectiveIconFromClueName
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class FName                             ClueName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush ARBKeyLockedRoomsCoordinator::GetClueObjectiveIconFromClueName(const class FName& ClueName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomsCoordinator", "GetClueObjectiveIconFromClueName");

	Params::RBKeyLockedRoomsCoordinator_GetClueObjectiveIconFromClueName Parms{};

	Parms.ClueName = ClueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.EndInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          InteractorPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::EndInteraction(bool bPredicted, class ARBPawn* InteractorPawn, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "EndInteraction");

	Params::RBInteractable_EndInteraction Parms{};

	Parms.bPredicted = bPredicted;
	Parms.InteractorPawn = InteractorPawn;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.OnPawnDoSpecialMoveAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBInteractable::OnPawnDoSpecialMoveAction(class ARBPawn* Pawn, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "OnPawnDoSpecialMoveAction");

	Params::RBInteractable_OnPawnDoSpecialMoveAction Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.OnPawnPlaySpecialMoveAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBInteractable::OnPawnPlaySpecialMoveAnimation(const class ARBPawn* Pawn, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "OnPawnPlaySpecialMoveAnimation");

	Params::RBInteractable_OnPawnPlaySpecialMoveAnimation Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.OnPawnSpecialMoveCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBInteractable::OnPawnSpecialMoveCompleted(class ARBPawn* Pawn, ESpecialMove SpecialMove, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "OnPawnSpecialMoveCompleted");

	Params::RBInteractable_OnPawnSpecialMoveCompleted Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.OnPawnSpecialMoveStarted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBInteractable::OnPawnSpecialMoveStarted(class ARBPawn* Pawn, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "OnPawnSpecialMoveStarted");

	Params::RBInteractable_OnPawnSpecialMoveStarted Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.PlaySpecialMoveAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::PlaySpecialMoveAnimation(class ARBPawn* InteractorPawn, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "PlaySpecialMoveAnimation");

	Params::RBInteractable_PlaySpecialMoveAnimation Parms{};

	Parms.InteractorPawn = InteractorPawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.PostInteractionSoundEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          PawnInteractor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBInteractable::PostInteractionSoundEvent(class ARBPawn* PawnInteractor, class UAkAudioEvent* AkEvent, class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "PostInteractionSoundEvent");

	Params::RBInteractable_PostInteractionSoundEvent Parms{};

	Parms.PawnInteractor = PawnInteractor;
	Parms.AkEvent = AkEvent;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.SnapToState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBInteractable::SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "SnapToState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractable.StartInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::StartInteraction(class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "StartInteraction");

	Params::RBInteractable_StartInteraction Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.GetInteractionPawnLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::GetInteractionPawnLocation(const class ARBPawn* Pawn, ESpecialMove SpecialMove, struct FVector* OutLocation, struct FVector* OutDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "GetInteractionPawnLocation");

	Params::RBInteractable_GetInteractionPawnLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.IsInteractionInputTriggered
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Interactor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::IsInteractionInputTriggered(const class ARBPlayer* Interactor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "IsInteractionInputTriggered");

	Params::RBInteractable_IsInteractionInputTriggered Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.IsInteractionPossible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::IsInteractionPossible(const class ARBPawn* InteractorPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "IsInteractionPossible");

	Params::RBInteractable_IsInteractionPossible Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.TestPhysicsClearance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::TestPhysicsClearance(const class ARBPawn* InteractorPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "TestPhysicsClearance");

	Params::RBInteractable_TestPhysicsClearance Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInteractable.ValidateInteractionLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InteractionLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBInteractable::ValidateInteractionLocation(const class ARBPlayer* Player, const struct FVector& InteractionLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractable", "ValidateInteractionLocation");

	Params::RBInteractable_ValidateInteractionLocation Parms{};

	Parms.Player = Player;
	Parms.InteractionLocation = std::move(InteractionLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Client
// (Final, Native, Public, BlueprintCallable)

void ARBCustomSpecialMoveInteractableActor::CompleteInteraction_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "CompleteInteraction_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Server
// (Final, Native, Public, BlueprintCallable)

void ARBCustomSpecialMoveInteractableActor::CompleteInteraction_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "CompleteInteraction_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Client
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCustomSpecialMoveInteractableActor::CompleteInteractionForPlayer_Client(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "CompleteInteractionForPlayer_Client");

	Params::RBCustomSpecialMoveInteractableActor_CompleteInteractionForPlayer_Client Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Server
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCustomSpecialMoveInteractableActor::CompleteInteractionForPlayer_Server(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "CompleteInteractionForPlayer_Server");

	Params::RBCustomSpecialMoveInteractableActor_CompleteInteractionForPlayer_Server Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteracted
// (Event, Public, BlueprintEvent)

void ARBCustomSpecialMoveInteractableActor::Event_OnLocalPlayerInteracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "Event_OnLocalPlayerInteracted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteractionCompleted
// (Event, Public, BlueprintEvent)

void ARBCustomSpecialMoveInteractableActor::Event_OnLocalPlayerInteractionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "Event_OnLocalPlayerInteractionCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteracted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCustomSpecialMoveInteractableActor::Multicast_OnPlayerInteracted(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "Multicast_OnPlayerInteracted");

	Params::RBCustomSpecialMoveInteractableActor_Multicast_OnPlayerInteracted Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteractionCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCustomSpecialMoveInteractableActor::Multicast_OnPlayerInteractionCompleted(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomSpecialMoveInteractableActor", "Multicast_OnPlayerInteractionCompleted");

	Params::RBCustomSpecialMoveInteractableActor_Multicast_OnPlayerInteractionCompleted Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuestGiver.GetNextStorylineVO
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   LevelPlayed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFallbackVO                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FeatureSwitchPlayed                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* ARBQuestGiver::GetNextStorylineVO(int32* LevelPlayed, bool* bIsFallbackVO, class FString* FeatureSwitchPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestGiver", "GetNextStorylineVO");

	Params::RBQuestGiver_GetNextStorylineVO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LevelPlayed != nullptr)
		*LevelPlayed = Parms.LevelPlayed;

	if (bIsFallbackVO != nullptr)
		*bIsFallbackVO = Parms.bIsFallbackVO;

	if (FeatureSwitchPlayed != nullptr)
		*FeatureSwitchPlayed = std::move(Parms.FeatureSwitchPlayed);

	return Parms.ReturnValue;
}


// Function OPP.RBQuestGiver.OnVOEnded
// (Final, Native, Private)
// Parameters:
// class AActor*                           RbTalker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayingId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBQuestGiver::OnVOEnded(class AActor* RbTalker, int32 PlayingId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestGiver", "OnVOEnded");

	Params::RBQuestGiver_OnVOEnded Parms{};

	Parms.RbTalker = RbTalker;
	Parms.PlayingId = PlayingId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuestGiver.PlayAkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOContext                              VOContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBQuestGiver::PlayAkEvent(class UAkAudioEvent* AkEvent, EVOContext VOContext, EVOPriority VOPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestGiver", "PlayAkEvent");

	Params::RBQuestGiver_PlayAkEvent Parms{};

	Parms.AkEvent = AkEvent;
	Parms.VOContext = VOContext;
	Parms.VOPriority = VOPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBQuestGiver.PlayStoryLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBQuestGiver::PlayStoryLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestGiver", "PlayStoryLine");

	Params::RBQuestGiver_PlayStoryLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBQuestGiver.GetMetaNPCType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMetaNPCType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMetaNPCType ARBQuestGiver::GetMetaNPCType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestGiver", "GetMetaNPCType");

	Params::RBQuestGiver_GetMetaNPCType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBot
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnAIDirectorSpawnedBot(class ARBBot* bot, class ARBNPC* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnAIDirectorSpawnedBot");

	Params::RBLevelScriptActor_OnAIDirectorSpawnedBot Parms{};

	Parms.bot = bot;
	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBotCallback
// (Final, Native, Public)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnAIDirectorSpawnedBotCallback(class ARBBot* bot, class ARBNPC* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnAIDirectorSpawnedBotCallback");

	Params::RBLevelScriptActor_OnAIDirectorSpawnedBotCallback Parms{};

	Parms.bot = bot;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLevelScriptActor.OnCoordinatorCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsApplyingCheats                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnCoordinatorCompleted(class ARBBaseObjectiveCoordinator* Coordinator, bool bIsApplyingCheats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnCoordinatorCompleted");

	Params::RBLevelScriptActor_OnCoordinatorCompleted Parms{};

	Parms.Coordinator = Coordinator;
	Parms.bIsApplyingCheats = bIsApplyingCheats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnCoordinatorStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsApplyingCheats                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnCoordinatorStarted(class ARBBaseObjectiveCoordinator* Coordinator, bool bIsApplyingCheats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnCoordinatorStarted");

	Params::RBLevelScriptActor_OnCoordinatorStarted Parms{};

	Parms.Coordinator = Coordinator;
	Parms.bIsApplyingCheats = bIsApplyingCheats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnObjectiveCoordinatorStateChanged
// (Final, Native, Public)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnObjectiveCoordinatorStateChanged");

	Params::RBLevelScriptActor_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLevelScriptActor.OnPopulatingFinished
// (Event, Public, BlueprintEvent)

void ARBLevelScriptActor::OnPopulatingFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnPopulatingFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLevelScriptActor.OnStageEnded
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FRBStageID                       StageID                                                (Parm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsFail                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bIsFail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageEnded");

	Params::RBLevelScriptActor_OnStageEnded Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.bIsFail = bIsFail;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnStageEndedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsFail                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageEndedCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bIsFail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageEndedCallback");

	Params::RBLevelScriptActor_OnStageEndedCallback Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.bIsFail = bIsFail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLevelScriptActor.OnStageReady
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FRBStageID                       StageID                                                (Parm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (Parm, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageReady");

	Params::RBLevelScriptActor_OnStageReady Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnStageReadyCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageReadyCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageReadyCallback");

	Params::RBLevelScriptActor_OnStageReadyCallback Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLevelScriptActor.OnStageStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FRBStageID                       StageID                                                (Parm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (Parm, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageStarted(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageStarted");

	Params::RBLevelScriptActor_OnStageStarted Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLevelScriptActor.OnStageStartedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLevelScriptActor::OnStageStartedCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnStageStartedCallback");

	Params::RBLevelScriptActor_OnStageStartedCallback Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLevelScriptActor.OnWorldLoadingFinished
// (Event, Public, BlueprintEvent)

void ARBLevelScriptActor::OnWorldLoadingFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLevelScriptActor", "OnWorldLoadingFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAnimInstance.GetIsLeftFootDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAnimInstance::GetIsLeftFootDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstance", "GetIsLeftFootDown");

	Params::RBAnimInstance_GetIsLeftFootDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAnimInstance.OnTraversalSlideDone
// (Native, Public)
// Parameters:
// bool                                    bHitWall                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAnimInstance::OnTraversalSlideDone(bool bHitWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstance", "OnTraversalSlideDone");

	Params::RBAnimInstance_OnTraversalSlideDone Parms{};

	Parms.bHitWall = bHitWall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstance.SetHoldingItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAnimInstance::SetHoldingItem(bool Value, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstance", "SetHoldingItem");

	Params::RBAnimInstance_SetHoldingItem Parms{};

	Parms.Value = Value;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstance.SetIsPlayingSpecialMoveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    In_IsPlayingSpecialMoveAnimation                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAnimInstance::SetIsPlayingSpecialMoveAnimation(bool In_IsPlayingSpecialMoveAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstance", "SetIsPlayingSpecialMoveAnimation");

	Params::RBAnimInstance_SetIsPlayingSpecialMoveAnimation Parms{};

	Parms.In_IsPlayingSpecialMoveAnimation = In_IsPlayingSpecialMoveAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstance.GetIsPlayingSpecialMoveAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAnimInstance::GetIsPlayingSpecialMoveAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstance", "GetIsPlayingSpecialMoveAnimation");

	Params::RBAnimInstance_GetIsPlayingSpecialMoveAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMinigameRoomComponent.OnDoorFullyUnlocked_Server
// (Final, Native, Public)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMinigameRoomComponent::OnDoorFullyUnlocked_Server(class ARBDoor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnDoorFullyUnlocked_Server");

	Params::RBMinigameRoomComponent_OnDoorFullyUnlocked_Server Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomComponent.OnMinigameScoreScoreChanged
// (Event, Public, BlueprintEvent)

void URBMinigameRoomComponent::OnMinigameScoreScoreChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnMinigameScoreScoreChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMinigameRoomComponent.OnOperatableCompleted_Server
// (Final, Native, Public)
// Parameters:
// bool                                    bIsOn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMinigameRoomComponent::OnOperatableCompleted_Server(bool bIsOn, class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnOperatableCompleted_Server");

	Params::RBMinigameRoomComponent_OnOperatableCompleted_Server Parms{};

	Parms.bIsOn = bIsOn;
	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomComponent.OnRep_MinigameScore
// (Final, Native, Public)

void URBMinigameRoomComponent::OnRep_MinigameScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnRep_MinigameScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomComponent.OnRep_MinigameState
// (Final, Native, Public)

void URBMinigameRoomComponent::OnRep_MinigameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnRep_MinigameState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomComponent.OnRep_Scheduled
// (Final, Native, Public)

void URBMinigameRoomComponent::OnRep_Scheduled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomComponent", "OnRep_Scheduled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstanceNPC.Event_OnInDarknessChanged
// (Event, Public, BlueprintEvent)

void URBAnimInstanceNPC::Event_OnInDarknessChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstanceNPC", "Event_OnInDarknessChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAnimInstanceNPC.IsPlayingSpecialAnimState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBAnimInstanceNPC::IsPlayingSpecialAnimState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstanceNPC", "IsPlayingSpecialAnimState");

	Params::RBAnimInstanceNPC_IsPlayingSpecialAnimState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAnimInstancePlayer.ClearItemAnimData
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::ClearItemAnimData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "ClearItemAnimData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.ClearNightVisionAnimation
// (Final, Native, Public)

void URBAnimInstancePlayer::ClearNightVisionAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "ClearNightVisionAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.ForceNoNetCombiningThisFrame
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::ForceNoNetCombiningThisFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "ForceNoNetCombiningThisFrame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.GetItemHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* URBAnimInstancePlayer::GetItemHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "GetItemHeld");

	Params::RBAnimInstancePlayer_GetItemHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAnimInstancePlayer.HideSwappedItems
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::HideSwappedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "HideSwappedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.OnWantsNightVisionChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAnimInstancePlayer::OnWantsNightVisionChanged(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "OnWantsNightVisionChanged");

	Params::RBAnimInstancePlayer_OnWantsNightVisionChanged Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.SetNextInventoryMontageTime
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::SetNextInventoryMontageTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "SetNextInventoryMontageTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.SwapInventoryItemAnimationsToNextItem
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::SwapInventoryItemAnimationsToNextItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "SwapInventoryItemAnimationsToNextItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAnimInstancePlayer.UpdateItemAnimData
// (Final, Native, Public, BlueprintCallable)

void URBAnimInstancePlayer::UpdateItemAnimData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAnimInstancePlayer", "UpdateItemAnimData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDWorldIconWidget.Event_DrawHudUpdate
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRBWorldIconUpdateContext        UpdateContext                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBHUDWorldIconWidget::Event_DrawHudUpdate(const struct FRBWorldIconUpdateContext& UpdateContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWorldIconWidget", "Event_DrawHudUpdate");

	Params::RBHUDWorldIconWidget_Event_DrawHudUpdate Parms{};

	Parms.UpdateContext = std::move(UpdateContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDOverheadInfo.Event_CurrentLoadoutChanged
// (Event, Protected, BlueprintEvent)

void URBHUDOverheadInfo::Event_CurrentLoadoutChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_CurrentLoadoutChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDOverheadInfo.Event_HUDSettingsUpdated
// (Event, Protected, BlueprintEvent)

void URBHUDOverheadInfo::Event_HUDSettingsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_HUDSettingsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDOverheadInfo.Event_ImposterUpdated
// (Event, Protected, BlueprintEvent)

void URBHUDOverheadInfo::Event_ImposterUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_ImposterUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDOverheadInfo.Event_InventoryUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// EInventoryUpdateEventType               InventoryEventType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::Event_InventoryUpdated(EInventoryUpdateEventType InventoryEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_InventoryUpdated");

	Params::RBHUDOverheadInfo_Event_InventoryUpdated Parms{};

	Parms.InventoryEventType = InventoryEventType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDOverheadInfo.Event_PlayerHealthChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipAnims                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::Event_PlayerHealthChanged(float NewHealth, bool bSkipAnims)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_PlayerHealthChanged");

	Params::RBHUDOverheadInfo_Event_PlayerHealthChanged Parms{};

	Parms.NewHealth = NewHealth;
	Parms.bSkipAnims = bSkipAnims;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDOverheadInfo.Event_PlayerIndicatorTypeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EPlayerIndicatorType                    PlayerIndicatorType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::Event_PlayerIndicatorTypeChanged(EPlayerIndicatorType PlayerIndicatorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_PlayerIndicatorTypeChanged");

	Params::RBHUDOverheadInfo_Event_PlayerIndicatorTypeChanged Parms{};

	Parms.PlayerIndicatorType = PlayerIndicatorType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDOverheadInfo.Event_PlayerMaxHealthChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewMaxHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::Event_PlayerMaxHealthChanged(float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_PlayerMaxHealthChanged");

	Params::RBHUDOverheadInfo_Event_PlayerMaxHealthChanged Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDOverheadInfo.Event_PlayerPartyStateUpdated
// (Event, Protected, BlueprintEvent)

void URBHUDOverheadInfo::Event_PlayerPartyStateUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_PlayerPartyStateUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDOverheadInfo.Event_PlayerStateUpdated
// (Event, Protected, BlueprintEvent)

void URBHUDOverheadInfo::Event_PlayerStateUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "Event_PlayerStateUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDOverheadInfo.OnHUDSettingsModified
// (Final, Native, Private)

void URBHUDOverheadInfo::OnHUDSettingsModified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "OnHUDSettingsModified");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDOverheadInfo.OnLastPossessedPlayerUpdated
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        LastPossessedPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::OnLastPossessedPlayerUpdated(class ARBPlayer* LastPossessedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "OnLastPossessedPlayerUpdated");

	Params::RBHUDOverheadInfo_OnLastPossessedPlayerUpdated Parms{};

	Parms.LastPossessedPlayer = LastPossessedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDOverheadInfo.OnPlayerHealthChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::OnPlayerHealthChanged(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "OnPlayerHealthChanged");

	Params::RBHUDOverheadInfo_OnPlayerHealthChanged Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDOverheadInfo.OnPlayerPartyStateUpdated
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   Unused                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDOverheadInfo::OnPlayerPartyStateUpdated(class ARBPlayerState* Unused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDOverheadInfo", "OnPlayerPartyStateUpdated");

	Params::RBHUDOverheadInfo_OnPlayerPartyStateUpdated Parms{};

	Parms.Unused = Unused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleHoldPanelComponent.Event_OnAccumulatedInteractionTimeChanged
// (Event, Public, BlueprintEvent)

void URBSimpleHoldPanelComponent::Event_OnAccumulatedInteractionTimeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "Event_OnAccumulatedInteractionTimeChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSimpleHoldPanelComponent.OnAccumulatedInteractionTimeChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSimpleHoldPanelComponent::OnAccumulatedInteractionTimeChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "OnAccumulatedInteractionTimeChangedCallback");

	Params::RBSimpleHoldPanelComponent_OnAccumulatedInteractionTimeChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleHoldPanelComponent.OnHoldCompletedChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSimpleHoldPanelComponent::OnHoldCompletedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "OnHoldCompletedChangedCallback");

	Params::RBSimpleHoldPanelComponent_OnHoldCompletedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleHoldPanelComponent.OnRep_AccumulatedInteractionTime
// (Final, Native, Private)

void URBSimpleHoldPanelComponent::OnRep_AccumulatedInteractionTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "OnRep_AccumulatedInteractionTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleHoldPanelComponent.OnRep_HoldCompleted
// (Final, Native, Private)

void URBSimpleHoldPanelComponent::OnRep_HoldCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "OnRep_HoldCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleHoldPanelComponent.BP_GetProgressRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSimpleHoldPanelComponent::BP_GetProgressRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "BP_GetProgressRatio");

	Params::RBSimpleHoldPanelComponent_BP_GetProgressRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSimpleHoldPanelComponent.GetHeldTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSimpleHoldPanelComponent::GetHeldTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "GetHeldTime");

	Params::RBSimpleHoldPanelComponent_GetHeldTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSimpleHoldPanelComponent.IsHoldCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSimpleHoldPanelComponent::IsHoldCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleHoldPanelComponent", "IsHoldCompleted");

	Params::RBSimpleHoldPanelComponent_IsHoldCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerEnteredTrigger
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBZoneDefenceObjectiveCoordinator::OnPlayerEnteredTrigger(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "OnPlayerEnteredTrigger");

	Params::RBZoneDefenceObjectiveCoordinator_OnPlayerEnteredTrigger Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerExitedTrigger
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBZoneDefenceObjectiveCoordinator::OnPlayerExitedTrigger(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "OnPlayerExitedTrigger");

	Params::RBZoneDefenceObjectiveCoordinator_OnPlayerExitedTrigger Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.OnRep_ObjectiveZoneInfos
// (Final, Native, Protected)

void ARBZoneDefenceObjectiveCoordinator::OnRep_ObjectiveZoneInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "OnRep_ObjectiveZoneInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.GetZoneProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBZoneDefenceLocation*           Zone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBZoneDefenceObjectiveCoordinator::GetZoneProgress(const class ARBZoneDefenceLocation* Zone) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "GetZoneProgress");

	Params::RBZoneDefenceObjectiveCoordinator_GetZoneProgress Parms{};

	Parms.Zone = Zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBZoneDefenceLocation*           Zone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBZoneDefenceObjectiveCoordinator::IsZoneActive(const class ARBZoneDefenceLocation* Zone) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "IsZoneActive");

	Params::RBZoneDefenceObjectiveCoordinator_IsZoneActive Parms{};

	Parms.Zone = Zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBZoneDefenceLocation*           Zone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBZoneDefenceObjectiveCoordinator::IsZoneCompleted(const class ARBZoneDefenceLocation* Zone) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceObjectiveCoordinator", "IsZoneCompleted");

	Params::RBZoneDefenceObjectiveCoordinator_IsZoneCompleted Parms{};

	Parms.Zone = Zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDGenericInWorldIcon.Event_UpdateIconTexture
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       NewTexture                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDGenericInWorldIcon::Event_UpdateIconTexture(class UTexture2D* NewTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDGenericInWorldIcon", "Event_UpdateIconTexture");

	Params::RBHUDGenericInWorldIcon_Event_UpdateIconTexture Parms{};

	Parms.NewTexture = NewTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBKeyLockedRoomComponent.OnRep_FinalRoomType
// (Final, Native, Public)

void URBKeyLockedRoomComponent::OnRep_FinalRoomType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomComponent", "OnRep_FinalRoomType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBKeyLockedRoomComponent.OnRep_Scheduled
// (Final, Native, Public)

void URBKeyLockedRoomComponent::OnRep_Scheduled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomComponent", "OnRep_Scheduled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.BP_SetTVChannel
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBNarrativeScreenChannel*        Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreen::BP_SetTVChannel(class ARBNarrativeScreenChannel* Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "BP_SetTVChannel");

	Params::RBNarrativeScreen_BP_SetTVChannel Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.BP_SetTVOn
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateOnAllLinkedChannelTVs                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreen::BP_SetTVOn(bool bValue, bool bPropagateOnAllLinkedChannelTVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "BP_SetTVOn");

	Params::RBNarrativeScreen_BP_SetTVOn Parms{};

	Parms.bValue = bValue;
	Parms.bPropagateOnAllLinkedChannelTVs = bPropagateOnAllLinkedChannelTVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.Event_OnDamageCountChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreen::Event_OnDamageCountChanged(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "Event_OnDamageCountChanged");

	Params::RBNarrativeScreen_Event_OnDamageCountChanged Parms{};

	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNarrativeScreen.Event_OnIsOnChanged
// (Event, Public, BlueprintEvent)

void ARBNarrativeScreen::Event_OnIsOnChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "Event_OnIsOnChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNarrativeScreen.Event_OnLinkedStatusChanged
// (Event, Public, BlueprintEvent)

void ARBNarrativeScreen::Event_OnLinkedStatusChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "Event_OnLinkedStatusChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNarrativeScreen.OnNumberOfHitChanged
// (Final, Native, Private)
// Parameters:
// class URBDamageableComponent*           DamagedComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreen::OnNumberOfHitChanged(class URBDamageableComponent* DamagedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "OnNumberOfHitChanged");

	Params::RBNarrativeScreen_OnNumberOfHitChanged Parms{};

	Parms.DamagedComponent = DamagedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.OnRep_IsOn
// (Final, Native, Public)

void ARBNarrativeScreen::OnRep_IsOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "OnRep_IsOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.OnRep_LinkedChannel
// (Final, Native, Public)
// Parameters:
// class ARBNarrativeScreenChannel*        OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreen::OnRep_LinkedChannel(class ARBNarrativeScreenChannel* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "OnRep_LinkedChannel");

	Params::RBNarrativeScreen_OnRep_LinkedChannel Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreen.IsCurrentlyPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNarrativeScreen::IsCurrentlyPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreen", "IsCurrentlyPlaying");

	Params::RBNarrativeScreen_IsCurrentlyPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetSetDirect3DVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGraphicsRHI                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGraphicsRHI URBGameUserSettings::GetSetDirect3DVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetSetDirect3DVersion");

	Params::RBGameUserSettings_GetSetDirect3DVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.SetDirect3DVersion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGraphicsRHI                            D3DVersion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserSettings::SetDirect3DVersion(EGraphicsRHI D3DVersion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "SetDirect3DVersion");

	Params::RBGameUserSettings_SetDirect3DVersion Parms{};

	Parms.D3DVersion = D3DVersion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserSettings.SetQualityPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PresetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserSettings::SetQualityPreset(int32 PresetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "SetQualityPreset");

	Params::RBGameUserSettings_SetQualityPreset Parms{};

	Parms.PresetValue = PresetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserSettings.UpdateQualityFromPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PresetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserSettings::UpdateQualityFromPreset(int32 PresetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "UpdateQualityFromPreset");

	Params::RBGameUserSettings_UpdateQualityFromPreset Parms{};

	Parms.PresetValue = PresetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserSettings.ComputeQualityPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::ComputeQualityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "ComputeQualityPreset");

	Params::RBGameUserSettings_ComputeQualityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetAntiAliasingQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetAntiAliasingQuality");

	Params::RBGameUserSettings_GetAntiAliasingQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserSettings::GetBrightness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetBrightness");

	Params::RBGameUserSettings_GetBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetCurrentDirect3DVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGraphicsRHI                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGraphicsRHI URBGameUserSettings::GetCurrentDirect3DVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetCurrentDirect3DVersion");

	Params::RBGameUserSettings_GetCurrentDirect3DVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetDLSSQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetDLSSQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetDLSSQuality");

	Params::RBGameUserSettings_GetDLSSQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetFSR2Quality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetFSR2Quality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetFSR2Quality");

	Params::RBGameUserSettings_GetFSR2Quality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetQualityPreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetQualityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetQualityPreset");

	Params::RBGameUserSettings_GetQualityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetRTEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserSettings::GetRTEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetRTEnabled");

	Params::RBGameUserSettings_GetRTEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetRTReflectionsQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetRTReflectionsQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetRTReflectionsQuality");

	Params::RBGameUserSettings_GetRTReflectionsQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetRTShadowsQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserSettings::GetRTShadowsQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetRTShadowsQuality");

	Params::RBGameUserSettings_GetRTShadowsQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.GetWantedDirect3DVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGraphicsRHI                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGraphicsRHI URBGameUserSettings::GetWantedDirect3DVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "GetWantedDirect3DVersion");

	Params::RBGameUserSettings_GetWantedDirect3DVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.HasResolutionChanged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserSettings::HasResolutionChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "HasResolutionChanged");

	Params::RBGameUserSettings_HasResolutionChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.HasRTHardware
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserSettings::HasRTHardware() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "HasRTHardware");

	Params::RBGameUserSettings_HasRTHardware Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.IsMotionBlurDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserSettings::IsMotionBlurDirty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "IsMotionBlurDirty");

	Params::RBGameUserSettings_IsMotionBlurDirty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserSettings.IsMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserSettings::IsMotionBlurEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserSettings", "IsMotionBlurEnabled");

	Params::RBGameUserSettings_IsMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASChairPanelComponent.BP_SetIsInDrugSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::BP_SetIsInDrugSequence(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "BP_SetIsInDrugSequence");

	Params::RBSASChairPanelComponent_BP_SetIsInDrugSequence Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.BP_SetShouldFaceTV
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::BP_SetShouldFaceTV(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "BP_SetShouldFaceTV");

	Params::RBSASChairPanelComponent_BP_SetShouldFaceTV Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.BP_StartExitSequence
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBSASChairPanelComponent::BP_StartExitSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "BP_StartExitSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.Debug_ForceAllowedToSit
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::Debug_ForceAllowedToSit(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "Debug_ForceAllowedToSit");

	Params::RBSASChairPanelComponent_Debug_ForceAllowedToSit Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnCanLeaveChairChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::OnCanLeaveChairChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnCanLeaveChairChangedCallback");

	Params::RBSASChairPanelComponent_OnCanLeaveChairChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnCanSitInChairChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::OnCanSitInChairChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnCanSitInChairChangedCallback");

	Params::RBSASChairPanelComponent_OnCanSitInChairChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnForceExitCallback
// (Final, Native, Private)

void URBSASChairPanelComponent::OnForceExitCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnForceExitCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSASChairPanelComponent::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnGamePhaseUpdated");

	Params::RBSASChairPanelComponent_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnRep_CanLeaveChair
// (Final, Native, Private)

void URBSASChairPanelComponent::OnRep_CanLeaveChair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnRep_CanLeaveChair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnRep_CanSitInChair
// (Final, Native, Private)

void URBSASChairPanelComponent::OnRep_CanSitInChair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnRep_CanSitInChair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.OnRep_ShouldFaceTV
// (Final, Native, Private)

void URBSASChairPanelComponent::OnRep_ShouldFaceTV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "OnRep_ShouldFaceTV");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASChairPanelComponent.GetCanLeaveChair
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSASChairPanelComponent::GetCanLeaveChair() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "GetCanLeaveChair");

	Params::RBSASChairPanelComponent_GetCanLeaveChair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASChairPanelComponent.GetCanSitInChair
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSASChairPanelComponent::GetCanSitInChair() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "GetCanSitInChair");

	Params::RBSASChairPanelComponent_GetCanSitInChair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASChairPanelComponent.ShouldFaceTV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSASChairPanelComponent::ShouldFaceTV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASChairPanelComponent", "ShouldFaceTV");

	Params::RBSASChairPanelComponent_ShouldFaceTV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoomConnectorComponent.SetConnectionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERoomConnectionState                    NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRoomConnectorComponent::SetConnectionState(ERoomConnectionState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomConnectorComponent", "SetConnectionState");

	Params::RBRoomConnectorComponent_SetConnectionState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomConnectorComponent.GetRoomInBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBRoom*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBRoom* URBRoomConnectorComponent::GetRoomInBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomConnectorComponent", "GetRoomInBack");

	Params::RBRoomConnectorComponent_GetRoomInBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoomConnectorComponent.GetRoomInFront
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBRoom*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBRoom* URBRoomConnectorComponent::GetRoomInFront() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomConnectorComponent", "GetRoomInFront");

	Params::RBRoomConnectorComponent_GetRoomInFront Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectSpawnerComponent.OnRep_NumberOfSpawnsLeft
// (Final, Native, Public)

void URBLargeObjectSpawnerComponent::OnRep_NumberOfSpawnsLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "OnRep_NumberOfSpawnsLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectSpawnerComponent.OnRep_SpawnedLargePickups
// (Final, Native, Public)

void URBLargeObjectSpawnerComponent::OnRep_SpawnedLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "OnRep_SpawnedLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectSpawnerComponent.OnSpawnedLargePickupHoldingPlayerChanged
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectSpawnerComponent::OnSpawnedLargePickupHoldingPlayerChanged(class ARBPawn* Pawn, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "OnSpawnedLargePickupHoldingPlayerChanged");

	Params::RBLargeObjectSpawnerComponent_OnSpawnedLargePickupHoldingPlayerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectSpawnerComponent.SetNumberOfSpawnsLeft
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_NumberOfSpawnsLeft                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectSpawnerComponent::SetNumberOfSpawnsLeft(int32 Param_NumberOfSpawnsLeft, bool bSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "SetNumberOfSpawnsLeft");

	Params::RBLargeObjectSpawnerComponent_SetNumberOfSpawnsLeft Parms{};

	Parms.Param_NumberOfSpawnsLeft = Param_NumberOfSpawnsLeft;
	Parms.bSpawn = bSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectSpawnerComponent.StartSpawningLargePickups
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBLargeObjectSpawnerComponent::StartSpawningLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "StartSpawningLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectSpawnerComponent.GetSpawningTransformSceneRef
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class USceneComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USceneComponent* URBLargeObjectSpawnerComponent::GetSpawningTransformSceneRef() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectSpawnerComponent", "GetSpawningTransformSceneRef");

	Params::RBLargeObjectSpawnerComponent_GetSpawningTransformSceneRef Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRadialMenuBase.OnAddToSimulatedMouseLocation
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector2D                        Amount                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRadialMenuBase::OnAddToSimulatedMouseLocation(const struct FVector2D& Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRadialMenuBase", "OnAddToSimulatedMouseLocation");

	Params::RBRadialMenuBase_OnAddToSimulatedMouseLocation Parms{};

	Parms.Amount = std::move(Amount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRadialMenuBase.OnHide
// (Native, Public)

void URBRadialMenuBase::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRadialMenuBase", "OnHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRadialMenuBase.OnShow
// (Native, Public)

void URBRadialMenuBase::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRadialMenuBase", "OnShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGenericRadialMenu.Event_HighlightWheel
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   WheelIndexValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGenericRadialMenu::Event_HighlightWheel(int32 WheelIndexValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGenericRadialMenu", "Event_HighlightWheel");

	Params::RBGenericRadialMenu_Event_HighlightWheel Parms{};

	Parms.WheelIndexValue = WheelIndexValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerStatus.OnCompletingObjectiveChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsCompletingObjective                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerStatus::OnCompletingObjectiveChanged(bool IsCompletingObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerStatus", "OnCompletingObjectiveChanged");

	Params::RBHUDPlayerStatus_OnCompletingObjectiveChanged Parms{};

	Parms.IsCompletingObjective = IsCompletingObjective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerStatus.OnPlayerStatusChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerIndicatorType                    NewPlayerStatus                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerStatus::OnPlayerStatusChanged(EPlayerIndicatorType NewPlayerStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerStatus", "OnPlayerStatusChanged");

	Params::RBHUDPlayerStatus_OnPlayerStatusChanged Parms{};

	Parms.NewPlayerStatus = NewPlayerStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDPlayerStatus.SetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBindStatusChanges                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerStatus::SetPlayer(class ARBPlayer* NewPlayer, bool bShouldBindStatusChanges)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerStatus", "SetPlayer");

	Params::RBHUDPlayerStatus_SetPlayer Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.bShouldBindStatusChanges = bShouldBindStatusChanges;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.Multicast_EndClipboardCopyOfMsg
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBGameStateBase::Multicast_EndClipboardCopyOfMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "Multicast_EndClipboardCopyOfMsg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.Multicast_FunctionalTestLog
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FString                           ServerMsg                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FailTest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameStateBase::Multicast_FunctionalTestLog(const class FString& ServerMsg, bool FailTest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "Multicast_FunctionalTestLog");

	Params::RBGameStateBase_Multicast_FunctionalTestLog Parms{};

	Parms.ServerMsg = std::move(ServerMsg);
	Parms.FailTest = FailTest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.Multicast_OnPlayerRevived
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameStateBase::Multicast_OnPlayerRevived(class ARBPlayer* InstigatorActor, class ARBPlayer* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "Multicast_OnPlayerRevived");

	Params::RBGameStateBase_Multicast_OnPlayerRevived Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.Multicast_PlayMurkoffAnnouncement
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<struct FRBMurkoffAnnouncentAudioData>MurkoffAnnouncementAudioDatas                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMurkoffAnnouncentAudioData    StopAudioData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBGameStateBase::Multicast_PlayMurkoffAnnouncement(const TArray<struct FRBMurkoffAnnouncentAudioData>& MurkoffAnnouncementAudioDatas, const struct FRBMurkoffAnnouncentAudioData& StopAudioData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "Multicast_PlayMurkoffAnnouncement");

	Params::RBGameStateBase_Multicast_PlayMurkoffAnnouncement Parms{};

	Parms.MurkoffAnnouncementAudioDatas = std::move(MurkoffAnnouncementAudioDatas);
	Parms.StopAudioData = std::move(StopAudioData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.Multicast_StartClipboardCopyOfMsg
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBGameStateBase::Multicast_StartClipboardCopyOfMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "Multicast_StartClipboardCopyOfMsg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.OnRep_EffectiveNumberOfPlayers
// (Final, Native, Private)

void ARBGameStateBase::OnRep_EffectiveNumberOfPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "OnRep_EffectiveNumberOfPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.OnRep_EventFeatureSwitchOverrides
// (Final, Native, Private)

void ARBGameStateBase::OnRep_EventFeatureSwitchOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "OnRep_EventFeatureSwitchOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.OnRep_ExpectedPlayerCount
// (Final, Native, Private)

void ARBGameStateBase::OnRep_ExpectedPlayerCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "OnRep_ExpectedPlayerCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.OnRep_FeatureSwitchOverrides
// (Final, Native, Private)

void ARBGameStateBase::OnRep_FeatureSwitchOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "OnRep_FeatureSwitchOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.OnRep_LevelSeed
// (Final, Native, Private)

void ARBGameStateBase::OnRep_LevelSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "OnRep_LevelSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateBase.BP_GetGameModePersistentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBGameModePersistentData*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGameModePersistentData* ARBGameStateBase::BP_GetGameModePersistentData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "BP_GetGameModePersistentData");

	Params::RBGameStateBase_BP_GetGameModePersistentData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateBase.GetGameSessionRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBGameStateBase::GetGameSessionRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateBase", "GetGameSessionRegion");

	Params::RBGameStateBase_GetGameSessionRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.Multicast_PlayLobbyAnnouncement
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   AnnouncementIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AnnouncementLineSeed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameStateLobby::Multicast_PlayLobbyAnnouncement(int32 AnnouncementIndex, int32 AnnouncementLineSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "Multicast_PlayLobbyAnnouncement");

	Params::RBGameStateLobby_Multicast_PlayLobbyAnnouncement Parms{};

	Parms.AnnouncementIndex = AnnouncementIndex;
	Parms.AnnouncementLineSeed = AnnouncementLineSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBGameStateLobby.OnCharacterReleaseCountUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   Param_CharacterReleaseCount                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameStateLobby::OnCharacterReleaseCountUpdated__DelegateSignature(int32 Param_CharacterReleaseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "OnCharacterReleaseCountUpdated__DelegateSignature");

	Params::RBGameStateLobby_OnCharacterReleaseCountUpdated__DelegateSignature Parms{};

	Parms.Param_CharacterReleaseCount = Param_CharacterReleaseCount;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBGameStateLobby.OnPlayerReleaseStateUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FPlayerReleaseState              Param_PlayerReleaseState                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBGameStateLobby::OnPlayerReleaseStateUpdated__DelegateSignature(const struct FPlayerReleaseState& Param_PlayerReleaseState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "OnPlayerReleaseStateUpdated__DelegateSignature");

	Params::RBGameStateLobby_OnPlayerReleaseStateUpdated__DelegateSignature Parms{};

	Parms.Param_PlayerReleaseState = std::move(Param_PlayerReleaseState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBGameStateLobby.OnRep_CharacterReleaseCount
// (Final, Native, Private)

void ARBGameStateLobby::OnRep_CharacterReleaseCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "OnRep_CharacterReleaseCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateLobby.OnRep_PlayerReleaseState
// (Final, Native, Private)

void ARBGameStateLobby::OnRep_PlayerReleaseState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "OnRep_PlayerReleaseState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameStateLobby.GetCharacterReleaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBGameStateLobby::GetCharacterReleaseCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "GetCharacterReleaseCount");

	Params::RBGameStateLobby_GetCharacterReleaseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.GetPlayerReleaseExpirationServerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBGameStateLobby::GetPlayerReleaseExpirationServerTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "GetPlayerReleaseExpirationServerTime");

	Params::RBGameStateLobby_GetPlayerReleaseExpirationServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.GetPlayerReleasePlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBLobbyPlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLobbyPlayerState* ARBGameStateLobby::GetPlayerReleasePlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "GetPlayerReleasePlayerState");

	Params::RBGameStateLobby_GetPlayerReleasePlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.GetPlayerReleaseState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerReleaseState        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FPlayerReleaseState ARBGameStateLobby::GetPlayerReleaseState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "GetPlayerReleaseState");

	Params::RBGameStateLobby_GetPlayerReleaseState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.IsPlayerReleasePending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameStateLobby::IsPlayerReleasePending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "IsPlayerReleasePending");

	Params::RBGameStateLobby_IsPlayerReleasePending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateLobby.IsPlayerReleasing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameStateLobby::IsPlayerReleasing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateLobby", "IsPlayerReleasing");

	Params::RBGameStateLobby_IsPlayerReleasing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledBool(const struct FScheduledBool& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledFloat(const struct FScheduledFloat& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledInt(const struct FScheduledInt& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledInt8(const struct FScheduledInt8& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledTransform(const struct FScheduledTransform& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledUObject(const struct FScheduledUObject& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetCurrentValue_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_GetCurrentValue_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBScheduledBlueprintLibrary::GetInitialValue_ScheduledBool(const struct FScheduledBool& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBScheduledBlueprintLibrary::GetInitialValue_ScheduledFloat(const struct FScheduledFloat& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBScheduledBlueprintLibrary::GetInitialValue_ScheduledInt(const struct FScheduledInt& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 URBScheduledBlueprintLibrary::GetInitialValue_ScheduledInt8(const struct FScheduledInt8& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBScheduledBlueprintLibrary::GetInitialValue_ScheduledTransform(const struct FScheduledTransform& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URBScheduledBlueprintLibrary::GetInitialValue_ScheduledUObject(const struct FScheduledUObject& ScheduledProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "GetInitialValue_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_GetInitialValue_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledBool(struct FScheduledBool& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledBool_Component(struct FScheduledBool& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledBool_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledBool_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledFloat(struct FScheduledFloat& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledFloat_Component(struct FScheduledFloat& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledFloat_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledFloat_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledInt(struct FScheduledInt& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledInt8(struct FScheduledInt8& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledInt8_Component(struct FScheduledInt8& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledInt8_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledInt8_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledInt_Component(struct FScheduledInt& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledInt_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledInt_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledTransform(struct FScheduledTransform& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledTransform_Component(struct FScheduledTransform& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledTransform_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledTransform_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledUObject(struct FScheduledUObject& ScheduledProperty, class AActor* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject_Component
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  Owner                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EScheduledPropertyValueChangedType ChangedType)>InDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::Initialize_ScheduledUObject_Component(struct FScheduledUObject& ScheduledProperty, class UActorComponent* Owner, TDelegate<void(EScheduledPropertyValueChangedType ChangedType)> InDelegate, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "Initialize_ScheduledUObject_Component");

	Params::RBScheduledBlueprintLibrary_Initialize_ScheduledUObject_Component Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Owner = Owner;
	Parms.InDelegate = InDelegate;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledBool(struct FScheduledBool& ScheduledProperty, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledFloat(struct FScheduledFloat& ScheduledProperty, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledInt(struct FScheduledInt& ScheduledProperty, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledInt8(struct FScheduledInt8& ScheduledProperty, uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledTransform(struct FScheduledTransform& ScheduledProperty, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledUObject(struct FScheduledUObject& ScheduledProperty, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "ScheduleValue_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_ScheduleValue_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledBool(struct FScheduledBool& ScheduledProperty, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledFloat(struct FScheduledFloat& ScheduledProperty, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledInt(struct FScheduledInt& ScheduledProperty, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledInt8(struct FScheduledInt8& ScheduledProperty, uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledTransform(struct FScheduledTransform& ScheduledProperty, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledUObject(struct FScheduledUObject& ScheduledProperty, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetInitialValue_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_SetInitialValue_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledBool                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledBool(struct FScheduledBool& ScheduledProperty, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledBool");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledBool Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledFloat                  ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledFloat(struct FScheduledFloat& ScheduledProperty, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledFloat");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledFloat Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt                    ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledInt(struct FScheduledInt& ScheduledProperty, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledInt");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledInt Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt8
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledInt8                   ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledInt8(struct FScheduledInt8& ScheduledProperty, uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledInt8");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledInt8 Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FScheduledTransform              ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledTransform(struct FScheduledTransform& ScheduledProperty, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledTransform");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledTransform Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledUObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScheduledUObject                ScheduledProperty                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBScheduledBlueprintLibrary::SetValue_ScheduledUObject(struct FScheduledUObject& ScheduledProperty, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBScheduledBlueprintLibrary", "SetValue_ScheduledUObject");

	Params::RBScheduledBlueprintLibrary_SetValue_ScheduledUObject Parms{};

	Parms.ScheduledProperty = std::move(ScheduledProperty);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ScheduledProperty = std::move(Parms.ScheduledProperty);
}


// Function OPP.RBHUDPlayerInfoBar.SetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfoBar::SetPlayer(class ARBPlayer* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfoBar", "SetPlayer");

	Params::RBHUDPlayerInfoBar_SetPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveActor.OnRep_IsInWorld
// (Final, Native, Public)

void ARBSimpleObjectiveActor::OnRep_IsInWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveActor", "OnRep_IsInWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.BP_Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URBMenuTabButton*>         InTabButtons                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UWidgetSwitcher*                  InTabSwitcher                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::BP_Initialize(const TArray<class URBMenuTabButton*>& InTabButtons, class UWidgetSwitcher* InTabSwitcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "BP_Initialize");

	Params::RBMenuWithTabsWidget_BP_Initialize Parms{};

	Parms.InTabButtons = std::move(InTabButtons);
	Parms.InTabSwitcher = InTabSwitcher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::BP_SetSelectedTab(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "BP_SetSelectedTab");

	Params::RBMenuWithTabsWidget_BP_SetSelectedTab Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTabFromButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBMenuTabButton*                 Button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::BP_SetSelectedTabFromButton(class URBMenuTabButton* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "BP_SetSelectedTabFromButton");

	Params::RBMenuWithTabsWidget_BP_SetSelectedTabFromButton Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.Event_OnMenuTabSwitched
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   PreviousIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::Event_OnMenuTabSwitched(int32 PreviousIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "Event_OnMenuTabSwitched");

	Params::RBMenuWithTabsWidget_Event_OnMenuTabSwitched Parms{};

	Parms.PreviousIndex = PreviousIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuWithTabsWidget.Event_StartTransitionIn
// (Event, Public, BlueprintEvent)

void URBMenuWithTabsWidget::Event_StartTransitionIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "Event_StartTransitionIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWithTabsWidget.Event_StartTransitionOut
// (Event, Public, BlueprintEvent)

void URBMenuWithTabsWidget::Event_StartTransitionOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "Event_StartTransitionOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuWithTabsWidget.Event_UpdateNavigation
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    CanExitMenu                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::Event_UpdateNavigation(bool CanExitMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "Event_UpdateNavigation");

	Params::RBMenuWithTabsWidget_Event_UpdateNavigation Parms{};

	Parms.CanExitMenu = CanExitMenu;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuWithTabsWidget.NextTab
// (Final, Native, Public, BlueprintCallable)

void URBMenuWithTabsWidget::NextTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "NextTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.OnMenuCancelPressed
// (Final, Native, Private)

void URBMenuWithTabsWidget::OnMenuCancelPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "OnMenuCancelPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.OnTabButtonClicked
// (Final, Native, Public)
// Parameters:
// class URBMenuTabButton*                 Button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::OnTabButtonClicked(class URBMenuTabButton* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "OnTabButtonClicked");

	Params::RBMenuWithTabsWidget_OnTabButtonClicked Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.OnTabNavigationChanged
// (Final, Native, Private)
// Parameters:
// bool                                    CanExitMenu                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::OnTabNavigationChanged(bool CanExitMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "OnTabNavigationChanged");

	Params::RBMenuWithTabsWidget_OnTabNavigationChanged Parms{};

	Parms.CanExitMenu = CanExitMenu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.PreNavigationChangeAction
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuWithTabsWidget::PreNavigationChangeAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "PreNavigationChangeAction");

	Params::RBMenuWithTabsWidget_PreNavigationChangeAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuWithTabsWidget.PreviousTab
// (Final, Native, Public, BlueprintCallable)

void URBMenuWithTabsWidget::PreviousTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "PreviousTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.RequestNavigationBack
// (Final, Native, Public, BlueprintCallable)

void URBMenuWithTabsWidget::RequestNavigationBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "RequestNavigationBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.TransitionDone
// (Final, Native, Public, BlueprintCallable)

void URBMenuWithTabsWidget::TransitionDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "TransitionDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.TryChangeTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuWithTabsWidget::TryChangeTab(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "TryChangeTab");

	Params::RBMenuWithTabsWidget_TryChangeTab Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuWithTabsWidget.CanExitMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuWithTabsWidget::CanExitMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "CanExitMenu");

	Params::RBMenuWithTabsWidget_CanExitMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuWithTabsWidget.GetSelectedTabButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBMenuTabButton*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuTabButton* URBMenuWithTabsWidget::GetSelectedTabButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuWithTabsWidget", "GetSelectedTabButton");

	Params::RBMenuWithTabsWidget_GetSelectedTabButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptions.Event_RefreshAllEntries
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuOptions::Event_RefreshAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptions", "Event_RefreshAllEntries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptions.OnFullscreenOrDesktopSettingsChanged
// (Event, Public, BlueprintEvent)

void URBMenuOptions::OnFullscreenOrDesktopSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptions", "OnFullscreenOrDesktopSettingsChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTimedBreadcrumb.BP_OnActivated
// (Event, Protected, BlueprintEvent)

void ARBTimedBreadcrumb::BP_OnActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "BP_OnActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTimedBreadcrumb.BP_OnDeactivated
// (Event, Protected, BlueprintEvent)

void ARBTimedBreadcrumb::BP_OnDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "BP_OnDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTimedBreadcrumb.BP_OnNeedsActivation
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTimedBreadcrumb::BP_OnNeedsActivation(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "BP_OnNeedsActivation");

	Params::RBTimedBreadcrumb_BP_OnNeedsActivation Parms{};

	Parms.bActivated = bActivated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTimedBreadcrumb.BP_OnWrongSwitch
// (Event, Protected, BlueprintEvent)

void ARBTimedBreadcrumb::BP_OnWrongSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "BP_OnWrongSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTimedBreadcrumb.Multicast_OnWrongSwitchUsed
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTimedBreadcrumb::Multicast_OnWrongSwitchUsed(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "Multicast_OnWrongSwitchUsed");

	Params::RBTimedBreadcrumb_Multicast_OnWrongSwitchUsed Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTimedBreadcrumb.OnRep_BreadcrumbState
// (Final, Native, Protected)

void ARBTimedBreadcrumb::OnRep_BreadcrumbState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimedBreadcrumb", "OnRep_BreadcrumbState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLineOfSightTrigger.BP_DisableTrigger
// (Final, Native, Public, BlueprintCallable)

void ARBLineOfSightTrigger::BP_DisableTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLineOfSightTrigger", "BP_DisableTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLineOfSightTrigger.BP_EnableTrigger
// (Final, Native, Public, BlueprintCallable)

void ARBLineOfSightTrigger::BP_EnableTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLineOfSightTrigger", "BP_EnableTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTradeable.IsTradeable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBTradeable::IsTradeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTradeable", "IsTradeable");

	Params::RBTradeable_IsTradeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGamepadControlSchemeLayerEntry.Event_UpdateDescription
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NewDescription                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBGamepadControlSchemeLayerEntry::Event_UpdateDescription(const class FText& NewDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGamepadControlSchemeLayerEntry", "Event_UpdateDescription");

	Params::RBGamepadControlSchemeLayerEntry_Event_UpdateDescription Parms{};

	Parms.NewDescription = std::move(NewDescription);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBGamepadControlSchemeLayerEntry.UpdateIcon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       NewIcon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGamepadControlSchemeLayerEntry::UpdateIcon(class UTexture2D* NewIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGamepadControlSchemeLayerEntry", "UpdateIcon");

	Params::RBGamepadControlSchemeLayerEntry_UpdateIcon Parms{};

	Parms.NewIcon = NewIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuPlayerController.Client_KickedFromServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ErrorCauseMessage                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ErrorFacility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlatformErrorCode                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Client_KickedFromServer(const class FText& Message, const class FText& ErrorCauseMessage, int32 ErrorFacility, int32 ErrorCode, const class FString& PlatformErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Client_KickedFromServer");

	Params::RBMenuPlayerController_Client_KickedFromServer Parms{};

	Parms.Message = std::move(Message);
	Parms.ErrorCauseMessage = std::move(ErrorCauseMessage);
	Parms.ErrorFacility = ErrorFacility;
	Parms.ErrorCode = ErrorCode;
	Parms.PlatformErrorCode = std::move(PlatformErrorCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Client_PartyMemberPlayerSlotsReservationProcessed
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FProfileId>               Members                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAccepted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Client_PartyMemberPlayerSlotsReservationProcessed(const TArray<struct FProfileId>& Members, bool bAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Client_PartyMemberPlayerSlotsReservationProcessed");

	Params::RBMenuPlayerController_Client_PartyMemberPlayerSlotsReservationProcessed Parms{};

	Parms.Members = std::move(Members);
	Parms.bAccepted = bAccepted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Client_SetPlayerStatsData
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FRBStatContext>           Stats                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRBUIReleasedCharacterDetails>ReleasedCharacterDetailsList                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Client_SetPlayerStatsData(const TArray<struct FRBStatContext>& Stats, const TArray<struct FRBUIReleasedCharacterDetails>& ReleasedCharacterDetailsList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Client_SetPlayerStatsData");

	Params::RBMenuPlayerController_Client_SetPlayerStatsData Parms{};

	Parms.Stats = std::move(Stats);
	Parms.ReleasedCharacterDetailsList = std::move(ReleasedCharacterDetailsList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.ExitGame
// (Final, Native, Public, BlueprintCallable)

void ARBMenuPlayerController::ExitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "ExitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.ExitToMainMenu
// (Native, Public, BlueprintCallable)

void ARBMenuPlayerController::ExitToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "ExitToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.OnExpectedPlayerCountUpdated
// (Final, Native, Private)
// Parameters:
// int32                                   ExpectedPlayerCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::OnExpectedPlayerCountUpdated(int32 ExpectedPlayerCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "OnExpectedPlayerCountUpdated");

	Params::RBMenuPlayerController_OnExpectedPlayerCountUpdated Parms{};

	Parms.ExpectedPlayerCount = ExpectedPlayerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.OnLocalProfileLoaded
// (Native, Protected)

void ARBMenuPlayerController::OnLocalProfileLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "OnLocalProfileLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.RestorePlayerViewTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OldMenuViewTarget                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewTargetBlendFunction                BlendFunc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::RestorePlayerViewTarget(class AActor* OldMenuViewTarget, float blendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "RestorePlayerViewTarget");

	Params::RBMenuPlayerController_RestorePlayerViewTarget Parms{};

	Parms.OldMenuViewTarget = OldMenuViewTarget;
	Parms.blendTime = blendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_KeepAlive
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ARBMenuPlayerController::Server_KeepAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_KeepAlive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_Report
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FProfileId                       TargetProfileId                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerReportReason                     Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReasonText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_Report(const struct FProfileId& TargetProfileId, EPlayerReportReason Reason, const class FString& ReasonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_Report");

	Params::RBMenuPlayerController_Server_Report Parms{};

	Parms.TargetProfileId = std::move(TargetProfileId);
	Parms.Reason = Reason;
	Parms.ReasonText = std::move(ReasonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_RequestPlayerStatsData
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBMenuPlayerController::Server_RequestPlayerStatsData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_RequestPlayerStatsData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_ReservePartyMemberPlayerSlots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FProfileId>               Members                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_ReservePartyMemberPlayerSlots(const TArray<struct FProfileId>& Members)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_ReservePartyMemberPlayerSlots");

	Params::RBMenuPlayerController_Server_ReservePartyMemberPlayerSlots Parms{};

	Parms.Members = std::move(Members);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetBlockedProfileIds
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<struct FProfileId>               ProfileIds                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetBlockedProfileIds(const TArray<struct FProfileId>& ProfileIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetBlockedProfileIds");

	Params::RBMenuPlayerController_Server_SetBlockedProfileIds Parms{};

	Parms.ProfileIds = std::move(ProfileIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetIsInLoadingScreen
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetIsInLoadingScreen(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetIsInLoadingScreen");

	Params::RBMenuPlayerController_Server_SetIsInLoadingScreen Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetIsLeaving
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EPlayerLeaveTarget                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetIsLeaving(EPlayerLeaveTarget Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetIsLeaving");

	Params::RBMenuPlayerController_Server_SetIsLeaving Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetPresenceInfo
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class FString                           PartyId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bJoinable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFriendRequiresInvite                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPublicRequiresInvite                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetPresenceInfo(const class FString& PartyId, int32 PlayerCount, bool bJoinable, bool bFriendRequiresInvite, bool bPublicRequiresInvite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetPresenceInfo");

	Params::RBMenuPlayerController_Server_SetPresenceInfo Parms{};

	Parms.PartyId = std::move(PartyId);
	Parms.PlayerCount = PlayerCount;
	Parms.bJoinable = bJoinable;
	Parms.bFriendRequiresInvite = bFriendRequiresInvite;
	Parms.bPublicRequiresInvite = bPublicRequiresInvite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetRegionLatency
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<struct FRegionLatency>           RegionLatency                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetRegionLatency(const TArray<struct FRegionLatency>& RegionLatency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetRegionLatency");

	Params::RBMenuPlayerController_Server_SetRegionLatency Parms{};

	Parms.RegionLatency = std::move(RegionLatency);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.Server_SetVoiceChatState
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::Server_SetVoiceChatState(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "Server_SetVoiceChatState");

	Params::RBMenuPlayerController_Server_SetVoiceChatState Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.SetAllowLookInMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::SetAllowLookInMenu(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "SetAllowLookInMenu");

	Params::RBMenuPlayerController_SetAllowLookInMenu Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.SetMenuViewTargetWithBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewTargetBlendFunction                BlendFunc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuPlayerController::SetMenuViewTargetWithBlend(class AActor* NewViewTarget, float blendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "SetMenuViewTargetWithBlend");

	Params::RBMenuPlayerController_SetMenuViewTargetWithBlend Parms{};

	Parms.NewViewTarget = NewViewTarget;
	Parms.blendTime = blendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuPlayerController.GetAllowLookInMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuPlayerController::GetAllowLookInMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "GetAllowLookInMenu");

	Params::RBMenuPlayerController_GetAllowLookInMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.GetCurrentGamepadType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGamepadType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGamepadType ARBMenuPlayerController::GetCurrentGamepadType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "GetCurrentGamepadType");

	Params::RBMenuPlayerController_GetCurrentGamepadType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.GetLeaveTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerLeaveTarget                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerLeaveTarget ARBMenuPlayerController::GetLeaveTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "GetLeaveTarget");

	Params::RBMenuPlayerController_GetLeaveTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.IsInLoadingScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuPlayerController::IsInLoadingScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "IsInLoadingScreen");

	Params::RBMenuPlayerController_IsInLoadingScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.IsInMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuPlayerController::IsInMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "IsInMenu");

	Params::RBMenuPlayerController_IsInMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.IsLeaving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuPlayerController::IsLeaving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "IsLeaving");

	Params::RBMenuPlayerController_IsLeaving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuPlayerController.IsUsingGamePad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuPlayerController::IsUsingGamePad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuPlayerController", "IsUsingGamePad");

	Params::RBMenuPlayerController_IsUsingGamePad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBController.BP_Cheat_AddOnlineItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             OnlineItemId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPersistentItem                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::BP_Cheat_AddOnlineItem(class FName OnlineItemId, bool bIsPersistentItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_Cheat_AddOnlineItem");

	Params::RBController_BP_Cheat_AddOnlineItem Parms{};

	Parms.OnlineItemId = OnlineItemId;
	Parms.bIsPersistentItem = bIsPersistentItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.BP_Cheat_AquireAllProgressionItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ProgressionItems                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::BP_Cheat_AquireAllProgressionItems(const TArray<class FName>& ProgressionItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_Cheat_AquireAllProgressionItems");

	Params::RBController_BP_Cheat_AquireAllProgressionItems Parms{};

	Parms.ProgressionItems = std::move(ProgressionItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.BP_Cheat_SetActiveSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActiveSkillType                        SkillType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::BP_Cheat_SetActiveSkill(EActiveSkillType SkillType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_Cheat_SetActiveSkill");

	Params::RBController_BP_Cheat_SetActiveSkill Parms{};

	Parms.SkillType = SkillType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.BP_GetRBSpectatedPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* ARBController::BP_GetRBSpectatedPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_GetRBSpectatedPawn");

	Params::RBController_BP_GetRBSpectatedPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBController.Client_ActivateVFX
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_ActivateVFX(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ActivateVFX");

	Params::RBController_Client_ActivateVFX Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_AddHudMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             MessageId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// EMessagePriority                        Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMessageCategory                    GameMessageCategory                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_AddHudMessage(const class FName& MessageId, const class FText& Text, EMessagePriority Priority, float Duration, const EGameMessageCategory GameMessageCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_AddHudMessage");

	Params::RBController_Client_AddHudMessage Parms{};

	Parms.MessageId = MessageId;
	Parms.Text = std::move(Text);
	Parms.Priority = Priority;
	Parms.Duration = Duration;
	Parms.GameMessageCategory = GameMessageCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_BadgeAcquired
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_BadgeAcquired(const class FName& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_BadgeAcquired");

	Params::RBController_Client_BadgeAcquired Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_Cheat_DebugCorridorDebugInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FRBEvalCorridorDebugInfo         ServerDebugInfo                                        (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBController::Client_Cheat_DebugCorridorDebugInfo(const struct FRBEvalCorridorDebugInfo& ServerDebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_Cheat_DebugCorridorDebugInfo");

	Params::RBController_Client_Cheat_DebugCorridorDebugInfo Parms{};

	Parms.ServerDebugInfo = std::move(ServerDebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ConnectToServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           IpAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerSessionId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_ConnectToServer(const class FString& IpAddress, uint32 Port, const class FString& PlayerSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ConnectToServer");

	Params::RBController_Client_ConnectToServer Parms{};

	Parms.IpAddress = std::move(IpAddress);
	Parms.Port = Port;
	Parms.PlayerSessionId = std::move(PlayerSessionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_DumpAILog
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           BotName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAIEventLogItem>          EventLog                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Client_DumpAILog(const class FString& BotName, const TArray<struct FAIEventLogItem>& EventLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_DumpAILog");

	Params::RBController_Client_DumpAILog Parms{};

	Parms.BotName = std::move(BotName);
	Parms.EventLog = std::move(EventLog);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_DumpGameEventLog
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FGameEvent>               EventLog                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Client_DumpGameEventLog(const TArray<struct FGameEvent>& EventLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_DumpGameEventLog");

	Params::RBController_Client_DumpGameEventLog Parms{};

	Parms.EventLog = std::move(EventLog);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_DumpRecentServerLog
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ServerLog                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_DumpRecentServerLog(const class FString& ServerLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_DumpRecentServerLog");

	Params::RBController_Client_DumpRecentServerLog Parms{};

	Parms.ServerLog = std::move(ServerLog);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_EnterSpectatorMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// ESpectatorMode                          Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_EnterSpectatorMode(ESpectatorMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_EnterSpectatorMode");

	Params::RBController_Client_EnterSpectatorMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_FinishBugItData
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBController::Client_FinishBugItData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_FinishBugItData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_HideTutorial
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ARBController::Client_HideTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_HideTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_KeepAlive
// (Net, Native, Event, Public, NetClient)

void ARBController::Client_KeepAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_KeepAlive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_LeaveSpectatorMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bRestartingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_LeaveSpectatorMode(bool bRestartingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_LeaveSpectatorMode");

	Params::RBController_Client_LeaveSpectatorMode Parms{};

	Parms.bRestartingPlayer = bRestartingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_MatchCanceled
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EMatchCancelationReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorFacility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_MatchCanceled(EMatchCancelationReason Reason, int32 ErrorFacility, int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_MatchCanceled");

	Params::RBController_Client_MatchCanceled Parms{};

	Parms.Reason = Reason;
	Parms.ErrorFacility = ErrorFacility;
	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_OnPlayerScoringEventRecorded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RuleId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScoreValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XpValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_OnPlayerScoringEventRecorded(EPlayerEvent EventType, const class FName& RuleId, int32 ScoreValue, int32 XpValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_OnPlayerScoringEventRecorded");

	Params::RBController_Client_OnPlayerScoringEventRecorded Parms{};

	Parms.EventType = EventType;
	Parms.RuleId = RuleId;
	Parms.ScoreValue = ScoreValue;
	Parms.XpValue = XpValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_OnTaskCompleted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_OnTaskCompleted(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_OnTaskCompleted");

	Params::RBController_Client_OnTaskCompleted Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PlaySingleShotMusicTrack
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    MusicTrack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPauseLevelMusic                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PlaySingleShotMusicTrack(class UAkAudioEvent* MusicTrack, bool bPauseLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PlaySingleShotMusicTrack");

	Params::RBController_Client_PlaySingleShotMusicTrack Parms{};

	Parms.MusicTrack = MusicTrack;
	Parms.bPauseLevelMusic = bPauseLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PlayVOOnActor
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           VoOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayOnPlayersWatch                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PlayVOOnActor(class UAkAudioEvent* AkEvent, class AActor* VoOwner, EVOPriority VOPriority, uint32 RandomSeed, bool bPlayOnPlayersWatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PlayVOOnActor");

	Params::RBController_Client_PlayVOOnActor Parms{};

	Parms.AkEvent = AkEvent;
	Parms.VoOwner = VoOwner;
	Parms.VOPriority = VOPriority;
	Parms.RandomSeed = RandomSeed;
	Parms.bPlayOnPlayersWatch = bPlayOnPlayersWatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PlayVOOnNarrator
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PlayVOOnNarrator(class UAkAudioEvent* AkEvent, EVOPriority VOPriority, uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PlayVOOnNarrator");

	Params::RBController_Client_PlayVOOnNarrator Parms{};

	Parms.AkEvent = AkEvent;
	Parms.VOPriority = VOPriority;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PlayVOOnWatch
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PlayVOOnWatch(class UAkAudioEvent* AkEvent, uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PlayVOOnWatch");

	Params::RBController_Client_PlayVOOnWatch Parms{};

	Parms.AkEvent = AkEvent;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PostAkEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkComponent*                     AkComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PostAkEvent(class UAkComponent* AkComponent, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PostAkEvent");

	Params::RBController_Client_PostAkEvent Parms{};

	Parms.AkComponent = AkComponent;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PostAkEventGlobal
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PostAkEventGlobal(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PostAkEventGlobal");

	Params::RBController_Client_PostAkEventGlobal Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PostAkEventOnActor
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PostAkEventOnActor(class AActor* Actor, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PostAkEventOnActor");

	Params::RBController_Client_PostAkEventOnActor Parms{};

	Parms.Actor = Actor;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PostAssociatedAKEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkComponent*                     AkComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PostAssociatedAKEvent(class UAkComponent* AkComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PostAssociatedAKEvent");

	Params::RBController_Client_PostAssociatedAKEvent Parms{};

	Parms.AkComponent = AkComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_PostAudioEventOnGroup
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GroupName                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_PostAudioEventOnGroup(class UAkAudioEvent* AkEvent, const class FName& GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_PostAudioEventOnGroup");

	Params::RBController_Client_PostAudioEventOnGroup Parms{};

	Parms.AkEvent = AkEvent;
	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ResolvePendingOrders
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<int64>                           PendingOrderIds                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Client_ResolvePendingOrders(const TArray<int64>& PendingOrderIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ResolvePendingOrders");

	Params::RBController_Client_ResolvePendingOrders Parms{};

	Parms.PendingOrderIds = std::move(PendingOrderIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ReturningToLobby
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           TicketId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchmakingConfigurationName                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FProfileId>               GroupMembers                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Client_ReturningToLobby(const class FString& TicketId, const class FString& MatchmakingConfigurationName, const TArray<struct FProfileId>& GroupMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ReturningToLobby");

	Params::RBController_Client_ReturningToLobby Parms{};

	Parms.TicketId = std::move(TicketId);
	Parms.MatchmakingConfigurationName = std::move(MatchmakingConfigurationName);
	Parms.GroupMembers = std::move(GroupMembers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ServerError
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ServerError                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisplayOnScreen                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_ServerError(const class FString& ServerError, bool bDisplayOnScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ServerError");

	Params::RBController_Client_ServerError Parms{};

	Parms.ServerError = std::move(ServerError);
	Parms.bDisplayOnScreen = bDisplayOnScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ServerMsg
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ServerMsg                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisplayOnScreen                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_ServerMsg(const class FString& ServerMsg, bool bDisplayOnScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ServerMsg");

	Params::RBController_Client_ServerMsg Parms{};

	Parms.ServerMsg = std::move(ServerMsg);
	Parms.bDisplayOnScreen = bDisplayOnScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_SetIgnoreLookInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bNewMoveInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_SetIgnoreLookInput(bool bNewMoveInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_SetIgnoreLookInput");

	Params::RBController_Client_SetIgnoreLookInput Parms{};

	Parms.bNewMoveInput = bNewMoveInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_SetIgnoreMoveInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bNewMoveInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_SetIgnoreMoveInput(bool bNewMoveInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_SetIgnoreMoveInput");

	Params::RBController_Client_SetIgnoreMoveInput Parms{};

	Parms.bNewMoveInput = bNewMoveInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_ShowGameMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             ObjectiveText                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Client_ShowGameMessage(const class FText& ObjectiveText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_ShowGameMessage");

	Params::RBController_Client_ShowGameMessage Parms{};

	Parms.ObjectiveText = std::move(ObjectiveText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_TravelToLobby
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBController::Client_TravelToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_TravelToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_TriggerGlobalAudioAnnouncement
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    AnnouncementEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_TriggerGlobalAudioAnnouncement(class UAkAudioEvent* AnnouncementEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_TriggerGlobalAudioAnnouncement");

	Params::RBController_Client_TriggerGlobalAudioAnnouncement Parms{};

	Parms.AnnouncementEvent = AnnouncementEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_TryTravelToLobby
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBController::Client_TryTravelToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_TryTravelToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_VoiceChat_SetChannelToken
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_VoiceChat_SetChannelToken(const struct FProfileId& ProfileId, const class FString& Token)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_VoiceChat_SetChannelToken");

	Params::RBController_Client_VoiceChat_SetChannelToken Parms{};

	Parms.ProfileId = std::move(ProfileId);
	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_VoiceChat_SetEchoChannelToken
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_VoiceChat_SetEchoChannelToken(const class FString& Token)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_VoiceChat_SetEchoChannelToken");

	Params::RBController_Client_VoiceChat_SetEchoChannelToken Parms{};

	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_VoiceChat_SetLoginToken
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_VoiceChat_SetLoginToken(const class FString& Token)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_VoiceChat_SetLoginToken");

	Params::RBController_Client_VoiceChat_SetLoginToken Parms{};

	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Client_WaitForMatchPlacement
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           PlacementId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Client_WaitForMatchPlacement(const class FString& PlacementId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Client_WaitForMatchPlacement");

	Params::RBController_Client_WaitForMatchPlacement Parms{};

	Parms.PlacementId = std::move(PlacementId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.IsPlaytestMode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBController::IsPlaytestMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "IsPlaytestMode");

	Params::RBController_IsPlaytestMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBController.Multicast_Cheat_DebugTalkWheel
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBController::Multicast_Cheat_DebugTalkWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_Cheat_DebugTalkWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Multicast_Cheat_ForceSnapToStateToAllActors
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBController::Multicast_Cheat_ForceSnapToStateToAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_Cheat_ForceSnapToStateToAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Multicast_LogStreamingDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBController::Multicast_LogStreamingDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_LogStreamingDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Multicast_NotifyEndOfStage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FEndStageInfo                    EndOfStageInfo                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShowEndOfMatchScreen                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Multicast_NotifyEndOfStage(const struct FEndStageInfo& EndOfStageInfo, bool bShowEndOfMatchScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_NotifyEndOfStage");

	Params::RBController_Multicast_NotifyEndOfStage Parms{};

	Parms.EndOfStageInfo = std::move(EndOfStageInfo);
	Parms.bShowEndOfMatchScreen = bShowEndOfMatchScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Multicast_SetNoConnectionTimeout
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    NoTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Multicast_SetNoConnectionTimeout(bool NoTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_SetNoConnectionTimeout");

	Params::RBController_Multicast_SetNoConnectionTimeout Parms{};

	Parms.NoTimeout = NoTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Multicast_StartTransitionFeedback
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Multicast_StartTransitionFeedback(float TransitionDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Multicast_StartTransitionFeedback");

	Params::RBController_Multicast_StartTransitionFeedback Parms{};

	Parms.TransitionDuration = TransitionDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnGamePhaseUpdated
// (Final, Native, Protected)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnGamePhaseUpdated");

	Params::RBController_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnPlayerInsideActiveSkillChanged
// (Final, Native, Public)
// Parameters:
// class ARBActiveSkill*                   ActiveSkillActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::OnPlayerInsideActiveSkillChanged(class ARBActiveSkill* ActiveSkillActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnPlayerInsideActiveSkillChanged");

	Params::RBController_OnPlayerInsideActiveSkillChanged Parms{};

	Parms.ActiveSkillActor = ActiveSkillActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnPlayerInsideCameraCustomizationChanged
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Param_RBPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::OnPlayerInsideCameraCustomizationChanged(class ARBPlayer* Param_RBPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnPlayerInsideCameraCustomizationChanged");

	Params::RBController_OnPlayerInsideCameraCustomizationChanged Parms{};

	Parms.Param_RBPlayer = Param_RBPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnPlayerJoinedGame
// (Native, Protected)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnPlayerJoinedGame");

	Params::RBController_OnPlayerJoinedGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnPlayerLeftGame
// (Native, Protected)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnPlayerLeftGame");

	Params::RBController_OnPlayerLeftGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnRep_bSpectator
// (Final, Native, Public)

void ARBController::OnRep_bSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnRep_bSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.OnRep_RBSpectatorPawn
// (Final, Native, Protected)

void ARBController::OnRep_RBSpectatorPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "OnRep_RBSpectatorPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireAllCellCustomization
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AcquireAllCellCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireAllCellCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireAllCustomization
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AcquireAllCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireAllCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireAllDocuments
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AcquireAllDocuments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireAllDocuments");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireAllTrialRewards
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AcquireAllTrialRewards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireAllTrialRewards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireBadge
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AcquireBadge(const class FName& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireBadge");

	Params::RBController_Server_Cheat_AcquireBadge Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireFullRewardPool
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             RewardPoolId                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AcquireFullRewardPool(const class FName& RewardPoolId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireFullRewardPool");

	Params::RBController_Server_Cheat_AcquireFullRewardPool Parms{};

	Parms.RewardPoolId = RewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AcquireRewardPoolItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             RewardPoolId                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AcquireRewardPoolItem(const class FName& RewardPoolId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AcquireRewardPoolItem");

	Params::RBController_Server_Cheat_AcquireRewardPoolItem Parms{};

	Parms.RewardPoolId = RewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ActivateAllMines
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ActivateAllMines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ActivateAllMines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddCurrency
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddCurrency(ECurrencyType CurrencyType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddCurrency");

	Params::RBController_Server_Cheat_AddCurrency Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class ARBPickup>            ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddItem(TSubclassOf<class ARBPickup> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddItem");

	Params::RBController_Server_Cheat_AddItem Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddMurkoffDollars
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddMurkoffDollars(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddMurkoffDollars");

	Params::RBController_Server_Cheat_AddMurkoffDollars Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddMurkoffPoints
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddMurkoffPoints(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddMurkoffPoints");

	Params::RBController_Server_Cheat_AddMurkoffPoints Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddOnlineItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             OnlineItemId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPersistentItem                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddOnlineItem(class FName OnlineItemId, bool bIsPersistentItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddOnlineItem");

	Params::RBController_Server_Cheat_AddOnlineItem Parms{};

	Parms.OnlineItemId = OnlineItemId;
	Parms.bIsPersistentItem = bIsPersistentItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddProgressivePsychosis
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGas                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddProgressivePsychosis(int32 Amount, bool bGas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddProgressivePsychosis");

	Params::RBController_Server_Cheat_AddProgressivePsychosis Parms{};

	Parms.Amount = Amount;
	Parms.bGas = bGas;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddSelfRevive
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AddSelfRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddSelfRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddStageXp
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddStageXp(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddStageXp");

	Params::RBController_Server_Cheat_AddStageXp Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddTask
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddTask(const class FName& TaskId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddTask");

	Params::RBController_Server_Cheat_AddTask Parms{};

	Parms.TaskId = TaskId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddTQ
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddTQ(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddTQ");

	Params::RBController_Server_Cheat_AddTQ Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddTrialChainingUpgradePoints
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddTrialChainingUpgradePoints(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddTrialChainingUpgradePoints");

	Params::RBController_Server_Cheat_AddTrialChainingUpgradePoints Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AddXp
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AddXp(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AddXp");

	Params::RBController_Server_Cheat_AddXp Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AquireAllProgressionItems
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FName>                     ProgressionItems                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_AquireAllProgressionItems(const TArray<class FName>& ProgressionItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AquireAllProgressionItems");

	Params::RBController_Server_Cheat_AquireAllProgressionItems Parms{};

	Parms.ProgressionItems = std::move(ProgressionItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_AquireAllTrialChainingItems
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_AquireAllTrialChainingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_AquireAllTrialChainingItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ClearPlayerActiveTasks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ClearPlayerActiveTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ClearPlayerActiveTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ClearProgressivePsychosis
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ClearProgressivePsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ClearProgressivePsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ClearRandomState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Query                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ClearRandomState(const class FString& Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ClearRandomState");

	Params::RBController_Server_Cheat_ClearRandomState Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ClearTasks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ClearTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ClearTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteCurrentObjectiveCoordinators
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_CompleteCurrentObjectiveCoordinators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteCurrentObjectiveCoordinators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteMainObjectivesInStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_CompleteMainObjectivesInStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteMainObjectivesInStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteMainObjectivesTo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_CompleteMainObjectivesTo(class ARBBaseObjectiveCoordinator* Coordinator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteMainObjectivesTo");

	Params::RBController_Server_Cheat_CompleteMainObjectivesTo Parms{};

	Parms.Coordinator = Coordinator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteObjectiveCoordinator
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsExactMatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_CompleteObjectiveCoordinator(const class FString& Param_Name, bool bIsExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteObjectiveCoordinator");

	Params::RBController_Server_Cheat_CompleteObjectiveCoordinator Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.bIsExactMatch = bIsExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_CompleteStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteTask
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_CompleteTask(const class FName& TaskId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteTask");

	Params::RBController_Server_Cheat_CompleteTask Parms{};

	Parms.TaskId = TaskId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_CompleteTasks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_CompleteTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_CompleteTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugAlertedStance
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   DebugOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_DebugAlertedStance(int32 DebugOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugAlertedStance");

	Params::RBController_Server_Cheat_DebugAlertedStance Parms{};

	Parms.DebugOption = DebugOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugDoorRepulsion
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bSlam                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_DebugDoorRepulsion(bool bSlam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugDoorRepulsion");

	Params::RBController_Server_Cheat_DebugDoorRepulsion Parms{};

	Parms.bSlam = bSlam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugDrawInteractionBox
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DebugDrawInteractionBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugDrawInteractionBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugGameMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DebugGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugGameMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugInventory
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_DebugInventory(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugInventory");

	Params::RBController_Server_Cheat_DebugInventory Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugJumpScare
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DebugJumpScare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugJumpScare");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DebugTalkWheel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DebugTalkWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DebugTalkWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DisabledActiveSkill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_DisabledActiveSkill(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DisabledActiveSkill");

	Params::RBController_Server_Cheat_DisabledActiveSkill Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DisableStageEnding
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DisableStageEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DisableStageEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_DropAllItems
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_DropAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_DropAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_EndExperiment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_EndExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_EndExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_FailStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_FailStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_FailStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceDeath
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceDecodableState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UObject*                          Decodable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForceDecodableState(class UObject* Decodable, bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceDecodableState");

	Params::RBController_Server_Cheat_ForceDecodableState Parms{};

	Parms.Decodable = Decodable;
	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceGrabs
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Direction                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForceGrabs(const class FString& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceGrabs");

	Params::RBController_Server_Cheat_ForceGrabs Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceLungeAttacks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceLungeAttacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceLungeAttacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceMovementDesynch
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   DesyncSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForceMovementDesynch(float DesyncSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceMovementDesynch");

	Params::RBController_Server_Cheat_ForceMovementDesynch Parms{};

	Parms.DesyncSize = DesyncSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForcePreLoginError
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Error                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForcePreLoginError(const class FString& Error, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForcePreLoginError");

	Params::RBController_Server_Cheat_ForcePreLoginError Parms{};

	Parms.Error = std::move(Error);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceRandomState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Query                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForceRandomState(const class FString& Query, bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceRandomState");

	Params::RBController_Server_Cheat_ForceRandomState Parms{};

	Parms.Query = std::move(Query);
	Parms.bStateA = bStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceSitInSASChair
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceSitInSASChair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceSitInSASChair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceSnapToStateToAllActors
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceSnapToStateToAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceSnapToStateToAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseAllContainers
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceUseAllContainers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseAllContainers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseAllObjectiveActors
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceUseAllObjectiveActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseAllObjectiveActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseAllPuzzleRooms
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceUseAllPuzzleRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseAllPuzzleRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseAllRewardRooms
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceUseAllRewardRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseAllRewardRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseAllTrapsOfType
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EObstacleVariatorType                   TrapType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ForceUseAllTrapsOfType(EObstacleVariatorType TrapType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseAllTrapsOfType");

	Params::RBController_Server_Cheat_ForceUseAllTrapsOfType Parms{};

	Parms.TrapType = TrapType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ForceUseClientOnlyLevels
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ForceUseClientOnlyLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ForceUseClientOnlyLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_GetGoodCharacter
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_GetGoodCharacter(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_GetGoodCharacter");

	Params::RBController_Server_Cheat_GetGoodCharacter Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_GetRich
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_GetRich()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_GetRich");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_keOnActor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_keOnActor(class AActor* Actor, const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_keOnActor");

	Params::RBController_Server_Cheat_keOnActor Parms{};

	Parms.Actor = Actor;
	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_Kick
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_Kick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_Kick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_MakeNoise
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_MakeNoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_MakeNoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_RefreshTrialChainingChoices
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_RefreshTrialChainingChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_RefreshTrialChainingChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_RequestEvalCorridorDebugInfo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_RequestEvalCorridorDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_RequestEvalCorridorDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ResetAccountProgression
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ResetAccountProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ResetAccountProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ResetCharacterProgression
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ResetCharacterProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ResetCharacterProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ResetLoadouts
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ResetLoadouts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ResetLoadouts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ResetStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ResetStage(uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ResetStage");

	Params::RBController_Server_Cheat_ResetStage Parms{};

	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ResetWorldState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ResetWorldState(uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ResetWorldState");

	Params::RBController_Server_Cheat_ResetWorldState Parms{};

	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_RestartExperiment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_RestartExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_RestartExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ReturnToLobby
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ReturnToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ReturnToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SaveTrialChainingSaveState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_SaveTrialChainingSaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SaveTrialChainingSaveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetActiveSkill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EActiveSkillType                        SkillType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetActiveSkill(EActiveSkillType SkillType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetActiveSkill");

	Params::RBController_Server_Cheat_SetActiveSkill Parms{};

	Parms.SkillType = SkillType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetActiveUpgrades
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TArray<class FName>                     CoreUpgrades                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EActiveSkillType                        ActiveSkillType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ActiveSkillUpgrades                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     Perks                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetActiveUpgrades(const TArray<class FName>& CoreUpgrades, EActiveSkillType ActiveSkillType, const TArray<class FName>& ActiveSkillUpgrades, const TArray<class FName>& Perks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetActiveUpgrades");

	Params::RBController_Server_Cheat_SetActiveUpgrades Parms{};

	Parms.CoreUpgrades = std::move(CoreUpgrades);
	Parms.ActiveSkillType = ActiveSkillType;
	Parms.ActiveSkillUpgrades = std::move(ActiveSkillUpgrades);
	Parms.Perks = std::move(Perks);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetAlwaysKeepConsumables
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetAlwaysKeepConsumables(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetAlwaysKeepConsumables");

	Params::RBController_Server_Cheat_SetAlwaysKeepConsumables Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetCharacterIcon
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             IconId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetCharacterIcon(const class FName& IconId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetCharacterIcon");

	Params::RBController_Server_Cheat_SetCharacterIcon Parms{};

	Parms.IconId = IconId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetCharacterLevel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetCharacterLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetCharacterLevel");

	Params::RBController_Server_Cheat_SetCharacterLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetDebugFailedAdjustment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bNewDebugFailedAdjustment                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetDebugFailedAdjustment(bool bNewDebugFailedAdjustment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetDebugFailedAdjustment");

	Params::RBController_Server_Cheat_SetDebugFailedAdjustment Parms{};

	Parms.bNewDebugFailedAdjustment = bNewDebugFailedAdjustment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetFeatureSwitchOverrides
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FRBFeatureSwitchOverride> FeatureSwitchOverrides                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetFeatureSwitchOverrides(const TArray<struct FRBFeatureSwitchOverride>& FeatureSwitchOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetFeatureSwitchOverrides");

	Params::RBController_Server_Cheat_SetFeatureSwitchOverrides Parms{};

	Parms.FeatureSwitchOverrides = std::move(FeatureSwitchOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetForcedRollingGateVariatorIndex
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetForcedRollingGateVariatorIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetForcedRollingGateVariatorIndex");

	Params::RBController_Server_Cheat_SetForcedRollingGateVariatorIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetForcedSASVariatorIndex
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetForcedSASVariatorIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetForcedSASVariatorIndex");

	Params::RBController_Server_Cheat_SetForcedSASVariatorIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetInfiniteActiveSkills
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bInfinite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetInfiniteActiveSkills(bool bInfinite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetInfiniteActiveSkills");

	Params::RBController_Server_Cheat_SetInfiniteActiveSkills Parms{};

	Parms.bInfinite = bInfinite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetInfiniteThrowables
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bInfinite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetInfiniteThrowables(bool bInfinite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetInfiniteThrowables");

	Params::RBController_Server_Cheat_SetInfiniteThrowables Parms{};

	Parms.bInfinite = bInfinite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetLevelSeed
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint32                                  Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetLevelSeed(uint32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetLevelSeed");

	Params::RBController_Server_Cheat_SetLevelSeed Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetMaxReservedPlayerSlotsOverride
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   MaxReservedPlayerSlotsOverride                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetMaxReservedPlayerSlotsOverride(int32 MaxReservedPlayerSlotsOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetMaxReservedPlayerSlotsOverride");

	Params::RBController_Server_Cheat_SetMaxReservedPlayerSlotsOverride Parms{};

	Parms.MaxReservedPlayerSlotsOverride = MaxReservedPlayerSlotsOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetNPCToDebug
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBPawn*                          NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetNPCToDebug(class ARBPawn* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetNPCToDebug");

	Params::RBController_Server_Cheat_SetNPCToDebug Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetPlayerLoadout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FRBPlayerLoadout                 Loadout                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetPlayerLoadout(const struct FRBPlayerLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetPlayerLoadout");

	Params::RBController_Server_Cheat_SetPlayerLoadout Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetServerAnimTickOptimsEnabled
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetServerAnimTickOptimsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetServerAnimTickOptimsEnabled");

	Params::RBController_Server_Cheat_SetServerAnimTickOptimsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetServerPartition
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Partition                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetServerPartition(const class FString& Partition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetServerPartition");

	Params::RBController_Server_Cheat_SetServerPartition Parms{};

	Parms.Partition = std::move(Partition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetSoloMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bSoloMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetSoloMode(bool bSoloMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetSoloMode");

	Params::RBController_Server_Cheat_SetSoloMode Parms{};

	Parms.bSoloMode = bSoloMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetStimulusDebug
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetStimulusDebug(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetStimulusDebug");

	Params::RBController_Server_Cheat_SetStimulusDebug Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SetTrialCompleted
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SetTrialCompleted(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SetTrialCompleted");

	Params::RBController_Server_Cheat_SetTrialCompleted Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ShoveAIs
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ShoveAIs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ShoveAIs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ShowEndOfStageScreen
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ShowEndOfStageScreen(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ShowEndOfStageScreen");

	Params::RBController_Server_Cheat_ShowEndOfStageScreen Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SpawnDeadPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_SpawnDeadPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SpawnDeadPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SpawnDownedPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_SpawnDownedPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SpawnDownedPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SpawnInteractingPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_SpawnInteractingPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SpawnInteractingPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_SpawnLargePickup
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class ARBLargePickup>       ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_SpawnLargePickup(TSubclassOf<class ARBLargePickup> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_SpawnLargePickup");

	Params::RBController_Server_Cheat_SpawnLargePickup Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartEndOfStageDamage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StartEndOfStageDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartEndOfStageDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartExperiment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StartExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartObjectiveCoordinator
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_StartObjectiveCoordinator(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartObjectiveCoordinator");

	Params::RBController_Server_Cheat_StartObjectiveCoordinator Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartPsychosis
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StartPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartPsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartPsychosisSpook
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StartPsychosisSpook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartPsychosisSpook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StartStageEnding
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StartStageEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StartStageEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_StopPsychosis
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_StopPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_StopPsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_TasksAddDay
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_TasksAddDay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_TasksAddDay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_TeleportToEndOfStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_TeleportToEndOfStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_TeleportToEndOfStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_TeleportToSASExit
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_TeleportToSASExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_TeleportToSASExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Query                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ToggleAll(const class FString& Query, bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleAll");

	Params::RBController_Server_Cheat_ToggleAll Parms{};

	Parms.Query = std::move(Query);
	Parms.bStateA = bStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleAlwaysAllowLoadoutMenu
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ToggleAlwaysAllowLoadoutMenu(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleAlwaysAllowLoadoutMenu");

	Params::RBController_Server_Cheat_ToggleAlwaysAllowLoadoutMenu Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleDeadRepsulsion
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ToggleDeadRepsulsion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleDeadRepsulsion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleDebugPlayerInterruption
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ToggleDebugPlayerInterruption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleDebugPlayerInterruption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleInfiniteLives
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ToggleInfiniteLives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleInfiniteLives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleResetStageWhenAllPlayersDead
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ToggleResetStageWhenAllPlayersDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleResetStageWhenAllPlayersDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleRespawnDeadPlayerInStage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_ToggleRespawnDeadPlayerInStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleRespawnDeadPlayerInStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_ToggleVariator
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_ToggleVariator(class FName ID, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_ToggleVariator");

	Params::RBController_Server_Cheat_ToggleVariator Parms{};

	Parms.ID = ID;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_UnlockAllTrials
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_Cheat_UnlockAllTrials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_UnlockAllTrials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cheat_UpdateStatistic
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EPlayerStat                             PlayerStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cheat_UpdateStatistic(EPlayerStat PlayerStat, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cheat_UpdateStatistic");

	Params::RBController_Server_Cheat_UpdateStatistic Parms{};

	Parms.PlayerStat = PlayerStat;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatDestroyAllNPCs
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_CheatDestroyAllNPCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatDestroyAllNPCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatDestroyNPC
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatDestroyNPC(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatDestroyNPC");

	Params::RBController_Server_CheatDestroyNPC Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatDestroyOtherNPC
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatDestroyOtherNPC(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatDestroyOtherNPC");

	Params::RBController_Server_CheatDestroyOtherNPC Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatRespawnAllPlayers
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_CheatRespawnAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatRespawnAllPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatRespawnDeadPlayers
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatRespawnDeadPlayers(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatRespawnDeadPlayers");

	Params::RBController_Server_CheatRespawnDeadPlayers Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatSendXPEvent
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatSendXPEvent(EPlayerEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatSendXPEvent");

	Params::RBController_Server_CheatSendXPEvent Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatSpawnAIFollow
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          SpawnLoc                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SpawnRot                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           CheatName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatSpawnAIFollow(const struct FVector& SpawnLoc, const struct FRotator& SpawnRot, const class FString& CheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatSpawnAIFollow");

	Params::RBController_Server_CheatSpawnAIFollow Parms{};

	Parms.SpawnLoc = std::move(SpawnLoc);
	Parms.SpawnRot = std::move(SpawnRot);
	Parms.CheatName = std::move(CheatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatSpawnBot
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          SpawnLoc                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SpawnRot                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           CheatName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatSpawnBot(const struct FVector& SpawnLoc, const struct FRotator& SpawnRot, const class FString& CheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatSpawnBot");

	Params::RBController_Server_CheatSpawnBot Parms{};

	Parms.SpawnLoc = std::move(SpawnLoc);
	Parms.SpawnRot = std::move(SpawnRot);
	Parms.CheatName = std::move(CheatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatSpawnPouncersInHidingSpot
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class URBHidespotComponent*             HidingSpot                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_CheatSpawnPouncersInHidingSpot(class URBHidespotComponent* HidingSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatSpawnPouncersInHidingSpot");

	Params::RBController_Server_CheatSpawnPouncersInHidingSpot Parms{};

	Parms.HidingSpot = HidingSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatSpawnRandomPouncers
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_CheatSpawnRandomPouncers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatSpawnRandomPouncers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_CheatTeleportAtLocation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          TargetLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TargetRot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBController::Server_CheatTeleportAtLocation(const struct FVector& TargetLoc, const struct FRotator& TargetRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_CheatTeleportAtLocation");

	Params::RBController_Server_CheatTeleportAtLocation Parms{};

	Parms.TargetLoc = std::move(TargetLoc);
	Parms.TargetRot = std::move(TargetRot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_ClaimBadgeReward
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_ClaimBadgeReward(const class FName& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_ClaimBadgeReward");

	Params::RBController_Server_ClaimBadgeReward Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_ClearGameEventLog
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_ClearGameEventLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_ClearGameEventLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Cmd
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           ServerCmd                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Cmd(const class FString& ServerCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Cmd");

	Params::RBController_Server_Cmd Parms{};

	Parms.ServerCmd = std::move(ServerCmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_DumpAILog
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxEvents                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_DumpAILog(class ARBNPC* NPC, int32 MaxEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_DumpAILog");

	Params::RBController_Server_DumpAILog Parms{};

	Parms.NPC = NPC;
	Parms.MaxEvents = MaxEvents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_DumpGameEventLog
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_DumpGameEventLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_DumpGameEventLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_DumpRecentServerLog
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_DumpRecentServerLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_DumpRecentServerLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_EquipOutfit
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class URBCustomizationOutfit*           Outfit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_EquipOutfit(class URBCustomizationOutfit* Outfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_EquipOutfit");

	Params::RBController_Server_EquipOutfit Parms{};

	Parms.Outfit = Outfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_GhostPawn
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// bool                                    bGhost                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CamLoc                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CamRot                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBController::Server_GhostPawn(bool bGhost, const struct FVector& CamLoc, const struct FRotator& CamRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_GhostPawn");

	Params::RBController_Server_GhostPawn Parms{};

	Parms.bGhost = bGhost;
	Parms.CamLoc = std::move(CamLoc);
	Parms.CamRot = std::move(CamRot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_KillFakePlayers
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_KillFakePlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_KillFakePlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_LogStreamingDebug
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_LogStreamingDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_LogStreamingDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_Multicast_Command
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           ServerMulticastCommand                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_Multicast_Command(const class FString& ServerMulticastCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_Multicast_Command");

	Params::RBController_Server_Multicast_Command Parms{};

	Parms.ServerMulticastCommand = std::move(ServerMulticastCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_OnCreditsDone
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_OnCreditsDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_OnCreditsDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseBattlePass
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             BattlePassId                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchaseBattlePass(const class FName& BattlePassId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseBattlePass");

	Params::RBController_Server_PurchaseBattlePass Parms{};

	Parms.BattlePassId = BattlePassId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseBattlePassItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             BattlePassId                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchaseBattlePassItem(const class FName& BattlePassId, const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseBattlePassItem");

	Params::RBController_Server_PurchaseBattlePassItem Parms{};

	Parms.BattlePassId = BattlePassId;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchasedCurrencyPack
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchasedCurrencyPack(ECurrencyType CurrencyType, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchasedCurrencyPack");

	Params::RBController_Server_PurchasedCurrencyPack Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             ItemOnlineUnlockId                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationRarity              Rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchaseItem(const class FName& ItemOnlineUnlockId, EPlayerCustomizationRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseItem");

	Params::RBController_Server_PurchaseItem Parms{};

	Parms.ItemOnlineUnlockId = ItemOnlineUnlockId;
	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseNextTrialChainingSkillUpgrade
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_PurchaseNextTrialChainingSkillUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseNextTrialChainingSkillUpgrade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseOutfit
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchaseOutfit(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseOutfit");

	Params::RBController_Server_PurchaseOutfit Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_PurchaseTrialChainingItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_PurchaseTrialChainingItem(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_PurchaseTrialChainingItem");

	Params::RBController_Server_PurchaseTrialChainingItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_QuickTest
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_QuickTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_QuickTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_RandomizeCustomization
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ARBController::Server_RandomizeCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_RandomizeCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_ReportLobbyFound
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_ReportLobbyFound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_ReportLobbyFound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_RequestBugItData
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_RequestBugItData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_RequestBugItData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetClientInitData
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bVoiceChatEnabled                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRegionLatency>           RegionLatency                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   OwnedProductIds                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_SetClientInitData(bool bVoiceChatEnabled, const TArray<struct FRegionLatency>& RegionLatency, const TArray<class FString>& OwnedProductIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetClientInitData");

	Params::RBController_Server_SetClientInitData Parms{};

	Parms.bVoiceChatEnabled = bVoiceChatEnabled;
	Parms.RegionLatency = std::move(RegionLatency);
	Parms.OwnedProductIds = std::move(OwnedProductIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetGameDownloadCompleted
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBController::Server_SetGameDownloadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetGameDownloadCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetIsRunningFunctionalTest
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetIsRunningFunctionalTest(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetIsRunningFunctionalTest");

	Params::RBController_Server_SetIsRunningFunctionalTest Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetNewPlayerCustomizationOptions
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URBPlayerCustomizationOption*>NewCustomizationOptions                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             NewHairColor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOutfit*           LegendaryOutfit                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBVoiceCustomizationOption*      VoiceOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerIconCustomizationOption* PlayerIconOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetNewPlayerCustomizationOptions(bool bIsFemale, const TArray<class URBPlayerCustomizationOption*>& NewCustomizationOptions, const class FName NewHairColor, class URBCustomizationOutfit* LegendaryOutfit, class URBVoiceCustomizationOption* VoiceOption, class URBPlayerIconCustomizationOption* PlayerIconOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetNewPlayerCustomizationOptions");

	Params::RBController_Server_SetNewPlayerCustomizationOptions Parms{};

	Parms.bIsFemale = bIsFemale;
	Parms.NewCustomizationOptions = std::move(NewCustomizationOptions);
	Parms.NewHairColor = NewHairColor;
	Parms.LegendaryOutfit = LegendaryOutfit;
	Parms.VoiceOption = VoiceOption;
	Parms.PlayerIconOption = PlayerIconOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetNoConnectionTimeout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    NoTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetNoConnectionTimeout(bool NoTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetNoConnectionTimeout");

	Params::RBController_Server_SetNoConnectionTimeout Parms{};

	Parms.NoTimeout = NoTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetProcessId
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// uint32                                  ProcessId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetProcessId(uint32 ProcessId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetProcessId");

	Params::RBController_Server_SetProcessId Parms{};

	Parms.ProcessId = ProcessId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetReadyForStageReset
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bReadyForStageReset                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetReadyForStageReset(bool bReadyForStageReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetReadyForStageReset");

	Params::RBController_Server_SetReadyForStageReset Parms{};

	Parms.bReadyForStageReset = bReadyForStageReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetStreamingReadyToCommit
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bStreamingReadyToCommit                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetStreamingReadyToCommit(bool bStreamingReadyToCommit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetStreamingReadyToCommit");

	Params::RBController_Server_SetStreamingReadyToCommit Parms{};

	Parms.bStreamingReadyToCommit = bStreamingReadyToCommit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetStreamingStable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bStreamingStable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetStreamingStable(bool bStreamingStable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetStreamingStable");

	Params::RBController_Server_SetStreamingStable Parms{};

	Parms.bStreamingStable = bStreamingStable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetStreamingTargetStateReached
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bStreamingTargetStateReached                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetStreamingTargetStateReached(bool bStreamingTargetStateReached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetStreamingTargetStateReached");

	Params::RBController_Server_SetStreamingTargetStateReached Parms{};

	Parms.bStreamingTargetStateReached = bStreamingTargetStateReached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetTemporarySpectatorMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bSpectate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetTemporarySpectatorMode(bool bSpectate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetTemporarySpectatorMode");

	Params::RBController_Server_SetTemporarySpectatorMode Parms{};

	Parms.bSpectate = bSpectate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SetWorldPopulatingDone
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bbWorldPopulatingDone                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SetWorldPopulatingDone(bool bbWorldPopulatingDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SetWorldPopulatingDone");

	Params::RBController_Server_SetWorldPopulatingDone Parms{};

	Parms.bbWorldPopulatingDone = bbWorldPopulatingDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_SpectatorCyclePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bNext                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_SpectatorCyclePlayer(bool bNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_SpectatorCyclePlayer");

	Params::RBController_Server_SpectatorCyclePlayer Parms{};

	Parms.bNext = bNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_UpdatePlayerLoadout
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FRBPlayerLoadout                 Loadout                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBController::Server_UpdatePlayerLoadout(const struct FRBPlayerLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_UpdatePlayerLoadout");

	Params::RBController_Server_UpdatePlayerLoadout Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_VoiceChat_RequestChannelToken
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_VoiceChat_RequestChannelToken(const struct FProfileId& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_VoiceChat_RequestChannelToken");

	Params::RBController_Server_VoiceChat_RequestChannelToken Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_VoiceChat_RequestEchoChannelToken
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_VoiceChat_RequestEchoChannelToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_VoiceChat_RequestEchoChannelToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_VoiceChat_RequestLoginToken
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_VoiceChat_RequestLoginToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_VoiceChat_RequestLoginToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_VoiceChat_VoiceChatActiveStateChanged
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bNewVoiceChatActive                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::Server_VoiceChat_VoiceChatActiveStateChanged(bool bNewVoiceChatActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_VoiceChat_VoiceChatActiveStateChanged");

	Params::RBController_Server_VoiceChat_VoiceChatActiveStateChanged Parms{};

	Parms.bNewVoiceChatActive = bNewVoiceChatActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.Server_VoteForRetryTrial
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBController::Server_VoteForRetryTrial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "Server_VoteForRetryTrial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.SetForceHideObjectiveIcons
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::SetForceHideObjectiveIcons(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "SetForceHideObjectiveIcons");

	Params::RBController_SetForceHideObjectiveIcons Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.StartTransitionFeedback_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBController::StartTransitionFeedback_Server(float TransitionDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "StartTransitionFeedback_Server");

	Params::RBController_StartTransitionFeedback_Server Parms{};

	Parms.TransitionDuration = TransitionDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.TravelToLobby
// (Final, Native, Public, BlueprintCallable)

void ARBController::TravelToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "TravelToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.ViewNextPlayer
// (Final, Exec, Native, Public)

void ARBController::ViewNextPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "ViewNextPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.ViewPrevPlayer
// (Final, Exec, Native, Public)

void ARBController::ViewPrevPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "ViewPrevPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBController.BP_CanSpectatorRespawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBController::BP_CanSpectatorRespawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_CanSpectatorRespawn");

	Params::RBController_BP_CanSpectatorRespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBController.BP_GetPlayerViewPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Out_location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Out_Rotation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBController::BP_GetPlayerViewPoint(struct FVector* Out_location, struct FRotator* Out_Rotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "BP_GetPlayerViewPoint");

	Params::RBController_BP_GetPlayerViewPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_location != nullptr)
		*Out_location = std::move(Parms.Out_location);

	if (Out_Rotation != nullptr)
		*Out_Rotation = std::move(Parms.Out_Rotation);
}


// Function OPP.RBController.CanTravelToLobby
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBController::CanTravelToLobby() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBController", "CanTravelToLobby");

	Params::RBController_CanTravelToLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.Client_CharacterReleased
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBLobbyPlayerController::Client_CharacterReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_CharacterReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_ConsumedExpiredTaskRewards
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FRBUIXPGainInfo>          Result                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_ConsumedExpiredTaskRewards(const TArray<struct FRBUIXPGainInfo>& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_ConsumedExpiredTaskRewards");

	Params::RBLobbyPlayerController_Client_ConsumedExpiredTaskRewards Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_FailTravelToPendingMatch
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBLobbyPlayerController::Client_FailTravelToPendingMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_FailTravelToPendingMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_FindPartyCanceled
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EMatchCancelationReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorFacility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_FindPartyCanceled(EMatchCancelationReason Reason, int32 ErrorFacility, int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_FindPartyCanceled");

	Params::RBLobbyPlayerController_Client_FindPartyCanceled Parms{};

	Parms.Reason = Reason;
	Parms.ErrorFacility = ErrorFacility;
	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_ReadyToTravelToMatch
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBLobbyPlayerController::Client_ReadyToTravelToMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_ReadyToTravelToMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_ResetProgram
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_ResetProgram(const class FName& ProgramId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_ResetProgram");

	Params::RBLobbyPlayerController_Client_ResetProgram Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_TravelToPendingMatch
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_TravelToPendingMatch(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_TravelToPendingMatch");

	Params::RBLobbyPlayerController_Client_TravelToPendingMatch Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_WaitForMatchTicket
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           TicketId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchmakingConfigurationName                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FProfileId>               GroupMembers                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_WaitForMatchTicket(const class FString& TicketId, const class FString& MatchmakingConfigurationName, const TArray<struct FProfileId>& GroupMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_WaitForMatchTicket");

	Params::RBLobbyPlayerController_Client_WaitForMatchTicket Parms{};

	Parms.TicketId = std::move(TicketId);
	Parms.MatchmakingConfigurationName = std::move(MatchmakingConfigurationName);
	Parms.GroupMembers = std::move(GroupMembers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Client_WaitForParty
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           TicketId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchmakingConfigurationName                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FProfileId>               GroupMembers                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ProgramId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrialId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Client_WaitForParty(const class FString& TicketId, const class FString& MatchmakingConfigurationName, const TArray<struct FProfileId>& GroupMembers, const class FName& ProgramId, const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Client_WaitForParty");

	Params::RBLobbyPlayerController_Client_WaitForParty Parms{};

	Parms.TicketId = std::move(TicketId);
	Parms.MatchmakingConfigurationName = std::move(MatchmakingConfigurationName);
	Parms.GroupMembers = std::move(GroupMembers);
	Parms.ProgramId = ProgramId;
	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Event_OnFailedTravelToPendingMatch
// (Event, Public, BlueprintEvent)

void ARBLobbyPlayerController::Event_OnFailedTravelToPendingMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Event_OnFailedTravelToPendingMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLobbyPlayerController.Event_OnFindPartyStateUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindPartyState                  FindPartyState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Event_OnFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Event_OnFindPartyStateUpdated");

	Params::RBLobbyPlayerController_Event_OnFindPartyStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.FindPartyState = std::move(FindPartyState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyPlayerController.Event_OnMatchReady
// (Event, Public, BlueprintEvent)

void ARBLobbyPlayerController::Event_OnMatchReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Event_OnMatchReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLobbyPlayerController.Event_OnMatchSettingsUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Event_OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Event_OnMatchSettingsUpdated");

	Params::RBLobbyPlayerController_Event_OnMatchSettingsUpdated Parms{};

	Parms.MatchSettings = std::move(MatchSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyPlayerController.Event_OnMatchStateUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchState                      MatchState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Event_OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Event_OnMatchStateUpdated");

	Params::RBLobbyPlayerController_Event_OnMatchStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchState = std::move(MatchState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyPlayerController.OnEvalCorridorUpdated
// (Final, Native, Public)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBEvalCorridor*                  EvalCorridor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnEvalCorridorUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, class ARBEvalCorridor* EvalCorridor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnEvalCorridorUpdated");

	Params::RBLobbyPlayerController_OnEvalCorridorUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.EvalCorridor = EvalCorridor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPartyOwnerMatchSettingsUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPartyOwnerMatchSettingsUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPartyOwnerMatchSettingsUpdated");

	Params::RBLobbyPlayerController_OnPartyOwnerMatchSettingsUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchSettings = std::move(MatchSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPlayerCellUpdated
// (Final, Native, Public)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayerCell*                    PlayerCell                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPlayerCellUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, class ARBPlayerCell* PlayerCell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPlayerCellUpdated");

	Params::RBLobbyPlayerController_OnPlayerCellUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.PlayerCell = PlayerCell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPlayerReleaseAvailableServerTimeUpdated
// (Final, Native, Public)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayerReleaseAvailableServerTime                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPlayerReleaseAvailableServerTimeUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, float PlayerReleaseAvailableServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPlayerReleaseAvailableServerTimeUpdated");

	Params::RBLobbyPlayerController_OnPlayerReleaseAvailableServerTimeUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.PlayerReleaseAvailableServerTime = PlayerReleaseAvailableServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPlayerReleaseStateUpdated
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPlayerReleaseState              PlayerReleaseState                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPlayerReleaseStateUpdated(const struct FPlayerReleaseState& PlayerReleaseState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPlayerReleaseStateUpdated");

	Params::RBLobbyPlayerController_OnPlayerReleaseStateUpdated Parms{};

	Parms.PlayerReleaseState = std::move(PlayerReleaseState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPlayerStateFindPartyStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindPartyState                  FindPartyState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPlayerStateFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPlayerStateFindPartyStateUpdated");

	Params::RBLobbyPlayerController_OnPlayerStateFindPartyStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.FindPartyState = std::move(FindPartyState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.OnPlayerStateMatchStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchState                      MatchState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::OnPlayerStateMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "OnPlayerStateMatchStateUpdated");

	Params::RBLobbyPlayerController_OnPlayerStateMatchStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchState = std::move(MatchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.RequestReleaseCurrentCharacter
// (Final, Native, Public, BlueprintCallable)

void ARBLobbyPlayerController::RequestReleaseCurrentCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "RequestReleaseCurrentCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.RequestTravelToPendingMatch
// (Final, Native, Public, BlueprintCallable)

void ARBLobbyPlayerController::RequestTravelToPendingMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "RequestTravelToPendingMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_CancelFindParty
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EMatchCancelationReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_CancelFindParty(EMatchCancelationReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_CancelFindParty");

	Params::RBLobbyPlayerController_Server_CancelFindParty Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_CancelMatchCountdown
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EMatchCancelationReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_CancelMatchCountdown(EMatchCancelationReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_CancelMatchCountdown");

	Params::RBLobbyPlayerController_Server_CancelMatchCountdown Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Cheat_DisableAutoBackfill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBLobbyPlayerController::Server_Cheat_DisableAutoBackfill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Cheat_DisableAutoBackfill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Cheat_EnableAutoBackfill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBLobbyPlayerController::Server_Cheat_EnableAutoBackfill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Cheat_EnableAutoBackfill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Cheat_ForceAssignCell
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_Cheat_ForceAssignCell(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Cheat_ForceAssignCell");

	Params::RBLobbyPlayerController_Server_Cheat_ForceAssignCell Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Cheat_PersistPlayerProgression
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBLobbyPlayerController::Server_Cheat_PersistPlayerProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Cheat_PersistPlayerProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Cheat_StartRelease
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBLobbyPlayerController::Server_Cheat_StartRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Cheat_StartRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_CleanupTasks
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bCleanupPersistentTasks                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_CleanupTasks(bool bCleanupPersistentTasks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_CleanupTasks");

	Params::RBLobbyPlayerController_Server_CleanupTasks Parms{};

	Parms.bCleanupPersistentTasks = bCleanupPersistentTasks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_ConsumeTaskReward
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_ConsumeTaskReward(const class FName& TaskId, int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_ConsumeTaskReward");

	Params::RBLobbyPlayerController_Server_ConsumeTaskReward Parms{};

	Parms.TaskId = TaskId;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedPlayerCount
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   FixedPlayerCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_Debug_SetMatchFixedPlayerCount(int32 FixedPlayerCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Debug_SetMatchFixedPlayerCount");

	Params::RBLobbyPlayerController_Server_Debug_SetMatchFixedPlayerCount Parms{};

	Parms.FixedPlayerCount = FixedPlayerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedSeed
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   FixedSeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_Debug_SetMatchFixedSeed(int32 FixedSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_Debug_SetMatchFixedSeed");

	Params::RBLobbyPlayerController_Server_Debug_SetMatchFixedSeed Parms{};

	Parms.FixedSeed = FixedSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_FindPartyForGroup
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TArray<class ARBLobbyPlayerState*>      Members                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ProgramId                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrialId                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FProfileId>               LastPartyFindProfileIds                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_FindPartyForGroup(const TArray<class ARBLobbyPlayerState*>& Members, const class FName& ProgramId, const class FName& TrialId, const TArray<struct FProfileId>& LastPartyFindProfileIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_FindPartyForGroup");

	Params::RBLobbyPlayerController_Server_FindPartyForGroup Parms{};

	Parms.Members = std::move(Members);
	Parms.ProgramId = ProgramId;
	Parms.TrialId = TrialId;
	Parms.LastPartyFindProfileIds = std::move(LastPartyFindProfileIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_OnOwnedProductsUpdated
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ARBLobbyPlayerController::Server_OnOwnedProductsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_OnOwnedProductsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_ReportMatchFound
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ARBLobbyPlayerController::Server_ReportMatchFound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_ReportMatchFound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_ReportPartyFound
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   PartySize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_ReportPartyFound(int32 PartySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_ReportPartyFound");

	Params::RBLobbyPlayerController_Server_ReportPartyFound Parms{};

	Parms.PartySize = PartySize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_ReportWaitForMatchFailed
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ARBLobbyPlayerController::Server_ReportWaitForMatchFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_ReportWaitForMatchFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_ReportWaitForPartyFailed
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   ErrorFacility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_ReportWaitForPartyFailed(int32 ErrorFacility, int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_ReportWaitForPartyFailed");

	Params::RBLobbyPlayerController_Server_ReportWaitForPartyFailed Parms{};

	Parms.ErrorFacility = ErrorFacility;
	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_RequestReleaseCurrentCharacter
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBLobbyPlayerController::Server_RequestReleaseCurrentCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_RequestReleaseCurrentCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_RequestTravelToPendingMatch
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ARBLobbyPlayerController::Server_RequestTravelToPendingMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_RequestTravelToPendingMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_SetHasStorylinesToPlay
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<bool>                            HasStorylinesToPlay                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_SetHasStorylinesToPlay(const TArray<bool>& HasStorylinesToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_SetHasStorylinesToPlay");

	Params::RBLobbyPlayerController_Server_SetHasStorylinesToPlay Parms{};

	Parms.HasStorylinesToPlay = std::move(HasStorylinesToPlay);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_SetIsPlayingLobbyTutorial
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bPlayingLobbyTutorial                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_SetIsPlayingLobbyTutorial(bool bPlayingLobbyTutorial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_SetIsPlayingLobbyTutorial");

	Params::RBLobbyPlayerController_Server_SetIsPlayingLobbyTutorial Parms{};

	Parms.bPlayingLobbyTutorial = bPlayingLobbyTutorial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_SetNarratorSpeaking
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bSpeaking                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_SetNarratorSpeaking(bool bSpeaking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_SetNarratorSpeaking");

	Params::RBLobbyPlayerController_Server_SetNarratorSpeaking Parms{};

	Parms.bSpeaking = bSpeaking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_StartMatchCountdown
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TArray<class ARBLobbyPlayerState*>      Members                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUseLongCancelGracePeriod                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_StartMatchCountdown(const TArray<class ARBLobbyPlayerState*>& Members, const struct FMatchSettings& MatchSettings, bool bUseLongCancelGracePeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_StartMatchCountdown");

	Params::RBLobbyPlayerController_Server_StartMatchCountdown Parms{};

	Parms.Members = std::move(Members);
	Parms.MatchSettings = std::move(MatchSettings);
	Parms.bUseLongCancelGracePeriod = bUseLongCancelGracePeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_UpdateMatchSettings
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_UpdateMatchSettings(const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_UpdateMatchSettings");

	Params::RBLobbyPlayerController_Server_UpdateMatchSettings Parms{};

	Parms.MatchSettings = std::move(MatchSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.Server_UpdatePlayerCellCustomization
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FRBPlayerCellCustomizationEntry>PlayerCellCustomization                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::Server_UpdatePlayerCellCustomization(const TArray<struct FRBPlayerCellCustomizationEntry>& PlayerCellCustomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "Server_UpdatePlayerCellCustomization");

	Params::RBLobbyPlayerController_Server_UpdatePlayerCellCustomization Parms{};

	Parms.PlayerCellCustomization = std::move(PlayerCellCustomization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.SetIsPlayingLobbyTutorial_Client
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPlayingLobbyTutorial                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::SetIsPlayingLobbyTutorial_Client(bool bPlayingLobbyTutorial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "SetIsPlayingLobbyTutorial_Client");

	Params::RBLobbyPlayerController_SetIsPlayingLobbyTutorial_Client Parms{};

	Parms.bPlayingLobbyTutorial = bPlayingLobbyTutorial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.SetMatchFixedPlayerCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FixedPlayerCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::SetMatchFixedPlayerCount(int32 FixedPlayerCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "SetMatchFixedPlayerCount");

	Params::RBLobbyPlayerController_SetMatchFixedPlayerCount Parms{};

	Parms.FixedPlayerCount = FixedPlayerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.SetMatchFixedSeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FixedSeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerController::SetMatchFixedSeed(int32 FixedSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "SetMatchFixedSeed");

	Params::RBLobbyPlayerController_SetMatchFixedSeed Parms{};

	Parms.FixedSeed = FixedSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.TryShowCharacterSheet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowPlayerInteracting                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerController::TryShowCharacterSheet(bool bAllowPlayerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "TryShowCharacterSheet");

	Params::RBLobbyPlayerController_TryShowCharacterSheet Parms{};

	Parms.bAllowPlayerInteracting = bAllowPlayerInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.UpdateHasNewCustoItems
// (Final, Native, Public, BlueprintCallable)

void ARBLobbyPlayerController::UpdateHasNewCustoItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "UpdateHasNewCustoItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerController.CanReleaseCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerController::CanReleaseCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "CanReleaseCharacter");

	Params::RBLobbyPlayerController_CanReleaseCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.GetClientTravelSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EClientTravelSource                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClientTravelSource ARBLobbyPlayerController::GetClientTravelSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "GetClientTravelSource");

	Params::RBLobbyPlayerController_GetClientTravelSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.GetMatchFixedPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBLobbyPlayerController::GetMatchFixedPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "GetMatchFixedPlayerCount");

	Params::RBLobbyPlayerController_GetMatchFixedPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.GetMatchFixedSeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBLobbyPlayerController::GetMatchFixedSeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "GetMatchFixedSeed");

	Params::RBLobbyPlayerController_GetMatchFixedSeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerController.IsPlayerInOwnCell
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerController::IsPlayerInOwnCell() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerController", "IsPlayerInOwnCell");

	Params::RBLobbyPlayerController_IsPlayerInOwnCell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingSpectatorPanelComponent.Multicast_PlayerTaunt
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URBArmWreslingSpectatorPanelComponent::Multicast_PlayerTaunt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingSpectatorPanelComponent", "Multicast_PlayerTaunt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.Event_OnPlayerConnected
// (Event, Protected, BlueprintEvent)
// Parameters:
// class URBArmWreslingPanelComponent*     PanelComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Event_OnPlayerConnected(class URBArmWreslingPanelComponent* PanelComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Event_OnPlayerConnected");

	Params::RBArmWreslingTable_Event_OnPlayerConnected Parms{};

	Parms.PanelComponent = PanelComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBArmWreslingTable.Event_OnPlayerDisconnected
// (Event, Protected, BlueprintEvent)
// Parameters:
// class URBArmWreslingPanelComponent*     PanelComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Event_OnPlayerDisconnected(class URBArmWreslingPanelComponent* PanelComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Event_OnPlayerDisconnected");

	Params::RBArmWreslingTable_Event_OnPlayerDisconnected Parms{};

	Parms.PanelComponent = PanelComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBArmWreslingTable.Event_OnRoundEnded
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FArmWreslingPlayerRoundData      Player1Data                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FArmWreslingPlayerRoundData      Player2Data                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Event_OnRoundEnded(const struct FArmWreslingPlayerRoundData& Player1Data, const struct FArmWreslingPlayerRoundData& Player2Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Event_OnRoundEnded");

	Params::RBArmWreslingTable_Event_OnRoundEnded Parms{};

	Parms.Player1Data = std::move(Player1Data);
	Parms.Player2Data = std::move(Player2Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBArmWreslingTable.Event_OnTableStateChanged
// (Event, Protected, BlueprintEvent)

void ARBArmWreslingTable::Event_OnTableStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Event_OnTableStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBArmWreslingTable.Event_OnWinningRatioPerPointChanged
// (Event, Protected, BlueprintEvent)

void ARBArmWreslingTable::Event_OnWinningRatioPerPointChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Event_OnWinningRatioPerPointChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBArmWreslingTable.GetMatchesLost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetMatchesLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetMatchesLost");

	Params::RBArmWreslingTable_GetMatchesLost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetMatchesWon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetMatchesWon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetMatchesWon");

	Params::RBArmWreslingTable_GetMatchesWon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetOpponentMatchesLost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetOpponentMatchesLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetOpponentMatchesLost");

	Params::RBArmWreslingTable_GetOpponentMatchesLost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetOpponentMatchesWon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetOpponentMatchesWon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetOpponentMatchesWon");

	Params::RBArmWreslingTable_GetOpponentMatchesWon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetOpponentRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetOpponentRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetOpponentRating");

	Params::RBArmWreslingTable_GetOpponentRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBArmWreslingTable::GetRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetRating");

	Params::RBArmWreslingTable_GetRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchEndMessage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARBPlayer*                        WinnerPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        LoserPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    GameTied_value                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Multicast_BroadcastMatchEndMessage(class ARBPlayer* WinnerPlayer, class ARBPlayer* LoserPlayer, bool GameTied_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Multicast_BroadcastMatchEndMessage");

	Params::RBArmWreslingTable_Multicast_BroadcastMatchEndMessage Parms{};

	Parms.WinnerPlayer = WinnerPlayer;
	Parms.LoserPlayer = LoserPlayer;
	Parms.GameTied_value = GameTied_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchStartMessage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARBPlayer*                        Player1Ptr                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player2Ptr                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Multicast_BroadcastMatchStartMessage(class ARBPlayer* Player1Ptr, class ARBPlayer* Player2Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Multicast_BroadcastMatchStartMessage");

	Params::RBArmWreslingTable_Multicast_BroadcastMatchStartMessage Parms{};

	Parms.Player1Ptr = Player1Ptr;
	Parms.Player2Ptr = Player2Ptr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.Multicast_OnResetMatch
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ARBArmWreslingTable::Multicast_OnResetMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Multicast_OnResetMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.Multicast_OnRoundEnded
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FArmWreslingPlayerRoundData      Player1Data                                            (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FArmWreslingPlayerRoundData      Player2Data                                            (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Multicast_OnRoundEnded(const struct FArmWreslingPlayerRoundData& Player1Data, const struct FArmWreslingPlayerRoundData& Player2Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Multicast_OnRoundEnded");

	Params::RBArmWreslingTable_Multicast_OnRoundEnded Parms{};

	Parms.Player1Data = std::move(Player1Data);
	Parms.Player2Data = std::move(Player2Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.Multicast_PlayerInputEvent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FArmWreslingPlayerRoundData      PlayerData                                             (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBArmWreslingTable::Multicast_PlayerInputEvent(const struct FArmWreslingPlayerRoundData& PlayerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "Multicast_PlayerInputEvent");

	Params::RBArmWreslingTable_Multicast_PlayerInputEvent Parms{};

	Parms.PlayerData = std::move(PlayerData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.OnRep_Stats
// (Final, Native, Private)

void ARBArmWreslingTable::OnRep_Stats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "OnRep_Stats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.OnRep_TableState
// (Final, Native, Protected)

void ARBArmWreslingTable::OnRep_TableState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "OnRep_TableState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBArmWreslingTable.GetElapsedRoundTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBArmWreslingTable::GetElapsedRoundTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetElapsedRoundTime");

	Params::RBArmWreslingTable_GetElapsedRoundTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetLocallyWatchedPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBArmWreslingPanelComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBArmWreslingPanelComponent* ARBArmWreslingTable::GetLocallyWatchedPanel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetLocallyWatchedPanel");

	Params::RBArmWreslingTable_GetLocallyWatchedPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetOpposingWatchedPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBArmWreslingPanelComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBArmWreslingPanelComponent* ARBArmWreslingTable::GetOpposingWatchedPanel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetOpposingWatchedPanel");

	Params::RBArmWreslingTable_GetOpposingWatchedPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.GetTableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EArmWreslingTableState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EArmWreslingTableState ARBArmWreslingTable::GetTableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "GetTableState");

	Params::RBArmWreslingTable_GetTableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.IsMatchInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBArmWreslingTable::IsMatchInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "IsMatchInProgress");

	Params::RBArmWreslingTable_IsMatchInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBArmWreslingTable.IsMatchStartedOrCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBArmWreslingTable::IsMatchStartedOrCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBArmWreslingTable", "IsMatchStartedOrCompleted");

	Params::RBArmWreslingTable_IsMatchStartedOrCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTortureRoom.Event_OnCurrentMeterChanged
// (Event, Public, BlueprintEvent)

void ARBTortureRoom::Event_OnCurrentMeterChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnCurrentMeterChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTortureRoom.Event_OnPlayerConnected
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBTorturePanelComponent*         TortureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureRoom::Event_OnPlayerConnected(class URBTorturePanelComponent* TortureComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnPlayerConnected");

	Params::RBTortureRoom_Event_OnPlayerConnected Parms{};

	Parms.TortureComponent = TortureComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTortureRoom.Event_OnPlayerDisconnected
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBTorturePanelComponent*         TortureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureRoom::Event_OnPlayerDisconnected(class URBTorturePanelComponent* TortureComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnPlayerDisconnected");

	Params::RBTortureRoom_Event_OnPlayerDisconnected Parms{};

	Parms.TortureComponent = TortureComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTortureRoom.Event_OnPlayerInputFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBTorturePanelComponent*         TortureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureRoom::Event_OnPlayerInputFailed(class URBTorturePanelComponent* TortureComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnPlayerInputFailed");

	Params::RBTortureRoom_Event_OnPlayerInputFailed Parms{};

	Parms.TortureComponent = TortureComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTortureRoom.Event_OnPlayerInputSuccess
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBTorturePanelComponent*         TortureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureRoom::Event_OnPlayerInputSuccess(class URBTorturePanelComponent* TortureComponent, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnPlayerInputSuccess");

	Params::RBTortureRoom_Event_OnPlayerInputSuccess Parms{};

	Parms.TortureComponent = TortureComponent;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTortureRoom.Event_OnTortureCompletedChanged
// (Event, Public, BlueprintEvent)

void ARBTortureRoom::Event_OnTortureCompletedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnTortureCompletedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTortureRoom.Event_OnTortureEnabledChanged
// (Event, Public, BlueprintEvent)

void ARBTortureRoom::Event_OnTortureEnabledChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "Event_OnTortureEnabledChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTortureRoom.OnRep_CurrentMeter
// (Final, Native, Private)

void ARBTortureRoom::OnRep_CurrentMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "OnRep_CurrentMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureRoom.OnRep_TortureCompleted
// (Final, Native, Private)

void ARBTortureRoom::OnRep_TortureCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "OnRep_TortureCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureRoom.OnRep_TortureEnabled
// (Final, Native, Private)

void ARBTortureRoom::OnRep_TortureEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureRoom", "OnRep_TortureEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAttackDummy.BP_ResetAttackDummy
// (Final, Native, Public, BlueprintCallable)

void ARBAttackDummy::BP_ResetAttackDummy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAttackDummy", "BP_ResetAttackDummy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAttackDummy.BP_SetLocationFromTimeline
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAttackDummy::BP_SetLocationFromTimeline(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAttackDummy", "BP_SetLocationFromTimeline");

	Params::RBAttackDummy_BP_SetLocationFromTimeline Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAttackDummy.Event_OnHit
// (Event, Public, BlueprintEvent)

void ARBAttackDummy::Event_OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAttackDummy", "Event_OnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAudioSettingsWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBAudioSettingsWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAudioSettingsWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAutoCompleteStageTestAgent.OnFindHubCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    bPending                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAutoCompleteStageTestAgent::OnFindHubCompleted(bool bPending, bool bSucceeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoCompleteStageTestAgent", "OnFindHubCompleted");

	Params::RBAutoCompleteStageTestAgent_OnFindHubCompleted Parms{};

	Parms.bPending = bPending;
	Parms.bSucceeded = bSucceeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoCompleteStageTestAgent.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAutoCompleteStageTestAgent::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoCompleteStageTestAgent", "OnGamePhaseUpdated");

	Params::RBAutoCompleteStageTestAgent_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoCompleteStageTestAgent.OnMatchReady
// (Final, Native, Private)

void URBAutoCompleteStageTestAgent::OnMatchReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoCompleteStageTestAgent", "OnMatchReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoCompleteStageTestAgent.OnStageEnded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bisReset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBAutoCompleteStageTestAgent::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bisReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoCompleteStageTestAgent", "OnStageEnded");

	Params::RBAutoCompleteStageTestAgent_OnStageEnded Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.bisReset = bisReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoCompleteStageTestAgent.OnStageReady
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBAutoCompleteStageTestAgent::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoCompleteStageTestAgent", "OnStageReady");

	Params::RBAutoCompleteStageTestAgent_OnStageReady Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInGameMenuWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBInGameMenuWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInGameMenuWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInGameMenuWidget.GetSocialMenuManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBSocialMenuManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSocialMenuManager* URBInGameMenuWidget::GetSocialMenuManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInGameMenuWidget", "GetSocialMenuManager");

	Params::RBInGameMenuWidget_GetSocialMenuManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInGameMenuWidget.HandleNavigationBack
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void URBInGameMenuWidget::HandleNavigationBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInGameMenuWidget", "HandleNavigationBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInGameMenuWidget.OnMenuCancelPressed
// (Native, Protected)

void URBInGameMenuWidget::OnMenuCancelPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInGameMenuWidget", "OnMenuCancelPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineActor.SetLink
// (Native, Public, BlueprintCallable)
// Parameters:
// class ARBSplineActor*                   NextMarker                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineActor::SetLink(class ARBSplineActor* NextMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineActor", "SetLink");

	Params::RBSplineActor_SetLink Parms{};

	Parms.NextMarker = NextMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.BP_SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLedgeMarker::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "BP_SetEnabled");

	Params::RBLedgeMarker_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.GotoNext
// (Final, Native, Public)

void ARBLedgeMarker::GotoNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "GotoNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.GotoPrevious
// (Final, Native, Public)

void ARBLedgeMarker::GotoPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "GotoPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.SelectGroup
// (Final, Native, Public)

void ARBLedgeMarker::SelectGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "SelectGroup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.SelectNext
// (Final, Native, Public)

void ARBLedgeMarker::SelectNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "SelectNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.SelectPrevious
// (Final, Native, Public)

void ARBLedgeMarker::SelectPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "SelectPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.SetCanBeUsedByAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CanBeUsedByAI                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLedgeMarker::SetCanBeUsedByAI(bool CanBeUsedByAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "SetCanBeUsedByAI");

	Params::RBLedgeMarker_SetCanBeUsedByAI Parms{};

	Parms.CanBeUsedByAI = CanBeUsedByAI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.UnlinkNext
// (Final, Native, Public)

void ARBLedgeMarker::UnlinkNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "UnlinkNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.UnlinkPrevious
// (Final, Native, Public)

void ARBLedgeMarker::UnlinkPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "UnlinkPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLedgeMarker.Validate
// (Final, Native, Public)
// Parameters:
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLedgeMarker::Validate(bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLedgeMarker", "Validate");

	Params::RBLedgeMarker_Validate Parms{};

	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.BP_GetSyncLocationFromSequence
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Sequence                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNetworkSyncComponent::BP_GetSyncLocationFromSequence(const TArray<struct FVector>& Sequence, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_GetSyncLocationFromSequence");

	Params::RBNetworkSyncComponent_BP_GetSyncLocationFromSequence Parms{};

	Parms.Sequence = std::move(Sequence);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);
}


// Function OPP.RBNetworkSyncComponent.BP_GetSyncRotationFromSequence
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FRotator>                 Sequence                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBNetworkSyncComponent::BP_GetSyncRotationFromSequence(const TArray<struct FRotator>& Sequence, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_GetSyncRotationFromSequence");

	Params::RBNetworkSyncComponent_BP_GetSyncRotationFromSequence Parms{};

	Parms.Sequence = std::move(Sequence);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function OPP.RBNetworkSyncComponent.BP_ResetNetworkSync
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBNetworkSyncComponent::BP_ResetNetworkSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_ResetNetworkSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.BP_SlowToStop
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNetworkSyncComponent::BP_SlowToStop(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_SlowToStop");

	Params::RBNetworkSyncComponent_BP_SlowToStop Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.BP_TriggerNetworkSync
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBNetworkSyncComponent::BP_TriggerNetworkSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_TriggerNetworkSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.BP_UntriggerNetworkSync
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBNetworkSyncComponent::BP_UntriggerNetworkSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_UntriggerNetworkSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.OnRep_NetworkSyncInitialValue
// (Final, Native, Private)

void URBNetworkSyncComponent::OnRep_NetworkSyncInitialValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "OnRep_NetworkSyncInitialValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.OnRep_PlayingChanged
// (Final, Native, Private)

void URBNetworkSyncComponent::OnRep_PlayingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "OnRep_PlayingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSyncComponent.BP_GetSyncValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBNetworkSyncComponent::BP_GetSyncValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_GetSyncValue");

	Params::RBNetworkSyncComponent_BP_GetSyncValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNetworkSyncComponent.BP_IsFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNetworkSyncComponent::BP_IsFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_IsFinished");

	Params::RBNetworkSyncComponent_BP_IsFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNetworkSyncComponent.BP_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNetworkSyncComponent::BP_IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_IsPlaying");

	Params::RBNetworkSyncComponent_BP_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNetworkSyncComponent.BP_IsStopped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNetworkSyncComponent::BP_IsStopped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSyncComponent", "BP_IsStopped");

	Params::RBNetworkSyncComponent_BP_IsStopped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBAutomaticDoor.BackBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBAutomaticDoor::BackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutomaticDoor", "BackBeginOverlap");

	Params::RBAutomaticDoor_BackBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutomaticDoor.BackEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAutomaticDoor::BackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutomaticDoor", "BackEndOverlap");

	Params::RBAutomaticDoor_BackEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutomaticDoor.FrontBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBAutomaticDoor::FrontBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutomaticDoor", "FrontBeginOverlap");

	Params::RBAutomaticDoor_FrontBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutomaticDoor.FrontEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAutomaticDoor::FrontEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutomaticDoor", "FrontEndOverlap");

	Params::RBAutomaticDoor_FrontEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoRespawnContainer.BP_SetAutoRespawnForcedItemsEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnRightNow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAutoRespawnContainer::BP_SetAutoRespawnForcedItemsEnabled(bool bEnabled, bool bSpawnRightNow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoRespawnContainer", "BP_SetAutoRespawnForcedItemsEnabled");

	Params::RBAutoRespawnContainer_BP_SetAutoRespawnForcedItemsEnabled Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bSpawnRightNow = bSpawnRightNow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoRespawnContainer.Event_OnAutoRespawnItemsEnabledChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBAutoRespawnContainer::Event_OnAutoRespawnItemsEnabledChanged(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoRespawnContainer", "Event_OnAutoRespawnItemsEnabledChanged");

	Params::RBAutoRespawnContainer_Event_OnAutoRespawnItemsEnabledChanged Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBAutoRespawnContainer.Event_OnSpawnsInBatchRemainingChanged
// (Event, Public, BlueprintEvent)

void ARBAutoRespawnContainer::Event_OnSpawnsInBatchRemainingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoRespawnContainer", "Event_OnSpawnsInBatchRemainingChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBAutoRespawnContainer.OnRep_AutoRespawnForcedItemsEnabled
// (Final, Native, Private)

void ARBAutoRespawnContainer::OnRep_AutoRespawnForcedItemsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoRespawnContainer", "OnRep_AutoRespawnForcedItemsEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBAutoRespawnContainer.OnRep_SpawnsInBatchRemaining
// (Final, Native, Private)

void ARBAutoRespawnContainer::OnRep_SpawnsInBatchRemaining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBAutoRespawnContainer", "OnRep_SpawnsInBatchRemaining");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLivesCounter.Event_OnRemainingLivesChanged
// (Event, Public, BlueprintEvent)

void URBHUDLivesCounter::Event_OnRemainingLivesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "Event_OnRemainingLivesChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDLivesCounter.OnIsDeadChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsDead                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLivesCounter::OnIsDeadChanged(bool bIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "OnIsDeadChanged");

	Params::RBHUDLivesCounter_OnIsDeadChanged Parms{};

	Parms.bIsDead = bIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLivesCounter.OnRemainingLivesChanged
// (Final, Native, Public)

void URBHUDLivesCounter::OnRemainingLivesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "OnRemainingLivesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLivesCounter.SetPlayerState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayerState*                   NewPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLivesCounter::SetPlayerState(class ARBPlayerState* NewPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "SetPlayerState");

	Params::RBHUDLivesCounter_SetPlayerState Parms{};

	Parms.NewPlayerState = NewPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLivesCounter.GetMaxNumberOfLives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBHUDLivesCounter::GetMaxNumberOfLives() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "GetMaxNumberOfLives");

	Params::RBHUDLivesCounter_GetMaxNumberOfLives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDLivesCounter.GetRemainingNumberOfLives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBHUDLivesCounter::GetRemainingNumberOfLives() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLivesCounter", "GetRemainingNumberOfLives");

	Params::RBHUDLivesCounter_GetRemainingNumberOfLives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBackToLobbyMenu.BackToLobby
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWithParty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBackToLobbyMenu::BackToLobby(bool bWithParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "BackToLobby");

	Params::RBBackToLobbyMenu_BackToLobby Parms{};

	Parms.bWithParty = bWithParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBackToLobbyMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBBackToLobbyMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBackToLobbyMenu.CanReturnWithParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBackToLobbyMenu::CanReturnWithParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "CanReturnWithParty");

	Params::RBBackToLobbyMenu_CanReturnWithParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBackToLobbyMenu.IsLeaving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBackToLobbyMenu::IsLeaving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "IsLeaving");

	Params::RBBackToLobbyMenu_IsLeaving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBackToLobbyMenu.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBackToLobbyMenu::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "IsOperationPending");

	Params::RBBackToLobbyMenu_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBackToLobbyMenu.LeavingWillLeaveParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBackToLobbyMenu::LeavingWillLeaveParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBackToLobbyMenu", "LeavingWillLeaveParty");

	Params::RBBackToLobbyMenu_LeavingWillLeaveParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBandagePickup.BP_OnBloodyRatioChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   bloodyRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBandagePickup::BP_OnBloodyRatioChanged(float bloodyRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBandagePickup", "BP_OnBloodyRatioChanged");

	Params::RBBandagePickup_BP_OnBloodyRatioChanged Parms{};

	Parms.bloodyRatio = bloodyRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBandagePickup.BP_OnStartHoldConsumeAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBandagePickup::BP_OnStartHoldConsumeAction(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBandagePickup", "BP_OnStartHoldConsumeAction");

	Params::RBBandagePickup_BP_OnStartHoldConsumeAction Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuTransition.BP_TransitionInDone
// (Final, Native, Public, BlueprintCallable)

void URBMenuTransition::BP_TransitionInDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTransition", "BP_TransitionInDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTransition.BP_TransitionOutDone
// (Final, Native, Public, BlueprintCallable)

void URBMenuTransition::BP_TransitionOutDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTransition", "BP_TransitionOutDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTransition.Event_TransitionIn
// (Event, Public, BlueprintEvent)

void URBMenuTransition::Event_TransitionIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTransition", "Event_TransitionIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTransition.Event_TransitionOut
// (Event, Public, BlueprintEvent)

void URBMenuTransition::Event_TransitionOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTransition", "Event_TransitionOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBarcodeScanner.Event_OnCorrectBarcode
// (Event, Protected, BlueprintEvent)

void ARBBarcodeScanner::Event_OnCorrectBarcode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBarcodeScanner", "Event_OnCorrectBarcode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBarcodeScanner.Event_OnTVBarcodeChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   Code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Prefix                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBBarcodeScanner::Event_OnTVBarcodeChanged(int32 Code, const class FText& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBarcodeScanner", "Event_OnTVBarcodeChanged");

	Params::RBBarcodeScanner_Event_OnTVBarcodeChanged Parms{};

	Parms.Code = Code;
	Parms.Prefix = std::move(Prefix);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBarcodeScanner.OnRep_AcceptedBarcodes
// (Final, Native, Public)

void ARBBarcodeScanner::OnRep_AcceptedBarcodes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBarcodeScanner", "OnRep_AcceptedBarcodes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyStatBoard.Event_CurrentStatUpdated
// (Event, Protected, BlueprintEvent)

void ARBLobbyStatBoard::Event_CurrentStatUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyStatBoard", "Event_CurrentStatUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLobbyStatBoard.Event_EntriesUpdated
// (Event, Protected, BlueprintEvent)

void ARBLobbyStatBoard::Event_EntriesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyStatBoard", "Event_EntriesUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLobbyStatBoard.OnRep_CurrentStatConfigId
// (Final, Native, Private)

void ARBLobbyStatBoard::OnRep_CurrentStatConfigId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyStatBoard", "OnRep_CurrentStatConfigId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyStatBoard.OnRep_Entries
// (Final, Native, Private)

void ARBLobbyStatBoard::OnRep_Entries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyStatBoard", "OnRep_Entries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBattlePassMenu.Event_Rebuild
// (Event, Public, BlueprintEvent)

void URBBattlePassMenu::Event_Rebuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "Event_Rebuild");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBattlePassMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBBattlePassMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBattlePassMenu.NextPage
// (Final, Native, Public, BlueprintCallable)

void URBBattlePassMenu::NextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "NextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBattlePassMenu.PreviousPage
// (Final, Native, Public, BlueprintCallable)

void URBBattlePassMenu::PreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "PreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBattlePassMenu.PurchaseItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBattlePassMenu::PurchaseItem(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "PurchaseItem");

	Params::RBBattlePassMenu_PurchaseItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBattlePassMenu.SelectBattlePass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BattlePassId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBattlePassMenu::SelectBattlePass(const class FName& BattlePassId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "SelectBattlePass");

	Params::RBBattlePassMenu_SelectBattlePass Parms{};

	Parms.BattlePassId = BattlePassId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBattlePassMenu.GetBattlePassAvailability
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BattlePassId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattlePassAvailability                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBattlePassAvailability URBBattlePassMenu::GetBattlePassAvailability(const class FName& BattlePassId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "GetBattlePassAvailability");

	Params::RBBattlePassMenu_GetBattlePassAvailability Parms{};

	Parms.BattlePassId = BattlePassId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.GetBattlePasses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBBattlePassData>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBBattlePassData> URBBattlePassMenu::GetBattlePasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "GetBattlePasses");

	Params::RBBattlePassMenu_GetBattlePasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.GetItemAvailability
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattlePassItemAvailability             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBattlePassItemAvailability URBBattlePassMenu::GetItemAvailability(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "GetItemAvailability");

	Params::RBBattlePassMenu_GetItemAvailability Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.GetSelectedBattlePass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBBattlePassData          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBBattlePassData URBBattlePassMenu::GetSelectedBattlePass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "GetSelectedBattlePass");

	Params::RBBattlePassMenu_GetSelectedBattlePass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.GetSelectedPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBBattlePassPageData      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBBattlePassPageData URBBattlePassMenu::GetSelectedPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "GetSelectedPage");

	Params::RBBattlePassMenu_GetSelectedPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.HasNextPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBattlePassMenu::HasNextPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "HasNextPage");

	Params::RBBattlePassMenu_HasNextPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.HasPreviousPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBattlePassMenu::HasPreviousPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "HasPreviousPage");

	Params::RBBattlePassMenu_HasPreviousPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBattlePassMenu.HasSelectedBattlePass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBattlePassMenu::HasSelectedBattlePass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBattlePassMenu", "HasSelectedBattlePass");

	Params::RBBattlePassMenu_HasSelectedBattlePass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProjectile.DelayedDestroy
// (Final, Native, Protected)

void ARBProjectile::DelayedDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectile", "DelayedDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectile.OnRep_Launched
// (Final, Native, Protected)

void ARBProjectile::OnRep_Launched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectile", "OnRep_Launched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMolotovProjectile.Event_OnFireFinished
// (Event, Public, BlueprintEvent)

void ARBMolotovProjectile::Event_OnFireFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMolotovProjectile", "Event_OnFireFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMolotovProjectile.Event_OnFireStarted
// (Event, Public, BlueprintEvent)

void ARBMolotovProjectile::Event_OnFireStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMolotovProjectile", "Event_OnFireStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMolotovProjectile.OnRep_FireStartedTimestamp
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMolotovProjectile::OnRep_FireStartedTimestamp(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMolotovProjectile", "OnRep_FireStartedTimestamp");

	Params::RBMolotovProjectile_OnRep_FireStartedTimestamp Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_DamageParams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDamageType                             DmgType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageParameters          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDamageParameters ARBPawn::BP_DamageParams(EDamageType DmgType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawn", "BP_DamageParams");

	Params::RBPawn_BP_DamageParams Parms{};

	Parms.DmgType = DmgType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.AddForcedDarknessSource_Server
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::AddForcedDarknessSource_Server(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "AddForcedDarknessSource_Server");

	Params::RBPawn_AddForcedDarknessSource_Server Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_AddHealth
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HealthToAdd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveBleeding                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_AddHealth(float HealthToAdd, bool bRemoveBleeding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_AddHealth");

	Params::RBPawn_BP_AddHealth Parms{};

	Parms.HealthToAdd = HealthToAdd;
	Parms.bRemoveBleeding = bRemoveBleeding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_DEBUG_TryInteraction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Interactable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_DEBUG_TryInteraction(class UObject* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_DEBUG_TryInteraction");

	Params::RBPawn_BP_DEBUG_TryInteraction Parms{};

	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_DetachTemporaryComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_DetachTemporaryComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_DetachTemporaryComponent");

	Params::RBPawn_BP_DetachTemporaryComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_Die
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPawn::BP_Die()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_Die");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_EnterCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ELocomotionMode                         ExitLocomotionMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_EnterCinematicMode(const struct FVector& Location, const struct FRotator& Rotation, ELocomotionMode ExitLocomotionMode, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_EnterCinematicMode");

	Params::RBPawn_BP_EnterCinematicMode Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.ExitLocomotionMode = ExitLocomotionMode;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_ExitCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPawn::BP_ExitCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_ExitCinematicMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_ForceDropLargeObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPawn::BP_ForceDropLargeObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_ForceDropLargeObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_PlayAkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_PlayAkEvent(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_PlayAkEvent");

	Params::RBPawn_BP_PlayAkEvent Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_PlaySpecialMoveAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_PlaySpecialMoveAnim(class UAnimSequenceBase* AnimSeq, float blendIn, float blendOut, float PlayRate, float StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_PlaySpecialMoveAnim");

	Params::RBPawn_BP_PlaySpecialMoveAnim Parms{};

	Parms.AnimSeq = AnimSeq;
	Parms.blendIn = blendIn;
	Parms.blendOut = blendOut;
	Parms.PlayRate = PlayRate;
	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_PlayVoiceAkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_PlayVoiceAkEvent(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_PlayVoiceAkEvent");

	Params::RBPawn_BP_PlayVoiceAkEvent Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_RemoveTemporaryComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnapBack                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_RemoveTemporaryComponent(class USceneComponent* Component, bool bSnapBack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_RemoveTemporaryComponent");

	Params::RBPawn_BP_RemoveTemporaryComponent Parms{};

	Parms.Component = Component;
	Parms.bSnapBack = bSnapBack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_SpecialMoveNotify
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpecialMoveNotifyType                  NotifyType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_SpecialMoveNotify(ESpecialMoveNotifyType NotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_SpecialMoveNotify");

	Params::RBPawn_BP_SpecialMoveNotify Parms{};

	Parms.NotifyType = NotifyType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPawn.BP_StartScriptedAnimation
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAnimRef                       Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ScriptedAttachBone                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param_ScriptedAttachActor                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ScriptedAttachOffset                                   (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::BP_StartScriptedAnimation(const struct FVector& Location, const struct FVector& Forward, const struct FRBAnimRef& Animation, class FName ScriptedAttachBone, class AActor* Param_ScriptedAttachActor, const struct FTransform& ScriptedAttachOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_StartScriptedAnimation");

	Params::RBPawn_BP_StartScriptedAnimation Parms{};

	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);
	Parms.Animation = std::move(Animation);
	Parms.ScriptedAttachBone = ScriptedAttachBone;
	Parms.Param_ScriptedAttachActor = Param_ScriptedAttachActor;
	Parms.ScriptedAttachOffset = std::move(ScriptedAttachOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_StartSpecialMove
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_StartSpecialMove(ESpecialMove SpecialMove, const struct FVector& TargetPosition, const struct FVector& TargetDirection, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_StartSpecialMove");

	Params::RBPawn_BP_StartSpecialMove Parms{};

	Parms.SpecialMove = SpecialMove;
	Parms.TargetPosition = std::move(TargetPosition);
	Parms.TargetDirection = std::move(TargetDirection);
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.BP_TemporaryAttachComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::BP_TemporaryAttachComponent(class USceneComponent* Component, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_TemporaryAttachComponent");

	Params::RBPawn_BP_TemporaryAttachComponent Parms{};

	Parms.Component = Component;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.ClearGhostAnimInstance
// (Native, Public, BlueprintCallable)

void ARBPawn::ClearGhostAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "ClearGhostAnimInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Event_HealthUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncreased                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Event_HealthUpdated(float NewHealth, bool bIncreased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_HealthUpdated");

	Params::RBPawn_Event_HealthUpdated Parms{};

	Parms.NewHealth = NewHealth;
	Parms.bIncreased = bIncreased;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPawn.Event_OnDie
// (Event, Public, BlueprintEvent)

void ARBPawn::Event_OnDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_OnDie");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPawn.Event_OnFootstep
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FFootstepData                    FootstepData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Event_OnFootstep(const struct FFootstepData& FootstepData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_OnFootstep");

	Params::RBPawn_Event_OnFootstep Parms{};

	Parms.FootstepData = std::move(FootstepData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPawn.Event_OnStartSeeThroughWallMeshSwap
// (Event, Public, BlueprintEvent)

void ARBPawn::Event_OnStartSeeThroughWallMeshSwap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_OnStartSeeThroughWallMeshSwap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPawn.Event_OnStopSeeThroughWallMeshSwap
// (Event, Public, BlueprintEvent)

void ARBPawn::Event_OnStopSeeThroughWallMeshSwap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_OnStopSeeThroughWallMeshSwap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPawn.Event_OnTakeDamage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDamageInfo                      Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Event_OnTakeDamage(const struct FDamageInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Event_OnTakeDamage");

	Params::RBPawn_Event_OnTakeDamage Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPawn.GetFacePoseAsset
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPoseAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPoseAsset* ARBPawn::GetFacePoseAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GetFacePoseAsset");

	Params::RBPawn_GetFacePoseAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.GhostAnimTransition
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::GhostAnimTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GhostAnimTransition");

	Params::RBPawn_GhostAnimTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.Multicast_AddExternalImpulse
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Impulse                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_AddExternalImpulse(const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_AddExternalImpulse");

	Params::RBPawn_Multicast_AddExternalImpulse Parms{};

	Parms.Impulse = std::move(Impulse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_AddServerBreadcrumb
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FPawnBreadcrumb                  NewBreadcrumb                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_AddServerBreadcrumb(const struct FPawnBreadcrumb& NewBreadcrumb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_AddServerBreadcrumb");

	Params::RBPawn_Multicast_AddServerBreadcrumb Parms{};

	Parms.NewBreadcrumb = std::move(NewBreadcrumb);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_BashBreakableObstacle
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBBreakableObstacle*             breakableObstacle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_BashBreakableObstacle(class ARBBreakableObstacle* breakableObstacle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_BashBreakableObstacle");

	Params::RBPawn_Multicast_BashBreakableObstacle Parms{};

	Parms.breakableObstacle = breakableObstacle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_BlendOutActiveSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   blendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpecialMoveIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_BlendOutActiveSpecialMove(float blendOutTime, int32 SpecialMoveIndex, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_BlendOutActiveSpecialMove");

	Params::RBPawn_Multicast_BlendOutActiveSpecialMove Parms{};

	Parms.blendOutTime = blendOutTime;
	Parms.SpecialMoveIndex = SpecialMoveIndex;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_DoActionBashDoor
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_DoActionBashDoor(class ARBDoor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_DoActionBashDoor");

	Params::RBPawn_Multicast_DoActionBashDoor Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ExitCinematicMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPawn::Multicast_ExitCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ExitCinematicMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_InteruptCurrentAction
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPawn::Multicast_InteruptCurrentAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_InteruptCurrentAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_KnockbackPawn
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_KnockbackPawn(const struct FVector& Direction, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_KnockbackPawn");

	Params::RBPawn_Multicast_KnockbackPawn Parms{};

	Parms.Direction = std::move(Direction);
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_OnDie
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_OnDie(class ARBPawn* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_OnDie");

	Params::RBPawn_Multicast_OnDie Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_OnTakeDamage
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FDamageInfo                      DmgInfo                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_OnTakeDamage(const struct FDamageInfo& DmgInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_OnTakeDamage");

	Params::RBPawn_Multicast_OnTakeDamage Parms{};

	Parms.DmgInfo = std::move(DmgInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_QueueProceduralAnim
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FProceduralTranslationAnimData   AnimData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_QueueProceduralAnim(const struct FProceduralTranslationAnimData& AnimData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_QueueProceduralAnim");

	Params::RBPawn_Multicast_QueueProceduralAnim Parms{};

	Parms.AnimData = std::move(AnimData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ResetPawn
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPawn::Multicast_ResetPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ResetPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ScheduleBlendOutControl
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FScheduledSpecialMoveBlendOut    Param_ScheduledSpecialMoveBlendOut                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_ScheduleBlendOutControl(const struct FScheduledSpecialMoveBlendOut& Param_ScheduledSpecialMoveBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ScheduleBlendOutControl");

	Params::RBPawn_Multicast_ScheduleBlendOutControl Parms{};

	Parms.Param_ScheduledSpecialMoveBlendOut = std::move(Param_ScheduledSpecialMoveBlendOut);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ScheduleCompleteSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   PawnTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpecialMoveSubType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_ScheduleCompleteSpecialMove(float PawnTime, float ServerTime, ESpecialMove SpecialMove, int32 SpecialMoveSubType, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ScheduleCompleteSpecialMove");

	Params::RBPawn_Multicast_ScheduleCompleteSpecialMove Parms{};

	Parms.PawnTime = PawnTime;
	Parms.ServerTime = ServerTime;
	Parms.SpecialMove = SpecialMove;
	Parms.SpecialMoveSubType = SpecialMoveSubType;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ScheduleLocomotionMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ELocomotionMode                         NewLocomotionMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PawnTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_ScheduleLocomotionMode(ELocomotionMode NewLocomotionMode, float PawnTime, float ServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ScheduleLocomotionMode");

	Params::RBPawn_Multicast_ScheduleLocomotionMode Parms{};

	Parms.NewLocomotionMode = NewLocomotionMode;
	Parms.PawnTime = PawnTime;
	Parms.ServerTime = ServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_ScheduleSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FScheduledSpecialMoveData        ScheduledSpecialMoveData                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_ScheduleSpecialMove(const struct FScheduledSpecialMoveData& ScheduledSpecialMoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_ScheduleSpecialMove");

	Params::RBPawn_Multicast_ScheduleSpecialMove Parms{};

	Parms.ScheduledSpecialMoveData = std::move(ScheduledSpecialMoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SetCurrentInteractable
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UObject*                          NewCurrentInteractable                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SetCurrentInteractable(class UObject* NewCurrentInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SetCurrentInteractable");

	Params::RBPawn_Multicast_SetCurrentInteractable Parms{};

	Parms.NewCurrentInteractable = NewCurrentInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SetFinishedGhostReason
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EGhostFinishReason                      FinishReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomFinishReason                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SetFinishedGhostReason(EGhostFinishReason FinishReason, int32 CustomFinishReason, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SetFinishedGhostReason");

	Params::RBPawn_Multicast_SetFinishedGhostReason Parms{};

	Parms.FinishReason = FinishReason;
	Parms.CustomFinishReason = CustomFinishReason;
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SetPairedPawn
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Param_PairedPawn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPairedPawnIsLeader                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SetPairedPawn(class ARBPawn* Param_PairedPawn, bool bPairedPawnIsLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SetPairedPawn");

	Params::RBPawn_Multicast_SetPairedPawn Parms{};

	Parms.Param_PairedPawn = Param_PairedPawn;
	Parms.bPairedPawnIsLeader = bPairedPawnIsLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SetSpecialMoveInterruptedLocomotionMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   SpecialMoveIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocomotionMode                         NextLocomotionMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SetSpecialMoveInterruptedLocomotionMode(int32 SpecialMoveIndex, ESpecialMove SpecialMove, ELocomotionMode NextLocomotionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SetSpecialMoveInterruptedLocomotionMode");

	Params::RBPawn_Multicast_SetSpecialMoveInterruptedLocomotionMode Parms{};

	Parms.SpecialMoveIndex = SpecialMoveIndex;
	Parms.SpecialMove = SpecialMove;
	Parms.NextLocomotionMode = NextLocomotionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SetSpecialMoveNextLocomotionMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   SpecialMoveIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocomotionMode                         NextLocomotionMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SetSpecialMoveNextLocomotionMode(int32 SpecialMoveIndex, ESpecialMove SpecialMove, ELocomotionMode NextLocomotionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SetSpecialMoveNextLocomotionMode");

	Params::RBPawn_Multicast_SetSpecialMoveNextLocomotionMode Parms{};

	Parms.SpecialMoveIndex = SpecialMoveIndex;
	Parms.SpecialMove = SpecialMove;
	Parms.NextLocomotionMode = NextLocomotionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SpecialMoveInterrupted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            SpecialMoveInterrupted                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SpecialMoveInterrupted(ESpecialMove SpecialMoveInterrupted, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SpecialMoveInterrupted");

	Params::RBPawn_Multicast_SpecialMoveInterrupted Parms{};

	Parms.SpecialMoveInterrupted = SpecialMoveInterrupted;
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_StartBashDoor
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBashDoorType                           bashType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartCharLocation                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_StartBashDoor(class ARBDoor* Door, EBashDoorType bashType, bool bPredicted, const struct FVector& StartCharLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_StartBashDoor");

	Params::RBPawn_Multicast_StartBashDoor Parms{};

	Parms.Door = Door;
	Parms.bashType = bashType;
	Parms.bPredicted = bPredicted;
	Parms.StartCharLocation = std::move(StartCharLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_StartDoorInteraction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDoorInteractionType                    DoorInteractionType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_StartDoorInteraction(class ARBDoor* Door, EDoorInteractionType DoorInteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_StartDoorInteraction");

	Params::RBPawn_Multicast_StartDoorInteraction Parms{};

	Parms.Door = Door;
	Parms.DoorInteractionType = DoorInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_StartPairedMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Param_PairedPawn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpecialMoveMulticastData        SpecialMoveData                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPairedPawnIsLeader                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBasicDirection                         Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_StartPairedMove(class ARBPawn* Param_PairedPawn, const struct FSpecialMoveMulticastData& SpecialMoveData, bool bPairedPawnIsLeader, EBasicDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_StartPairedMove");

	Params::RBPawn_Multicast_StartPairedMove Parms{};

	Parms.Param_PairedPawn = Param_PairedPawn;
	Parms.SpecialMoveData = std::move(SpecialMoveData);
	Parms.bPairedPawnIsLeader = bPairedPawnIsLeader;
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_StartScriptedAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBAnimRef                       Animation                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ScriptedAttachName                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param_ScriptedAttachActor                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ScriptedAttachOffset                                   (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_StartScriptedAnimation(const struct FVector& Location, const struct FVector& Forward, const struct FRBAnimRef& Animation, const class FName& ScriptedAttachName, class AActor* Param_ScriptedAttachActor, const struct FTransform& ScriptedAttachOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_StartScriptedAnimation");

	Params::RBPawn_Multicast_StartScriptedAnimation Parms{};

	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);
	Parms.Animation = std::move(Animation);
	Parms.ScriptedAttachName = ScriptedAttachName;
	Parms.Param_ScriptedAttachActor = Param_ScriptedAttachActor;
	Parms.ScriptedAttachOffset = std::move(ScriptedAttachOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_StartSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FSpecialMoveMulticastData        SpecialMoveData                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_StartSpecialMove(const struct FSpecialMoveMulticastData& SpecialMoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_StartSpecialMove");

	Params::RBPawn_Multicast_StartSpecialMove Parms{};

	Parms.SpecialMoveData = std::move(SpecialMoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_SwitchLocomotionMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ELocomotionMode                         NewLocomotionMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_SwitchLocomotionMode(ELocomotionMode NewLocomotionMode, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_SwitchLocomotionMode");

	Params::RBPawn_Multicast_SwitchLocomotionMode Parms{};

	Parms.NewLocomotionMode = NewLocomotionMode;
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Multicast_TraversalSlideDone
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bHitWall                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Multicast_TraversalSlideDone(bool bHitWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Multicast_TraversalSlideDone");

	Params::RBPawn_Multicast_TraversalSlideDone Parms{};

	Parms.bHitWall = bHitWall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnCurrentInteractableChangedCallback
// (Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::OnCurrentInteractableChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnCurrentInteractableChangedCallback");

	Params::RBPawn_OnCurrentInteractableChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnDamageVolumeHit
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBPawn::OnDamageVolumeHit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnDamageVolumeHit");

	Params::RBPawn_OnDamageVolumeHit Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnFootstep
// (Native, Public)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeftFoot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::OnFootstep(class USkeletalMeshComponent* MeshComp, bool bLeftFoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnFootstep");

	Params::RBPawn_OnFootstep Parms{};

	Parms.MeshComp = MeshComp;
	Parms.bLeftFoot = bLeftFoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_CurrentInteractable
// (Final, Native, Public)

void ARBPawn::OnRep_CurrentInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_CurrentInteractable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_Health
// (Final, Native, Public)
// Parameters:
// int32                                   OldHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::OnRep_Health(int32 OldHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_Health");

	Params::RBPawn_OnRep_Health Parms{};

	Parms.OldHealth = OldHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_InDarkness
// (Final, Native, Public)

void ARBPawn::OnRep_InDarkness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_InDarkness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_LocomotionMode
// (Final, Native, Public)

void ARBPawn::OnRep_LocomotionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_LocomotionMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_LocomotionMode_Callback
// (Final, Native, Public)

void ARBPawn::OnRep_LocomotionMode_Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_LocomotionMode_Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_PairedPawn
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          OldPairedPawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::OnRep_PairedPawn(class ARBPawn* OldPairedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_PairedPawn");

	Params::RBPawn_OnRep_PairedPawn Parms{};

	Parms.OldPairedPawn = OldPairedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_Repulsion
// (Final, Native, Public)

void ARBPawn::OnRep_Repulsion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_Repulsion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.OnRep_SlideFinished
// (Final, Native, Public)

void ARBPawn::OnRep_SlideFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "OnRep_SlideFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.PostCharacterMeshPoseUpdate
// (Native, Public)

void ARBPawn::PostCharacterMeshPoseUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "PostCharacterMeshPoseUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.RemoveForcedDarknessSource_Server
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::RemoveForcedDarknessSource_Server(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "RemoveForcedDarknessSource_Server");

	Params::RBPawn_RemoveForcedDarknessSource_Server Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Server_ResetPawn
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPawn::Server_ResetPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Server_ResetPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.Server_SetFinishedGhostReason
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EGhostFinishReason                      FinishReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomFinishReason                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::Server_SetFinishedGhostReason(EGhostFinishReason FinishReason, int32 CustomFinishReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "Server_SetFinishedGhostReason");

	Params::RBPawn_Server_SetFinishedGhostReason Parms{};

	Parms.FinishReason = FinishReason;
	Parms.CustomFinishReason = CustomFinishReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.SetImmobileTickOptimsActiveCallback
// (Final, Native, Private)

void ARBPawn::SetImmobileTickOptimsActiveCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "SetImmobileTickOptimsActiveCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.SpecialMoveNotify
// (Native, Public)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAnimNotify_SpecialMove*        AnimNotify                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::SpecialMoveNotify(class USkeletalMeshComponent* MeshComp, class URBAnimNotify_SpecialMove* AnimNotify, class UAnimSequenceBase* AnimationSequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "SpecialMoveNotify");

	Params::RBPawn_SpecialMoveNotify Parms{};

	Parms.MeshComp = MeshComp;
	Parms.AnimNotify = AnimNotify;
	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.StartGhostAnimState
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URBGhostAnimInstance> AnimInstanceClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::StartGhostAnimState(TSubclassOf<class URBGhostAnimInstance> AnimInstanceClass, float blendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "StartGhostAnimState");

	Params::RBPawn_StartGhostAnimState Parms{};

	Parms.AnimInstanceClass = AnimInstanceClass;
	Parms.blendTime = blendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.StopGhostAnimState
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   blendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::StopGhostAnimState(float blendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "StopGhostAnimState");

	Params::RBPawn_StopGhostAnimState Parms{};

	Parms.blendTime = blendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.TraversalNotify
// (Native, Public)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAnimNotify_Traversal*          AnimNotify                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPawn::TraversalNotify(class USkeletalMeshComponent* MeshComp, class URBAnimNotify_Traversal* AnimNotify, class UAnimSequenceBase* AnimationSequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "TraversalNotify");

	Params::RBPawn_TraversalNotify Parms{};

	Parms.MeshComp = MeshComp;
	Parms.AnimNotify = AnimNotify;
	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawn.TryPlayFacialAnim_Pawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::TryPlayFacialAnim_Pawn(const class FString& LineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "TryPlayFacialAnim_Pawn");

	Params::RBPawn_TryPlayFacialAnim_Pawn Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetCurrentARBInteractible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBInteractible*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBInteractible* ARBPawn::BP_GetCurrentARBInteractible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetCurrentARBInteractible");

	Params::RBPawn_BP_GetCurrentARBInteractible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetCurrentInteractibleActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBPawn::BP_GetCurrentInteractibleActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetCurrentInteractibleActor");

	Params::RBPawn_BP_GetCurrentInteractibleActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetDebugPawnName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBPawn::BP_GetDebugPawnName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetDebugPawnName");

	Params::RBPawn_BP_GetDebugPawnName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPawn::BP_GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetMaxHealth");

	Params::RBPawn_BP_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetPawnTargetForward
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBPawn::BP_GetPawnTargetForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetPawnTargetForward");

	Params::RBPawn_BP_GetPawnTargetForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetPawnTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBPawn::BP_GetPawnTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetPawnTargetLocation");

	Params::RBPawn_BP_GetPawnTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetRandomSelector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPawn::BP_GetRandomSelector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetRandomSelector");

	Params::RBPawn_BP_GetRandomSelector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetSpecialMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpecialMove                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpecialMove ARBPawn::BP_GetSpecialMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetSpecialMove");

	Params::RBPawn_BP_GetSpecialMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_GetSpecialMoveSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ARBPawn::BP_GetSpecialMoveSubtype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_GetSpecialMoveSubtype");

	Params::RBPawn_BP_GetSpecialMoveSubtype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_IsConsideredCrouched
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::BP_IsConsideredCrouched() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_IsConsideredCrouched");

	Params::RBPawn_BP_IsConsideredCrouched Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_IsDoingSpecialMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::BP_IsDoingSpecialMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_IsDoingSpecialMove");

	Params::RBPawn_BP_IsDoingSpecialMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.BP_IsInFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::BP_IsInFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "BP_IsInFirstPerson");

	Params::RBPawn_BP_IsInFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.GetAnimInstance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBAnimInstance*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBAnimInstance* ARBPawn::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GetAnimInstance");

	Params::RBPawn_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.GetCarriedLargePickup
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBLargePickup*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLargePickup* ARBPawn::GetCarriedLargePickup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GetCarriedLargePickup");

	Params::RBPawn_GetCarriedLargePickup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.GetFaceFXSkeletalMeshComponentWithLineId
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARBPawn::GetFaceFXSkeletalMeshComponentWithLineId(const class FString& LineId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GetFaceFXSkeletalMeshComponentWithLineId");

	Params::RBPawn_GetFaceFXSkeletalMeshComponentWithLineId Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.GetGhostAnimBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBGhostAnimInstance*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGhostAnimInstance* ARBPawn::GetGhostAnimBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "GetGhostAnimBP");

	Params::RBPawn_GetGhostAnimBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.HasGhostAnimActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::HasGhostAnimActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "HasGhostAnimActive");

	Params::RBPawn_HasGhostAnimActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.HasRecentlyBeenSpawned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::HasRecentlyBeenSpawned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "HasRecentlyBeenSpawned");

	Params::RBPawn_HasRecentlyBeenSpawned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.IsCarryingLargePickup
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::IsCarryingLargePickup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "IsCarryingLargePickup");

	Params::RBPawn_IsCarryingLargePickup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.IsConsideredDead
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::IsConsideredDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "IsConsideredDead");

	Params::RBPawn_IsConsideredDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawn.IsRunning
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPawn::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawn", "IsRunning");

	Params::RBPawn_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.BP_DamageNPC
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EDamageType                             DmgType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DmgAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanKill                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanKnockdown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::BP_DamageNPC(EDamageType DmgType, class AActor* SrcActor, float DmgAmount, bool bCanKill, bool bCanKnockdown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_DamageNPC");

	Params::RBNPC_BP_DamageNPC Parms{};

	Parms.DmgType = DmgType;
	Parms.SrcActor = SrcActor;
	Parms.DmgAmount = DmgAmount;
	Parms.bCanKill = bCanKill;
	Parms.bCanKnockdown = bCanKnockdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.BP_OnCharacterAssembled
// (Final, Native, Public, BlueprintCallable)

void ARBNPC::BP_OnCharacterAssembled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_OnCharacterAssembled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.BP_SetVoiceType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_VoiceType                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::BP_SetVoiceType(const class FString& Param_VoiceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_SetVoiceType");

	Params::RBNPC_BP_SetVoiceType Parms{};

	Parms.Param_VoiceType = std::move(Param_VoiceType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.BP_TeleportTo
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DestLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::BP_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_TeleportTo");

	Params::RBNPC_BP_TeleportTo Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.BP_TestHitReaction
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ENPCHitReactionType                     HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::BP_TestHitReaction(ENPCHitReactionType HitReactionType, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_TestHitReaction");

	Params::RBNPC_BP_TestHitReaction Parms{};

	Parms.HitReactionType = HitReactionType;
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Event_OnAIEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// EAIEvent                                EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           RelevantActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnAIEvent(EAIEvent EventType, class AActor* RelevantActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnAIEvent");

	Params::RBNPC_Event_OnAIEvent Parms{};

	Parms.EventType = EventType;
	Parms.RelevantActor = RelevantActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnDealtUnarmedDamage
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          OtherPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DamageSourceBone                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnDealtUnarmedDamage(class ARBPawn* OtherPawn, class FName DamageSourceBone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnDealtUnarmedDamage");

	Params::RBNPC_Event_OnDealtUnarmedDamage Parms{};

	Parms.OtherPawn = OtherPawn;
	Parms.DamageSourceBone = DamageSourceBone;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnDealtWeaponDamage
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class ARBPawn*                          OtherPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DamageLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnDealtWeaponDamage(class ARBPawn* OtherPawn, const struct FVector& DamageLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnDealtWeaponDamage");

	Params::RBNPC_Event_OnDealtWeaponDamage Parms{};

	Parms.OtherPawn = OtherPawn;
	Parms.DamageLocation = std::move(DamageLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnEndBlindPaintState
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnEndBlindPaintState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnEndBlindPaintState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnEndGrenadeStun
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnEndGrenadeStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnEndGrenadeStun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnHeadBoom
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnHeadBoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnHeadBoom");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnScreamerSonicStun
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HeadLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnScreamerSonicStun(const struct FVector& HeadLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnScreamerSonicStun");

	Params::RBNPC_Event_OnScreamerSonicStun Parms{};

	Parms.HeadLocation = std::move(HeadLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnSpectreIntroSpecialMoveStarted
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnSpectreIntroSpecialMoveStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnSpectreIntroSpecialMoveStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnSpectreOutroSpecialMoveStarted
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnSpectreOutroSpecialMoveStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnSpectreOutroSpecialMoveStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnSpectreVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldBeVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnSpectreVisibilityChanged(bool bShouldBeVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnSpectreVisibilityChanged");

	Params::RBNPC_Event_OnSpectreVisibilityChanged Parms{};

	Parms.bShouldBeVisible = bShouldBeVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnSpectreVisualTypeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EAISpectreVisualType                    OldType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAISpectreVisualType                    NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnSpectreVisualTypeChanged(EAISpectreVisualType OldType, EAISpectreVisualType NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnSpectreVisualTypeChanged");

	Params::RBNPC_Event_OnSpectreVisualTypeChanged Parms{};

	Parms.OldType = OldType;
	Parms.NewType = NewType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnStartBlindPaintState
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnStartBlindPaintState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnStartBlindPaintState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnStartGrenadeStun
// (Event, Public, BlueprintEvent)

void ARBNPC::Event_OnStartGrenadeStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnStartGrenadeStun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPC.Event_OnStartPusherAttack
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnStartPusherAttack(class ARBPlayer* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnStartPusherAttack");

	Params::RBNPC_Event_OnStartPusherAttack Parms{};

	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnWeaponHidden
// (Event, Public, BlueprintEvent)
// Parameters:
// ENPCWeapon                              WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPCWeapon*                     WeaponActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnWeaponHidden(ENPCWeapon WeaponType, class ARBNPCWeapon* WeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnWeaponHidden");

	Params::RBNPC_Event_OnWeaponHidden Parms{};

	Parms.WeaponType = WeaponType;
	Parms.WeaponActor = WeaponActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_OnWeaponVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// ENPCWeapon                              WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPCWeapon*                     WeaponActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Event_OnWeaponVisible(ENPCWeapon WeaponType, class ARBNPCWeapon* WeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_OnWeaponVisible");

	Params::RBNPC_Event_OnWeaponVisible Parms{};

	Parms.WeaponType = WeaponType;
	Parms.WeaponActor = WeaponActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.Event_PlayHitReactionEffects
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          AttackLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EffectRotation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Event_PlayHitReactionEffects(const struct FVector& AttackLoc, const struct FRotator& EffectRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Event_PlayHitReactionEffects");

	Params::RBNPC_Event_PlayHitReactionEffects Parms{};

	Parms.AttackLoc = std::move(AttackLoc);
	Parms.EffectRotation = std::move(EffectRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNPC.GetAmbientStationComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBAmbientStationComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBAmbientStationComponent* ARBNPC::GetAmbientStationComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "GetAmbientStationComponent");

	Params::RBNPC_GetAmbientStationComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.Multicast_AlignToMark
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          AlignPos                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AlignYaw                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_AlignToMark(const struct FVector& AlignPos, float AlignYaw, float blendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_AlignToMark");

	Params::RBNPC_Multicast_AlignToMark Parms{};

	Parms.AlignPos = std::move(AlignPos);
	Parms.AlignYaw = AlignYaw;
	Parms.blendTime = blendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_AnimatedStart
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCAnimatedStartData            StartData                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_AnimatedStart(const struct FNPCAnimatedStartData& StartData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_AnimatedStart");

	Params::RBNPC_Multicast_AnimatedStart Parms{};

	Parms.StartData = std::move(StartData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_AnimatedStop
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCAnimatedStopData             StopData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_AnimatedStop(const struct FNPCAnimatedStopData& StopData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_AnimatedStop");

	Params::RBNPC_Multicast_AnimatedStop Parms{};

	Parms.StopData = std::move(StopData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_CompleteNPCSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            SpecialMoveCompleted                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpecialMoveEndVelocityOverride                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_CompleteNPCSpecialMove(ESpecialMove SpecialMoveCompleted, float SpecialMoveEndVelocityOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_CompleteNPCSpecialMove");

	Params::RBNPC_Multicast_CompleteNPCSpecialMove Parms{};

	Parms.SpecialMoveCompleted = SpecialMoveCompleted;
	Parms.SpecialMoveEndVelocityOverride = SpecialMoveEndVelocityOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_CycleBreaker
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ENPCAnimStyle                           breakerAnimStyle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomSelector                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_CycleBreaker(ENPCAnimStyle breakerAnimStyle, int32 RandomSelector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_CycleBreaker");

	Params::RBNPC_Multicast_CycleBreaker Parms{};

	Parms.breakerAnimStyle = breakerAnimStyle;
	Parms.RandomSelector = RandomSelector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_DoorInvestigate
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCDoorInvestigationParams      Param_DoorInvParams                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_DoorInvestigate(const struct FNPCDoorInvestigationParams& Param_DoorInvParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_DoorInvestigate");

	Params::RBNPC_Multicast_DoorInvestigate Parms{};

	Parms.Param_DoorInvParams = std::move(Param_DoorInvParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_DoorPass
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCDoorInteractionData          DoorPass                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_DoorPass(const struct FNPCDoorInteractionData& DoorPass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_DoorPass");

	Params::RBNPC_Multicast_DoorPass Parms{};

	Parms.DoorPass = std::move(DoorPass);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterAmbientStation
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class URBAmbientStationComponent*       AmbientStation                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EntryLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EntryForward                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_EnterAmbientStation(class URBAmbientStationComponent* AmbientStation, bool bImmediate, const struct FVector& EntryLocation, const struct FVector& EntryForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterAmbientStation");

	Params::RBNPC_Multicast_EnterAmbientStation Parms{};

	Parms.AmbientStation = AmbientStation;
	Parms.bImmediate = bImmediate;
	Parms.EntryLocation = std::move(EntryLocation);
	Parms.EntryForward = std::move(EntryForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterBlindPaintState
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// float                                   RelYawToPaint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartDir                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_EnterBlindPaintState(float RelYawToPaint, const struct FVector& StartLocation, const struct FVector& StartDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterBlindPaintState");

	Params::RBNPC_Multicast_EnterBlindPaintState Parms{};

	Parms.RelYawToPaint = RelYawToPaint;
	Parms.StartLocation = std::move(StartLocation);
	Parms.StartDir = std::move(StartDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterGrenadeStun
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// float                                   StunDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_EnterGrenadeStun(float StunDuration, const struct FVector& Location, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterGrenadeStun");

	Params::RBNPC_Multicast_EnterGrenadeStun Parms{};

	Parms.StunDuration = StunDuration;
	Parms.Location = std::move(Location);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterGroundAndPoundAttacker
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    EnterGnPAnimSeq                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_EnterGroundAndPoundAttacker(class ARBPawn* Victim, const struct FVector& TargetPos, const struct FVector& TargetDir, class UAnimSequence* EnterGnPAnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterGroundAndPoundAttacker");

	Params::RBNPC_Multicast_EnterGroundAndPoundAttacker Parms{};

	Parms.Victim = Victim;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);
	Parms.EnterGnPAnimSeq = EnterGnPAnimSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterHealSlowdownState
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBNPC::Multicast_EnterHealSlowdownState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterHealSlowdownState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_EnterMonsterCloset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBMonsterCloset*                 Closet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_EnterMonsterCloset(class ARBMonsterCloset* Closet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_EnterMonsterCloset");

	Params::RBNPC_Multicast_EnterMonsterCloset Parms{};

	Parms.Closet = Closet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_ExitGrenadeStun
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_ExitGrenadeStun(const struct FVector& Location, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_ExitGrenadeStun");

	Params::RBNPC_Multicast_ExitGrenadeStun Parms{};

	Parms.Location = std::move(Location);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_ExitMonsterCloset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBMonsterCloset*                 Closet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_ExitMonsterCloset(class ARBMonsterCloset* Closet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_ExitMonsterCloset");

	Params::RBNPC_Multicast_ExitMonsterCloset Parms{};

	Parms.Closet = Closet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_GroundAndPoundInterrupted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        PinnedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NpcToInterrupterRelativeYaw                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_GroundAndPoundInterrupted(class ARBPlayer* PinnedPlayer, float NpcToInterrupterRelativeYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_GroundAndPoundInterrupted");

	Params::RBNPC_Multicast_GroundAndPoundInterrupted Parms{};

	Parms.PinnedPlayer = PinnedPlayer;
	Parms.NpcToInterrupterRelativeYaw = NpcToInterrupterRelativeYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_GroundAndPoundPlayerEscape
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        EscapingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    PouncerAnim                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    PlayerAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBThrowableWeapon*               EscapeItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_GroundAndPoundPlayerEscape(class ARBPlayer* EscapingPlayer, class UAnimSequence* PouncerAnim, class UAnimSequence* PlayerAnim, class ARBThrowableWeapon* EscapeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_GroundAndPoundPlayerEscape");

	Params::RBNPC_Multicast_GroundAndPoundPlayerEscape Parms{};

	Parms.EscapingPlayer = EscapingPlayer;
	Parms.PouncerAnim = PouncerAnim;
	Parms.PlayerAnim = PlayerAnim;
	Parms.EscapeItem = EscapeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_InterruptHidespotPeeking
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBNPC::Multicast_InterruptHidespotPeeking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_InterruptHidespotPeeking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_OnDealtUnarmedDamage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          OtherPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DamageSourceBone                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_OnDealtUnarmedDamage(class ARBPawn* OtherPawn, class FName DamageSourceBone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_OnDealtUnarmedDamage");

	Params::RBNPC_Multicast_OnDealtUnarmedDamage Parms{};

	Parms.OtherPawn = OtherPawn;
	Parms.DamageSourceBone = DamageSourceBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_OnDealtWeaponDamage
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          OtherPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DamageLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_OnDealtWeaponDamage(class ARBPawn* OtherPawn, const struct FVector& DamageLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_OnDealtWeaponDamage");

	Params::RBNPC_Multicast_OnDealtWeaponDamage Parms{};

	Parms.OtherPawn = OtherPawn;
	Parms.DamageLocation = std::move(DamageLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_OnFinishedExitingMonsterCloset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBMonsterCloset*                 Closet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayVO                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_OnFinishedExitingMonsterCloset(class ARBMonsterCloset* Closet, bool bPlayVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_OnFinishedExitingMonsterCloset");

	Params::RBNPC_Multicast_OnFinishedExitingMonsterCloset Parms{};

	Parms.Closet = Closet;
	Parms.bPlayVO = bPlayVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_OverrideAnimRefs
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URBAnimReferences*                OverrideAnimRefs                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_OverrideAnimRefs(class URBAnimReferences* OverrideAnimRefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_OverrideAnimRefs");

	Params::RBNPC_Multicast_OverrideAnimRefs Parms{};

	Parms.OverrideAnimRefs = OverrideAnimRefs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PerformStandardFatality
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FStandardFatalityData            FatalityData                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PerformStandardFatality(const struct FStandardFatalityData& FatalityData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PerformStandardFatality");

	Params::RBNPC_Multicast_PerformStandardFatality Parms{};

	Parms.FatalityData = std::move(FatalityData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayAmbientStationExitAnim
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayAmbientStationExitAnim(class UAnimSequence* AnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayAmbientStationExitAnim");

	Params::RBNPC_Multicast_PlayAmbientStationExitAnim Parms{};

	Parms.AnimSeq = AnimSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayGrab
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FPairedTwoPhaseAnimData          AnimData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ARBPlayer*                        GrabbedPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayGrab(const struct FPairedTwoPhaseAnimData& AnimData, class ARBPlayer* GrabbedPlayer, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayGrab");

	Params::RBNPC_Multicast_PlayGrab Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.GrabbedPlayer = GrabbedPlayer;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayNPCHitReaction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCHitReactionParams            Params_0                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayNPCHitReaction(const struct FNPCHitReactionParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayNPCHitReaction");

	Params::RBNPC_Multicast_PlayNPCHitReaction Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayPullFromHidespot
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FPairedTwoPhaseAnimData          AnimData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ARBPlayer*                        GrabbedPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBHidespotComponent*             Hidespot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayPullFromHidespot(const struct FPairedTwoPhaseAnimData& AnimData, class ARBPlayer* GrabbedPlayer, class URBHidespotComponent* Hidespot, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayPullFromHidespot");

	Params::RBNPC_Multicast_PlayPullFromHidespot Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.GrabbedPlayer = GrabbedPlayer;
	Parms.Hidespot = Hidespot;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlaySingleShotAnim
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlaySingleShotAnim(class UAnimSequence* AnimSeq, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlaySingleShotAnim");

	Params::RBNPC_Multicast_PlaySingleShotAnim Parms{};

	Parms.AnimSeq = AnimSeq;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayStartled
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCStartleData                  StartleData                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayStartled(const struct FNPCStartleData& StartleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayStartled");

	Params::RBNPC_Multicast_PlayStartled Parms{};

	Parms.StartleData = std::move(StartleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayWaypointAnim
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoopAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayWaypointAnim(class UAnimSequence* AnimSeq, bool bLoopAnim, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayWaypointAnim");

	Params::RBNPC_Multicast_PlayWaypointAnim Parms{};

	Parms.AnimSeq = AnimSeq;
	Parms.bLoopAnim = bLoopAnim;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_PlayWeaponImpactParticles
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// TArray<struct FVector>                  ImpactPoints                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         ImpactRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_PlayWeaponImpactParticles(const TArray<struct FVector>& ImpactPoints, const struct FRotator& ImpactRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_PlayWeaponImpactParticles");

	Params::RBNPC_Multicast_PlayWeaponImpactParticles Parms{};

	Parms.ImpactPoints = std::move(ImpactPoints);
	Parms.ImpactRotation = std::move(ImpactRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_SetBlindPaintStateStyle
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bAgitated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_SetBlindPaintStateStyle(bool bAgitated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_SetBlindPaintStateStyle");

	Params::RBNPC_Multicast_SetBlindPaintStateStyle Parms{};

	Parms.bAgitated = bAgitated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_SleeperDisturbed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_SleeperDisturbed(class UAnimSequence* AnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_SleeperDisturbed");

	Params::RBNPC_Multicast_SleeperDisturbed Parms{};

	Parms.AnimSeq = AnimSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_SleeperScream
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAnimSequence*                    AnimSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoScream                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreamDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_SleeperScream(class UAnimSequence* AnimSeq, bool bNoScream, float ScreamDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_SleeperScream");

	Params::RBNPC_Multicast_SleeperScream Parms{};

	Parms.AnimSeq = AnimSeq;
	Parms.bNoScream = bNoScream;
	Parms.ScreamDuration = ScreamDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartAttackMove
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          StartPos                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartDir                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNPCAttackParams                 Param_AttackParams                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartAttackMove(const struct FVector& StartPos, const struct FVector& StartDir, const struct FNPCAttackParams& Param_AttackParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartAttackMove");

	Params::RBNPC_Multicast_StartAttackMove Parms{};

	Parms.StartPos = std::move(StartPos);
	Parms.StartDir = std::move(StartDir);
	Parms.Param_AttackParams = std::move(Param_AttackParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartFixedDurationSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            SpecialMoveType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpirationServerTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartFixedDurationSpecialMove(ESpecialMove SpecialMoveType, float ExpirationServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartFixedDurationSpecialMove");

	Params::RBNPC_Multicast_StartFixedDurationSpecialMove Parms{};

	Parms.SpecialMoveType = SpecialMoveType;
	Parms.ExpirationServerTime = ExpirationServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartHidespotPeeking
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URBHidespotComponent*             Hidespot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    PeekingAnim                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartHidespotPeeking(class URBHidespotComponent* Hidespot, class UAnimSequence* PeekingAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartHidespotPeeking");

	Params::RBNPC_Multicast_StartHidespotPeeking Parms{};

	Parms.Hidespot = Hidespot;
	Parms.PeekingAnim = PeekingAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartInvestigationAction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCInvestigationData            Param_InvestigationData                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartInvestigationAction(const struct FNPCInvestigationData& Param_InvestigationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartInvestigationAction");

	Params::RBNPC_Multicast_StartInvestigationAction Parms{};

	Parms.Param_InvestigationData = std::move(Param_InvestigationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartRelativeYawSpecialMove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            RelYawSpecialMove                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RelativeYaw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartRelativeYawSpecialMove(ESpecialMove RelYawSpecialMove, float RelativeYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartRelativeYawSpecialMove");

	Params::RBNPC_Multicast_StartRelativeYawSpecialMove Parms{};

	Parms.RelYawSpecialMove = RelYawSpecialMove;
	Parms.RelativeYaw = RelativeYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartSabotageAction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UObject*                          SabotageInteractableTarget                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartSabotageAction(class UObject* SabotageInteractableTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartSabotageAction");

	Params::RBNPC_Multicast_StartSabotageAction Parms{};

	Parms.SabotageInteractableTarget = SabotageInteractableTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartSpecialMoveOrientedToActor
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            SpecialMoveType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartSpecialMoveOrientedToActor(ESpecialMove SpecialMoveType, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartSpecialMoveOrientedToActor");

	Params::RBNPC_Multicast_StartSpecialMoveOrientedToActor Parms{};

	Parms.SpecialMoveType = SpecialMoveType;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_StartTurnOnSpot
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCTurnOnSpotData               Param_TurnOnSpot                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_StartTurnOnSpot(const struct FNPCTurnOnSpotData& Param_TurnOnSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_StartTurnOnSpot");

	Params::RBNPC_Multicast_StartTurnOnSpot Parms{};

	Parms.Param_TurnOnSpot = std::move(Param_TurnOnSpot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_TeleportTo
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          DestLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestRotation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_TeleportTo");

	Params::RBNPC_Multicast_TeleportTo Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_TraversalMoveStarted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FTraversalMoveData               MoveData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_TraversalMoveStarted(const struct FTraversalMoveData& MoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_TraversalMoveStarted");

	Params::RBNPC_Multicast_TraversalMoveStarted Parms{};

	Parms.MoveData = std::move(MoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_TriggerContextualVO
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EVOContext                              VOContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_TriggerContextualVO(EVOContext VOContext, uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_TriggerContextualVO");

	Params::RBNPC_Multicast_TriggerContextualVO Parms{};

	Parms.VOContext = VOContext;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_TriggerScriptedVO
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAkAudioEvent*                    AudioEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_TriggerScriptedVO(class UAkAudioEvent* AudioEvent, EVOPriority VOPriority, uint32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_TriggerScriptedVO");

	Params::RBNPC_Multicast_TriggerScriptedVO Parms{};

	Parms.AudioEvent = AudioEvent;
	Parms.VOPriority = VOPriority;
	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.Multicast_UpdateReplicatedNPCConfig
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FNPCReplicatedConfig             ConfigData                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBNPC::Multicast_UpdateReplicatedNPCConfig(const struct FNPCReplicatedConfig& ConfigData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "Multicast_UpdateReplicatedNPCConfig");

	Params::RBNPC_Multicast_UpdateReplicatedNPCConfig Parms{};

	Parms.ConfigData = std::move(ConfigData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnCanShowSpectreChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::OnCanShowSpectreChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnCanShowSpectreChangedCallback");

	Params::RBNPC_OnCanShowSpectreChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnPlayingFullBodyIdleBreakerStateChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bPlayingFullBodyIdleBreaker                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPC::OnPlayingFullBodyIdleBreakerStateChanged(bool bPlayingFullBodyIdleBreaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnPlayingFullBodyIdleBreakerStateChanged");

	Params::RBNPC_OnPlayingFullBodyIdleBreakerStateChanged Parms{};

	Parms.bPlayingFullBodyIdleBreaker = bPlayingFullBodyIdleBreaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_AffectedByBlindPaint
// (Final, Native, Public)

void ARBNPC::OnRep_AffectedByBlindPaint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_AffectedByBlindPaint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_AffectedByGrenadeStun
// (Final, Native, Public)

void ARBNPC::OnRep_AffectedByGrenadeStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_AffectedByGrenadeStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_AllowPlayerPing
// (Final, Native, Public)

void ARBNPC::OnRep_AllowPlayerPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_AllowPlayerPing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_AmbientIdle
// (Final, Native, Public)

void ARBNPC::OnRep_AmbientIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_AmbientIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_CanShowSpectre
// (Final, Native, Public)

void ARBNPC::OnRep_CanShowSpectre()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_CanShowSpectre");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_PreparedFatalityAnimData
// (Final, Native, Public)

void ARBNPC::OnRep_PreparedFatalityAnimData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_PreparedFatalityAnimData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_ScriptedAnim
// (Final, Native, Public)

void ARBNPC::OnRep_ScriptedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_ScriptedAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_VariatorVOMappingOverridesRef
// (Final, Native, Private)

void ARBNPC::OnRep_VariatorVOMappingOverridesRef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_VariatorVOMappingOverridesRef");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.OnRep_VoiceType
// (Final, Native, Public)

void ARBNPC::OnRep_VoiceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "OnRep_VoiceType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.SetupEditorAudioState
// (Final, Native, Public)

void ARBNPC::SetupEditorAudioState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "SetupEditorAudioState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPC.BP_GetWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBNPCWeapon*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBNPCWeapon* ARBNPC::BP_GetWeaponActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "BP_GetWeaponActor");

	Params::RBNPC_BP_GetWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.CanTriggerSoundTraps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::CanTriggerSoundTraps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "CanTriggerSoundTraps");

	Params::RBNPC_CanTriggerSoundTraps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.GetAttachedScriptedAnimStation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBScriptedAnimStation*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBScriptedAnimStation* ARBNPC::GetAttachedScriptedAnimStation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "GetAttachedScriptedAnimStation");

	Params::RBNPC_GetAttachedScriptedAnimStation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.GetFoleySwitchOverride
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARBNPC::GetFoleySwitchOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "GetFoleySwitchOverride");

	Params::RBNPC_GetFoleySwitchOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.GetWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCWeapon                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCWeapon ARBNPC::GetWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "GetWeaponType");

	Params::RBNPC_GetWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.HasDoneGoryDeath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::HasDoneGoryDeath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "HasDoneGoryDeath");

	Params::RBNPC_HasDoneGoryDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.IsAHiddenSpectre
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::IsAHiddenSpectre() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "IsAHiddenSpectre");

	Params::RBNPC_IsAHiddenSpectre Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.IsForcedCustomizationFemale
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::IsForcedCustomizationFemale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "IsForcedCustomizationFemale");

	Params::RBNPC_IsForcedCustomizationFemale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.IsForcedCustomizationSex
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::IsForcedCustomizationSex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "IsForcedCustomizationSex");

	Params::RBNPC_IsForcedCustomizationSex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.IsLocalSpectre
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::IsLocalSpectre() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "IsLocalSpectre");

	Params::RBNPC_IsLocalSpectre Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPC.IsUsingConfigVoiceType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNPC::IsUsingConfigVoiceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPC", "IsUsingConfigVoiceType");

	Params::RBNPC_IsUsingConfigVoiceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlacklight.Event_SetupPPVolume
// (Event, Protected, BlueprintEvent)

void ARBBlacklight::Event_SetupPPVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlacklight", "Event_SetupPPVolume");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBlacklight.RegisterBlacklightableActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBlacklight::RegisterBlacklightableActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlacklight", "RegisterBlacklightableActor");

	Params::RBBlacklight_RegisterBlacklightableActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlacklight.UnregisterBlacklightableActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBlacklight::UnregisterBlacklightableActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlacklight", "UnregisterBlacklightableActor");

	Params::RBBlacklight_UnregisterBlacklightableActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMainMenuPlayerController.FindHub
// (Final, Native, Public, BlueprintCallable)

void ARBMainMenuPlayerController::FindHub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMainMenuPlayerController", "FindHub");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMainMenuPlayerController.FindTutorialServer
// (Final, Native, Public, BlueprintCallable)

void ARBMainMenuPlayerController::FindTutorialServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMainMenuPlayerController", "FindTutorialServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMainMenuPlayerController.IsCrossplayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMainMenuPlayerController::IsCrossplayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMainMenuPlayerController", "IsCrossplayEnabled");

	Params::RBMainMenuPlayerController_IsCrossplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockable.GetBlockableState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBlockableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlockableState IRBBlockable::GetBlockableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockable", "GetBlockableState");

	Params::RBBlockable_GetBlockableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockingVolume.DisableBlockingVolume
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBlockingVolume::DisableBlockingVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "DisableBlockingVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlockingVolume.EnableBlockingVolume
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBBlockingVolume::EnableBlockingVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "EnableBlockingVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlockingVolume.OnRep_PropertyChanged
// (Final, Native, Private)

void ARBBlockingVolume::OnRep_PropertyChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "OnRep_PropertyChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlockingVolume.SetBlockingState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewBlockNPCs                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewBlockPlayers                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBlockingVolume::SetBlockingState(bool bNewBlockNPCs, bool bNewBlockPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "SetBlockingState");

	Params::RBBlockingVolume_SetBlockingState Parms{};

	Parms.bNewBlockNPCs = bNewBlockNPCs;
	Parms.bNewBlockPlayers = bNewBlockPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlockingVolume.GetBlockInteractions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBlockingVolume::GetBlockInteractions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "GetBlockInteractions");

	Params::RBBlockingVolume_GetBlockInteractions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockingVolume.GetBlockNPCs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBlockingVolume::GetBlockNPCs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "GetBlockNPCs");

	Params::RBBlockingVolume_GetBlockNPCs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockingVolume.GetBlockPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBlockingVolume::GetBlockPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "GetBlockPlayers");

	Params::RBBlockingVolume_GetBlockPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockingVolume.GetBlockVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBlockingVolume::GetBlockVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "GetBlockVisibility");

	Params::RBBlockingVolume_GetBlockVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlockingVolume.GetEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBlockingVolume::GetEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBlockingVolume", "GetEnabled");

	Params::RBBlockingVolume_GetEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBToasterDetector.BP_ClearExternalAlertedStateActions
// (Final, Native, Public, BlueprintCallable)

void ARBToasterDetector::BP_ClearExternalAlertedStateActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToasterDetector", "BP_ClearExternalAlertedStateActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToasterDetector.BP_SetExternalAlertedStateActions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAlertedStateActions             InAlertedStateActions                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBToasterDetector::BP_SetExternalAlertedStateActions(const struct FAlertedStateActions& InAlertedStateActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToasterDetector", "BP_SetExternalAlertedStateActions");

	Params::RBToasterDetector_BP_SetExternalAlertedStateActions Parms{};

	Parms.InAlertedStateActions = std::move(InAlertedStateActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToasterDetector.BP_GetAllLinkedTriggerables
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBTriggerable*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBTriggerable*> ARBToasterDetector::BP_GetAllLinkedTriggerables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToasterDetector", "BP_GetAllLinkedTriggerables");

	Params::RBToasterDetector_BP_GetAllLinkedTriggerables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.ActivateStageExitSAS
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ActivateStageExitSAS(ETeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ActivateStageExitSAS");

	Params::RBBlueprintLibrary_ActivateStageExitSAS Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.AddActorTagToSelectedActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::AddActorTagToSelectedActors(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AddActorTagToSelectedActors");

	Params::RBBlueprintLibrary_AddActorTagToSelectedActors Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.AddRandomizeRelativeLocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeXMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeXMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeYMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeYMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeZMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeZMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::AddRandomizeRelativeLocation(class USceneComponent* Component, int32 RandomSeed, float RangeXMin, float RangeXMax, float RangeYMin, float RangeYMax, float RangeZMin, float RangeZMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AddRandomizeRelativeLocation");

	Params::RBBlueprintLibrary_AddRandomizeRelativeLocation Parms{};

	Parms.Component = Component;
	Parms.RandomSeed = RandomSeed;
	Parms.RangeXMin = RangeXMin;
	Parms.RangeXMax = RangeXMax;
	Parms.RangeYMin = RangeYMin;
	Parms.RangeYMax = RangeYMax;
	Parms.RangeZMin = RangeZMin;
	Parms.RangeZMax = RangeZMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.AddVariatorGlobalSwitch
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SwitchGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SwitchName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::AddVariatorGlobalSwitch(class FName SwitchGroup, class FName SwitchName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AddVariatorGlobalSwitch");

	Params::RBBlueprintLibrary_AddVariatorGlobalSwitch Parms{};

	Parms.SwitchGroup = SwitchGroup;
	Parms.SwitchName = SwitchName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.AInterpTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::AInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AInterpTo");

	Params::RBBlueprintLibrary_AInterpTo Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.ApplyVFXParam
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ParticleComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVFXParams                       Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ApplyVFXParam(class UObject* WorldContextObject, class UNiagaraComponent* ParticleComponent, const struct FVFXParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ApplyVFXParam");

	Params::RBBlueprintLibrary_ApplyVFXParam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ParticleComponent = ParticleComponent;
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Approach
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Coeff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::Approach(const float& Current, const float& Target, float Coeff, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Approach");

	Params::RBBlueprintLibrary_Approach Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.Coeff = Coeff;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.AreCheatsEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::AreCheatsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AreCheatsEnabled");

	Params::RBBlueprintLibrary_AreCheatsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.AreSameProfileIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       FirstProfileId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProfileId                       SecondProfileId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::AreSameProfileIds(const struct FProfileId& FirstProfileId, const struct FProfileId& SecondProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "AreSameProfileIds");

	Params::RBBlueprintLibrary_AreSameProfileIds Parms{};

	Parms.FirstProfileId = std::move(FirstProfileId);
	Parms.SecondProfileId = std::move(SecondProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.BlendVFX
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVFXParams                       ParamsA                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVFXParams                       ParamsB                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVFXParams                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVFXParams URBBlueprintLibrary::BlendVFX(const struct FVFXParams& ParamsA, const struct FVFXParams& ParamsB, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "BlendVFX");

	Params::RBBlueprintLibrary_BlendVFX Parms{};

	Parms.ParamsA = std::move(ParamsA);
	Parms.ParamsB = std::move(ParamsB);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.BlockPlayerRespawnInStage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          blockOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::BlockPlayerRespawnInStage(class UObject* blockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "BlockPlayerRespawnInStage");

	Params::RBBlueprintLibrary_BlockPlayerRespawnInStage Parms{};

	Parms.blockOwner = blockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfIncapacitatedType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerIndicatorType                    IndicatorType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::BP_IsIndicatorOfIncapacitatedType(EPlayerIndicatorType IndicatorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "BP_IsIndicatorOfIncapacitatedType");

	Params::RBBlueprintLibrary_BP_IsIndicatorOfIncapacitatedType Parms{};

	Parms.IndicatorType = IndicatorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfObjectiveType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerIndicatorType                    IndicatorType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::BP_IsIndicatorOfObjectiveType(EPlayerIndicatorType IndicatorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "BP_IsIndicatorOfObjectiveType");

	Params::RBBlueprintLibrary_BP_IsIndicatorOfObjectiveType Parms{};

	Parms.IndicatorType = IndicatorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.BP_IsRayTracingEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::BP_IsRayTracingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "BP_IsRayTracingEnabled");

	Params::RBBlueprintLibrary_BP_IsRayTracingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.CanActorCollisionOverlapInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           baseActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::CanActorCollisionOverlapInEditor(class AActor* baseActor, class AActor* ActorToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "CanActorCollisionOverlapInEditor");

	Params::RBBlueprintLibrary_CanActorCollisionOverlapInEditor Parms{};

	Parms.baseActor = baseActor;
	Parms.ActorToCheck = ActorToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.CanEditLoadouts
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::CanEditLoadouts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "CanEditLoadouts");

	Params::RBBlueprintLibrary_CanEditLoadouts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.CanNPCBeFemale
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGruntCustomizationMeshesConfig  CustomizationMeshesConfig                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ENPCFlavor                              Flavor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::CanNPCBeFemale(const struct FGruntCustomizationMeshesConfig& CustomizationMeshesConfig, ENPCFlavor Flavor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "CanNPCBeFemale");

	Params::RBBlueprintLibrary_CanNPCBeFemale Parms{};

	Parms.CustomizationMeshesConfig = std::move(CustomizationMeshesConfig);
	Parms.Flavor = Flavor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.CheckFeatureSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::CheckFeatureSwitch(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "CheckFeatureSwitch");

	Params::RBBlueprintLibrary_CheckFeatureSwitch Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.ClearVariatorGlobalSwitchesChanged
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::ClearVariatorGlobalSwitchesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ClearVariatorGlobalSwitchesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ClientOnly_PlayVOOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ForcedRandomSeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ClientOnly_PlayVOOnActor(class UAkAudioEvent* AkEvent, class AActor* Owner, EVOPriority VOPriority, int32 ForcedRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ClientOnly_PlayVOOnActor");

	Params::RBBlueprintLibrary_ClientOnly_PlayVOOnActor Parms{};

	Parms.AkEvent = AkEvent;
	Parms.Owner = Owner;
	Parms.VOPriority = VOPriority;
	Parms.ForcedRandomSeed = ForcedRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ClientOnly_QueueVOOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrePlayDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ForcedRandomSeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ClientOnly_QueueVOOnActor(class UAkAudioEvent* AkEvent, class AActor* Owner, EVOPriority VOPriority, float PrePlayDelay, int32 ForcedRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ClientOnly_QueueVOOnActor");

	Params::RBBlueprintLibrary_ClientOnly_QueueVOOnActor Parms{};

	Parms.AkEvent = AkEvent;
	Parms.Owner = Owner;
	Parms.VOPriority = VOPriority;
	Parms.PrePlayDelay = PrePlayDelay;
	Parms.ForcedRandomSeed = ForcedRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.CompleteSingleObjective
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          PlayerCompleting                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ObjectiveActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::CompleteSingleObjective(class ARBPawn* PlayerCompleting, class AActor* ObjectiveActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "CompleteSingleObjective");

	Params::RBBlueprintLibrary_CompleteSingleObjective Parms{};

	Parms.PlayerCompleting = PlayerCompleting;
	Parms.ObjectiveActor = ObjectiveActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ConfigurableBoolToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableBool                ConfigurableBool                                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::ConfigurableBoolToString(const struct FConfigurableBool& ConfigurableBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ConfigurableBoolToString");

	Params::RBBlueprintLibrary_ConfigurableBoolToString Parms{};

	Parms.ConfigurableBool = std::move(ConfigurableBool);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.ConfigurableFloatToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableFloat               ConfigurableFloat                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::ConfigurableFloatToString(const struct FConfigurableFloat& ConfigurableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ConfigurableFloatToString");

	Params::RBBlueprintLibrary_ConfigurableFloatToString Parms{};

	Parms.ConfigurableFloat = std::move(ConfigurableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.ConfigurableIntToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableInt                 ConfigurableInt                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::ConfigurableIntToString(const struct FConfigurableInt& ConfigurableInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ConfigurableIntToString");

	Params::RBBlueprintLibrary_ConfigurableIntToString Parms{};

	Parms.ConfigurableInt = std::move(ConfigurableInt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.DefaultTestInteractionAngle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InteractableObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsYFacing                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::DefaultTestInteractionAngle(const class UObject* InteractableObject, const class ARBPawn* InteractorPawn, bool bIsYFacing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "DefaultTestInteractionAngle");

	Params::RBBlueprintLibrary_DefaultTestInteractionAngle Parms{};

	Parms.InteractableObject = InteractableObject;
	Parms.InteractorPawn = InteractorPawn;
	Parms.bIsYFacing = bIsYFacing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.DestroyComponentHierarchy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::DestroyComponentHierarchy(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "DestroyComponentHierarchy");

	Params::RBBlueprintLibrary_DestroyComponentHierarchy Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.DisablePawnAnimOptims
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableOptims                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::DisablePawnAnimOptims(class ARBPawn* RBPawn, bool bDisableOptims)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "DisablePawnAnimOptims");

	Params::RBBlueprintLibrary_DisablePawnAnimOptims Parms{};

	Parms.RBPawn = RBPawn;
	Parms.bDisableOptims = bDisableOptims;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_ActivateCameraShake
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCameraShakeData                 ShakeData                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          SourceLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_ActivateCameraShake(const struct FCameraShakeData& ShakeData, const struct FVector& SourceLocation, class UObject* ShakeOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_ActivateCameraShake");

	Params::RBBlueprintLibrary_Dispatch_ActivateCameraShake Parms{};

	Parms.ShakeData = std::move(ShakeData);
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.ShakeOwner = ShakeOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_ActivateVFX
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_ActivateVFX(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_ActivateVFX");

	Params::RBBlueprintLibrary_Dispatch_ActivateVFX Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PlaySingleShotMusicTrack
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    MusicTrack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPauseLevelMusic                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PlaySingleShotMusicTrack(class UAkAudioEvent* MusicTrack, class ARBPlayer* Player, bool bPauseLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PlaySingleShotMusicTrack");

	Params::RBBlueprintLibrary_Dispatch_PlaySingleShotMusicTrack Parms{};

	Parms.MusicTrack = MusicTrack;
	Parms.Player = Player;
	Parms.bPauseLevelMusic = bPauseLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayOnPlayersWatch                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PlayVOOnActor(class UAkAudioEvent* AkEvent, class AActor* Owner, EVOPriority VOPriority, bool bPlayOnPlayersWatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PlayVOOnActor");

	Params::RBBlueprintLibrary_Dispatch_PlayVOOnActor Parms{};

	Parms.AkEvent = AkEvent;
	Parms.Owner = Owner;
	Parms.VOPriority = VOPriority;
	Parms.bPlayOnPlayersWatch = bPlayOnPlayersWatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnNarrator
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOPriority                             VOPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PlayVOOnNarrator(class UAkAudioEvent* AkEvent, EVOPriority VOPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PlayVOOnNarrator");

	Params::RBBlueprintLibrary_Dispatch_PlayVOOnNarrator Parms{};

	Parms.AkEvent = AkEvent;
	Parms.VOPriority = VOPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnWatch
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PlayVOOnWatch(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PlayVOOnWatch");

	Params::RBBlueprintLibrary_Dispatch_PlayVOOnWatch Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAkEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     AkComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAkEvent(class UAkComponent* AkComponent, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAkEvent");

	Params::RBBlueprintLibrary_Dispatch_PostAkEvent Parms{};

	Parms.AkComponent = AkComponent;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventGlobal
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAkEventGlobal(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAkEventGlobal");

	Params::RBBlueprintLibrary_Dispatch_PostAkEventGlobal Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventOnActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAkEventOnActor(class AActor* Actor, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAkEventOnActor");

	Params::RBBlueprintLibrary_Dispatch_PostAkEventOnActor Parms{};

	Parms.Actor = Actor;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAssociatedAKEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     AkComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAssociatedAKEvent(class UAkComponent* AkComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAssociatedAKEvent");

	Params::RBBlueprintLibrary_Dispatch_PostAssociatedAKEvent Parms{};

	Parms.AkComponent = AkComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnGroup
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAudioEventOnGroup(class UAkAudioEvent* AkEvent, class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAudioEventOnGroup");

	Params::RBBlueprintLibrary_Dispatch_PostAudioEventOnGroup Parms{};

	Parms.AkEvent = AkEvent;
	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnIntercom
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_PostAudioEventOnIntercom(class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_PostAudioEventOnIntercom");

	Params::RBBlueprintLibrary_Dispatch_PostAudioEventOnIntercom Parms{};

	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Dispatch_StopCameraShake
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstantly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreOwnerCondition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Dispatch_StopCameraShake(bool bInstantly, class UObject* ShakeOwner, bool bIgnoreOwnerCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Dispatch_StopCameraShake");

	Params::RBBlueprintLibrary_Dispatch_StopCameraShake Parms{};

	Parms.bInstantly = bInstantly;
	Parms.ShakeOwner = ShakeOwner;
	Parms.bIgnoreOwnerCondition = bIgnoreOwnerCondition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Editor_SelectActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Editor_SelectActors(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Editor_SelectActors");

	Params::RBBlueprintLibrary_Editor_SelectActors Parms{};

	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.EndCurrentStage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::EndCurrentStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "EndCurrentStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Error
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ErrorText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Error(const class FString& ErrorText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Error");

	Params::RBBlueprintLibrary_Error Parms{};

	Parms.ErrorText = std::move(ErrorText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.EvalRuntimeFloatCurve
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRuntimeFloatCurve               Curve                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::EvalRuntimeFloatCurve(const struct FRuntimeFloatCurve& Curve, float Time, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "EvalRuntimeFloatCurve");

	Params::RBBlueprintLibrary_EvalRuntimeFloatCurve Parms{};

	Parms.Curve = std::move(Curve);
	Parms.Time = Time;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FBoxIntersect
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox                             boxA                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             boxB                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::FBoxIntersect(const struct FBox& boxA, const struct FBox& boxB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FBoxIntersect");

	Params::RBBlueprintLibrary_FBoxIntersect Parms{};

	Parms.boxA = std::move(boxA);
	Parms.boxB = std::move(boxB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FilterByRandomState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsStateA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URBBlueprintLibrary::FilterByRandomState(const TArray<class AActor*>& InActors, bool bIsStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FilterByRandomState");

	Params::RBBlueprintLibrary_FilterByRandomState Parms{};

	Parms.InActors = std::move(InActors);
	Parms.bIsStateA = bIsStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindAssociatedComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* URBBlueprintLibrary::FindAssociatedComponent(class USceneComponent* Component, TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindAssociatedComponent");

	Params::RBBlueprintLibrary_FindAssociatedComponent Parms{};

	Parms.Component = Component;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindChildComponentByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class USceneComponent*> URBBlueprintLibrary::FindChildComponentByTag(class USceneComponent* Component, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindChildComponentByTag");

	Params::RBBlueprintLibrary_FindChildComponentByTag Parms{};

	Parms.Component = Component;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindCollisionUVFromHit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector2D                        UV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::FindCollisionUVFromHit(const struct FHitResult& Hit, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindCollisionUVFromHit");

	Params::RBBlueprintLibrary_FindCollisionUVFromHit Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindFaceAnimSequenceFromLobbyData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBBlueprintLibrary::FindFaceAnimSequenceFromLobbyData(const class FString& LineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindFaceAnimSequenceFromLobbyData");

	Params::RBBlueprintLibrary_FindFaceAnimSequenceFromLobbyData Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindFaceAnimSequenceFromTrialAsyncData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBBlueprintLibrary::FindFaceAnimSequenceFromTrialAsyncData(const class FString& LineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindFaceAnimSequenceFromTrialAsyncData");

	Params::RBBlueprintLibrary_FindFaceAnimSequenceFromTrialAsyncData Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FindQuatBetweenVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Vec1                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Vec2                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat URBBlueprintLibrary::FindQuatBetweenVectors(const struct FVector& Vec1, const struct FVector& Vec2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FindQuatBetweenVectors");

	Params::RBBlueprintLibrary_FindQuatBetweenVectors Parms{};

	Parms.Vec1 = std::move(Vec1);
	Parms.Vec2 = std::move(Vec2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FlipRelativeLocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFlipX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFlipY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFlipZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::FlipRelativeLocation(class USceneComponent* Component, bool bFlipX, bool bFlipY, bool bFlipZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FlipRelativeLocation");

	Params::RBBlueprintLibrary_FlipRelativeLocation Parms{};

	Parms.Component = Component;
	Parms.bFlipX = bFlipX;
	Parms.bFlipY = bFlipY;
	Parms.bFlipZ = bFlipZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ForceSpecificClosetPlayerRespawnPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBMonsterCloset*                 Closet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ForceSpecificClosetPlayerRespawnPoint(class ARBMonsterCloset* Closet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ForceSpecificClosetPlayerRespawnPoint");

	Params::RBBlueprintLibrary_ForceSpecificClosetPlayerRespawnPoint Parms{};

	Parms.Closet = Closet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.FormatTimeFromFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::FormatTimeFromFloat(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FormatTimeFromFloat");

	Params::RBBlueprintLibrary_FormatTimeFromFloat Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FormatTimeFromInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::FormatTimeFromInt(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FormatTimeFromInt");

	Params::RBBlueprintLibrary_FormatTimeFromInt Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.FromUnixTimestamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime URBBlueprintLibrary::FromUnixTimestamp(int64 Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "FromUnixTimestamp");

	Params::RBBlueprintLibrary_FromUnixTimestamp Parms{};

	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GenerateDeterministicRandomString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NbOfCharactersNeeded                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::GenerateDeterministicRandomString(int32 RandomSeed, int32 NbOfCharactersNeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GenerateDeterministicRandomString");

	Params::RBBlueprintLibrary_GenerateDeterministicRandomString Parms{};

	Parms.RandomSeed = RandomSeed;
	Parms.NbOfCharactersNeeded = NbOfCharactersNeeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GenerateRandomSeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          RandomSeedObject                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GenerateRandomSeed(class UObject* RandomSeedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GenerateRandomSeed");

	Params::RBBlueprintLibrary_GenerateRandomSeed Parms{};

	Parms.RandomSeedObject = RandomSeedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GenerateRandomSeedNonDeterministic
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          RandomSeedObject                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GenerateRandomSeedNonDeterministic(class UObject* RandomSeedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GenerateRandomSeedNonDeterministic");

	Params::RBBlueprintLibrary_GenerateRandomSeedNonDeterministic Parms{};

	Parms.RandomSeedObject = RandomSeedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GenerateRandomString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   NbOfCharactersNeeded                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::GenerateRandomString(int32 NbOfCharactersNeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GenerateRandomString");

	Params::RBBlueprintLibrary_GenerateRandomString Parms{};

	Parms.NbOfCharactersNeeded = NbOfCharactersNeeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetActiveSkillClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EActiveSkillType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARBActiveSkill>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ARBActiveSkill> URBBlueprintLibrary::GetActiveSkillClass(EActiveSkillType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetActiveSkillClass");

	Params::RBBlueprintLibrary_GetActiveSkillClass Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EActiveSkillType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActiveSkillCommonParams   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FActiveSkillCommonParams URBBlueprintLibrary::GetActiveSkillCommonParams(EActiveSkillType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetActiveSkillCommonParams");

	Params::RBBlueprintLibrary_GetActiveSkillCommonParams Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParamsById
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActiveSkillCommonParams   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FActiveSkillCommonParams URBBlueprintLibrary::GetActiveSkillCommonParamsById(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetActiveSkillCommonParamsById");

	Params::RBBlueprintLibrary_GetActiveSkillCommonParamsById Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetActorSelectedInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URBBlueprintLibrary::GetActorSelectedInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetActorSelectedInEditor");

	Params::RBBlueprintLibrary_GetActorSelectedInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAllPlayerStates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class ARBPlayerState*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBPlayerState*> URBBlueprintLibrary::GetAllPlayerStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAllPlayerStates");

	Params::RBBlueprintLibrary_GetAllPlayerStates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAllPushableCarts
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARBBasePushable*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBBasePushable*> URBBlueprintLibrary::GetAllPushableCarts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAllPushableCarts");

	Params::RBBlueprintLibrary_GetAllPushableCarts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAllTeamPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBPlayer*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBPlayer*> URBBlueprintLibrary::GetAllTeamPlayers(ETeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAllTeamPlayers");

	Params::RBBlueprintLibrary_GetAllTeamPlayers Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetAnchorOffsetTransform(class UAnimSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnchorOffsetTransform");

	Params::RBBlueprintLibrary_GetAnchorOffsetTransform Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransformFromGhostAnimation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class URBGhostAnimInstance> GhostAnimClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetAnchorOffsetTransformFromGhostAnimation(TSubclassOf<class URBGhostAnimInstance> GhostAnimClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnchorOffsetTransformFromGhostAnimation");

	Params::RBBlueprintLibrary_GetAnchorOffsetTransformFromGhostAnimation Parms{};

	Parms.GhostAnimClass = GhostAnimClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnchorTransformForInteraction
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetAnchorTransformForInteraction(class UAnimSequence* Sequence, class USceneComponent* InSceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnchorTransformForInteraction");

	Params::RBBlueprintLibrary_GetAnchorTransformForInteraction Parms{};

	Parms.Sequence = Sequence;
	Parms.InSceneComponent = InSceneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnimBoneTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMesh                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimAsset                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetAnimBoneTransform(class USkeletalMeshComponent* SkeletalMesh, const class UAnimSequence* AnimAsset, class FName BoneName, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnimBoneTransform");

	Params::RBBlueprintLibrary_GetAnimBoneTransform Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.AnimAsset = AnimAsset;
	Parms.BoneName = BoneName;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnimPlayLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimSeqence                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetAnimPlayLength(class UAnimSequence* AnimSeqence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnimPlayLength");

	Params::RBBlueprintLibrary_GetAnimPlayLength Parms{};

	Parms.AnimSeqence = AnimSeqence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnimTimeMatchForCurve
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetAnimTimeMatchForCurve(class UAnimSequence* AnimSequence, class FName CurveName, float CurveValue, bool bFromEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnimTimeMatchForCurve");

	Params::RBBlueprintLibrary_GetAnimTimeMatchForCurve Parms{};

	Parms.AnimSequence = AnimSequence;
	Parms.CurveName = CurveName;
	Parms.CurveValue = CurveValue;
	Parms.bFromEnd = bFromEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnyAlivePlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetAnyAlivePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnyAlivePlayer");

	Params::RBBlueprintLibrary_GetAnyAlivePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetAnyPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetAnyPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetAnyPlayer");

	Params::RBBlueprintLibrary_GetAnyPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBinariesVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetBinariesVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBinariesVersion");

	Params::RBBlueprintLibrary_GetBinariesVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBlacklightFromRoom
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBRoom*                          Room                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBlacklight*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBlacklight* URBBlueprintLibrary::GetBlacklightFromRoom(class ARBRoom* Room)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBlacklightFromRoom");

	Params::RBBlueprintLibrary_GetBlacklightFromRoom Parms{};

	Parms.Room = Room;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBoneTransformForAnimation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EvalTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetBoneTransformForAnimation(class UAnimSequence* Sequence, class FName BoneName, float EvalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBoneTransformForAnimation");

	Params::RBBlueprintLibrary_GetBoneTransformForAnimation Parms{};

	Parms.Sequence = Sequence;
	Parms.BoneName = BoneName;
	Parms.EvalTime = EvalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBoolValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableBool                ConfigurableBool                                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::GetBoolValue(const struct FConfigurableBool& ConfigurableBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBoolValue");

	Params::RBBlueprintLibrary_GetBoolValue Parms{};

	Parms.ConfigurableBool = std::move(ConfigurableBool);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBoundsFromStaticMeshCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBox>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBox> URBBlueprintLibrary::GetBoundsFromStaticMeshCollision(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBoundsFromStaticMeshCollision");

	Params::RBBlueprintLibrary_GetBoundsFromStaticMeshCollision Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetBoxFromPositions
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox URBBlueprintLibrary::GetBoxFromPositions(const TArray<struct FVector>& Positions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetBoxFromPositions");

	Params::RBBlueprintLibrary_GetBoxFromPositions Parms{};

	Parms.Positions = std::move(Positions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetChildComponentByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USceneComponent>      ClassOf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* URBBlueprintLibrary::GetChildComponentByClass(class USceneComponent* Component, TSubclassOf<class USceneComponent> ClassOf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetChildComponentByClass");

	Params::RBBlueprintLibrary_GetChildComponentByClass Parms{};

	Parms.Component = Component;
	Parms.ClassOf = ClassOf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetChildComponentByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComponentTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  OutComponent                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetChildComponentByTag(class USceneComponent* Component, class FName ComponentTag, class USceneComponent** OutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetChildComponentByTag");

	Params::RBBlueprintLibrary_GetChildComponentByTag Parms{};

	Parms.Component = Component;
	Parms.ComponentTag = ComponentTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponent != nullptr)
		*OutComponent = Parms.OutComponent;
}


// Function OPP.RBBlueprintLibrary.GetChildComponentsByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USceneComponent>      ClassOf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetChildComponentsByClass(class USceneComponent* Component, TSubclassOf<class USceneComponent> ClassOf, TArray<class USceneComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetChildComponentsByClass");

	Params::RBBlueprintLibrary_GetChildComponentsByClass Parms{};

	Parms.Component = Component;
	Parms.ClassOf = ClassOf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function OPP.RBBlueprintLibrary.GetChildComponentsByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComponentTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetChildComponentsByTag(class USceneComponent* Component, class FName ComponentTag, TArray<class USceneComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetChildComponentsByTag");

	Params::RBBlueprintLibrary_GetChildComponentsByTag Parms{};

	Parms.Component = Component;
	Parms.ComponentTag = ComponentTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function OPP.RBBlueprintLibrary.GetChunkInstallManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBChunkInstallManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBChunkInstallManager* URBBlueprintLibrary::GetChunkInstallManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetChunkInstallManager");

	Params::RBBlueprintLibrary_GetChunkInstallManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetClosestPushCartGoalManager
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPushCartGoalManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPushCartGoalManager* URBBlueprintLibrary::GetClosestPushCartGoalManager(const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetClosestPushCartGoalManager");

	Params::RBBlueprintLibrary_GetClosestPushCartGoalManager Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCollectibleDocumentsConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBCollectibleDocumentsConfig*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCollectibleDocumentsConfig* URBBlueprintLibrary::GetCollectibleDocumentsConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCollectibleDocumentsConfig");

	Params::RBBlueprintLibrary_GetCollectibleDocumentsConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetComponentByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassOf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetComponentByClass(class AActor* Actor, TSubclassOf<class UActorComponent> ClassOf, TArray<class UActorComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetComponentByClass");

	Params::RBBlueprintLibrary_GetComponentByClass Parms{};

	Parms.Actor = Actor;
	Parms.ClassOf = ClassOf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function OPP.RBBlueprintLibrary.GetComponentFromSelector
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRBComponentSelector             ComponentSelector                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* URBBlueprintLibrary::GetComponentFromSelector(struct FRBComponentSelector& ComponentSelector, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetComponentFromSelector");

	Params::RBBlueprintLibrary_GetComponentFromSelector Parms{};

	Parms.ComponentSelector = std::move(ComponentSelector);
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ComponentSelector = std::move(Parms.ComponentSelector);

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetControlledPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* URBBlueprintLibrary::GetControlledPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetControlledPawn");

	Params::RBBlueprintLibrary_GetControlledPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetControlledPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetControlledPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetControlledPlayer");

	Params::RBBlueprintLibrary_GetControlledPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurrentEditorNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBBlueprintLibrary::GetCurrentEditorNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurrentEditorNormal");

	Params::RBBlueprintLibrary_GetCurrentEditorNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurrentMissionID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBMissionID                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBMissionID URBBlueprintLibrary::GetCurrentMissionID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurrentMissionID");

	Params::RBBlueprintLibrary_GetCurrentMissionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurrentSAS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSAS*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBSAS* URBBlueprintLibrary::GetCurrentSAS(ETeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurrentSAS");

	Params::RBBlueprintLibrary_GetCurrentSAS Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurrentSASList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ARBSAS*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBSAS*> URBBlueprintLibrary::GetCurrentSASList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurrentSASList");

	Params::RBBlueprintLibrary_GetCurrentSASList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurveValueForAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EvalTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetCurveValueForAnimation(class UAnimSequence* Sequence, class FName CurveName, float EvalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurveValueForAnimation");

	Params::RBBlueprintLibrary_GetCurveValueForAnimation Parms{};

	Parms.Sequence = Sequence;
	Parms.CurveName = CurveName;
	Parms.EvalTime = EvalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCurveValueFromAnimInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Out_value                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::GetCurveValueFromAnimInstance(const class UAnimInstance* AnimInstance, const class FName& CurveName, float* Out_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCurveValueFromAnimInstance");

	Params::RBBlueprintLibrary_GetCurveValueFromAnimInstance Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_value != nullptr)
		*Out_value = Parms.Out_value;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetCustomizationMeshForGrunt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGruntCustomizationMeshesConfig  CustomizationMeshesConfig                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSelectedGruntCustomizationMeshesInfoCustomizationMeshesInfo                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ENPCCustomizationSlot                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNPCCustomizationMesh            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNPCCustomizationMesh URBBlueprintLibrary::GetCustomizationMeshForGrunt(const struct FGruntCustomizationMeshesConfig& CustomizationMeshesConfig, const struct FSelectedGruntCustomizationMeshesInfo& CustomizationMeshesInfo, ENPCCustomizationSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetCustomizationMeshForGrunt");

	Params::RBBlueprintLibrary_GetCustomizationMeshForGrunt Parms{};

	Parms.CustomizationMeshesConfig = std::move(CustomizationMeshesConfig);
	Parms.CustomizationMeshesInfo = std::move(CustomizationMeshesInfo);
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URBBlueprintLibrary::GetDefaultObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetDefaultObject");

	Params::RBBlueprintLibrary_GetDefaultObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetDefaultObjectFromAssetData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FAssetData                       Asset                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URBBlueprintLibrary::GetDefaultObjectFromAssetData(const struct FAssetData& Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetDefaultObjectFromAssetData");

	Params::RBBlueprintLibrary_GetDefaultObjectFromAssetData Parms{};

	Parms.Asset = std::move(Asset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetDefaultStagePrimeAssetType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCType URBBlueprintLibrary::GetDefaultStagePrimeAssetType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetDefaultStagePrimeAssetType");

	Params::RBBlueprintLibrary_GetDefaultStagePrimeAssetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetDefaultVoiceComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBSoundComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSoundComponent* URBBlueprintLibrary::GetDefaultVoiceComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetDefaultVoiceComponent");

	Params::RBBlueprintLibrary_GetDefaultVoiceComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetEditorWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBWorldSettings*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBWorldSettings* URBBlueprintLibrary::GetEditorWorldSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetEditorWorldSettings");

	Params::RBBlueprintLibrary_GetEditorWorldSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetEffectivePlayerCountForConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetEffectivePlayerCountForConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetEffectivePlayerCountForConfiguration");

	Params::RBBlueprintLibrary_GetEffectivePlayerCountForConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetEffectiveSASVariatorType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESASVariatorType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESASVariatorType URBBlueprintLibrary::GetEffectiveSASVariatorType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetEffectiveSASVariatorType");

	Params::RBBlueprintLibrary_GetEffectiveSASVariatorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetElapsedPawnTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetElapsedPawnTime(class ARBPawn* Pawn, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetElapsedPawnTime");

	Params::RBBlueprintLibrary_GetElapsedPawnTime Parms{};

	Parms.Pawn = Pawn;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetElapsedServerTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetElapsedServerTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetElapsedServerTime");

	Params::RBBlueprintLibrary_GetElapsedServerTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetElapsedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetElapsedTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetElapsedTime");

	Params::RBBlueprintLibrary_GetElapsedTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetFirstPushableCart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBBasePushable*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBBasePushable* URBBlueprintLibrary::GetFirstPushableCart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetFirstPushableCart");

	Params::RBBlueprintLibrary_GetFirstPushableCart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetFloatValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableFloat               ConfigurableFloat                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetFloatValue(const struct FConfigurableFloat& ConfigurableFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetFloatValue");

	Params::RBBlueprintLibrary_GetFloatValue Parms{};

	Parms.ConfigurableFloat = std::move(ConfigurableFloat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetFoleySwitchOverrideFromGruntCustomization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSelectedGruntCustomizationMeshesInfoSelectedMeshInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGruntCustomizationMeshesConfig  MeshesConfig                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URBBlueprintLibrary::GetFoleySwitchOverrideFromGruntCustomization(const struct FSelectedGruntCustomizationMeshesInfo& SelectedMeshInfo, const struct FGruntCustomizationMeshesConfig& MeshesConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetFoleySwitchOverrideFromGruntCustomization");

	Params::RBBlueprintLibrary_GetFoleySwitchOverrideFromGruntCustomization Parms{};

	Parms.SelectedMeshInfo = std::move(SelectedMeshInfo);
	Parms.MeshesConfig = std::move(MeshesConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetFXManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBFXManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBFXManager* URBBlueprintLibrary::GetFXManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetFXManager");

	Params::RBBlueprintLibrary_GetFXManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGameDifficulty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameDifficulty URBBlueprintLibrary::GetGameDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGameDifficulty");

	Params::RBBlueprintLibrary_GetGameDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGameStageInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBGameStageInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBGameStageInfo URBBlueprintLibrary::GetGameStageInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGameStageInfo");

	Params::RBBlueprintLibrary_GetGameStageInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGameStructureConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGameStructureConfig*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGameStructureConfig* URBBlueprintLibrary::GetGameStructureConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGameStructureConfig");

	Params::RBBlueprintLibrary_GetGameStructureConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGameTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGameTime");

	Params::RBBlueprintLibrary_GetGameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGameVersionString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::GetGameVersionString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGameVersionString");

	Params::RBBlueprintLibrary_GetGameVersionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGlobalAudioConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGlobalAudioConfig*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGlobalAudioConfig* URBBlueprintLibrary::GetGlobalAudioConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGlobalAudioConfig");

	Params::RBBlueprintLibrary_GetGlobalAudioConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetGlobalUIConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGlobalUIConfig*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGlobalUIConfig* URBBlueprintLibrary::GetGlobalUIConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetGlobalUIConfig");

	Params::RBBlueprintLibrary_GetGlobalUIConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetHallucinationManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBHallucinationManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBHallucinationManager* URBBlueprintLibrary::GetHallucinationManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetHallucinationManager");

	Params::RBBlueprintLibrary_GetHallucinationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetHUD
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBHUD*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBHUD* URBBlueprintLibrary::GetHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetHUD");

	Params::RBBlueprintLibrary_GetHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetHUDWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBHUDWidget*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBHUDWidget* URBBlueprintLibrary::GetHUDWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetHUDWidget");

	Params::RBBlueprintLibrary_GetHUDWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetInputBinding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceGamepad                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceKBM                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionKeyMapping           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputActionKeyMapping URBBlueprintLibrary::GetInputBinding(class FName ActionName, int32 Value, bool bForceGamepad, bool bForceKBM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetInputBinding");

	Params::RBBlueprintLibrary_GetInputBinding Parms{};

	Parms.ActionName = ActionName;
	Parms.Value = Value;
	Parms.bForceGamepad = bForceGamepad;
	Parms.bForceKBM = bForceKBM;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetIntValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FConfigurableInt                 ConfigurableInt                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetIntValue(const struct FConfigurableInt& ConfigurableInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetIntValue");

	Params::RBBlueprintLibrary_GetIntValue Parms{};

	Parms.ConfigurableInt = std::move(ConfigurableInt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetKeyFName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URBBlueprintLibrary::GetKeyFName(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetKeyFName");

	Params::RBBlueprintLibrary_GetKeyFName Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLargePickupTossAnim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Default1PAnim                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Default3PAnim                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBBlueprintLibrary::GetLargePickupTossAnim(class ARBLargePickup* LargePickup, class ARBPlayer* Player, class UAnimSequence* Default1PAnim, class UAnimSequence* Default3PAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLargePickupTossAnim");

	Params::RBBlueprintLibrary_GetLargePickupTossAnim Parms{};

	Parms.LargePickup = LargePickup;
	Parms.Player = Player;
	Parms.Default1PAnim = Default1PAnim;
	Parms.Default3PAnim = Default3PAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLoadedOnServerComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> URBBlueprintLibrary::GetLoadedOnServerComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLoadedOnServerComponents");

	Params::RBBlueprintLibrary_GetLoadedOnServerComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalCameraFOV
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetLocalCameraFOV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalCameraFOV");

	Params::RBBlueprintLibrary_GetLocalCameraFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalLobbyPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBLobbyPlayerController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLobbyPlayerController* URBBlueprintLibrary::GetLocalLobbyPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalLobbyPlayerController");

	Params::RBBlueprintLibrary_GetLocalLobbyPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalMainMenuPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBMainMenuPlayerController*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBMainMenuPlayerController* URBBlueprintLibrary::GetLocalMainMenuPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalMainMenuPlayerController");

	Params::RBBlueprintLibrary_GetLocalMainMenuPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalMenuController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBMenuPlayerController*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBMenuPlayerController* URBBlueprintLibrary::GetLocalMenuController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalMenuController");

	Params::RBBlueprintLibrary_GetLocalMenuController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetLocalPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalPawn");

	Params::RBBlueprintLibrary_GetLocalPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBController*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBController* URBBlueprintLibrary::GetLocalPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalPlayerController");

	Params::RBBlueprintLibrary_GetLocalPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalPlayerProgressionData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerProgressionData*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerProgressionData* URBBlueprintLibrary::GetLocalPlayerProgressionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalPlayerProgressionData");

	Params::RBBlueprintLibrary_GetLocalPlayerProgressionData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* URBBlueprintLibrary::GetLocalPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalPlayerState");

	Params::RBBlueprintLibrary_GetLocalPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetLocalTeamRBObjectiveManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBObjectiveManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBObjectiveManager* URBBlueprintLibrary::GetLocalTeamRBObjectiveManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetLocalTeamRBObjectiveManager");

	Params::RBBlueprintLibrary_GetLocalTeamRBObjectiveManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetMenuManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBMenuManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuManager* URBBlueprintLibrary::GetMenuManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetMenuManager");

	Params::RBBlueprintLibrary_GetMenuManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetMissionInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class URBMissionInfo*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMissionInfo* URBBlueprintLibrary::GetMissionInfo(const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetMissionInfo");

	Params::RBBlueprintLibrary_GetMissionInfo Parms{};

	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNarrator_ClientOnly
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URBBlueprintLibrary::GetNarrator_ClientOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNarrator_ClientOnly");

	Params::RBBlueprintLibrary_GetNarrator_ClientOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNearbyBots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckClearance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBBot*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBBot*> URBBlueprintLibrary::GetNearbyBots(class AActor* Source, float Radius, bool bCheckClearance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNearbyBots");

	Params::RBBlueprintLibrary_GetNearbyBots Parms{};

	Parms.Source = Source;
	Parms.Radius = Radius;
	Parms.bCheckClearance = bCheckClearance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNearbyPlayers
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckClearance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OriginOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBPlayer*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBPlayer*> URBBlueprintLibrary::GetNearbyPlayers(class AActor* Source, float Radius, bool bCheckClearance, const struct FVector& OriginOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNearbyPlayers");

	Params::RBBlueprintLibrary_GetNearbyPlayers Parms{};

	Parms.Source = Source;
	Parms.Radius = Radius;
	Parms.bCheckClearance = bCheckClearance;
	Parms.OriginOffset = std::move(OriginOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNewRandomActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ActorList                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           CurrentActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URBBlueprintLibrary::GetNewRandomActor(const TArray<class AActor*>& ActorList, class AActor* CurrentActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNewRandomActor");

	Params::RBBlueprintLibrary_GetNewRandomActor Parms{};

	Parms.ActorList = std::move(ActorList);
	Parms.CurrentActor = CurrentActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNonDefaultStagePrimeAssetType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCType                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCType URBBlueprintLibrary::GetNonDefaultStagePrimeAssetType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNonDefaultStagePrimeAssetType");

	Params::RBBlueprintLibrary_GetNonDefaultStagePrimeAssetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNumberOfAlivePlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetNumberOfAlivePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNumberOfAlivePlayer");

	Params::RBBlueprintLibrary_GetNumberOfAlivePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetNumberOfPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetNumberOfPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetNumberOfPlayer");

	Params::RBBlueprintLibrary_GetNumberOfPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPawnCustomizationManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPawnCustomizationManager*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPawnCustomizationManager* URBBlueprintLibrary::GetPawnCustomizationManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPawnCustomizationManager");

	Params::RBBlueprintLibrary_GetPawnCustomizationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerByPlayerId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBPlayerId                      PlayerId                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetPlayerByPlayerId(const struct FRBPlayerId& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerByPlayerId");

	Params::RBBlueprintLibrary_GetPlayerByPlayerId Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerByUniqueId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 UniqueId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetPlayerByUniqueId(const struct FUniqueNetIdRepl& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerByUniqueId");

	Params::RBBlueprintLibrary_GetPlayerByUniqueId Parms{};

	Parms.UniqueId = std::move(UniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerCellCustomizationConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerCellCustomizationConfig* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCellCustomizationConfig* URBBlueprintLibrary::GetPlayerCellCustomizationConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerCellCustomizationConfig");

	Params::RBBlueprintLibrary_GetPlayerCellCustomizationConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerCustomizationConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerCustomizationConfig*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationConfig* URBBlueprintLibrary::GetPlayerCustomizationConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerCustomizationConfig");

	Params::RBBlueprintLibrary_GetPlayerCustomizationConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerCustomizationOptionForSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* URBBlueprintLibrary::GetPlayerCustomizationOptionForSlot(class AActor* CustomizationOwner, EPlayerCustomizationSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerCustomizationOptionForSlot");

	Params::RBBlueprintLibrary_GetPlayerCustomizationOptionForSlot Parms{};

	Parms.CustomizationOwner = CustomizationOwner;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerGameSessionManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerGameSessionManager*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerGameSessionManager* URBBlueprintLibrary::GetPlayerGameSessionManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerGameSessionManager");

	Params::RBBlueprintLibrary_GetPlayerGameSessionManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerLoadoutConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerLoadoutConfig*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerLoadoutConfig* URBBlueprintLibrary::GetPlayerLoadoutConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerLoadoutConfig");

	Params::RBBlueprintLibrary_GetPlayerLoadoutConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerPingDataFromId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DataId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerPingData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerPingData URBBlueprintLibrary::GetPlayerPingDataFromId(const class FName& DataId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerPingDataFromId");

	Params::RBBlueprintLibrary_GetPlayerPingDataFromId Parms{};

	Parms.DataId = DataId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerProgressionData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerProgressionData*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerProgressionData* URBBlueprintLibrary::GetPlayerProgressionData(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerProgressionData");

	Params::RBBlueprintLibrary_GetPlayerProgressionData Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerProgressionManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerProgressionManager*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerProgressionManager* URBBlueprintLibrary::GetPlayerProgressionManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerProgressionManager");

	Params::RBBlueprintLibrary_GetPlayerProgressionManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByPlayer(const class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerStateByPlayer");

	Params::RBBlueprintLibrary_GetPlayerStateByPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayerId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBPlayerId                      PlayerId                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByPlayerId(const struct FRBPlayerId& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerStateByPlayerId");

	Params::RBBlueprintLibrary_GetPlayerStateByPlayerId Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerStateByUniqueId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 UniqueId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByUniqueId(const struct FUniqueNetIdRepl& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerStateByUniqueId");

	Params::RBBlueprintLibrary_GetPlayerStateByUniqueId Parms{};

	Parms.UniqueId = std::move(UniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPlayerStatsConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBPlayerStatsConfig*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerStatsConfig* URBBlueprintLibrary::GetPlayerStatsConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPlayerStatsConfig");

	Params::RBBlueprintLibrary_GetPlayerStatsConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetPostProcessUpdateManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPostProcessUpdateManager*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPostProcessUpdateManager* URBBlueprintLibrary::GetPostProcessUpdateManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetPostProcessUpdateManager");

	Params::RBBlueprintLibrary_GetPostProcessUpdateManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetProfile
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBLocalProfile*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBLocalProfile* URBBlueprintLibrary::GetProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetProfile");

	Params::RBBlueprintLibrary_GetProfile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRandomIndexForNPCCustomizationSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGruntCustomizationMeshesConfig  CustomizationMeshesConfig                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bFemale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCCustomizationSlot                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCFlavor                              Flavor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetRandomIndexForNPCCustomizationSlot(const struct FGruntCustomizationMeshesConfig& CustomizationMeshesConfig, bool bFemale, ENPCCustomizationSlot Slot, ENPCFlavor Flavor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRandomIndexForNPCCustomizationSlot");

	Params::RBBlueprintLibrary_GetRandomIndexForNPCCustomizationSlot Parms{};

	Parms.CustomizationMeshesConfig = std::move(CustomizationMeshesConfig);
	Parms.bFemale = bFemale;
	Parms.Slot = Slot;
	Parms.Flavor = Flavor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGameInstance*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGameInstance* URBBlueprintLibrary::GetRBGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameInstance");

	Params::RBBlueprintLibrary_GetRBGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameMode*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameMode* URBBlueprintLibrary::GetRBGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameMode");

	Params::RBBlueprintLibrary_GetRBGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameModeBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameModeBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameModeBase* URBBlueprintLibrary::GetRBGameModeBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameModeBase");

	Params::RBBlueprintLibrary_GetRBGameModeBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameModeLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameModeLobby*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameModeLobby* URBBlueprintLibrary::GetRBGameModeLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameModeLobby");

	Params::RBBlueprintLibrary_GetRBGameModeLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameModeMainMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameModeMainMenu*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameModeMainMenu* URBBlueprintLibrary::GetRBGameModeMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameModeMainMenu");

	Params::RBBlueprintLibrary_GetRBGameModeMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameState* URBBlueprintLibrary::GetRBGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameState");

	Params::RBBlueprintLibrary_GetRBGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameStateBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameStateBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameStateBase* URBBlueprintLibrary::GetRBGameStateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameStateBase");

	Params::RBBlueprintLibrary_GetRBGameStateBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameStateLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBGameStateLobby*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBGameStateLobby* URBBlueprintLibrary::GetRBGameStateLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameStateLobby");

	Params::RBBlueprintLibrary_GetRBGameStateLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameUserPreferences
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGameUserPreferences*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGameUserPreferences* URBBlueprintLibrary::GetRBGameUserPreferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameUserPreferences");

	Params::RBBlueprintLibrary_GetRBGameUserPreferences Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBGameUserSettings*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBGameUserSettings* URBBlueprintLibrary::GetRBGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBGameUserSettings");

	Params::RBBlueprintLibrary_GetRBGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBObjectiveManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBObjectiveManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBObjectiveManager* URBBlueprintLibrary::GetRBObjectiveManager(ETeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBObjectiveManager");

	Params::RBBlueprintLibrary_GetRBObjectiveManager Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBPlayerLoadoutManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerLoadoutManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerLoadoutManager* URBBlueprintLibrary::GetRBPlayerLoadoutManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBPlayerLoadoutManager");

	Params::RBBlueprintLibrary_GetRBPlayerLoadoutManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBSettings_Anim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBSettings_Anim*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSettings_Anim* URBBlueprintLibrary::GetRBSettings_Anim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBSettings_Anim");

	Params::RBBlueprintLibrary_GetRBSettings_Anim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBSettings_Audio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBSettings_Audio*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSettings_Audio* URBBlueprintLibrary::GetRBSettings_Audio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBSettings_Audio");

	Params::RBBlueprintLibrary_GetRBSettings_Audio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBSettings_Gameplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBSettings_Gameplay*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSettings_Gameplay* URBBlueprintLibrary::GetRBSettings_Gameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBSettings_Gameplay");

	Params::RBBlueprintLibrary_GetRBSettings_Gameplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBStreaming
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBStreaming*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBStreaming* URBBlueprintLibrary::GetRBStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBStreaming");

	Params::RBBlueprintLibrary_GetRBStreaming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBTaskManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBTaskManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBTaskManager* URBBlueprintLibrary::GetRBTaskManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBTaskManager");

	Params::RBBlueprintLibrary_GetRBTaskManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRBWorld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBWorld*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBWorld* URBBlueprintLibrary::GetRBWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRBWorld");

	Params::RBBlueprintLibrary_GetRBWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRefPoseBoneComponentSpace
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           SkelMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetRefPoseBoneComponentSpace(class USkeletalMeshComponent* SkelMesh, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRefPoseBoneComponentSpace");

	Params::RBBlueprintLibrary_GetRefPoseBoneComponentSpace Parms{};

	Parms.SkelMesh = SkelMesh;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRoomForActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBRoom*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBRoom* URBBlueprintLibrary::GetRoomForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRoomForActor");

	Params::RBBlueprintLibrary_GetRoomForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetRoomPathedDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DestActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Out_ValidPath                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowCoopRooms                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetRoomPathedDistance(class AActor* SourceActor, class AActor* DestActor, bool* Out_ValidPath, float MaxDistance, bool AllowCoopRooms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetRoomPathedDistance");

	Params::RBBlueprintLibrary_GetRoomPathedDistance Parms{};

	Parms.SourceActor = SourceActor;
	Parms.DestActor = DestActor;
	Parms.MaxDistance = MaxDistance;
	Parms.AllowCoopRooms = AllowCoopRooms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_ValidPath != nullptr)
		*Out_ValidPath = Parms.Out_ValidPath;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetScoringConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBScoringConfig*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBScoringConfig* URBBlueprintLibrary::GetScoringConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetScoringConfig");

	Params::RBBlueprintLibrary_GetScoringConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetServerAddressUrl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::GetServerAddressUrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetServerAddressUrl");

	Params::RBBlueprintLibrary_GetServerAddressUrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetServerTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetServerTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetServerTime");

	Params::RBBlueprintLibrary_GetServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetSoftObjectPathFromSoftObjectReference
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectReference                                    (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath URBBlueprintLibrary::GetSoftObjectPathFromSoftObjectReference(const TSoftObjectPtr<class UObject>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetSoftObjectPathFromSoftObjectReference");

	Params::RBBlueprintLibrary_GetSoftObjectPathFromSoftObjectReference Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetSpectatedPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* URBBlueprintLibrary::GetSpectatedPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetSpectatedPlayer");

	Params::RBBlueprintLibrary_GetSpectatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetSpectatorPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBSpectatorPawn*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBSpectatorPawn* URBBlueprintLibrary::GetSpectatorPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetSpectatorPawn");

	Params::RBBlueprintLibrary_GetSpectatorPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStageInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class URBStageInfo*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBStageInfo* URBBlueprintLibrary::GetStageInfo(const struct FRBStageID& StageID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStageInfo");

	Params::RBBlueprintLibrary_GetStageInfo Parms{};

	Parms.StageID = std::move(StageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStageResetCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::GetStageResetCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStageResetCount");

	Params::RBBlueprintLibrary_GetStageResetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStageTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::GetStageTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStageTime");

	Params::RBBlueprintLibrary_GetStageTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStaticMeshImportSettingsGenerateLightmapUVs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::GetStaticMeshImportSettingsGenerateLightmapUVs(class UStaticMesh* StaticMesh, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStaticMeshImportSettingsGenerateLightmapUVs");

	Params::RBBlueprintLibrary_GetStaticMeshImportSettingsGenerateLightmapUVs Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStaticMeshLODGenerateLightmapUVs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::GetStaticMeshLODGenerateLightmapUVs(class UStaticMesh* StaticMesh, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStaticMeshLODGenerateLightmapUVs");

	Params::RBBlueprintLibrary_GetStaticMeshLODGenerateLightmapUVs Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetStaticMeshMemorySize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxOccurences                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinFileSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetStaticMeshMemorySize(class UObject* WorldContextObject, int32 MaxOccurences, int32 MinFileSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetStaticMeshMemorySize");

	Params::RBBlueprintLibrary_GetStaticMeshMemorySize Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MaxOccurences = MaxOccurences;
	Parms.MinFileSize = MinFileSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.GetTasksConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBTasksConfig*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBTasksConfig* URBBlueprintLibrary::GetTasksConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetTasksConfig");

	Params::RBBlueprintLibrary_GetTasksConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetTexturesFromMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTexture*>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture*> URBBlueprintLibrary::GetTexturesFromMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetTexturesFromMaterial");

	Params::RBBlueprintLibrary_GetTexturesFromMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetUniqueVariatorTypeValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EUniqueVariatorType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Param_Name                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::GetUniqueVariatorTypeValue(EUniqueVariatorType Type, const class FName& Param_Name, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetUniqueVariatorTypeValue");

	Params::RBBlueprintLibrary_GetUniqueVariatorTypeValue Parms{};

	Parms.Type = Type;
	Parms.Param_Name = Param_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetValidCustomizationOption
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUICustomizationItem             Item                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class URBCustomizationOption*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCustomizationOption* URBBlueprintLibrary::GetValidCustomizationOption(struct FUICustomizationItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetValidCustomizationOption");

	Params::RBBlueprintLibrary_GetValidCustomizationOption Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Item = std::move(Parms.Item);

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetVariatorManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBVariatorManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBVariatorManager* URBBlueprintLibrary::GetVariatorManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetVariatorManager");

	Params::RBBlueprintLibrary_GetVariatorManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetViewForward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBBlueprintLibrary::GetViewForward(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetViewForward");

	Params::RBBlueprintLibrary_GetViewForward Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetViewLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBBlueprintLibrary::GetViewLocation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetViewLocation");

	Params::RBBlueprintLibrary_GetViewLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetViewPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ViewRotation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetViewPoint(class UObject* WorldContextObject, struct FVector* ViewLocation, struct FRotator* ViewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetViewPoint");

	Params::RBBlueprintLibrary_GetViewPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ViewLocation != nullptr)
		*ViewLocation = std::move(Parms.ViewLocation);

	if (ViewRotation != nullptr)
		*ViewRotation = std::move(Parms.ViewRotation);
}


// Function OPP.RBBlueprintLibrary.GetViewRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URBBlueprintLibrary::GetViewRotation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetViewRotation");

	Params::RBBlueprintLibrary_GetViewRotation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetWorldAnchorTransformForGhostAnimation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class URBGhostAnimInstance> GhostAnimClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBBlueprintLibrary::GetWorldAnchorTransformForGhostAnimation(TSubclassOf<class URBGhostAnimInstance> GhostAnimClass, class USceneComponent* InSceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldAnchorTransformForGhostAnimation");

	Params::RBBlueprintLibrary_GetWorldAnchorTransformForGhostAnimation Parms{};

	Parms.GhostAnimClass = GhostAnimClass;
	Parms.InSceneComponent = InSceneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBWorldSettings*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBWorldSettings* URBBlueprintLibrary::GetWorldSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldSettings");

	Params::RBBlueprintLibrary_GetWorldSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnapToGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SnapToGroundRequester                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformFromAnimationAnchor(const class ARBPawn* Pawn, const class UAnimSequence* Sequence, class USceneComponent* InSceneComponent, bool bSnapToGround, struct FVector* OutLocation, struct FVector* OutDirection, class UObject* SnapToGroundRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformFromAnimationAnchor");

	Params::RBBlueprintLibrary_GetWorldTransformFromAnimationAnchor Parms{};

	Parms.Pawn = Pawn;
	Parms.Sequence = Sequence;
	Parms.InSceneComponent = InSceneComponent;
	Parms.bSnapToGround = bSnapToGround;
	Parms.SnapToGroundRequester = SnapToGroundRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchorByTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSnapToGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SnapToGroundRequester                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformFromAnimationAnchorByTransform(const class ARBPawn* Pawn, const class UAnimSequence* Sequence, const struct FTransform& InTransformReference, bool bSnapToGround, struct FVector* OutLocation, struct FVector* OutDirection, class UObject* SnapToGroundRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformFromAnimationAnchorByTransform");

	Params::RBBlueprintLibrary_GetWorldTransformFromAnimationAnchorByTransform Parms{};

	Parms.Pawn = Pawn;
	Parms.Sequence = Sequence;
	Parms.InTransformReference = std::move(InTransformReference);
	Parms.bSnapToGround = bSnapToGround;
	Parms.SnapToGroundRequester = SnapToGroundRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformFromGhostAnimationAnchorByTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class URBGhostAnimInstance> GhostAnimClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformFromGhostAnimationAnchorByTransform(TSubclassOf<class URBGhostAnimInstance> GhostAnimClass, const struct FTransform& InTransformReference, struct FVector* OutLocation, struct FVector* OutDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformFromGhostAnimationAnchorByTransform");

	Params::RBBlueprintLibrary_GetWorldTransformFromGhostAnimationAnchorByTransform Parms{};

	Parms.GhostAnimClass = GhostAnimClass;
	Parms.InTransformReference = std::move(InTransformReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform(const class UAnimSequence* Sequence, const class FName BoneName, const struct FTransform& InTransformReference, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform");

	Params::RBBlueprintLibrary_GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform Parms{};

	Parms.Sequence = Sequence;
	Parms.BoneName = BoneName;
	Parms.InTransformReference = std::move(InTransformReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTimeRelativeToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EvalTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformMatrixForBoneAtTimeRelativeToTransform(const class UAnimSequence* Sequence, const class FName BoneName, const float EvalTime, const struct FTransform& InTransformReference, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformMatrixForBoneAtTimeRelativeToTransform");

	Params::RBBlueprintLibrary_GetWorldTransformMatrixForBoneAtTimeRelativeToTransform Parms{};

	Parms.Sequence = Sequence;
	Parms.BoneName = BoneName;
	Parms.EvalTime = EvalTime;
	Parms.InTransformReference = std::move(InTransformReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSnapToGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          SnapToGroundRequester                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformMatrixFromAnimationAnchorByTransform(const class ARBPawn* Pawn, const class UAnimSequence* Sequence, const struct FTransform& InTransformReference, bool bSnapToGround, struct FTransform* OutTransform, class UObject* SnapToGroundRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformMatrixFromAnimationAnchorByTransform");

	Params::RBBlueprintLibrary_GetWorldTransformMatrixFromAnimationAnchorByTransform Parms{};

	Parms.Pawn = Pawn;
	Parms.Sequence = Sequence;
	Parms.InTransformReference = std::move(InTransformReference);
	Parms.bSnapToGround = bSnapToGround;
	Parms.SnapToGroundRequester = SnapToGroundRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSnapToGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          SnapToGroundRequester                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace(const class ARBPawn* Pawn, const class UAnimSequence* Sequence, const struct FTransform& InTransformReference, bool bSnapToGround, struct FTransform* OutTransform, class UObject* SnapToGroundRequester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace");

	Params::RBBlueprintLibrary_GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace Parms{};

	Parms.Pawn = Pawn;
	Parms.Sequence = Sequence;
	Parms.InTransformReference = std::move(InTransformReference);
	Parms.bSnapToGround = bSnapToGround;
	Parms.SnapToGroundRequester = SnapToGroundRequester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromGhostAnimationAnchorByTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class URBGhostAnimInstance> GhostAnimClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransformReference                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::GetWorldTransformMatrixFromGhostAnimationAnchorByTransform(TSubclassOf<class URBGhostAnimInstance> GhostAnimClass, const struct FTransform& InTransformReference, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "GetWorldTransformMatrixFromGhostAnimationAnchorByTransform");

	Params::RBBlueprintLibrary_GetWorldTransformMatrixFromGhostAnimationAnchorByTransform Parms{};

	Parms.GhostAnimClass = GhostAnimClass;
	Parms.InTransformReference = std::move(InTransformReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function OPP.RBBlueprintLibrary.HasActorBegunPlay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::HasActorBegunPlay(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HasActorBegunPlay");

	Params::RBBlueprintLibrary_HasActorBegunPlay Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.HasActorNotBegunPlay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::HasActorNotBegunPlay(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HasActorNotBegunPlay");

	Params::RBBlueprintLibrary_HasActorNotBegunPlay Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.HashString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::HashString(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HashString");

	Params::RBBlueprintLibrary_HashString Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.HasPlayedTutorialMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::HasPlayedTutorialMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HasPlayedTutorialMap");

	Params::RBBlueprintLibrary_HasPlayedTutorialMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.HasPlayerUpgradeEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::HasPlayerUpgradeEffect(class ARBPlayer* Player, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HasPlayerUpgradeEffect");

	Params::RBBlueprintLibrary_HasPlayerUpgradeEffect Parms{};

	Parms.Player = Player;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.HideInteractionMessage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::HideInteractionMessage(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HideInteractionMessage");

	Params::RBBlueprintLibrary_HideInteractionMessage Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.HideInteractionMessageForAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::HideInteractionMessageForAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "HideInteractionMessageForAllPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ImportTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FileFullPath                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureCompressionSettings             CompressionSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::ImportTexture(class FString& FileFullPath, class FString& Filename, ETextureCompressionSettings CompressionSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ImportTexture");

	Params::RBBlueprintLibrary_ImportTexture Parms{};

	Parms.FileFullPath = std::move(FileFullPath);
	Parms.Filename = std::move(Filename);
	Parms.CompressionSettings = CompressionSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FileFullPath = std::move(Parms.FileFullPath);
	Filename = std::move(Parms.Filename);

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsActionMappingValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputActionKeyMapping           KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsActionMappingValid(const struct FInputActionKeyMapping& KeyMapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsActionMappingValid");

	Params::RBBlueprintLibrary_IsActionMappingValid Parms{};

	Parms.KeyMapping = std::move(KeyMapping);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsAxisMappingValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputAxisKeyMapping             KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsAxisMappingValid(const struct FInputAxisKeyMapping& KeyMapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsAxisMappingValid");

	Params::RBBlueprintLibrary_IsAxisMappingValid Parms{};

	Parms.KeyMapping = std::move(KeyMapping);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsClient
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsClient");

	Params::RBBlueprintLibrary_IsClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsConsideredSoloGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsConsideredSoloGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsConsideredSoloGame");

	Params::RBBlueprintLibrary_IsConsideredSoloGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsConsole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsConsole");

	Params::RBBlueprintLibrary_IsConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrGreaterThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsDifficultyEqualOrGreaterThan(EGameDifficulty Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsDifficultyEqualOrGreaterThan");

	Params::RBBlueprintLibrary_IsDifficultyEqualOrGreaterThan Parms{};

	Parms.Difficulty = Difficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrLessThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsDifficultyEqualOrLessThan(EGameDifficulty Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsDifficultyEqualOrLessThan");

	Params::RBBlueprintLibrary_IsDifficultyEqualOrLessThan Parms{};

	Parms.Difficulty = Difficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsDifficultyEqualTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsDifficultyEqualTo(EGameDifficulty Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsDifficultyEqualTo");

	Params::RBBlueprintLibrary_IsDifficultyEqualTo Parms{};

	Parms.Difficulty = Difficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsDifficultyGreaterThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsDifficultyGreaterThan(EGameDifficulty Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsDifficultyGreaterThan");

	Params::RBBlueprintLibrary_IsDifficultyGreaterThan Parms{};

	Parms.Difficulty = Difficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsDifficultyLessThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameDifficulty                         Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsDifficultyLessThan(EGameDifficulty Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsDifficultyLessThan");

	Params::RBBlueprintLibrary_IsDifficultyLessThan Parms{};

	Parms.Difficulty = Difficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 UniqueID1                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 UniqueID2                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsEqual(const struct FUniqueNetIdRepl& UniqueID1, const struct FUniqueNetIdRepl& UniqueID2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsEqual");

	Params::RBBlueprintLibrary_IsEqual Parms{};

	Parms.UniqueID1 = std::move(UniqueID1);
	Parms.UniqueID2 = std::move(UniqueID2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsExperimentStarted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsExperimentStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsExperimentStarted");

	Params::RBBlueprintLibrary_IsExperimentStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsHiddenInEditor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsHiddenInEditor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsHiddenInEditor");

	Params::RBBlueprintLibrary_IsHiddenInEditor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInBlueprintEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInBlueprintEditor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInBlueprintEditor");

	Params::RBBlueprintLibrary_IsInBlueprintEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInEditor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInEditor");

	Params::RBBlueprintLibrary_IsInEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInEditorOrCommandlet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInEditorOrCommandlet(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInEditorOrCommandlet");

	Params::RBBlueprintLibrary_IsInEditorOrCommandlet Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInPIE
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInPIE(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInPIE");

	Params::RBBlueprintLibrary_IsInPIE Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInReagentReleaseTrial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInReagentReleaseTrial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInReagentReleaseTrial");

	Params::RBBlueprintLibrary_IsInReagentReleaseTrial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsInTutorialStage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsInTutorialStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsInTutorialStage");

	Params::RBBlueprintLibrary_IsInTutorialStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsMissionIDEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBMissionID                     MissionID1                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID2                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsMissionIDEqual(const struct FRBMissionID& MissionID1, const struct FRBMissionID& MissionID2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsMissionIDEqual");

	Params::RBBlueprintLibrary_IsMissionIDEqual Parms{};

	Parms.MissionID1 = std::move(MissionID1);
	Parms.MissionID2 = std::move(MissionID2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsMissionIDValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsMissionIDValid(const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsMissionIDValid");

	Params::RBBlueprintLibrary_IsMissionIDValid Parms{};

	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsPlayInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsPlayInEditor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsPlayInEditor");

	Params::RBBlueprintLibrary_IsPlayInEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsProgramEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsProgramEnabled(const class FName& ProgramId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsProgramEnabled");

	Params::RBBlueprintLibrary_IsProgramEnabled Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsPropertyWidgetSelected
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InWidgetName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutWidgetIndex                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsPropertyWidgetSelected(class AActor* InActor, const class FString& InWidgetName, int32* OutWidgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsPropertyWidgetSelected");

	Params::RBBlueprintLibrary_IsPropertyWidgetSelected Parms{};

	Parms.InActor = InActor;
	Parms.InWidgetName = std::move(InWidgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidgetIndex != nullptr)
		*OutWidgetIndex = Parms.OutWidgetIndex;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsRecentEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsRecentEvent(float Time, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsRecentEvent");

	Params::RBBlueprintLibrary_IsRecentEvent Parms{};

	Parms.Time = Time;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsRecentServerEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsRecentServerEvent(float Time, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsRecentServerEvent");

	Params::RBBlueprintLibrary_IsRecentServerEvent Parms{};

	Parms.Time = Time;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsRunningFunctionalTests
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsRunningFunctionalTests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsRunningFunctionalTests");

	Params::RBBlueprintLibrary_IsRunningFunctionalTests Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsSoloMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsSoloMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsSoloMode");

	Params::RBBlueprintLibrary_IsSoloMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsSonyConsole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsSonyConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsSonyConsole");

	Params::RBBlueprintLibrary_IsSonyConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsStageIDEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBStageID                       StageID1                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBStageID                       StageID2                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsStageIDEqual(const struct FRBStageID& StageID1, const struct FRBStageID& StageID2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsStageIDEqual");

	Params::RBBlueprintLibrary_IsStageIDEqual Parms{};

	Parms.StageID1 = std::move(StageID1);
	Parms.StageID2 = std::move(StageID2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsStageIDValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsStageIDValid(const struct FRBStageID& StageID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsStageIDValid");

	Params::RBBlueprintLibrary_IsStageIDValid Parms{};

	Parms.StageID = std::move(StageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsStagePrepared
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsStagePrepared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsStagePrepared");

	Params::RBBlueprintLibrary_IsStagePrepared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsStageReady
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsStageReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsStageReady");

	Params::RBBlueprintLibrary_IsStageReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsStageStarted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsStageStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsStageStarted");

	Params::RBBlueprintLibrary_IsStageStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsTransactional
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsTransactional(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsTransactional");

	Params::RBBlueprintLibrary_IsTransactional Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsTransient
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsTransient(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsTransient");

	Params::RBBlueprintLibrary_IsTransient Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsTrialChainingMetaActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsTrialChainingMetaActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsTrialChainingMetaActive");

	Params::RBBlueprintLibrary_IsTrialChainingMetaActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsTrialEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsTrialEnabled(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsTrialEnabled");

	Params::RBBlueprintLibrary_IsTrialEnabled Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsUniqueVariatorTypeActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUniqueVariatorType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsUniqueVariatorTypeActive(EUniqueVariatorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsUniqueVariatorTypeActive");

	Params::RBBlueprintLibrary_IsUniqueVariatorTypeActive Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 UniqueId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsValid(const struct FUniqueNetIdRepl& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsValid");

	Params::RBBlueprintLibrary_IsValid Parms{};

	Parms.UniqueId = std::move(UniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsValidNPCForAuraVariator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBNPC*                           RBNPC                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsValidNPCForAuraVariator(class ARBNPC* RBNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsValidNPCForAuraVariator");

	Params::RBBlueprintLibrary_IsValidNPCForAuraVariator Parms{};

	Parms.RBNPC = RBNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsWaitingToStart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsWaitingToStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsWaitingToStart");

	Params::RBBlueprintLibrary_IsWaitingToStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsWorldPopulated
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsWorldPopulated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsWorldPopulated");

	Params::RBBlueprintLibrary_IsWorldPopulated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.IsWorldPopulatingOrPopulated
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::IsWorldPopulatingOrPopulated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "IsWorldPopulatingOrPopulated");

	Params::RBBlueprintLibrary_IsWorldPopulatingOrPopulated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LerpAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   AngleA                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::LerpAngle(const float AngleA, float AngleB, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LerpAngle");

	Params::RBBlueprintLibrary_LerpAngle Parms{};

	Parms.AngleA = AngleA;
	Parms.AngleB = AngleB;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LevelRandomBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::LevelRandomBool(int32 RandomizerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LevelRandomBool");

	Params::RBBlueprintLibrary_LevelRandomBool Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LevelRandomFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::LevelRandomFloat(int32 RandomizerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LevelRandomFloat");

	Params::RBBlueprintLibrary_LevelRandomFloat Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LevelRandomFloatRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::LevelRandomFloatRange(int32 RandomizerId, float MinValue, float MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LevelRandomFloatRange");

	Params::RBBlueprintLibrary_LevelRandomFloatRange Parms{};

	Parms.RandomizerId = RandomizerId;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LevelRandomInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::LevelRandomInt(int32 RandomizerId, int32 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LevelRandomInt");

	Params::RBBlueprintLibrary_LevelRandomInt Parms{};

	Parms.RandomizerId = RandomizerId;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LevelRandomIntRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::LevelRandomIntRange(int32 RandomizerId, int32 MinValue, int32 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LevelRandomIntRange");

	Params::RBBlueprintLibrary_LevelRandomIntRange Parms{};

	Parms.RandomizerId = RandomizerId;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.LogMovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::LogMovement(class ARBPawn* Pawn, const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "LogMovement");

	Params::RBBlueprintLibrary_LogMovement Parms{};

	Parms.Pawn = Pawn;
	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.MarkPackageDirty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::MarkPackageDirty(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "MarkPackageDirty");

	Params::RBBlueprintLibrary_MarkPackageDirty Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.MarkRenderStateDirty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::MarkRenderStateDirty(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "MarkRenderStateDirty");

	Params::RBBlueprintLibrary_MarkRenderStateDirty Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.NormalizeRotationAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBBlueprintLibrary::NormalizeRotationAngle(const float& Current)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "NormalizeRotationAngle");

	Params::RBBlueprintLibrary_NormalizeRotationAngle Parms{};

	Parms.Current = Current;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.PlayAnnouncerLine_Server
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVOBehavior                             VoBehavior                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrePlayQueueDelay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlayAnnouncerLine_Server(class UAkAudioEvent* AkEvent, EVOBehavior VoBehavior, float PrePlayQueueDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayAnnouncerLine_Server");

	Params::RBBlueprintLibrary_PlayAnnouncerLine_Server Parms{};

	Parms.AkEvent = AkEvent;
	Parms.VoBehavior = VoBehavior;
	Parms.PrePlayQueueDelay = PrePlayQueueDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlayLobbyMurkoffAnnouncement
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::PlayLobbyMurkoffAnnouncement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayLobbyMurkoffAnnouncement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlayLoopingMusicTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    StartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopLevelMusic                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlayLoopingMusicTrack(class UAkAudioEvent* StartEvent, class UAkAudioEvent* StopEvent, bool bStopLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayLoopingMusicTrack");

	Params::RBBlueprintLibrary_PlayLoopingMusicTrack Parms{};

	Parms.StartEvent = StartEvent;
	Parms.StopEvent = StopEvent;
	Parms.bStopLevelMusic = bStopLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlayLoopingSoundOnActor
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    StartAkEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StopAkEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBBlueprintLibrary::PlayLoopingSoundOnActor(class UAkAudioEvent* StartAkEvent, class UAkAudioEvent* StopAkEvent, class UObject* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayLoopingSoundOnActor");

	Params::RBBlueprintLibrary_PlayLoopingSoundOnActor Parms{};

	Parms.StartAkEvent = StartAkEvent;
	Parms.StopAkEvent = StopAkEvent;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.PlayMurkoffAnnouncement
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRBMurkoffAnnouncentData         AnnouncementData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StopDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlayMurkoffAnnouncement(const struct FRBMurkoffAnnouncentData& AnnouncementData, class UAkAudioEvent* StopEvent, float StopDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayMurkoffAnnouncement");

	Params::RBBlueprintLibrary_PlayMurkoffAnnouncement Parms{};

	Parms.AnnouncementData = std::move(AnnouncementData);
	Parms.StopEvent = StopEvent;
	Parms.StopDelay = StopDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlayObjectiveNarrativeScreenAnimation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNarrativeScreenAnimationData    AnimData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlayerDefaultIntro                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlayObjectiveNarrativeScreenAnimation(const struct FNarrativeScreenAnimationData& AnimData, bool bPlayerDefaultIntro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayObjectiveNarrativeScreenAnimation");

	Params::RBBlueprintLibrary_PlayObjectiveNarrativeScreenAnimation Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.bPlayerDefaultIntro = bPlayerDefaultIntro;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlayScareStinger
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ScareActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StingerEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlayScareStinger(class AActor* ScareActor, class UAkAudioEvent* StingerEvent, const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlayScareStinger");

	Params::RBBlueprintLibrary_PlayScareStinger Parms{};

	Parms.ScareActor = ScareActor;
	Parms.StingerEvent = StingerEvent;
	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PlaySingleShotMusicTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    MusicTrack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPauseLevelMusic                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PlaySingleShotMusicTrack(class UAkAudioEvent* MusicTrack, bool bPauseLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PlaySingleShotMusicTrack");

	Params::RBBlueprintLibrary_PlaySingleShotMusicTrack Parms{};

	Parms.MusicTrack = MusicTrack;
	Parms.bPauseLevelMusic = bPauseLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PostAudioEventOnGroup_Client
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PostAudioEventOnGroup_Client(class UAkAudioEvent* AkEvent, class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PostAudioEventOnGroup_Client");

	Params::RBBlueprintLibrary_PostAudioEventOnGroup_Client Parms{};

	Parms.AkEvent = AkEvent;
	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.PrintScreenMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::PrintScreenMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "PrintScreenMessage");

	Params::RBBlueprintLibrary_PrintScreenMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.RandomizeActorArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URBBlueprintLibrary::RandomizeActorArray(int32 RandomizerId, const TArray<class AActor*>& InActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RandomizeActorArray");

	Params::RBBlueprintLibrary_RandomizeActorArray Parms{};

	Parms.RandomizerId = RandomizerId;
	Parms.InActors = std::move(InActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.RemoveActorTagToSelectedActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::RemoveActorTagToSelectedActors(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RemoveActorTagToSelectedActors");

	Params::RBBlueprintLibrary_RemoveActorTagToSelectedActors Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.RemoveObjectiveIcon
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::RemoveObjectiveIcon(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RemoveObjectiveIcon");

	Params::RBBlueprintLibrary_RemoveObjectiveIcon Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.RemoveObjectiveIconForSpecificPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::RemoveObjectiveIconForSpecificPlayer(class ARBPlayer* Player, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RemoveObjectiveIconForSpecificPlayer");

	Params::RBBlueprintLibrary_RemoveObjectiveIconForSpecificPlayer Parms{};

	Parms.Player = Player;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.RemovePing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PingedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::RemovePing(class AActor* PingedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RemovePing");

	Params::RBBlueprintLibrary_RemovePing Parms{};

	Parms.PingedActor = PingedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.RotatorToQuaternion
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat URBBlueprintLibrary::RotatorToQuaternion(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RotatorToQuaternion");

	Params::RBBlueprintLibrary_RotatorToQuaternion Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.RunConstructionScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::RunConstructionScript(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "RunConstructionScript");

	Params::RBBlueprintLibrary_RunConstructionScript Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SaveProfile
// (Final, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::SaveProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SaveProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SeekOnEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           In_EventName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkComponent*                     In_pComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   In_fPercent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    In_bSeekToNearestMarker                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SeekOnEvent(const class FString& In_EventName, class UAkComponent* In_pComponent, float In_fPercent, bool In_bSeekToNearestMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SeekOnEvent");

	Params::RBBlueprintLibrary_SeekOnEvent Parms{};

	Parms.In_EventName = std::move(In_EventName);
	Parms.In_pComponent = In_pComponent;
	Parms.In_fPercent = In_fPercent;
	Parms.In_bSeekToNearestMarker = In_bSeekToNearestMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Select3DWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PropertyIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPropertyTransform                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Select3DWidget(const class FString& PropertyName, int32 PropertyIndex, bool bIsPropertyTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Select3DWidget");

	Params::RBBlueprintLibrary_Select3DWidget Parms{};

	Parms.PropertyName = std::move(PropertyName);
	Parms.PropertyIndex = PropertyIndex;
	Parms.bIsPropertyTransform = bIsPropertyTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SelectActorsInEditor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bClearSelection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SelectActorsInEditor(const TArray<class AActor*>& Actors, bool bClearSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SelectActorsInEditor");

	Params::RBBlueprintLibrary_SelectActorsInEditor Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bClearSelection = bClearSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SelectActorsWithTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SelectActorsWithTag(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SelectActorsWithTag");

	Params::RBBlueprintLibrary_SelectActorsWithTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SelectComponentsInEditor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UActorComponent*>          Components                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bClearSelection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SelectComponentsInEditor(const TArray<class UActorComponent*>& Components, bool bClearSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SelectComponentsInEditor");

	Params::RBBlueprintLibrary_SelectComponentsInEditor Parms{};

	Parms.Components = std::move(Components);
	Parms.bClearSelection = bClearSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SelectInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SelectInEditor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SelectInEditor");

	Params::RBBlueprintLibrary_SelectInEditor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Set3DWidgetEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWidgetEnabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Set3DWidgetEnabled(class AActor* Actor, class FName PropertyName, bool bWidgetEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Set3DWidgetEnabled");

	Params::RBBlueprintLibrary_Set3DWidgetEnabled Parms{};

	Parms.Actor = Actor;
	Parms.PropertyName = PropertyName;
	Parms.bWidgetEnabled = bWidgetEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetActorCastStaticShadow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCastStaticShadow                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetActorCastStaticShadow(class AActor* Actor, bool bCastStaticShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetActorCastStaticShadow");

	Params::RBBlueprintLibrary_SetActorCastStaticShadow Parms{};

	Parms.Actor = Actor;
	Parms.bCastStaticShadow = bCastStaticShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetActorTemporarilyHiddenInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetActorTemporarilyHiddenInEditor(class AActor* TargetActor, bool bIsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetActorTemporarilyHiddenInEditor");

	Params::RBBlueprintLibrary_SetActorTemporarilyHiddenInEditor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bIsHidden = bIsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetCanStepUpon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECanBeCharacterBase                     CanStepUponValue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetCanStepUpon(class USceneComponent* SceneComponent, ECanBeCharacterBase CanStepUponValue, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetCanStepUpon");

	Params::RBBlueprintLibrary_SetCanStepUpon Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.CanStepUponValue = CanStepUponValue;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetCollisionEnabledOnHierarchy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionEnabled                       NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetCollisionEnabledOnHierarchy(class USceneComponent* SceneComponent, ECollisionEnabled NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetCollisionEnabledOnHierarchy");

	Params::RBBlueprintLibrary_SetCollisionEnabledOnHierarchy Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.NewType = NewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetDoNotGenerateAutomaticUVs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetDoNotGenerateAutomaticUVs(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetDoNotGenerateAutomaticUVs");

	Params::RBBlueprintLibrary_SetDoNotGenerateAutomaticUVs Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetForceNoVolumetricLightmapsOnHierarchy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceNoVolumetricLightMap                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetForceNoVolumetricLightmapsOnHierarchy(class USceneComponent* SceneComponent, bool bForceNoVolumetricLightMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetForceNoVolumetricLightmapsOnHierarchy");

	Params::RBBlueprintLibrary_SetForceNoVolumetricLightmapsOnHierarchy Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.bForceNoVolumetricLightMap = bForceNoVolumetricLightMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetGlobalAudioRTPC
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RtpcName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetGlobalAudioRTPC(class FName RtpcName, float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetGlobalAudioRTPC");

	Params::RBBlueprintLibrary_SetGlobalAudioRTPC Parms{};

	Parms.RtpcName = RtpcName;
	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetGlobalAudioState
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StateGroup                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetGlobalAudioState(class FName StateGroup, class FName StateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetGlobalAudioState");

	Params::RBBlueprintLibrary_SetGlobalAudioState Parms{};

	Parms.StateGroup = StateGroup;
	Parms.StateValue = StateValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetHasCompletedReleaseTrial
// (Final, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::SetHasCompletedReleaseTrial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetHasCompletedReleaseTrial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetHasPlayedTutorialMap
// (Final, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::SetHasPlayedTutorialMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetHasPlayedTutorialMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetHiddenInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetHiddenInEditor(class AActor* Actor, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetHiddenInEditor");

	Params::RBBlueprintLibrary_SetHiddenInEditor Parms{};

	Parms.Actor = Actor;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetLevelMusic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UAkAudioEvent*>            StartEvents                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UAkAudioEvent*>            StopEvents                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetLevelMusic(const TArray<class UAkAudioEvent*>& StartEvents, const TArray<class UAkAudioEvent*>& StopEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetLevelMusic");

	Params::RBBlueprintLibrary_SetLevelMusic Parms{};

	Parms.StartEvents = std::move(StartEvents);
	Parms.StopEvents = std::move(StopEvents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetListenAtPlayerLocation
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          RequestOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bListenAtPlayerLocation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetListenAtPlayerLocation(class UObject* RequestOwner, bool bListenAtPlayerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetListenAtPlayerLocation");

	Params::RBBlueprintLibrary_SetListenAtPlayerLocation Parms{};

	Parms.RequestOwner = RequestOwner;
	Parms.bListenAtPlayerLocation = bListenAtPlayerLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetNarrativeMusicClient
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNarrativeSoundEventsInfo        NarrativeSoundEventsInfo                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetNarrativeMusicClient(const struct FNarrativeSoundEventsInfo& NarrativeSoundEventsInfo, const class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetNarrativeMusicClient");

	Params::RBBlueprintLibrary_SetNarrativeMusicClient Parms{};

	Parms.NarrativeSoundEventsInfo = std::move(NarrativeSoundEventsInfo);
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetNarrativeMusicServer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNarrativeSoundEventsInfo        NarrativeSoundEventsInfo                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPauseLevelMusic                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetNarrativeMusicServer(const struct FNarrativeSoundEventsInfo& NarrativeSoundEventsInfo, bool bPauseLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetNarrativeMusicServer");

	Params::RBBlueprintLibrary_SetNarrativeMusicServer Parms{};

	Parms.NarrativeSoundEventsInfo = std::move(NarrativeSoundEventsInfo);
	Parms.bPauseLevelMusic = bPauseLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetNetworkSyncState
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetNetworkSyncState(class AActor* Actor, bool bActive, bool bChain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetNetworkSyncState");

	Params::RBBlueprintLibrary_SetNetworkSyncState Parms{};

	Parms.Actor = Actor;
	Parms.bActive = bActive;
	Parms.bChain = bChain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetNVBattery
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetNVBattery(class ARBPlayer* Player, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetNVBattery");

	Params::RBBlueprintLibrary_SetNVBattery Parms{};

	Parms.Player = Player;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetSwitchGlobal
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SwitchGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SwitchState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetSwitchGlobal(class FName SwitchGroup, class FName SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetSwitchGlobal");

	Params::RBBlueprintLibrary_SetSwitchGlobal Parms{};

	Parms.SwitchGroup = SwitchGroup;
	Parms.SwitchState = SwitchState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              DisableMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetupDisabledHidespotMeshCollision(class UPrimitiveComponent* DisableMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetupDisabledHidespotMeshCollision");

	Params::RBBlueprintLibrary_SetupDisabledHidespotMeshCollision Parms{};

	Parms.DisableMeshComponent = DisableMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshesCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  DisabledRoot                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetupDisabledHidespotMeshesCollision(class USceneComponent* DisabledRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetupDisabledHidespotMeshesCollision");

	Params::RBBlueprintLibrary_SetupDisabledHidespotMeshesCollision Parms{};

	Parms.DisabledRoot = DisabledRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SetupMasterPose
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MasterPoseComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SetupMasterPose(class USkeletalMeshComponent* MasterPoseComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SetupMasterPose");

	Params::RBBlueprintLibrary_SetupMasterPose Parms{};

	Parms.MasterPoseComponent = MasterPoseComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ShowInteractionMessage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EMessagePriority                        Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ShowInteractionMessage(class ARBPlayer* Player, const class FText& Message, EMessagePriority Priority, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ShowInteractionMessage");

	Params::RBBlueprintLibrary_ShowInteractionMessage Parms{};

	Parms.Player = Player;
	Parms.Message = std::move(Message);
	Parms.Priority = Priority;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ShowInteractionMessageToAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EMessagePriority                        Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ShowInteractionMessageToAllPlayers(const class FText& Message, EMessagePriority Priority, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ShowInteractionMessageToAllPlayers");

	Params::RBBlueprintLibrary_ShowInteractionMessageToAllPlayers Parms{};

	Parms.Message = std::move(Message);
	Parms.Priority = Priority;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ShowObjectiveMessage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlaySounds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ShowObjectiveMessage(class UObject* WorldContextObject, const class FText& Message, float Duration, bool PlaySounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ShowObjectiveMessage");

	Params::RBBlueprintLibrary_ShowObjectiveMessage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Message = std::move(Message);
	Parms.Duration = Duration;
	Parms.PlaySounds = PlaySounds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SortByName
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  InObjects                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> URBBlueprintLibrary::SortByName(const TArray<class UObject*>& InObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SortByName");

	Params::RBBlueprintLibrary_SortByName Parms{};

	Parms.InObjects = std::move(InObjects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.SortCompareActorsByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::SortCompareActorsByName(const class AActor* ActorA, const class AActor* ActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SortCompareActorsByName");

	Params::RBBlueprintLibrary_SortCompareActorsByName Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.SortCompareString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           StringA                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StringB                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::SortCompareString(const class FString& StringA, const class FString& StringB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SortCompareString");

	Params::RBBlueprintLibrary_SortCompareString Parms{};

	Parms.StringA = std::move(StringA);
	Parms.StringB = std::move(StringB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.StartPsychosisOnAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class URBHalluCfg_Psychosis*            PsychosisConfig                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::StartPsychosisOnAllPlayers(class URBHalluCfg_Psychosis* PsychosisConfig, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StartPsychosisOnAllPlayers");

	Params::RBBlueprintLibrary_StartPsychosisOnAllPlayers Parms{};

	Parms.PsychosisConfig = PsychosisConfig;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopAllMusic
// (Final, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::StopAllMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopAllMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopAllSounds
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::StopAllSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopAllSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopAllTimersOnObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          TimerOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::StopAllTimersOnObject(class UObject* TimerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopAllTimersOnObject");

	Params::RBBlueprintLibrary_StopAllTimersOnObject Parms{};

	Parms.TimerOwner = TimerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopLoopingSoundOnActor
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    StartAkEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StopAkEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::StopLoopingSoundOnActor(class UAkAudioEvent* StartAkEvent, class UAkAudioEvent* StopAkEvent, class UObject* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopLoopingSoundOnActor");

	Params::RBBlueprintLibrary_StopLoopingSoundOnActor Parms{};

	Parms.StartAkEvent = StartAkEvent;
	Parms.StopAkEvent = StopAkEvent;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopMusicTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    StartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResumeLevelMusic                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::StopMusicTrack(class UAkAudioEvent* StartEvent, class UAkAudioEvent* StopEvent, bool bResumeLevelMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopMusicTrack");

	Params::RBBlueprintLibrary_StopMusicTrack Parms{};

	Parms.StartEvent = StartEvent;
	Parms.StopEvent = StopEvent;
	Parms.bResumeLevelMusic = bResumeLevelMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.StopPsychosisOnAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bFadeOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::StopPsychosisOnAllPlayers(bool bFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "StopPsychosisOnAllPlayers");

	Params::RBBlueprintLibrary_StopPsychosisOnAllPlayers Parms{};

	Parms.bFadeOut = bFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.SwitchLevelRandom2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERandomSwitch2                          RandomSwitch                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SwitchLevelRandom2(int32 RandomizerId, ERandomSwitch2* RandomSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SwitchLevelRandom2");

	Params::RBBlueprintLibrary_SwitchLevelRandom2 Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomSwitch != nullptr)
		*RandomSwitch = Parms.RandomSwitch;
}


// Function OPP.RBBlueprintLibrary.SwitchLevelRandom3
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERandomSwitch3                          RandomSwitch                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SwitchLevelRandom3(int32 RandomizerId, ERandomSwitch3* RandomSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SwitchLevelRandom3");

	Params::RBBlueprintLibrary_SwitchLevelRandom3 Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomSwitch != nullptr)
		*RandomSwitch = Parms.RandomSwitch;
}


// Function OPP.RBBlueprintLibrary.SwitchLevelRandom4
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERandomSwitch4                          RandomSwitch                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SwitchLevelRandom4(int32 RandomizerId, ERandomSwitch4* RandomSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SwitchLevelRandom4");

	Params::RBBlueprintLibrary_SwitchLevelRandom4 Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomSwitch != nullptr)
		*RandomSwitch = Parms.RandomSwitch;
}


// Function OPP.RBBlueprintLibrary.SwitchLevelRandom5
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERandomSwitch5                          RandomSwitch                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SwitchLevelRandom5(int32 RandomizerId, ERandomSwitch5* RandomSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SwitchLevelRandom5");

	Params::RBBlueprintLibrary_SwitchLevelRandom5 Parms{};

	Parms.RandomizerId = RandomizerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomSwitch != nullptr)
		*RandomSwitch = Parms.RandomSwitch;
}


// Function OPP.RBBlueprintLibrary.SwitchLevelRandomN
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RandomizerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxOptions                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERandomSwitch10                         RandomSwitch                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::SwitchLevelRandomN(int32 RandomizerId, int32 MaxOptions, ERandomSwitch10* RandomSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "SwitchLevelRandomN");

	Params::RBBlueprintLibrary_SwitchLevelRandomN Parms{};

	Parms.RandomizerId = RandomizerId;
	Parms.MaxOptions = MaxOptions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomSwitch != nullptr)
		*RandomSwitch = Parms.RandomSwitch;
}


// Function OPP.RBBlueprintLibrary.TeleportPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTransitionFX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTargetForRotation                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterruptAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::TeleportPlayer(class ARBPlayer* Player, const class AActor* TargetLocation, bool bUseTransitionFX, bool bUseTargetForRotation, bool bInterruptAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "TeleportPlayer");

	Params::RBBlueprintLibrary_TeleportPlayer Parms{};

	Parms.Player = Player;
	Parms.TargetLocation = TargetLocation;
	Parms.bUseTransitionFX = bUseTransitionFX;
	Parms.bUseTargetForRotation = bUseTargetForRotation;
	Parms.bInterruptAction = bInterruptAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.TeleportRelative
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceReference                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetReference                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTransitionFX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::TeleportRelative(class ARBPlayer* Player, const class AActor* SourceReference, const class AActor* TargetReference, bool bUseTransitionFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "TeleportRelative");

	Params::RBBlueprintLibrary_TeleportRelative Parms{};

	Parms.Player = Player;
	Parms.SourceReference = SourceReference;
	Parms.TargetReference = TargetReference;
	Parms.bUseTransitionFX = bUseTransitionFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.TestPlayerConditions
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoolCommandResult                      OperationResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerConditionSet            ConditionSet                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::TestPlayerConditions(class ARBPlayer* Player, EBoolCommandResult* OperationResult, const struct FRBPlayerConditionSet& ConditionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "TestPlayerConditions");

	Params::RBBlueprintLibrary_TestPlayerConditions Parms{};

	Parms.Player = Player;
	Parms.ConditionSet = std::move(ConditionSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OperationResult != nullptr)
		*OperationResult = Parms.OperationResult;
}


// Function OPP.RBBlueprintLibrary.ToggleActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ToggleActor(class AActor* Actor, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ToggleActor");

	Params::RBBlueprintLibrary_ToggleActor Parms{};

	Parms.Actor = Actor;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ToggleDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)

void URBBlueprintLibrary::ToggleDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ToggleDebugMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ToggleLedgeMarkerOnActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::ToggleLedgeMarkerOnActor(class AActor* Actor, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ToggleLedgeMarkerOnActor");

	Params::RBBlueprintLibrary_ToggleLedgeMarkerOnActor Parms{};

	Parms.Actor = Actor;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.ToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 UniqueId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBBlueprintLibrary::ToString(const struct FUniqueNetIdRepl& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "ToString");

	Params::RBBlueprintLibrary_ToString Parms{};

	Parms.UniqueId = std::move(UniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.TryPlayFacialAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBBlueprintLibrary::TryPlayFacialAnim(class UObject* Target, const class FString& LineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "TryPlayFacialAnim");

	Params::RBBlueprintLibrary_TryPlayFacialAnim Parms{};

	Parms.Target = Target;
	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBlueprintLibrary.UnblockPlayerRespawnInStage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          blockOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::UnblockPlayerRespawnInStage(class UObject* blockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "UnblockPlayerRespawnInStage");

	Params::RBBlueprintLibrary_UnblockPlayerRespawnInStage Parms{};

	Parms.blockOwner = blockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.WaitForPlayerConditions
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRBPlayerConditionSet            ConditionSet                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::WaitForPlayerConditions(class ARBPlayer* Player, const struct FLatentActionInfo& LatentInfo, const struct FRBPlayerConditionSet& ConditionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "WaitForPlayerConditions");

	Params::RBBlueprintLibrary_WaitForPlayerConditions Parms{};

	Parms.Player = Player;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ConditionSet = std::move(ConditionSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBlueprintLibrary.Warning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           WarningText                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBlueprintLibrary::Warning(const class FString& WarningText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBBlueprintLibrary", "Warning");

	Params::RBBlueprintLibrary_Warning Parms{};

	Parms.WarningText = std::move(WarningText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBot.ReleaseFromAIDirector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCancelRetirement                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBot::ReleaseFromAIDirector(bool bCancelRetirement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBot", "ReleaseFromAIDirector");

	Params::RBBot_ReleaseFromAIDirector Parms{};

	Parms.bCancelRetirement = bCancelRetirement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBot.BP_GetDebugPawnName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBBot::BP_GetDebugPawnName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBot", "BP_GetDebugPawnName");

	Params::RBBot_BP_GetDebugPawnName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBot.CanReleaseFromAIDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBot::CanReleaseFromAIDirector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBot", "CanReleaseFromAIDirector");

	Params::RBBot_CanReleaseFromAIDirector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBot.GetAwarenessStateType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIAwarenessStateType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIAwarenessStateType ARBBot::GetAwarenessStateType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBot", "GetAwarenessStateType");

	Params::RBBot_GetAwarenessStateType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBot.GetCurrentActivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIActivity                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIActivity ARBBot::GetCurrentActivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBot", "GetCurrentActivity");

	Params::RBBot_GetCurrentActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTaskConditionContext_Health.OnPlayerHealthChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskConditionContext_Health::OnPlayerHealthChanged(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskConditionContext_Health", "OnPlayerHealthChanged");

	Params::RBTaskConditionContext_Health_OnPlayerHealthChanged Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoObjectiveCoordinator.Multicast_OnNewHotPotatoSpawned
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBHotPotato*                     NewHotPotato                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotatoObjectiveCoordinator::Multicast_OnNewHotPotatoSpawned(class ARBHotPotato* NewHotPotato)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoObjectiveCoordinator", "Multicast_OnNewHotPotatoSpawned");

	Params::RBHotPotatoObjectiveCoordinator_Multicast_OnNewHotPotatoSpawned Parms{};

	Parms.NewHotPotato = NewHotPotato;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoObjectiveProgressChanged
// (Final, Native, Public)
// Parameters:
// class ARBHotPotato*                     HotPotato                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotatoObjectiveCoordinator::OnHotPotatoObjectiveProgressChanged(class ARBHotPotato* HotPotato, float NewProgress, float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoObjectiveCoordinator", "OnHotPotatoObjectiveProgressChanged");

	Params::RBHotPotatoObjectiveCoordinator_OnHotPotatoObjectiveProgressChanged Parms{};

	Parms.HotPotato = HotPotato;
	Parms.NewProgress = NewProgress;
	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoStateChanged
// (Final, Native, Public)
// Parameters:
// class ARBHotPotato*                     HotPotato                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHotPotatoState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotatoObjectiveCoordinator::OnHotPotatoStateChanged(class ARBHotPotato* HotPotato, EHotPotatoState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoObjectiveCoordinator", "OnHotPotatoStateChanged");

	Params::RBHotPotatoObjectiveCoordinator_OnHotPotatoStateChanged Parms{};

	Parms.HotPotato = HotPotato;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoObjectiveCoordinator.OnRep_CurrentHotPotatos
// (Final, Native, Public)

void ARBHotPotatoObjectiveCoordinator::OnRep_CurrentHotPotatos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoObjectiveCoordinator", "OnRep_CurrentHotPotatos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBoxNavMeshBlockingComponent.OnRep_CurrentlyBlocking
// (Final, Native, Private)

void URBBoxNavMeshBlockingComponent::OnRep_CurrentlyBlocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBoxNavMeshBlockingComponent", "OnRep_CurrentlyBlocking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBoxNavMeshBlockingComponent.RecomputeTransform
// (Final, Native, Public, BlueprintCallable)

void URBBoxNavMeshBlockingComponent::RecomputeTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBoxNavMeshBlockingComponent", "RecomputeTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBoxNavMeshBlockingComponent.SetBlocking
// (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bBlockingValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBBoxNavMeshBlockingComponent::SetBlocking(bool bBlockingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBoxNavMeshBlockingComponent", "SetBlocking");

	Params::RBBoxNavMeshBlockingComponent_SetBlocking Parms{};

	Parms.bBlockingValue = bBlockingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskManager.OnFeatureSwitchOverridesUpdated
// (Final, Native, Private)

void ARBTaskManager::OnFeatureSwitchOverridesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskManager", "OnFeatureSwitchOverridesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskManager.OnPlayerProgressionReceived
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTaskManager::OnPlayerProgressionReceived(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskManager", "OnPlayerProgressionReceived");

	Params::RBTaskManager_OnPlayerProgressionReceived Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbActivatedTriggerable.OnBreadcrumbStopOperating
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbActivatedTriggerable::OnBreadcrumbStopOperating(class ARBPawn* Interactor, class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbActivatedTriggerable", "OnBreadcrumbStopOperating");

	Params::RBBreadcrumbActivatedTriggerable_OnBreadcrumbStopOperating Parms{};

	Parms.Interactor = Interactor;
	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbActivatedTriggerable.OnRep_ChosenBreadcrumbScenario
// (Final, Native, Private)

void ARBBreadcrumbActivatedTriggerable::OnRep_ChosenBreadcrumbScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbActivatedTriggerable", "OnRep_ChosenBreadcrumbScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnInteractibleAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbSwitchesCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnInteractibleAddedToWorld");

	Params::RBBreadcrumbSwitchesCoordinator_OnInteractibleAddedToWorld Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnLargeObjectInteractionDoAction
// (Native, Protected)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*LargeObjectPanel                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbSwitchesCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* LargeObjectPanel, class ARBLargePickup* LargePickup, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnLargeObjectInteractionDoAction");

	Params::RBBreadcrumbSwitchesCoordinator_OnLargeObjectInteractionDoAction Parms{};

	Parms.LargeObjectPanel = LargeObjectPanel;
	Parms.LargePickup = LargePickup;
	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnLargePickupUsed_Server
// (Final, Native, Protected)
// Parameters:
// class ARBLargePickup*                   Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbSwitchesCoordinator::OnLargePickupUsed_Server(class ARBLargePickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnLargePickupUsed_Server");

	Params::RBBreadcrumbSwitchesCoordinator_OnLargePickupUsed_Server Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnLargePickupUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbSwitchesCoordinator::OnLargePickupUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnLargePickupUsedOnObject");

	Params::RBBreadcrumbSwitchesCoordinator_OnLargePickupUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreadcrumbSwitchesCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnPickupHolderChanged");

	Params::RBBreadcrumbSwitchesCoordinator_OnPickupHolderChanged Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreadcrumbSwitchesCoordinator.OnRep_AvailableLargePickups
// (Final, Native, Protected)

void ARBBreadcrumbSwitchesCoordinator::OnRep_AvailableLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreadcrumbSwitchesCoordinator", "OnRep_AvailableLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrapDart.BP_DoesDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTrapDart::BP_DoesDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_DoesDamage");

	Params::RBTrapDart_BP_DoesDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrapDart.BP_DoesPsychosis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTrapDart::BP_DoesPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_DoesPsychosis");

	Params::RBTrapDart_BP_DoesPsychosis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrapDart.BP_Launch
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTrapDart::BP_Launch(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_Launch");

	Params::RBTrapDart_BP_Launch Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrapDart.BP_OnDetachFromPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTrapDart::BP_OnDetachFromPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnDetachFromPlayer");

	Params::RBTrapDart_BP_OnDetachFromPlayer Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrapDart.BP_OnHitPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTrapDart::BP_OnHitPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnHitPlayer");

	Params::RBTrapDart_BP_OnHitPlayer Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrapDart.BP_OnLaunchEvent
// (Event, Public, BlueprintEvent)

void ARBTrapDart::BP_OnLaunchEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnLaunchEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrapDart.BP_OnPlayerDamage
// (Event, Public, BlueprintEvent)

void ARBTrapDart::BP_OnPlayerDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnPlayerDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrapDart.BP_OnPlayerPsychosis
// (Event, Public, BlueprintEvent)

void ARBTrapDart::BP_OnPlayerPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnPlayerPsychosis");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrapDart.BP_OnReachedMaxLimitServer
// (Event, Public, BlueprintEvent)

void ARBTrapDart::BP_OnReachedMaxLimitServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "BP_OnReachedMaxLimitServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrapDart.Multicast_TriggerTrap
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bInitial                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTrapDart::Multicast_TriggerTrap(bool bInitial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "Multicast_TriggerTrap");

	Params::RBTrapDart_Multicast_TriggerTrap Parms{};

	Parms.bInitial = bInitial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrapDart.OnPawnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBTrapDart::OnPawnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "OnPawnBeginOverlap");

	Params::RBTrapDart_OnPawnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrapDart.OnRep_Launched
// (Final, Native, Public)

void ARBTrapDart::OnRep_Launched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapDart", "OnRep_Launched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableObstacle.BrokenChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakableObstacle::BrokenChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "BrokenChangedCallback");

	Params::RBBreakableObstacle_BrokenChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableObstacle.Event_OnBreakObject
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakableObstacle::Event_OnBreakObject(class AActor* SourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "Event_OnBreakObject");

	Params::RBBreakableObstacle_Event_OnBreakObject Parms{};

	Parms.SourceActor = SourceActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBBreakableObstacle.Event_OnStateChanged
// (Event, Public, BlueprintEvent)

void ARBBreakableObstacle::Event_OnStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "Event_OnStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBreakableObstacle.OnBreak
// (Native, Protected)
// Parameters:
// class URBDamageableComponent*           DamageComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakableObstacle::OnBreak(class URBDamageableComponent* DamageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "OnBreak");

	Params::RBBreakableObstacle_OnBreak Parms{};

	Parms.DamageComponent = DamageComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableObstacle.OnRep_Broken
// (Final, Native, Public)

void ARBBreakableObstacle::OnRep_Broken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "OnRep_Broken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableObstacle.OnRep_CurrentlyEnabled
// (Final, Native, Protected)

void ARBBreakableObstacle::OnRep_CurrentlyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "OnRep_CurrentlyEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableObstacle.BP_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBreakableObstacle::BP_IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "BP_IsActive");

	Params::RBBreakableObstacle_BP_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBreakableObstacle.BP_IsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBreakableObstacle::BP_IsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "BP_IsBroken");

	Params::RBBreakableObstacle_BP_IsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBreakableObstacle.IsBlocked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBBreakableObstacle::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableObstacle", "IsBlocked");

	Params::RBBreakableObstacle_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBreakableWindowReplaceableClass.OnReplacedWindow
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBBreakableWindow*               Window                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBBreakableWindowReplaceableClass::OnReplacedWindow(class ARBBreakableWindow* Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindowReplaceableClass", "OnReplacedWindow");

	Params::RBBreakableWindowReplaceableClass_OnReplacedWindow Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureObjectiveCoordinator.OnPanelActiveChangedEvent
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureObjectiveCoordinator::OnPanelActiveChangedEvent(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureObjectiveCoordinator", "OnPanelActiveChangedEvent");

	Params::RBTortureObjectiveCoordinator_OnPanelActiveChangedEvent Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureObjectiveCoordinator", "OnPanelPawnInteractingChangedEvent");

	Params::RBTortureObjectiveCoordinator_OnPanelPawnInteractingChangedEvent Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureObjectiveCoordinator.OnRep_TortureRoom
// (Final, Native, Protected)
// Parameters:
// class ARBTortureRoom*                   OldTortureRoom                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureObjectiveCoordinator::OnRep_TortureRoom(class ARBTortureRoom* OldTortureRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureObjectiveCoordinator", "OnRep_TortureRoom");

	Params::RBTortureObjectiveCoordinator_OnRep_TortureRoom Parms{};

	Parms.OldTortureRoom = OldTortureRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCompleted
// (Final, Native, Protected)
// Parameters:
// class ARBTortureRoom*                   Param_TortureRoom                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureObjectiveCoordinator::OnTortureRoomCompleted(class ARBTortureRoom* Param_TortureRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureObjectiveCoordinator", "OnTortureRoomCompleted");

	Params::RBTortureObjectiveCoordinator_OnTortureRoomCompleted Parms{};

	Parms.Param_TortureRoom = Param_TortureRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCurrentMeterChanged
// (Final, Native, Protected)
// Parameters:
// class ARBTortureRoom*                   Param_TortureRoom                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTortureObjectiveCoordinator::OnTortureRoomCurrentMeterChanged(class ARBTortureRoom* Param_TortureRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTortureObjectiveCoordinator", "OnTortureRoomCurrentMeterChanged");

	Params::RBTortureObjectiveCoordinator_OnTortureRoomCurrentMeterChanged Parms{};

	Parms.Param_TortureRoom = Param_TortureRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.BP_ForceBlockableState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EBlockableState                         InBlockableState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakableWindow::BP_ForceBlockableState(EBlockableState InBlockableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "BP_ForceBlockableState");

	Params::RBBreakableWindow_BP_ForceBlockableState Parms{};

	Parms.InBlockableState = InBlockableState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.Editor_RefreshGroundDetection
// (Final, Native, Public)

void ARBBreakableWindow::Editor_RefreshGroundDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "Editor_RefreshGroundDetection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.Event_OnBlockableStateChanged
// (Event, Public, BlueprintEvent)

void ARBBreakableWindow::Event_OnBlockableStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "Event_OnBlockableStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBreakableWindow.Event_OnShutterStateChanged
// (Event, Public, BlueprintEvent)

void ARBBreakableWindow::Event_OnShutterStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "Event_OnShutterStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBBreakableWindow.OnLinkedShutterStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakableWindow::OnLinkedShutterStateChanged(bool IsOn, class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "OnLinkedShutterStateChanged");

	Params::RBBreakableWindow_OnLinkedShutterStateChanged Parms{};

	Parms.IsOn = IsOn;
	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.OnRep_BlockableState
// (Final, Native, Protected)

void ARBBreakableWindow::OnRep_BlockableState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "OnRep_BlockableState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.OnRep_DynamicallyReplaced
// (Final, Native, Public)

void ARBBreakableWindow::OnRep_DynamicallyReplaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "OnRep_DynamicallyReplaced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.OnRep_ShutterClosed
// (Final, Native, Protected)

void ARBBreakableWindow::OnRep_ShutterClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "OnRep_ShutterClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakableWindow.GetBlockableState
// (Native, Public, Const)
// Parameters:
// EBlockableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlockableState ARBBreakableWindow::GetBlockableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakableWindow", "GetBlockableState");

	Params::RBBreakableWindow_GetBlockableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBBreakActorsCoordinator.Multicast_OnBreakableDestroyed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           breakable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakActorsCoordinator::Multicast_OnBreakableDestroyed(class ARBPlayer* Player, class AActor* breakable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakActorsCoordinator", "Multicast_OnBreakableDestroyed");

	Params::RBBreakActorsCoordinator_Multicast_OnBreakableDestroyed Parms{};

	Parms.Player = Player;
	Parms.breakable = breakable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBBreakActorsCoordinator.OnDestroyed
// (Final, Native, Protected)
// Parameters:
// class URBDamageableComponent*           DamageableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBBreakActorsCoordinator::Func_OnDestroyed(class URBDamageableComponent* DamageableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBBreakActorsCoordinator", "OnDestroyed");

	Params::RBBreakActorsCoordinator_OnDestroyed Parms{};

	Parms.DamageableComponent = DamageableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskConditionContext_TakeDamage.OnDamagePlayer
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDamageInfo                      DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDamageResult                    DamageResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBTaskConditionContext_TakeDamage::OnDamagePlayer(const struct FDamageInfo& DamageInfo, const struct FDamageResult& DamageResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskConditionContext_TakeDamage", "OnDamagePlayer");

	Params::RBTaskConditionContext_TakeDamage_OnDamagePlayer Parms{};

	Parms.DamageInfo = std::move(DamageInfo);
	Parms.DamageResult = std::move(DamageResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBVoiceChatManager.OnLoadingScreenStateUpdated
// (Final, Native, Private)
// Parameters:
// bool                                    bShowing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBVoiceChatManager::OnLoadingScreenStateUpdated(bool bShowing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVoiceChatManager", "OnLoadingScreenStateUpdated");

	Params::RBVoiceChatManager_OnLoadingScreenStateUpdated Parms{};

	Parms.bShowing = bShowing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBVoiceChatManager.OnVoiceChatEnabledChanged
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBVoiceChatManager::OnVoiceChatEnabledChanged(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVoiceChatManager", "OnVoiceChatEnabledChanged");

	Params::RBVoiceChatManager_OnVoiceChatEnabledChanged Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.BP_OnStartedInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSwitchPanelPart*               PanelPart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanel::BP_OnStartedInteraction(class ARBPawn* Pawn, class ARBSwitchPanelPart* PanelPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_OnStartedInteraction");

	Params::RBSwitchPanel_BP_OnStartedInteraction Parms{};

	Parms.Pawn = Pawn;
	Parms.PanelPart = PanelPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchPanel.BP_OnStatusUpdated
// (Event, Public, BlueprintEvent)

void ARBSwitchPanel::BP_OnStatusUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_OnStatusUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanel.BP_OnStoppedInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSwitchPanelPart*               PanelPart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanel::BP_OnStoppedInteraction(class ARBPawn* Pawn, class ARBSwitchPanelPart* PanelPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_OnStoppedInteraction");

	Params::RBSwitchPanel_BP_OnStoppedInteraction Parms{};

	Parms.Pawn = Pawn;
	Parms.PanelPart = PanelPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchPanel.BP_ResetAllPartsValues
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bKeepCurrentValues                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanel::BP_ResetAllPartsValues(bool bKeepCurrentValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_ResetAllPartsValues");

	Params::RBSwitchPanel_BP_ResetAllPartsValues Parms{};

	Parms.bKeepCurrentValues = bKeepCurrentValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.BP_SetPanelEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanel::BP_SetPanelEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_SetPanelEnabled");

	Params::RBSwitchPanel_BP_SetPanelEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.BP_StartShake
// (Event, Public, BlueprintEvent)

void ARBSwitchPanel::BP_StartShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_StartShake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanel.BP_StopShake
// (Event, Public, BlueprintEvent)

void ARBSwitchPanel::BP_StopShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "BP_StopShake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanel.Event_PanelEnabledChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanel::Event_PanelEnabledChanged(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "Event_PanelEnabledChanged");

	Params::RBSwitchPanel_Event_PanelEnabledChanged Parms{};

	Parms.bEnabledValue = bEnabledValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchPanel.GivesFocusTo
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractionZoneComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBInteractionZoneComponent* ARBSwitchPanel::GivesFocusTo(const class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "GivesFocusTo");

	Params::RBSwitchPanel_GivesFocusTo Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSwitchPanel.OnRep_PanelEnabled
// (Final, Native, Public)

void ARBSwitchPanel::OnRep_PanelEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "OnRep_PanelEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.OnRep_PanelParts
// (Final, Native, Public)

void ARBSwitchPanel::OnRep_PanelParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "OnRep_PanelParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.OnRep_StatusValue
// (Final, Native, Public)

void ARBSwitchPanel::OnRep_StatusValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "OnRep_StatusValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanel.RefreshLightStatus
// (Final, Native, Public)

void ARBSwitchPanel::RefreshLightStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanel", "RefreshLightStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.Event_MaxDisplayNameLengthUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusEntryWidget::Event_MaxDisplayNameLengthUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_MaxDisplayNameLengthUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusEntryWidget.Event_OnPlayerSASChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPlayerState*                   Param_RBPlayerState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSAS*                           CurrentSAS                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::Event_OnPlayerSASChanged(class ARBPlayerState* Param_RBPlayerState, class ARBSAS* CurrentSAS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_OnPlayerSASChanged");

	Params::RBGroupStatusEntryWidget_Event_OnPlayerSASChanged Parms{};

	Parms.Param_RBPlayerState = Param_RBPlayerState;
	Parms.CurrentSAS = CurrentSAS;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBGroupStatusEntryWidget.Event_PlayerStatusUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusEntryWidget::Event_PlayerStatusUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_PlayerStatusUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusEntryWidget.Event_Refresh
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusEntryWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Audio
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusEntryWidget::Event_Refresh_Audio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_Refresh_Audio");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Health
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::Event_Refresh_Health(float NewHealth, bool SkipAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_Refresh_Health");

	Params::RBGroupStatusEntryWidget_Event_Refresh_Health Parms{};

	Parms.NewHealth = NewHealth;
	Parms.SkipAnim = SkipAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBGroupStatusEntryWidget.Event_Refresh_MaxHealth
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewMaxHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::Event_Refresh_MaxHealth(float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_Refresh_MaxHealth");

	Params::RBGroupStatusEntryWidget_Event_Refresh_MaxHealth Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBGroupStatusEntryWidget.Event_Refresh_ObjectiveItemsCount
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusEntryWidget::Event_Refresh_ObjectiveItemsCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "Event_Refresh_ObjectiveItemsCount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusEntryWidget.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* URBGroupStatusEntryWidget::GetPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetPlayerState");

	Params::RBGroupStatusEntryWidget_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.OnCurrentLoadoutChanged
// (Final, Native, Private)

void URBGroupStatusEntryWidget::OnCurrentLoadoutChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "OnCurrentLoadoutChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.OnHealthUpdated
// (Final, Native, Private)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::OnHealthUpdated(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "OnHealthUpdated");

	Params::RBGroupStatusEntryWidget_OnHealthUpdated Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.OnInventoryUpdated
// (Final, Native, Private)

void URBGroupStatusEntryWidget::OnInventoryUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "OnInventoryUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.OnPlayerIndicatorUpdated
// (Final, Native, Private)
// Parameters:
// EPlayerIndicatorType                    PlayerIndicatorType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::OnPlayerIndicatorUpdated(EPlayerIndicatorType PlayerIndicatorType, float TimeLeft, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "OnPlayerIndicatorUpdated");

	Params::RBGroupStatusEntryWidget_OnPlayerIndicatorUpdated Parms{};

	Parms.PlayerIndicatorType = PlayerIndicatorType;
	Parms.TimeLeft = TimeLeft;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.OnPlayerVoiceChatVolumeChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::OnPlayerVoiceChatVolumeChanged(const struct FProfileId& ProfileId, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "OnPlayerVoiceChatVolumeChanged");

	Params::RBGroupStatusEntryWidget_OnPlayerVoiceChatVolumeChanged Parms{};

	Parms.ProfileId = std::move(ProfileId);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.SetMaxDisplayNameLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MaxDisplayNameLength                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGroupStatusEntryWidget::SetMaxDisplayNameLength(int32 MaxDisplayNameLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "SetMaxDisplayNameLength");

	Params::RBGroupStatusEntryWidget_SetMaxDisplayNameLength Parms{};

	Parms.MaxDisplayNameLength = MaxDisplayNameLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGroupStatusEntryWidget.GetActiveSkillType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActiveSkillType URBGroupStatusEntryWidget::GetActiveSkillType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetActiveSkillType");

	Params::RBGroupStatusEntryWidget_GetActiveSkillType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBGroupStatusEntryWidget::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetDisplayName");

	Params::RBGroupStatusEntryWidget_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.GetMaxDisplayNameLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGroupStatusEntryWidget::GetMaxDisplayNameLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetMaxDisplayNameLength");

	Params::RBGroupStatusEntryWidget_GetMaxDisplayNameLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorIconProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGroupStatusEntryWidget::GetPlayerIndicatorIconProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetPlayerIndicatorIconProgress");

	Params::RBGroupStatusEntryWidget_GetPlayerIndicatorIconProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGroupStatusEntryWidget::GetPlayerIndicatorTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetPlayerIndicatorTimeLeft");

	Params::RBGroupStatusEntryWidget_GetPlayerIndicatorTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerIndicatorType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerIndicatorType URBGroupStatusEntryWidget::GetPlayerIndicatorType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "GetPlayerIndicatorType");

	Params::RBGroupStatusEntryWidget_GetPlayerIndicatorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.HasVoiceChatEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::HasVoiceChatEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "HasVoiceChatEnabled");

	Params::RBGroupStatusEntryWidget_HasVoiceChatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsBlocked");

	Params::RBGroupStatusEntryWidget_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsGloballyMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsGloballyMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsGloballyMuted");

	Params::RBGroupStatusEntryWidget_IsGloballyMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsMuted");

	Params::RBGroupStatusEntryWidget_IsMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsPartyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsPartyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsPartyOwner");

	Params::RBGroupStatusEntryWidget_IsPartyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsSelf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsSelf");

	Params::RBGroupStatusEntryWidget_IsSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsSpeaking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsSpeaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsSpeaking");

	Params::RBGroupStatusEntryWidget_IsSpeaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusEntryWidget.IsVoiceChatConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGroupStatusEntryWidget::IsVoiceChatConnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusEntryWidget", "IsVoiceChatConnected");

	Params::RBGroupStatusEntryWidget_IsVoiceChatConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTriggerableDoorWayDetector.BP_SetShouldBeOpened
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableDoorWayDetector::BP_SetShouldBeOpened(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "BP_SetShouldBeOpened");

	Params::RBTriggerableDoorWayDetector_BP_SetShouldBeOpened Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.Event_OnEnabledChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableDoorWayDetector::Event_OnEnabledChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "Event_OnEnabledChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableDoorWayDetector.Event_OnIsBlockingDoorwayChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableDoorWayDetector::Event_OnIsBlockingDoorwayChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "Event_OnIsBlockingDoorwayChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableDoorWayDetector.Event_OnLockedClosedChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableDoorWayDetector::Event_OnLockedClosedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "Event_OnLockedClosedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableDoorWayDetector.Event_OnShouldBeOpenedChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableDoorWayDetector::Event_OnShouldBeOpenedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "Event_OnShouldBeOpenedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorWaybackChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableDoorWayDetector::IsBlockingDoorWaybackChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "IsBlockingDoorWaybackChangedCallback");

	Params::RBTriggerableDoorWayDetector_IsBlockingDoorWaybackChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBTriggerableDoorWayDetector::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnComponentBeginOverlap");

	Params::RBTriggerableDoorWayDetector_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnComponentEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableDoorWayDetector::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnComponentEndOverlap");

	Params::RBTriggerableDoorWayDetector_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnLargePickupDropped
// (Final, Native, Protected)
// Parameters:
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableDoorWayDetector::OnLargePickupDropped(class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnLargePickupDropped");

	Params::RBTriggerableDoorWayDetector_OnLargePickupDropped Parms{};

	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnRep_Enabled
// (Final, Native, Protected)

void ARBTriggerableDoorWayDetector::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnRep_IsBlockingDoorWay
// (Final, Native, Protected)

void ARBTriggerableDoorWayDetector::OnRep_IsBlockingDoorWay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnRep_IsBlockingDoorWay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnRep_LockedClosed
// (Final, Native, Protected)

void ARBTriggerableDoorWayDetector::OnRep_LockedClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnRep_LockedClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.OnRep_ShouldBeOpened
// (Final, Native, Protected)

void ARBTriggerableDoorWayDetector::OnRep_ShouldBeOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "OnRep_ShouldBeOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorway
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTriggerableDoorWayDetector::IsBlockingDoorway() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableDoorWayDetector", "IsBlockingDoorway");

	Params::RBTriggerableDoorWayDetector_IsBlockingDoorway Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCameraPanel.BP_SetCameraPowerButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBSwitchPanelPart*               Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCameraPanel::BP_SetCameraPowerButton(class ARBSwitchPanelPart* Part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCameraPanel", "BP_SetCameraPowerButton");

	Params::RBCameraPanel_BP_SetCameraPowerButton Parms{};

	Parms.Part = Part;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCameraPanel.Event_PowerButtonActivatedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCameraPanel::Event_PowerButtonActivatedChanged(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCameraPanel", "Event_PowerButtonActivatedChanged");

	Params::RBCameraPanel_Event_PowerButtonActivatedChanged Parms{};

	Parms.bEnabledValue = bEnabledValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCameraPanel.OnRep_DestructionStage
// (Final, Native, Private)
// Parameters:
// int32                                   OldDestructionStage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCameraPanel::OnRep_DestructionStage(int32 OldDestructionStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCameraPanel", "OnRep_DestructionStage");

	Params::RBCameraPanel_OnRep_DestructionStage Parms{};

	Parms.OldDestructionStage = OldDestructionStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCameraPanel.OnRep_PowerButtonActivated
// (Final, Native, Private)

void ARBCameraPanel::OnRep_PowerButtonActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCameraPanel", "OnRep_PowerButtonActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialVolume.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBFloorMaterialVolume::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialVolume", "BeginOverlap");

	Params::RBFloorMaterialVolume_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialVolume.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFloorMaterialVolume::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialVolume", "BP_SetEnabled");

	Params::RBFloorMaterialVolume_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialVolume.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFloorMaterialVolume::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialVolume", "EndOverlap");

	Params::RBFloorMaterialVolume_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialVolume.OnRep_Enabled
// (Final, Native, Public)

void ARBFloorMaterialVolume::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialVolume", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialVolume.OnRep_RandomlyDisabled
// (Final, Native, Private)

void ARBFloorMaterialVolume::OnRep_RandomlyDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialVolume", "OnRep_RandomlyDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChainingUpgradePointItem.Multicast_OnPointsPickedUp
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ARBPlayer*                        Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChainingUpgradePointItem::Multicast_OnPointsPickedUp(class ARBPlayer* Pawn, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChainingUpgradePointItem", "Multicast_OnPointsPickedUp");

	Params::RBChainingUpgradePointItem_Multicast_OnPointsPickedUp Parms{};

	Parms.Pawn = Pawn;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.GetItemCountForCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECustomizationMenuCategory              Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCustomizingFemale                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBCharacterCustomizationContent::GetItemCountForCategory(ECustomizationMenuCategory Category, bool IsCustomizingFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBCharacterCustomizationContent", "GetItemCountForCategory");

	Params::RBCharacterCustomizationContent_GetItemCountForCategory Parms{};

	Parms.Category = Category;
	Parms.IsCustomizingFemale = IsCustomizingFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterCustomizationContent.CategoryClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomizationMenuCategory              Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::CategoryClicked(ECustomizationMenuCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "CategoryClicked");

	Params::RBCharacterCustomizationContent_CategoryClicked Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.EquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBPlayerCustomizationOption*     ClickedOption                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::EquipItem(class URBPlayerCustomizationOption* ClickedOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "EquipItem");

	Params::RBCharacterCustomizationContent_EquipItem Parms{};

	Parms.ClickedOption = ClickedOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.EquipOutfit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBCustomizationOutfit*           ClickedOutfit                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::EquipOutfit(class URBCustomizationOutfit* ClickedOutfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "EquipOutfit");

	Params::RBCharacterCustomizationContent_EquipOutfit Parms{};

	Parms.ClickedOutfit = ClickedOutfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.EquipPlayerIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBPlayerIconCustomizationOption* ClickedPlayerIcon                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::EquipPlayerIcon(class URBPlayerIconCustomizationOption* ClickedPlayerIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "EquipPlayerIcon");

	Params::RBCharacterCustomizationContent_EquipPlayerIcon Parms{};

	Parms.ClickedPlayerIcon = ClickedPlayerIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.EquipVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBVoiceCustomizationOption*      ClickedVoice                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::EquipVoice(class URBVoiceCustomizationOption* ClickedVoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "EquipVoice");

	Params::RBCharacterCustomizationContent_EquipVoice Parms{};

	Parms.ClickedVoice = ClickedVoice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationItems
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FUICustomizationItem>     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_AddCustomizationItems(const TArray<struct FUICustomizationItem>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_AddCustomizationItems");

	Params::RBCharacterCustomizationContent_Event_AddCustomizationItems Parms{};

	Parms.Items = std::move(Items);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationSlotOptions
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class URBPlayerCustomizationOption*>Options                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    SelectSpecificIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SelectedIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_AddCustomizationSlotOptions(const TArray<class URBPlayerCustomizationOption*>& Options, bool SelectSpecificIndex, int32 SelectedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_AddCustomizationSlotOptions");

	Params::RBCharacterCustomizationContent_Event_AddCustomizationSlotOptions Parms{};

	Parms.Options = std::move(Options);
	Parms.SelectSpecificIndex = SelectSpecificIndex;
	Parms.SelectedIndex = SelectedIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_AddPlayerIconOptions
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class URBPlayerIconCustomizationOption*>PlayerIconOptions                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_AddPlayerIconOptions(const TArray<class URBPlayerIconCustomizationOption*>& PlayerIconOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_AddPlayerIconOptions");

	Params::RBCharacterCustomizationContent_Event_AddPlayerIconOptions Parms{};

	Parms.PlayerIconOptions = std::move(PlayerIconOptions);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_AddVoiceOptions
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class URBVoiceCustomizationOption*>VoiceOptions                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_AddVoiceOptions(const TArray<class URBVoiceCustomizationOption*>& VoiceOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_AddVoiceOptions");

	Params::RBCharacterCustomizationContent_Event_AddVoiceOptions Parms{};

	Parms.VoiceOptions = std::move(VoiceOptions);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_ItemBought
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FUICustomizationItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_ItemBought(const struct FUICustomizationItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_ItemBought");

	Params::RBCharacterCustomizationContent_Event_ItemBought Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_ItemEquipped
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FUICustomizationItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_ItemEquipped(const struct FUICustomizationItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_ItemEquipped");

	Params::RBCharacterCustomizationContent_Event_ItemEquipped Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.Event_LoadingStarted
// (Event, Public, BlueprintEvent)

void URBCharacterCustomizationContent::Event_LoadingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_LoadingStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCharacterCustomizationContent.Event_PlayerCustomizationUpdated
// (Event, Public, BlueprintEvent)

void URBCharacterCustomizationContent::Event_PlayerCustomizationUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_PlayerCustomizationUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCharacterCustomizationContent.Event_RefreshItemInfos
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FUICustomizationItem>     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::Event_RefreshItemInfos(const TArray<struct FUICustomizationItem>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "Event_RefreshItemInfos");

	Params::RBCharacterCustomizationContent_Event_RefreshItemInfos Parms{};

	Parms.Items = std::move(Items);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCharacterCustomizationContent.OnAcquiredItemsChanged
// (Final, Native, Private)

void URBCharacterCustomizationContent::OnAcquiredItemsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnAcquiredItemsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.OnHairColorClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewHairColorId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::OnHairColorClicked(class FName NewHairColorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnHairColorClicked");

	Params::RBCharacterCustomizationContent_OnHairColorClicked Parms{};

	Parms.NewHairColorId = NewHairColorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.OnItemClicked
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUICustomizationItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ECustomizationMenuCategory              Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::OnItemClicked(const struct FUICustomizationItem& Item, ECustomizationMenuCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnItemClicked");

	Params::RBCharacterCustomizationContent_OnItemClicked Parms{};

	Parms.Item = std::move(Item);
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.OnItemMouseDown
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUICustomizationItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::OnItemMouseDown(const struct FUICustomizationItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnItemMouseDown");

	Params::RBCharacterCustomizationContent_OnItemMouseDown Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.OnItemMouseUp
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUICustomizationItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::OnItemMouseUp(const struct FUICustomizationItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnItemMouseUp");

	Params::RBCharacterCustomizationContent_OnItemMouseUp Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.OnPlayerCustomizationUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBPlayerCustomizationInfo       CustomizationInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBCharacterCustomizationContent::OnPlayerCustomizationUpdated(const struct FRBPlayerCustomizationInfo& CustomizationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "OnPlayerCustomizationUpdated");

	Params::RBCharacterCustomizationContent_OnPlayerCustomizationUpdated Parms{};

	Parms.CustomizationInfo = std::move(CustomizationInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCharacterCustomizationContent.BP_GetCurrentPreviewOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBCharacterCustomizationContent::BP_GetCurrentPreviewOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "BP_GetCurrentPreviewOptions");

	Params::RBCharacterCustomizationContent_BP_GetCurrentPreviewOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterCustomizationContent.BP_GetOptionsForPreview
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBPlayerCustomizationOption*     OptionToPreview                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOutfit*           OutfitToPreview                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBCharacterCustomizationContent::BP_GetOptionsForPreview(class URBPlayerCustomizationOption* OptionToPreview, class URBCustomizationOutfit* OutfitToPreview) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "BP_GetOptionsForPreview");

	Params::RBCharacterCustomizationContent_BP_GetOptionsForPreview Parms{};

	Parms.OptionToPreview = OptionToPreview;
	Parms.OutfitToPreview = OutfitToPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterCustomizationContent.GetEquippedHairColor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName URBCharacterCustomizationContent::GetEquippedHairColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "GetEquippedHairColor");

	Params::RBCharacterCustomizationContent_GetEquippedHairColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterCustomizationContent.GetIsCustomizingFemale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCharacterCustomizationContent::GetIsCustomizingFemale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationContent", "GetIsCustomizingFemale");

	Params::RBCharacterCustomizationContent_GetIsCustomizingFemale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBVariatorInfo.GetActions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class URBVariatorAction*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class URBVariatorAction*> URBVariatorInfo::GetActions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorInfo", "GetActions");

	Params::RBVariatorInfo_GetActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCharacterCustomizationMenu.Event_SetupPostRelease
// (Event, Public, BlueprintEvent)

void URBCharacterCustomizationMenu::Event_SetupPostRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationMenu", "Event_SetupPostRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCharacterCustomizationMenu.SaveCustomization
// (Final, Native, Public, BlueprintCallable)

void URBCharacterCustomizationMenu::SaveCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCharacterCustomizationMenu", "SaveCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.BP_GetGroupMasterEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBSoundComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSoundComponent* URBSoundComponent::BP_GetGroupMasterEmitter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "BP_GetGroupMasterEmitter");

	Params::RBSoundComponent_BP_GetGroupMasterEmitter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.BP_RegisterToAudioManager
// (Final, Native, Public, BlueprintCallable)

void URBSoundComponent::BP_RegisterToAudioManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "BP_RegisterToAudioManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.PlayLoopingSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    LoopStartEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    LoopStopEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowMultipleIdenticalLoops                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSoundComponent::PlayLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent, bool bAllowMultipleIdenticalLoops)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "PlayLoopingSound");

	Params::RBSoundComponent_PlayLoopingSound Parms{};

	Parms.LoopStartEvent = LoopStartEvent;
	Parms.LoopStopEvent = LoopStopEvent;
	Parms.bAllowMultipleIdenticalLoops = bAllowMultipleIdenticalLoops;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.PlayVOLoopingSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    LoopStartEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    LoopStopEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSoundComponent::PlayVOLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "PlayVOLoopingSound");

	Params::RBSoundComponent_PlayVOLoopingSound Parms{};

	Parms.LoopStartEvent = LoopStartEvent;
	Parms.LoopStopEvent = LoopStopEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.RemoveFromMultiPositionGroup
// (Final, Native, Public, BlueprintCallable)

void URBSoundComponent::RemoveFromMultiPositionGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "RemoveFromMultiPositionGroup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.SetBillboardVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBillboardVisibleValue                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundComponent::SetBillboardVisibility(bool bBillboardVisibleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "SetBillboardVisibility");

	Params::RBSoundComponent_SetBillboardVisibility Parms{};

	Parms.bBillboardVisibleValue = bBillboardVisibleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.SetMultiPositionGroup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NewCloneGroupName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundComponent::SetMultiPositionGroup(const class FName& NewCloneGroupName, bool bAddToGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "SetMultiPositionGroup");

	Params::RBSoundComponent_SetMultiPositionGroup Parms{};

	Parms.NewCloneGroupName = NewCloneGroupName;
	Parms.bAddToGroup = bAddToGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.StopAllLoopingSounds
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void URBSoundComponent::StopAllLoopingSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "StopAllLoopingSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.StopAssociatedAkEvent
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSoundComponent::StopAssociatedAkEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "StopAssociatedAkEvent");

	Params::RBSoundComponent_StopAssociatedAkEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.StopLoopingSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    LoopStartEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    LoopStopEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSoundComponent::StopLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "StopLoopingSound");

	Params::RBSoundComponent_StopLoopingSound Parms{};

	Parms.LoopStartEvent = LoopStartEvent;
	Parms.LoopStopEvent = LoopStopEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.StopLoopingSoundFromID
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoopingSoundID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundComponent::StopLoopingSoundFromID(int32 LoopingSoundID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "StopLoopingSoundFromID");

	Params::RBSoundComponent_StopLoopingSoundFromID Parms{};

	Parms.LoopingSoundID = LoopingSoundID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundComponent.BP_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSoundComponent::BP_IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "BP_IsPlaying");

	Params::RBSoundComponent_BP_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundComponent.IsPlayingLoopingSound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkAudioEvent*                    LoopStartEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    LoopStopEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSoundComponent::IsPlayingLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundComponent", "IsPlayingLoopingSound");

	Params::RBSoundComponent_IsPlayingLoopingSound Parms{};

	Parms.LoopStartEvent = LoopStartEvent;
	Parms.LoopStopEvent = LoopStopEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStatsManager.GetGlobalStatContext
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBStatsManager::GetGlobalStatContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBStatsManager", "GetGlobalStatContext");

	Params::RBStatsManager_GetGlobalStatContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStatsManager.GetTrialStatContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBStatsManager::GetTrialStatContext(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBStatsManager", "GetTrialStatContext");

	Params::RBStatsManager_GetTrialStatContext Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStatsManager.GetCurrentTrialStatContext
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBStatsManager::GetCurrentTrialStatContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStatsManager", "GetCurrentTrialStatContext");

	Params::RBStatsManager_GetCurrentTrialStatContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStatsManager.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBStatsManager::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStatsManager", "OnGamePhaseUpdated");

	Params::RBStatsManager_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStatsManager.GetCharacterStatContext
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBStatsManager::GetCharacterStatContext(class ARBPlayerState* RBPlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStatsManager", "GetCharacterStatContext");

	Params::RBStatsManager_GetCharacterStatContext Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStatsManager.GetCurrentCharacterStatContext
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBStatsManager::GetCurrentCharacterStatContext() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStatsManager", "GetCurrentCharacterStatContext");

	Params::RBStatsManager_GetCurrentCharacterStatContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCheatManager.AcquireAllCellCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::AcquireAllCellCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireAllCellCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireAllCosmetics
// (Final, Exec, Native, Public)

void URBCheatManager::AcquireAllCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireAllCosmetics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireAllCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::AcquireAllCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireAllCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireAllDocuments
// (Final, Exec, Native, Public)

void URBCheatManager::AcquireAllDocuments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireAllDocuments");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireAllTrialRewards
// (Final, Exec, Native, Public)

void URBCheatManager::AcquireAllTrialRewards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireAllTrialRewards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireBadge
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           BadgeId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AcquireBadge(const class FString& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireBadge");

	Params::RBCheatManager_AcquireBadge Parms{};

	Parms.BadgeId = std::move(BadgeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireFullRewardPool
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             RewardPoolId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AcquireFullRewardPool(const class FName& RewardPoolId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireFullRewardPool");

	Params::RBCheatManager_AcquireFullRewardPool Parms{};

	Parms.RewardPoolId = RewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AcquireRewardPoolItem
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             RewardPoolId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AcquireRewardPoolItem(const class FName& RewardPoolId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AcquireRewardPoolItem");

	Params::RBCheatManager_AcquireRewardPoolItem Parms{};

	Parms.RewardPoolId = RewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ActivateAllMines
// (Final, Exec, Native, Public)

void URBCheatManager::ActivateAllMines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ActivateAllMines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddAllTrialChainingItems
// (Final, Exec, Native, Public)

void URBCheatManager::AddAllTrialChainingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddAllTrialChainingItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddCurrency
// (Final, Exec, Native, Public)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddCurrency(ECurrencyType CurrencyType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddCurrency");

	Params::RBCheatManager_AddCurrency Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddDebugActorInViewFilter
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddDebugActorInViewFilter(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddDebugActorInViewFilter");

	Params::RBCheatManager_AddDebugActorInViewFilter Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddItem
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddItem(const class FString& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddItem");

	Params::RBCheatManager_AddItem Parms{};

	Parms.ItemName = std::move(ItemName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddMultipleItems
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberOfCopy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddMultipleItems(const class FString& ItemName, int32 NumberOfCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddMultipleItems");

	Params::RBCheatManager_AddMultipleItems Parms{};

	Parms.ItemName = std::move(ItemName);
	Parms.NumberOfCopy = NumberOfCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddMurkoffDollars
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddMurkoffDollars(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddMurkoffDollars");

	Params::RBCheatManager_AddMurkoffDollars Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddMurkoffPoints
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddMurkoffPoints(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddMurkoffPoints");

	Params::RBCheatManager_AddMurkoffPoints Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddOnlineItemWithID
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             UpgradeOnlineItemId                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPersistentItem                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddOnlineItemWithID(const class FName& UpgradeOnlineItemId, bool bIsPersistentItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddOnlineItemWithID");

	Params::RBCheatManager_AddOnlineItemWithID Parms{};

	Parms.UpgradeOnlineItemId = UpgradeOnlineItemId;
	Parms.bIsPersistentItem = bIsPersistentItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddPsychosis
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddPsychosis(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddPsychosis");

	Params::RBCheatManager_AddPsychosis Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddSelfRevive
// (Final, Exec, Native, Public)

void URBCheatManager::AddSelfRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddSelfRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddStageXp
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddStageXp(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddStageXp");

	Params::RBCheatManager_AddStageXp Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddTask
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddTask(const class FName& TaskId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddTask");

	Params::RBCheatManager_AddTask Parms{};

	Parms.TaskId = TaskId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddTQ
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddTQ(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddTQ");

	Params::RBCheatManager_AddTQ Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddTrialChainingUpgradePoints
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddTrialChainingUpgradePoints(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddTrialChainingUpgradePoints");

	Params::RBCheatManager_AddTrialChainingUpgradePoints Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddVariator
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddVariator(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddVariator");

	Params::RBCheatManager_AddVariator Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AddXp
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::AddXp(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AddXp");

	Params::RBCheatManager_AddXp Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.AILog
// (Final, Exec, Native, Public)

void URBCheatManager::AILog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "AILog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Assert
// (Final, Exec, Native, Public)

void URBCheatManager::Assert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Assert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.BadFPS
// (Final, Exec, Native, Public)

void URBCheatManager::BadFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "BadFPS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.BigLag
// (Final, Exec, Native, Public)

void URBCheatManager::BigLag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "BigLag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.BleedSelf
// (Final, Exec, Native, Public)

void URBCheatManager::BleedSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "BleedSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.BugIt_Input
// (Final, Native, Public)

void URBCheatManager::BugIt_Input()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "BugIt_Input");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.BugIt_TextEnteredCallback
// (Final, Native, Public)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::BugIt_TextEnteredCallback(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "BugIt_TextEnteredCallback");

	Params::RBCheatManager_BugIt_TextEnteredCallback Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CheatCameraLocation
// (Final, Exec, Native, Public)

void URBCheatManager::CheatCameraLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CheatCameraLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearDebugActorInViewFilters
// (Final, Exec, Native, Public)

void URBCheatManager::ClearDebugActorInViewFilters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearDebugActorInViewFilters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearForcedLevelSeed
// (Final, Exec, Native, Public)

void URBCheatManager::ClearForcedLevelSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearForcedLevelSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearHeatmap
// (Final, Exec, Native, Public)

void URBCheatManager::ClearHeatmap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearHeatmap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearItemsDisplayedInMenu
// (Final, Exec, Native, Public)

void URBCheatManager::ClearItemsDisplayedInMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearItemsDisplayedInMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearLastPartyFindProfileIds
// (Final, Exec, Native, Public)

void URBCheatManager::ClearLastPartyFindProfileIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearLastPartyFindProfileIds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearMenuTutorials
// (Final, Exec, Native, Public)

void URBCheatManager::ClearMenuTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearMenuTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearPlayerActiveTasks
// (Final, Exec, Native, Public)

void URBCheatManager::ClearPlayerActiveTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearPlayerActiveTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearPsychosis
// (Final, Exec, Native, Public)

void URBCheatManager::ClearPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearPsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearRandomState
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SearchQuery                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ClearRandomState(const class FString& SearchQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearRandomState");

	Params::RBCheatManager_ClearRandomState Parms{};

	Parms.SearchQuery = std::move(SearchQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearShowAll
// (Final, Exec, Native, Public)

void URBCheatManager::ClearShowAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearShowAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearTasks
// (Final, Exec, Native, Public)

void URBCheatManager::ClearTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ClearVisitedNPCs
// (Final, Exec, Native, Public)

void URBCheatManager::ClearVisitedNPCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ClearVisitedNPCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CloneCellCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::CloneCellCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CloneCellCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CollisionReport
// (Final, Exec, Native, Public)

void URBCheatManager::CollisionReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CollisionReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteCurrentStage
// (Final, Exec, Native, Public)

void URBCheatManager::CompleteCurrentStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteCurrentStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteMainObjective
// (Final, Exec, Native, Public)

void URBCheatManager::CompleteMainObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteMainObjective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteMainObjectivesTo
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::CompleteMainObjectivesTo(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteMainObjectivesTo");

	Params::RBCheatManager_CompleteMainObjectivesTo Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteObjectiveCoordinator
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::CompleteObjectiveCoordinator(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteObjectiveCoordinator");

	Params::RBCheatManager_CompleteObjectiveCoordinator Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteTask
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::CompleteTask(const class FName& TaskId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteTask");

	Params::RBCheatManager_CompleteTask Parms{};

	Parms.TaskId = TaskId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CompleteTasks
// (Final, Exec, Native, Public)

void URBCheatManager::CompleteTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CompleteTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CopyCameraLocation
// (Final, Exec, Native, Public)

void URBCheatManager::CopyCameraLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CopyCameraLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Crash
// (Final, Exec, Native, Public)

void URBCheatManager::Crash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Crash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CycleAIDebug
// (Final, Exec, Native, Public)

void URBCheatManager::CycleAIDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CycleAIDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CycleCollisionDebug
// (Final, Exec, Native, Public)

void URBCheatManager::CycleCollisionDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CycleCollisionDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CycleDebugPerceptionDarkness
// (Final, Exec, Native, Public)

void URBCheatManager::CycleDebugPerceptionDarkness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CycleDebugPerceptionDarkness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.CyclePlayerDebug
// (Final, Exec, Native, Public)

void URBCheatManager::CyclePlayerDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "CyclePlayerDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugActiveSkills
// (Final, Exec, Native, Public)

void URBCheatManager::DebugActiveSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugActiveSkills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugActorInView
// (Final, Exec, Native, Public)

void URBCheatManager::DebugActorInView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugActorInView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugAI
// (Final, Exec, Native, Public)

void URBCheatManager::DebugAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugAIPointSelection
// (Final, Exec, Native, Public)

void URBCheatManager::DebugAIPointSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugAIPointSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugAlertedStance
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugAlertedStance(int32 Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugAlertedStance");

	Params::RBCheatManager_DebugAlertedStance Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugAnimUsage
// (Final, Exec, Native, Public)

void URBCheatManager::DebugAnimUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugAnimUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugAudioEvents
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PlayingIDFilter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugAudioEvents(int32 PlayingIDFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugAudioEvents");

	Params::RBCheatManager_DebugAudioEvents Parms{};

	Parms.PlayingIDFilter = PlayingIDFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugBackgroundCharacters
// (Final, Exec, Native, Public)

void URBCheatManager::DebugBackgroundCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugBackgroundCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugBleedOut
// (Final, Exec, Native, Public)

void URBCheatManager::DebugBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugBleedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugBlockables
// (Final, Exec, Native, Public)

void URBCheatManager::DebugBlockables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugBlockables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugChase
// (Final, Exec, Native, Public)

void URBCheatManager::DebugChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugChase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugChunkInstall
// (Final, Exec, Native, Public)

void URBCheatManager::DebugChunkInstall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugChunkInstall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugClearance
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bForceShowValid                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugClearance(bool bForceShowValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugClearance");

	Params::RBCheatManager_DebugClearance Parms{};

	Parms.bForceShowValid = bForceShowValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugCoopMove
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bExceptLocal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugCoopMove(bool bExceptLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugCoopMove");

	Params::RBCheatManager_DebugCoopMove Parms{};

	Parms.bExceptLocal = bExceptLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDarkness
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDarkness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDarkness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDeadRepulsion
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDeadRepulsion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDeadRepulsion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDecoder
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDecoder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDecoder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDisplayMessages
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDisplayMessages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDisplayMessages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDoorRepulsion
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSlam                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugDoorRepulsion(bool bSlam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDoorRepulsion");

	Params::RBCheatManager_DebugDoorRepulsion Parms{};

	Parms.bSlam = bSlam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDoors
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDoors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDoors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDrawInteractionBox
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bServer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugDrawInteractionBox(bool bServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDrawInteractionBox");

	Params::RBCheatManager_DebugDrawInteractionBox Parms{};

	Parms.bServer = bServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugDrawPlayerLocations
// (Final, Exec, Native, Public)

void URBCheatManager::DebugDrawPlayerLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugDrawPlayerLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugEncroachment
// (Final, Exec, Native, Public)

void URBCheatManager::DebugEncroachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugEncroachment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugEvalCorridor
// (Final, Exec, Native, Public)

void URBCheatManager::DebugEvalCorridor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugEvalCorridor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugEyesClosed
// (Final, Exec, Native, Public)

void URBCheatManager::DebugEyesClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugEyesClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugFailedAdjustment
// (Final, Exec, Native, Public)

void URBCheatManager::DebugFailedAdjustment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugFailedAdjustment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugFatalities
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugFatalities(int32 Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugFatalities");

	Params::RBCheatManager_DebugFatalities Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugFatalitiesForceIndex
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugFatalitiesForceIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugFatalitiesForceIndex");

	Params::RBCheatManager_DebugFatalitiesForceIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugFirstPerson
// (Final, Exec, Native, Public)

void URBCheatManager::DebugFirstPerson()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugFirstPerson");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugFootsteps
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShowGrid                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugFootsteps(bool bShowGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugFootsteps");

	Params::RBCheatManager_DebugFootsteps Parms{};

	Parms.bShowGrid = bShowGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugForceListenerOnPlayer
// (Final, Exec, Native, Public)

void URBCheatManager::DebugForceListenerOnPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugForceListenerOnPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugForceTraversalNoBase
// (Final, Exec, Native, Public)

void URBCheatManager::DebugForceTraversalNoBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugForceTraversalNoBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugGameMode
// (Final, Exec, Native, Public)

void URBCheatManager::DebugGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugGameMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugGameplay
// (Final, Exec, Native, Public)

void URBCheatManager::DebugGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugGameplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugGameplayAttributes
// (Final, Exec, Native, Public)

void URBCheatManager::DebugGameplayAttributes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugGameplayAttributes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugGameplayRandom
// (Final, Exec, Native, Public)

void URBCheatManager::DebugGameplayRandom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugGameplayRandom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugGasPropagation
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bForceShowValid                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugGasPropagation(bool bForceShowValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugGasPropagation");

	Params::RBCheatManager_DebugGasPropagation Parms{};

	Parms.bForceShowValid = bForceShowValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugHidespotPeek
// (Final, Exec, Native, Public)

void URBCheatManager::DebugHidespotPeek()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugHidespotPeek");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugHidespots
// (Final, Exec, Native, Public)

void URBCheatManager::DebugHidespots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugHidespots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugHidingSpots
// (Final, Exec, Native, Public)

void URBCheatManager::DebugHidingSpots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugHidingSpots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugIgnoreSpecialMoveDesync_Local
// (Final, Exec, Native, Public)

void URBCheatManager::DebugIgnoreSpecialMoveDesync_Local()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugIgnoreSpecialMoveDesync_Local");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInputs
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInputs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInputs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInteraction
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInteractionDesync_Local
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInteractionDesync_Local()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInteractionDesync_Local");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInteractionDesync_Server
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInteractionDesync_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInteractionDesync_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInteractionResync_Local
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInteractionResync_Local()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInteractionResync_Local");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInventory
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugInvestigateInteraction
// (Final, Exec, Native, Public)

void URBCheatManager::DebugInvestigateInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugInvestigateInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugItemSpawning
// (Final, Exec, Native, Public)

void URBCheatManager::DebugItemSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugItemSpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugJumpOver
// (Final, Exec, Native, Public)

void URBCheatManager::DebugJumpOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugJumpOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugJumpScare
// (Final, Exec, Native, Public)

void URBCheatManager::DebugJumpScare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugJumpScare");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugLobbyGame
// (Final, Exec, Native, Public)

void URBCheatManager::DebugLobbyGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugLobbyGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugLobbyGameChess
// (Final, Exec, Native, Public)

void URBCheatManager::DebugLobbyGameChess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugLobbyGameChess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugLowPawnAnimOptimLevel
// (Final, Exec, Native, Public)

void URBCheatManager::DebugLowPawnAnimOptimLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugLowPawnAnimOptimLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugMovementAlwaysDesync_Server
// (Final, Exec, Native, Public)

void URBCheatManager::DebugMovementAlwaysDesync_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugMovementAlwaysDesync_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugMovementDesync
// (Final, Exec, Native, Public)

void URBCheatManager::DebugMovementDesync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugMovementDesync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugMovementNetwork
// (Final, Exec, Native, Public)

void URBCheatManager::DebugMovementNetwork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugMovementNetwork");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugMusic
// (Final, Exec, Native, Public)

void URBCheatManager::DebugMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugNextPage
// (Final, Exec, Native, Public)

void URBCheatManager::DebugNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugNPCAttacks
// (Final, Exec, Native, Public)

void URBCheatManager::DebugNPCAttacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugNPCAttacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugNPCLocomotion
// (Final, Exec, Native, Public)

void URBCheatManager::DebugNPCLocomotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugNPCLocomotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugNPCRandomization
// (Final, Exec, Native, Public)

void URBCheatManager::DebugNPCRandomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugNPCRandomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugObjectives
// (Final, Exec, Native, Public)

void URBCheatManager::DebugObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPasscodeDecals
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPasscodeDecals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPasscodeDecals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPerception
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPerception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPerception");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPhysics
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPlayerCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPlayerCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPlayerCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPlayerInterruptions
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPlayerInterruptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPlayerInterruptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPlayerStats
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPlayerStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPlayerStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugPrevPage
// (Final, Exec, Native, Public)

void URBCheatManager::DebugPrevPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugPrevPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugProjectileTrajectory
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bForceShowValid                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugProjectileTrajectory(bool bForceShowValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugProjectileTrajectory");

	Params::RBCheatManager_DebugProjectileTrajectory Parms{};

	Parms.bForceShowValid = bForceShowValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugProximity
// (Final, Exec, Native, Public)

void URBCheatManager::DebugProximity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugProximity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugProximityDetectables
// (Final, Exec, Native, Public)

void URBCheatManager::DebugProximityDetectables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugProximityDetectables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRandomSounds
// (Final, Exec, Native, Public)

void URBCheatManager::DebugRandomSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRandomSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRB
// (Final, Exec, Native, Public)

void URBCheatManager::DebugRB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRepulsion
// (Final, Exec, Native, Public)

void URBCheatManager::DebugRepulsion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRepulsion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRoomPathing
// (Final, Exec, Native, Public)

void URBCheatManager::DebugRoomPathing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRoomPathing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRooms
// (Final, Exec, Native, Public)

void URBCheatManager::DebugRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugRTPC
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugRTPC(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugRTPC");

	Params::RBCheatManager_DebugRTPC Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSafeZone
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSafeZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSafeZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugScheduledProperties
// (Final, Exec, Native, Public)

void URBCheatManager::DebugScheduledProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugScheduledProperties");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugScheduledSpecialMoveLate
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugScheduledSpecialMoveLate(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugScheduledSpecialMoveLate");

	Params::RBCheatManager_DebugScheduledSpecialMoveLate Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSimultaneousInteraction
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSimultaneousInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSimultaneousInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSimultaneousJumpForward
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSimultaneousJumpForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSimultaneousJumpForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSoundEnvironment
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugSoundEnvironment(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSoundEnvironment");

	Params::RBCheatManager_DebugSoundEnvironment Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSoundEnvironmentForCloneGroups
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugSoundEnvironmentForCloneGroups(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSoundEnvironmentForCloneGroups");

	Params::RBCheatManager_DebugSoundEnvironmentForCloneGroups Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSoundEnvironmentOnPlayer
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugSoundEnvironmentOnPlayer(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSoundEnvironmentOnPlayer");

	Params::RBCheatManager_DebugSoundEnvironmentOnPlayer Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSpatialReasoning
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSpatialReasoning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSpatialReasoning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSpecialRooms
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSpecialRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSpecialRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSubtitles
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSubtitles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugSwitchMatch
// (Final, Exec, Native, Public)

void URBCheatManager::DebugSwitchMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugSwitchMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugTalkWheel
// (Final, Exec, Native, Public)

void URBCheatManager::DebugTalkWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugTalkWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugTargetAI
// (Final, Exec, Native, Public)

void URBCheatManager::DebugTargetAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugTargetAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugThrow
// (Final, Exec, Native, Public)

void URBCheatManager::DebugThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugThrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugTq
// (Final, Exec, Native, Public)

void URBCheatManager::DebugTq()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugTq");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugTraps
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShowDisabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DebugTraps(bool bShowDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugTraps");

	Params::RBCheatManager_DebugTraps Parms{};

	Parms.bShowDisabled = bShowDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugUI
// (Final, Exec, Native, Public)

void URBCheatManager::DebugUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugUINoise
// (Final, Exec, Native, Public)

void URBCheatManager::DebugUINoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugUINoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugVariators
// (Final, Exec, Native, Public)

void URBCheatManager::DebugVariators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugVariators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugVO
// (Final, Exec, Native, Public)

void URBCheatManager::DebugVO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugVO");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DebugVoiceChat
// (Final, Exec, Native, Public)

void URBCheatManager::DebugVoiceChat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DebugVoiceChat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DelayedBugIt
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DelayInSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Description                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DelayedBugIt(float DelayInSeconds, const class FString& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DelayedBugIt");

	Params::RBCheatManager_DelayedBugIt Parms{};

	Parms.DelayInSeconds = DelayInSeconds;
	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DeleteProfile
// (Final, Exec, Native, Public)

void URBCheatManager::DeleteProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DeleteProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisableActiveSkill
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DisableActiveSkill(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisableActiveSkill");

	Params::RBCheatManager_DisableActiveSkill Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisableAutoBackfill
// (Final, Exec, Native, Public)

void URBCheatManager::DisableAutoBackfill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisableAutoBackfill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisableSkelCompTick
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DisableSkelCompTick(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisableSkelCompTick");

	Params::RBCheatManager_DisableSkelCompTick Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisableStageEnding
// (Final, Exec, Native, Public)

void URBCheatManager::DisableStageEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisableStageEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisconnectOnlineModule
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DisconnectOnlineModule(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisconnectOnlineModule");

	Params::RBCheatManager_DisconnectOnlineModule Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DisplayMenuManagerDebugInfo
// (Final, Exec, Native, Public)

void URBCheatManager::DisplayMenuManagerDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DisplayMenuManagerDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DownSelf
// (Final, Exec, Native, Public)

void URBCheatManager::DownSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DownSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DrawLocXYZ
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DrawLocXYZ(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DrawLocXYZ");

	Params::RBCheatManager_DrawLocXYZ Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DropAllItems
// (Final, Exec, Native, Public)

void URBCheatManager::DropAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DropAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpDebugInfoInViewOnClient
// (Final, Exec, Native, Public)

void URBCheatManager::DumpDebugInfoInViewOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpDebugInfoInViewOnClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpDebugInfoInViewOnServer
// (Final, Exec, Native, Public)

void URBCheatManager::DumpDebugInfoInViewOnServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpDebugInfoInViewOnServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpGameEventLog
// (Final, Exec, Native, Public)

void URBCheatManager::DumpGameEventLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpGameEventLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpNavMeshContinuousRequests
// (Final, Exec, Native, Public)

void URBCheatManager::DumpNavMeshContinuousRequests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpNavMeshContinuousRequests");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpPersistentLevelActors
// (Final, Exec, Native, Public)

void URBCheatManager::DumpPersistentLevelActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpPersistentLevelActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpPlayerMeshesDebugInfo
// (Final, Exec, Native, Public)

void URBCheatManager::DumpPlayerMeshesDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpPlayerMeshesDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpReplicatedLevelActors
// (Final, Exec, Native, Public)

void URBCheatManager::DumpReplicatedLevelActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpReplicatedLevelActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpServerLog
// (Final, Exec, Native, Public)

void URBCheatManager::DumpServerLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpServerLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpSoundVolumes
// (Final, Exec, Native, Public)

void URBCheatManager::DumpSoundVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpSoundVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.DumpWWWStats
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::DumpWWWStats(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "DumpWWWStats");

	Params::RBCheatManager_DumpWWWStats Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.EnableAutoBackfill
// (Final, Exec, Native, Public)

void URBCheatManager::EnableAutoBackfill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "EnableAutoBackfill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.EndExperiment
// (Final, Exec, Native, Public)

void URBCheatManager::EndExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "EndExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.EquipOutfit
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           OutfitId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::EquipOutfit(const class FString& OutfitId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "EquipOutfit");

	Params::RBCheatManager_EquipOutfit Parms{};

	Parms.OutfitId = std::move(OutfitId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FailStage
// (Final, Exec, Native, Public)

void URBCheatManager::FailStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FailStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FeatureSwitchAllCosmeticsOn
// (Final, Exec, Native, Public)

void URBCheatManager::FeatureSwitchAllCosmeticsOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FeatureSwitchAllCosmeticsOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FeatureSwitchOff
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FeatureSwitch                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::FeatureSwitchOff(const class FString& FeatureSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FeatureSwitchOff");

	Params::RBCheatManager_FeatureSwitchOff Parms{};

	Parms.FeatureSwitch = std::move(FeatureSwitch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FeatureSwitchOn
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FeatureSwitch                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::FeatureSwitchOn(const class FString& FeatureSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FeatureSwitchOn");

	Params::RBCheatManager_FeatureSwitchOn Parms{};

	Parms.FeatureSwitch = std::move(FeatureSwitch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FeatureSwitchToggle
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FeatureSwitch                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::FeatureSwitchToggle(const class FString& FeatureSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FeatureSwitchToggle");

	Params::RBCheatManager_FeatureSwitchToggle Parms{};

	Parms.FeatureSwitch = std::move(FeatureSwitch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FixedCam
// (Exec, Native, Public)

void URBCheatManager::FixedCam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FixedCam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FlushNetDormancyActorInView
// (Final, Exec, Native, Public)

void URBCheatManager::FlushNetDormancyActorInView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FlushNetDormancyActorInView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceAssignPlayerCell
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceAssignPlayerCell(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceAssignPlayerCell");

	Params::RBCheatManager_ForceAssignPlayerCell Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceGrabs
// (Final, Exec, Native, Public)

void URBCheatManager::ForceGrabs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceGrabs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceGrabsInDirection
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Direction                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceGrabsInDirection(const class FString& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceGrabsInDirection");

	Params::RBCheatManager_ForceGrabsInDirection Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceHideLoadingScreen
// (Final, Exec, Native, Public)

void URBCheatManager::ForceHideLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceHideLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceHudMode
// (Final, Exec, Native, Public)
// Parameters:
// EHudMode                                HudMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceHudMode(EHudMode HudMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceHudMode");

	Params::RBCheatManager_ForceHudMode Parms{};

	Parms.HudMode = HudMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceJoinPlayerSessionErrors
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceJoinPlayerSessionErrors(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceJoinPlayerSessionErrors");

	Params::RBCheatManager_ForceJoinPlayerSessionErrors Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceJumpOverOnFakePlayer
// (Final, Exec, Native, Public)

void URBCheatManager::ForceJumpOverOnFakePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceJumpOverOnFakePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceLungeAttacks
// (Final, Exec, Native, Public)

void URBCheatManager::ForceLungeAttacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceLungeAttacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceMovementDesynch
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DesyncSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceMovementDesynch(float DesyncSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceMovementDesynch");

	Params::RBCheatManager_ForceMovementDesynch Parms{};

	Parms.DesyncSize = DesyncSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForcePawnAnimOptimLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ForcedLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForcePawnAnimOptimLevel(int32 ForcedLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForcePawnAnimOptimLevel");

	Params::RBCheatManager_ForcePawnAnimOptimLevel Parms{};

	Parms.ForcedLevel = ForcedLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForcePreLoginError
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Error                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForcePreLoginError(const class FString& Error, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForcePreLoginError");

	Params::RBCheatManager_ForcePreLoginError Parms{};

	Parms.Error = std::move(Error);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceRandomSoundsCycle
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceRandomSoundsCycle(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceRandomSoundsCycle");

	Params::RBCheatManager_ForceRandomSoundsCycle Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceRandomState
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SearchQuery                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceRandomState(const class FString& SearchQuery, bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceRandomState");

	Params::RBCheatManager_ForceRandomState Parms{};

	Parms.SearchQuery = std::move(SearchQuery);
	Parms.bStateA = bStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceShowLoadingScreen
// (Final, Exec, Native, Public)

void URBCheatManager::ForceShowLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceShowLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceSnapToStateForAllActors
// (Final, Exec, Native, Public)

void URBCheatManager::ForceSnapToStateForAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceSnapToStateForAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseAllContainers
// (Final, Exec, Native, Public)

void URBCheatManager::ForceUseAllContainers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseAllContainers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseAllObjectiveActors
// (Final, Exec, Native, Public)

void URBCheatManager::ForceUseAllObjectiveActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseAllObjectiveActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseAllPuzzleRooms
// (Final, Exec, Native, Public)

void URBCheatManager::ForceUseAllPuzzleRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseAllPuzzleRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseAllRewardRooms
// (Final, Exec, Native, Public)

void URBCheatManager::ForceUseAllRewardRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseAllRewardRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseAllTrapsOfType
// (Final, Exec, Native, Public)
// Parameters:
// EObstacleVariatorType                   TrapType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ForceUseAllTrapsOfType(EObstacleVariatorType TrapType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseAllTrapsOfType");

	Params::RBCheatManager_ForceUseAllTrapsOfType Parms{};

	Parms.TrapType = TrapType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ForceUseClientOnlyLevels
// (Final, Exec, Native, Public)

void URBCheatManager::ForceUseClientOnlyLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ForceUseClientOnlyLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FreeCam
// (Exec, Native, Public)

void URBCheatManager::FreeCam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FreeCam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.FreeCamClean
// (Exec, Native, Public)

void URBCheatManager::FreeCamClean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "FreeCamClean");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.GetGoodCharacter
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::GetGoodCharacter(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "GetGoodCharacter");

	Params::RBCheatManager_GetGoodCharacter Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.GetLevelSeed
// (Final, Exec, Native, Public)

void URBCheatManager::GetLevelSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "GetLevelSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.GetRich
// (Final, Exec, Native, Public)

void URBCheatManager::GetRich()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "GetRich");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.GotoTargetAI
// (Final, Exec, Native, Public)

void URBCheatManager::GotoTargetAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "GotoTargetAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HealSelf
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HealSelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HealSelf");

	Params::RBCheatManager_HealSelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HeatmapClampMax
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HeatmapClampMax(float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HeatmapClampMax");

	Params::RBCheatManager_HeatmapClampMax Parms{};

	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HeatmapClampMin
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HeatmapClampMin(float Min)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HeatmapClampMin");

	Params::RBCheatManager_HeatmapClampMin Parms{};

	Parms.Min = Min;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HeatmapLowpass
// (Final, Exec, Native, Public)

void URBCheatManager::HeatmapLowpass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HeatmapLowpass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Dead
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Dead(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Dead");

	Params::RBCheatManager_HitReaction_Dead Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Flinch
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Flinch(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Flinch");

	Params::RBCheatManager_HitReaction_Flinch Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Heavy
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Heavy(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Heavy");

	Params::RBCheatManager_HitReaction_Heavy Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Knockdown
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Knockdown(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Knockdown");

	Params::RBCheatManager_HitReaction_Knockdown Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Light
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Light(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Light");

	Params::RBCheatManager_HitReaction_Light Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HitReaction_Medium
// (Final, Exec, Native, Public)
// Parameters:
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HitReaction_Medium(float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HitReaction_Medium");

	Params::RBCheatManager_HitReaction_Medium Parms{};

	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.HurtSelf
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitReaction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HurtType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::HurtSelf(float Amount, bool bHitReaction, int32 HurtType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "HurtSelf");

	Params::RBCheatManager_HurtSelf Parms{};

	Parms.Amount = Amount;
	Parms.bHitReaction = bHitReaction;
	Parms.HurtType = HurtType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.IncapacitateSelf
// (Final, Exec, Native, Public)

void URBCheatManager::IncapacitateSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "IncapacitateSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.IncrementTrialsCompletedCount
// (Final, Exec, Native, Public)

void URBCheatManager::IncrementTrialsCompletedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "IncrementTrialsCompletedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteBleedOut
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteBleedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteBottles
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteBottles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteBottles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteBricks
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteBricks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteBricks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteGibs
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteGibs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteGibs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteLockpick
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteLockpick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteLockpick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteMasterKey
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteMasterKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteMasterKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.InfiniteThrowables
// (Final, Exec, Native, Public)

void URBCheatManager::InfiniteThrowables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "InfiniteThrowables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.JoinParty
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ProfileId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::JoinParty(const class FString& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "JoinParty");

	Params::RBCheatManager_JoinParty Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.keOnDebugActorInView
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::KeOnDebugActorInView(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "keOnDebugActorInView");

	Params::RBCheatManager_KeOnDebugActorInView Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.keOnDebugActorInViewOnServer
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::KeOnDebugActorInViewOnServer(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "keOnDebugActorInViewOnServer");

	Params::RBCheatManager_KeOnDebugActorInViewOnServer Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Kick
// (Final, Exec, Native, Public)

void URBCheatManager::Kick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Kick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillBots
// (Final, Exec, Native, Public)

void URBCheatManager::KillBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillFakePlayers
// (Final, Exec, Native, Public)

void URBCheatManager::KillFakePlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillFakePlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillOtherBots
// (Final, Exec, Native, Public)

void URBCheatManager::KillOtherBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillOtherBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillSelectedBot
// (Final, Exec, Native, Public)

void URBCheatManager::KillSelectedBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillSelectedBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillSelf
// (Final, Exec, Native, Public)

void URBCheatManager::KillSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.KillSelfInstant
// (Final, Exec, Native, Public)

void URBCheatManager::KillSelfInstant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "KillSelfInstant");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListAllActiveSounds
// (Final, Exec, Native, Public)

void URBCheatManager::ListAllActiveSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListAllActiveSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListAllActiveSoundsInGroup
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ListAllActiveSoundsInGroup(class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListAllActiveSoundsInGroup");

	Params::RBCheatManager_ListAllActiveSoundsInGroup Parms{};

	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListAllTickingActors
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ListAllTickingActors(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListAllTickingActors");

	Params::RBCheatManager_ListAllTickingActors Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListContainers
// (Final, Exec, Native, Public)

void URBCheatManager::ListContainers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListContainers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListItems
// (Final, Exec, Native, Public)

void URBCheatManager::ListItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListLoadedAnimationSequences
// (Final, Exec, Native, Public)

void URBCheatManager::ListLoadedAnimationSequences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListLoadedAnimationSequences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListNews
// (Final, Exec, Native, Public)

void URBCheatManager::ListNews()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListNews");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListStaticMeshNoCollision
// (Final, Exec, Native, Public)

void URBCheatManager::ListStaticMeshNoCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListStaticMeshNoCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ListTickingSkelComp
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ListTickingSkelComp(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ListTickingSkelComp");

	Params::RBCheatManager_ListTickingSkelComp Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.LoadAllVOSwitchGroups
// (Final, Exec, Native, Public)

void URBCheatManager::LoadAllVOSwitchGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "LoadAllVOSwitchGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.LoadHeatmap
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::LoadHeatmap(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "LoadHeatmap");

	Params::RBCheatManager_LoadHeatmap Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.LoadProfile
// (Final, Exec, Native, Public)

void URBCheatManager::LoadProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "LoadProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.LoadWWW
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::LoadWWW(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "LoadWWW");

	Params::RBCheatManager_LoadWWW Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Local_SetInteractibleNetCullDistanceSquared
// (Final, Exec, Native, Public)
// Parameters:
// float                                   NetCullDistanceSquared                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::Local_SetInteractibleNetCullDistanceSquared(float NetCullDistanceSquared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Local_SetInteractibleNetCullDistanceSquared");

	Params::RBCheatManager_Local_SetInteractibleNetCullDistanceSquared Parms{};

	Parms.NetCullDistanceSquared = NetCullDistanceSquared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Local_SetTriggerableNetCullDistanceSquared
// (Final, Exec, Native, Public)
// Parameters:
// float                                   NetCullDistanceSquared                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::Local_SetTriggerableNetCullDistanceSquared(float NetCullDistanceSquared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Local_SetTriggerableNetCullDistanceSquared");

	Params::RBCheatManager_Local_SetTriggerableNetCullDistanceSquared Parms{};

	Parms.NetCullDistanceSquared = NetCullDistanceSquared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.LogStreamingDebug
// (Final, Exec, Native, Public)

void URBCheatManager::LogStreamingDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "LogStreamingDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.MakeNoise
// (Final, Exec, Native, Public)

void URBCheatManager::MakeNoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "MakeNoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.MarketingMode
// (Final, Exec, Native, Public)

void URBCheatManager::MarketingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "MarketingMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.MulticastCommand
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InMulticastCommand                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::MulticastCommand(const class FString& InMulticastCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "MulticastCommand");

	Params::RBCheatManager_MulticastCommand Parms{};

	Parms.InMulticastCommand = std::move(InMulticastCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.NextDebugActorInView
// (Final, Exec, Native, Public)

void URBCheatManager::NextDebugActorInView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "NextDebugActorInView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.PasteCameraLocation
// (Final, Exec, Native, Public)

void URBCheatManager::PasteCameraLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "PasteCameraLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.PersistPlayerProgression
// (Final, Exec, Native, Public)

void URBCheatManager::PersistPlayerProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "PersistPlayerProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.PlaytestMode
// (Final, Exec, Native, Public)

void URBCheatManager::PlaytestMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "PlaytestMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.PlayVO
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SoundEventName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ForcedRandomSeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::PlayVO(const class FString& SoundEventName, const class FString& SwitchGroup, const class FString& SwitchState, int32 ForcedRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "PlayVO");

	Params::RBCheatManager_PlayVO Parms{};

	Parms.SoundEventName = std::move(SoundEventName);
	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);
	Parms.ForcedRandomSeed = ForcedRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.PreviousDebugActorInView
// (Final, Exec, Native, Public)

void URBCheatManager::PreviousDebugActorInView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "PreviousDebugActorInView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.Profiling_NextCamera
// (Final, Exec, Native, Public)

void URBCheatManager::Profiling_NextCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "Profiling_NextCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.QuickTest
// (Final, Exec, Native, Public)

void URBCheatManager::QuickTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "QuickTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.QuickTestServer
// (Final, Exec, Native, Public)

void URBCheatManager::QuickTestServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "QuickTestServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RandomizeCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::RandomizeCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RandomizeCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RBSlomoFaster
// (Final, Exec, Native, Public)

void URBCheatManager::RBSlomoFaster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RBSlomoFaster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RBSlomoSlower
// (Final, Exec, Native, Public)

void URBCheatManager::RBSlomoSlower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RBSlomoSlower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ReactivateBenchmarkOnNextBoot
// (Final, Exec, Native, Public)

void URBCheatManager::ReactivateBenchmarkOnNextBoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ReactivateBenchmarkOnNextBoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RefreshPathfindingCosts
// (Final, Exec, Native, Public)

void URBCheatManager::RefreshPathfindingCosts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RefreshPathfindingCosts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RefreshTrialChainingChoices
// (Final, Exec, Native, Public)

void URBCheatManager::RefreshTrialChainingChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RefreshTrialChainingChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RemoveDebugActorInViewFilter
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::RemoveDebugActorInViewFilter(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RemoveDebugActorInViewFilter");

	Params::RBCheatManager_RemoveDebugActorInViewFilter Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RemoveVariator
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::RemoveVariator(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RemoveVariator");

	Params::RBCheatManager_RemoveVariator Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RequestReleaseCurrentCharacter
// (Final, Exec, Native, Public)

void URBCheatManager::RequestReleaseCurrentCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RequestReleaseCurrentCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ReregisterInteractionZonesWithRBWorld
// (Final, Exec, Native, Public)

void URBCheatManager::ReregisterInteractionZonesWithRBWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ReregisterInteractionZonesWithRBWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetAccount
// (Final, Exec, Native, Public)

void URBCheatManager::ResetAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetAccountProgression
// (Final, Exec, Native, Public)

void URBCheatManager::ResetAccountProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetAccountProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetCharacterProgression
// (Final, Exec, Native, Public)

void URBCheatManager::ResetCharacterProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetCharacterProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetCustomization
// (Final, Exec, Native, Public)

void URBCheatManager::ResetCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetDoors
// (Final, Exec, Native, Public)

void URBCheatManager::ResetDoors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetDoors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetLoadouts
// (Final, Exec, Native, Public)

void URBCheatManager::ResetLoadouts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetLoadouts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetPlayer
// (Final, Exec, Native, Public)

void URBCheatManager::ResetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetStage
// (Final, Exec, Native, Public)

void URBCheatManager::ResetStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetStageWithSeed
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ResetStageWithSeed(int32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetStageWithSeed");

	Params::RBCheatManager_ResetStageWithSeed Parms{};

	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetStorylinePlayedHistory
// (Final, Exec, Native, Public)

void URBCheatManager::ResetStorylinePlayedHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetStorylinePlayedHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetWorldState
// (Final, Exec, Native, Public)

void URBCheatManager::ResetWorldState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetWorldState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetWorldState_Input
// (Final, Native, Public)

void URBCheatManager::ResetWorldState_Input()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetWorldState_Input");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ResetWorldStateWithSeed
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ResetWorldStateWithSeed(int32 RandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ResetWorldStateWithSeed");

	Params::RBCheatManager_ResetWorldStateWithSeed Parms{};

	Parms.RandomSeed = RandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RespawnAllPlayers
// (Final, Exec, Native, Public)

void URBCheatManager::RespawnAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RespawnAllPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RespawnDeadPlayers
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::RespawnDeadPlayers(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RespawnDeadPlayers");

	Params::RBCheatManager_RespawnDeadPlayers Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RestartExperiment
// (Final, Exec, Native, Public)

void URBCheatManager::RestartExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RestartExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.RevalidateLedgeMarkers
// (Final, Exec, Native, Public)

void URBCheatManager::RevalidateLedgeMarkers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "RevalidateLedgeMarkers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SaveProfile
// (Final, Exec, Native, Public)

void URBCheatManager::SaveProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SaveProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SaveTrialChainingSaveState
// (Final, Exec, Native, Public)

void URBCheatManager::SaveTrialChainingSaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SaveTrialChainingSaveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SaveWWW
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SaveWWW(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SaveWWW");

	Params::RBCheatManager_SaveWWW Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SCE
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ServerConsoleEvent                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SCE(const class FString& ServerConsoleEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SCE");

	Params::RBCheatManager_SCE Parms{};

	Parms.ServerConsoleEvent = std::move(ServerConsoleEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SendXPEvent
// (Final, Exec, Native, Public)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SendXPEvent(EPlayerEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SendXPEvent");

	Params::RBCheatManager_SendXPEvent Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ServerCmd
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_ServerCmd                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ServerCmd(const class FString& Param_ServerCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ServerCmd");

	Params::RBCheatManager_ServerCmd Parms{};

	Parms.Param_ServerCmd = std::move(Param_ServerCmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ServerComponentsReport
// (Final, Exec, Native, Public)

void URBCheatManager::ServerComponentsReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ServerComponentsReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetActiveSkill
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SkillDisplayName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetActiveSkill(const class FString& SkillDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetActiveSkill");

	Params::RBCheatManager_SetActiveSkill Parms{};

	Parms.SkillDisplayName = std::move(SkillDisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetBreadcrumbsLogsEnabled
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetBreadcrumbsLogsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetBreadcrumbsLogsEnabled");

	Params::RBCheatManager_SetBreadcrumbsLogsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetBudgetPawnsHigh
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetBudgetPawnsHigh(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetBudgetPawnsHigh");

	Params::RBCheatManager_SetBudgetPawnsHigh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetBudgetPawnsVeryHigh
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetBudgetPawnsVeryHigh(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetBudgetPawnsVeryHigh");

	Params::RBCheatManager_SetBudgetPawnsVeryHigh Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetCharacterIcon
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             IconId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetCharacterIcon(const class FName& IconId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetCharacterIcon");

	Params::RBCheatManager_SetCharacterIcon Parms{};

	Parms.IconId = IconId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetCharacterLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetCharacterLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetCharacterLevel");

	Params::RBCheatManager_SetCharacterLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetCpulimit
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Limit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetCpulimit(int32 Limit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetCpulimit");

	Params::RBCheatManager_SetCpulimit Parms{};

	Parms.Limit = Limit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetDebugCameraRotationRatio
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetDebugCameraRotationRatio(float Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetDebugCameraRotationRatio");

	Params::RBCheatManager_SetDebugCameraRotationRatio Parms{};

	Parms.Ratio = Ratio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetDebugForceFeedbackScaling
// (Final, Exec, Native, Public)
// Parameters:
// float                                   SmallScaling                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LargeScaling                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetDebugForceFeedbackScaling(float SmallScaling, float LargeScaling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetDebugForceFeedbackScaling");

	Params::RBCheatManager_SetDebugForceFeedbackScaling Parms{};

	Parms.SmallScaling = SmallScaling;
	Parms.LargeScaling = LargeScaling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetFreeCamGamepadLookSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Sensitivity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetFreeCamGamepadLookSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetFreeCamGamepadLookSensitivity");

	Params::RBCheatManager_SetFreeCamGamepadLookSensitivity Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetFreeCamMouseSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Sensitivity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetFreeCamMouseSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetFreeCamMouseSensitivity");

	Params::RBCheatManager_SetFreeCamMouseSensitivity Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetFreeCamMoveSpeed
// (Final, Exec, Native, Public)
// Parameters:
// float                                   MovementSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetFreeCamMoveSpeed(float MovementSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetFreeCamMoveSpeed");

	Params::RBCheatManager_SetFreeCamMoveSpeed Parms{};

	Parms.MovementSpeed = MovementSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetFreeCamPos
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetFreeCamPos(float X, float Y, float Z, float Roll, float Pitch, float Yaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetFreeCamPos");

	Params::RBCheatManager_SetFreeCamPos Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Roll = Roll;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetGameDifficulty
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DifficultyStr                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetGameDifficulty(const class FString& DifficultyStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetGameDifficulty");

	Params::RBCheatManager_SetGameDifficulty Parms{};

	Parms.DifficultyStr = std::move(DifficultyStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetInteractibleNetCullDistanceSquared
// (Final, Exec, Native, Public)
// Parameters:
// float                                   NetCullDistanceSquared                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetInteractibleNetCullDistanceSquared(float NetCullDistanceSquared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetInteractibleNetCullDistanceSquared");

	Params::RBCheatManager_SetInteractibleNetCullDistanceSquared Parms{};

	Parms.NetCullDistanceSquared = NetCullDistanceSquared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetLevelSeed
// (Final, Exec, Native, Public)
// Parameters:
// uint32                                  InitSeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetLevelSeed(uint32 InitSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetLevelSeed");

	Params::RBCheatManager_SetLevelSeed Parms{};

	Parms.InitSeed = InitSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetMarketingMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetMarketingMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetMarketingMode");

	Params::RBCheatManager_SetMarketingMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetMaxNumberOfPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   MaxNumberOfPlayers                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetMaxNumberOfPlayers(int32 MaxNumberOfPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetMaxNumberOfPlayers");

	Params::RBCheatManager_SetMaxNumberOfPlayers Parms{};

	Parms.MaxNumberOfPlayers = MaxNumberOfPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetMaxReservedPlayerSlotsOverride
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   MaxReservedPlayerSlotsOverride                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetMaxReservedPlayerSlotsOverride(int32 MaxReservedPlayerSlotsOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetMaxReservedPlayerSlotsOverride");

	Params::RBCheatManager_SetMaxReservedPlayerSlotsOverride Parms{};

	Parms.MaxReservedPlayerSlotsOverride = MaxReservedPlayerSlotsOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetNoConnectionTimeout
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    NoTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetNoConnectionTimeout(bool NoTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetNoConnectionTimeout");

	Params::RBCheatManager_SetNoConnectionTimeout Parms{};

	Parms.NoTimeout = NoTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetNVBattery
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetNVBattery(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetNVBattery");

	Params::RBCheatManager_SetNVBattery Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetPlatformPartition
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Partition                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetPlatformPartition(const class FString& Partition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetPlatformPartition");

	Params::RBCheatManager_SetPlatformPartition Parms{};

	Parms.Partition = std::move(Partition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetPlayerLoadout
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           LoadoutCode                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetPlayerLoadout(const class FString& LoadoutCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetPlayerLoadout");

	Params::RBCheatManager_SetPlayerLoadout Parms{};

	Parms.LoadoutCode = std::move(LoadoutCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetServerAnimTickOptimsEnabled
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetServerAnimTickOptimsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetServerAnimTickOptimsEnabled");

	Params::RBCheatManager_SetServerAnimTickOptimsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetServerPartition
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Partition                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetServerPartition(const class FString& Partition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetServerPartition");

	Params::RBCheatManager_SetServerPartition Parms{};

	Parms.Partition = std::move(Partition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetSoloMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSoloMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetSoloMode(bool bSoloMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetSoloMode");

	Params::RBCheatManager_SetSoloMode Parms{};

	Parms.bSoloMode = bSoloMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetSubtitleSize
// (Final, Exec, Native, Public)
// Parameters:
// EUIFontSize                             Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetSubtitleSize(EUIFontSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetSubtitleSize");

	Params::RBCheatManager_SetSubtitleSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetTrialCompleted
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetTrialCompleted(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetTrialCompleted");

	Params::RBCheatManager_SetTrialCompleted Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetTrialsCompletedCount
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetTrialsCompletedCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetTrialsCompletedCount");

	Params::RBCheatManager_SetTrialsCompletedCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetTriggerableNetCullDistanceSquared
// (Final, Exec, Native, Public)
// Parameters:
// float                                   NetCullDistanceSquared                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetTriggerableNetCullDistanceSquared(float NetCullDistanceSquared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetTriggerableNetCullDistanceSquared");

	Params::RBCheatManager_SetTriggerableNetCullDistanceSquared Parms{};

	Parms.NetCullDistanceSquared = NetCullDistanceSquared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetTutorialSize
// (Final, Exec, Native, Public)
// Parameters:
// EUIFontSize                             Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetTutorialSize(EUIFontSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetTutorialSize");

	Params::RBCheatManager_SetTutorialSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SetVOSwitch
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SetVOSwitch(const class FString& SwitchGroup, const class FString& SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SetVOSwitch");

	Params::RBCheatManager_SetVOSwitch Parms{};

	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShoveAIs
// (Final, Exec, Native, Public)

void URBCheatManager::ShoveAIs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShoveAIs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowAll
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SearchQuery                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowAll(const class FString& SearchQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowAll");

	Params::RBCheatManager_ShowAll Parms{};

	Parms.SearchQuery = std::move(SearchQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowAllItems
// (Final, Exec, Native, Public)
// Parameters:
// EItemType                               ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowAllItems(EItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowAllItems");

	Params::RBCheatManager_ShowAllItems Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowBadgeNotification
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           BadgeId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowBadgeNotification(const class FString& BadgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowBadgeNotification");

	Params::RBCheatManager_ShowBadgeNotification Parms{};

	Parms.BadgeId = std::move(BadgeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowEndOfStageScreen
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowEndOfStageScreen(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowEndOfStageScreen");

	Params::RBCheatManager_ShowEndOfStageScreen Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowError
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Facility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowError(const class FString& Message, int32 Facility, int32 Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowError");

	Params::RBCheatManager_ShowError Parms{};

	Parms.Message = std::move(Message);
	Parms.Facility = Facility;
	Parms.Code = Code;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowFirstPartyStore
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ProductId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowFirstPartyStore(const class FString& ProductId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowFirstPartyStore");

	Params::RBCheatManager_ShowFirstPartyStore Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowFriendInviteNotification
// (Final, Exec, Native, Public)

void URBCheatManager::ShowFriendInviteNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowFriendInviteNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowHudGameMessage
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowHudGameMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowHudGameMessage");

	Params::RBCheatManager_ShowHudGameMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowMatchAcceptanceNotification
// (Final, Exec, Native, Public)

void URBCheatManager::ShowMatchAcceptanceNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowMatchAcceptanceNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowPartyInviteNotification
// (Final, Exec, Native, Public)

void URBCheatManager::ShowPartyInviteNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowPartyInviteNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowQuickGraph
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowQuickGraph(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowQuickGraph");

	Params::RBCheatManager_ShowQuickGraph Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowStageIntro
// (Final, Exec, Native, Public)

void URBCheatManager::ShowStageIntro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowStageIntro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ShowWorldOctreeObjects
// (Final, Exec, Native, Public)
// Parameters:
// EDebugWorldOctreeObjectType             ObjectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ShowWorldOctreeObjects(EDebugWorldOctreeObjectType ObjectType, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ShowWorldOctreeObjects");

	Params::RBCheatManager_ShowWorldOctreeObjects Parms{};

	Parms.ObjectType = ObjectType;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SimulateRTADisconnection
// (Final, Exec, Native, Public)

void URBCheatManager::SimulateRTADisconnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SimulateRTADisconnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SingleFrame
// (Final, Exec, Native, Public)

void URBCheatManager::SingleFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SingleFrame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SoloFoley
// (Final, Exec, Native, Public)

void URBCheatManager::SoloFoley()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SoloFoley");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SoloMusic
// (Final, Exec, Native, Public)

void URBCheatManager::SoloMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SoloMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SoloReset
// (Final, Exec, Native, Public)

void URBCheatManager::SoloReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SoloReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SoloSFX
// (Final, Exec, Native, Public)

void URBCheatManager::SoloSFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SoloSFX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SoloVO
// (Final, Exec, Native, Public)

void URBCheatManager::SoloVO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SoloVO");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnAI
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CheatName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnAI(const class FString& CheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnAI");

	Params::RBCheatManager_SpawnAI Parms{};

	Parms.CheatName = std::move(CheatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnDeadPlayer
// (Final, Exec, Native, Public)

void URBCheatManager::SpawnDeadPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnDeadPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnDownedPlayer
// (Final, Exec, Native, Public)

void URBCheatManager::SpawnDownedPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnDownedPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnFollowAI
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CheatName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnFollowAI(const class FString& CheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnFollowAI");

	Params::RBCheatManager_SpawnFollowAI Parms{};

	Parms.CheatName = std::move(CheatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnGuard
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnGuard(const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnGuard");

	Params::RBCheatManager_SpawnGuard Parms{};

	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnInteractingPlayer
// (Final, Exec, Native, Public)

void URBCheatManager::SpawnInteractingPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnInteractingPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnLargePickup
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnLargePickup(const class FString& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnLargePickup");

	Params::RBCheatManager_SpawnLargePickup Parms{};

	Parms.ItemName = std::move(ItemName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnMultipleLargePickups
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberOfCopy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnMultipleLargePickups(const class FString& ItemName, int32 NumberOfCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnMultipleLargePickups");

	Params::RBCheatManager_SpawnMultipleLargePickups Parms{};

	Parms.ItemName = std::move(ItemName);
	Parms.NumberOfCopy = NumberOfCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnPouncersInHidingSpot
// (Final, Exec, Native, Public)

void URBCheatManager::SpawnPouncersInHidingSpot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnPouncersInHidingSpot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnRandomPouncers
// (Final, Exec, Native, Public)

void URBCheatManager::SpawnRandomPouncers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnRandomPouncers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.SpawnScientist
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::SpawnScientist(const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "SpawnScientist");

	Params::RBCheatManager_SpawnScientist Parms{};

	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartEndOfStageDamage
// (Final, Exec, Native, Public)

void URBCheatManager::StartEndOfStageDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartEndOfStageDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartExperiment
// (Final, Exec, Native, Public)

void URBCheatManager::StartExperiment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartExperiment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartObjectiveCoordinator
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::StartObjectiveCoordinator(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartObjectiveCoordinator");

	Params::RBCheatManager_StartObjectiveCoordinator Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartPsychosis
// (Final, Exec, Native, Public)

void URBCheatManager::StartPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartPsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartPsychosisSpook
// (Final, Exec, Native, Public)

void URBCheatManager::StartPsychosisSpook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartPsychosisSpook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartRelease
// (Final, Exec, Native, Public)

void URBCheatManager::StartRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartStageEnding
// (Final, Exec, Native, Public)

void URBCheatManager::StartStageEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartStageEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StartWWiseProfiling
// (Final, Exec, Native, Public)

void URBCheatManager::StartWWiseProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StartWWiseProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StatHLODMem
// (Final, Exec, Native, Public)

void URBCheatManager::StatHLODMem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StatHLODMem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StopPsychosis
// (Final, Exec, Native, Public)

void URBCheatManager::StopPsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StopPsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StopWWiseProfiling
// (Final, Exec, Native, Public)

void URBCheatManager::StopWWiseProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StopWWiseProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.StunSelf
// (Final, Exec, Native, Public)

void URBCheatManager::StunSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "StunSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TasksAddDay
// (Final, Exec, Native, Public)

void URBCheatManager::TasksAddDay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TasksAddDay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TeleportAtLocation
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::TeleportAtLocation(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TeleportAtLocation");

	Params::RBCheatManager_TeleportAtLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TestDecodables
// (Final, Exec, Native, Public)

void URBCheatManager::TestDecodables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TestDecodables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TestIntercom
// (Final, Exec, Native, Public)

void URBCheatManager::TestIntercom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TestIntercom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TestRandomness
// (Final, Exec, Native, Public)

void URBCheatManager::TestRandomness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TestRandomness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleAll
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SearchQuery                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ToggleAll(const class FString& SearchQuery, bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleAll");

	Params::RBCheatManager_ToggleAll Parms{};

	Parms.SearchQuery = std::move(SearchQuery);
	Parms.bStateA = bStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleAlwaysAllowLoadoutMenu
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleAlwaysAllowLoadoutMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleAlwaysAllowLoadoutMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleAlwaysKeepConsumables
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleAlwaysKeepConsumables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleAlwaysKeepConsumables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleAnimationLog
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ToggleAnimationLog(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleAnimationLog");

	Params::RBCheatManager_ToggleAnimationLog Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleCameraShake
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleCameraShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleCameraShake");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleCheats
// (Exec, Native, Public)

void URBCheatManager::ToggleCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleCheats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleConditionalDebugActorInViewServer
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleConditionalDebugActorInViewServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleConditionalDebugActorInViewServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDarknessEffect
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDarknessEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDarknessEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDebugDarknessUpdate
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDebugDarknessUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDebugDarknessUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDebugMenu
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDebugMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDebugSelectedActor
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDebugSelectedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDebugSelectedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDebugStreaming
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDebugStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDebugStreaming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDisablePawnAnimOptimUpgrades
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDisablePawnAnimOptimUpgrades()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDisablePawnAnimOptimUpgrades");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleDumpWidgetHierarchyOnClick
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleDumpWidgetHierarchyOnClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleDumpWidgetHierarchyOnClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleFoleys
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleFoleys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleFoleys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleForceFeedback
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleForceFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleForceFeedback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleFullMovementLog
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleFullMovementLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleFullMovementLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleGameplayPPS
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleGameplayPPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleGameplayPPS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleInfiniteActiveSkills
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleInfiniteActiveSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleInfiniteActiveSkills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleInfiniteLives
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleInfiniteLives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleInfiniteLives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleInvisibleToBots
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleInvisibleToBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleInvisibleToBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleLoudnessMeter
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleLoudnessMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleLoudnessMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleMapWarnings
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleMapWarnings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleMapWarnings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleMusic
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleMute
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleMute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleNavmesh
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleNavmesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleNavmesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleNetMoveCorrection
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleNetMoveCorrection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleNetMoveCorrection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleNPCDebugIcons
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleNPCDebugIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleNPCDebugIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleOnlineDebug
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleOnlineDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleOnlineDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleOverseerInfo
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleOverseerInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleOverseerInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleOverseerMode
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleOverseerMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleOverseerMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TogglePause
// (Final, Exec, Native, Public)

void URBCheatManager::TogglePause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TogglePause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TogglePerformanceCapture
// (Final, Exec, Native, Public)

void URBCheatManager::TogglePerformanceCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TogglePerformanceCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TogglePlayerDetectionComponentsDebug
// (Final, Exec, Native, Public)

void URBCheatManager::TogglePlayerDetectionComponentsDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TogglePlayerDetectionComponentsDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TogglePsychosisDebugHud
// (Final, Exec, Native, Public)

void URBCheatManager::TogglePsychosisDebugHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TogglePsychosisDebugHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleReplacementSound
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FString                           SoundEventName                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ToggleReplacementSound(class FString* SoundEventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleReplacementSound");

	Params::RBCheatManager_ToggleReplacementSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SoundEventName != nullptr)
		*SoundEventName = std::move(Parms.SoundEventName);
}


// Function OPP.RBCheatManager.ToggleResetStageWhenAllPlayersDead
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleResetStageWhenAllPlayersDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleResetStageWhenAllPlayersDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleRespawnDeadPlayerInStage
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleRespawnDeadPlayerInStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleRespawnDeadPlayerInStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleSilentForBots
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleSilentForBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleSilentForBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleSpectator
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleStatUnit
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleStatUnit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleStatUnit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleStimulusDebug
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleStimulusDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleStimulusDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleVariator
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           VariatorName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::ToggleVariator(const class FString& VariatorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleVariator");

	Params::RBCheatManager_ToggleVariator Parms{};

	Parms.VariatorName = std::move(VariatorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleVOs
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleVOs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleVOs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ToggleWWWMode
// (Final, Exec, Native, Public)

void URBCheatManager::ToggleWWWMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ToggleWWWMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TriggerAIEvent
// (Final, Exec, Native, Public)
// Parameters:
// EAIEvent                                AIEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::TriggerAIEvent(EAIEvent AIEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TriggerAIEvent");

	Params::RBCheatManager_TriggerAIEvent Parms{};

	Parms.AIEvent = AIEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TriggerAll
// (Final, Exec, Native, Public)

void URBCheatManager::TriggerAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TriggerAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TriggerForceFeedback
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TypeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::TriggerForceFeedback(const class FString& TypeName, bool bLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TriggerForceFeedback");

	Params::RBCheatManager_TriggerForceFeedback Parms{};

	Parms.TypeName = std::move(TypeName);
	Parms.bLoop = bLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.TriggerPeriodicHazard
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::TriggerPeriodicHazard(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "TriggerPeriodicHazard");

	Params::RBCheatManager_TriggerPeriodicHazard Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.UnlockAllTrials
// (Final, Exec, Native, Public)

void URBCheatManager::UnlockAllTrials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "UnlockAllTrials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.UntriggerAll
// (Final, Exec, Native, Public)

void URBCheatManager::UntriggerAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "UntriggerAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.UpdateStatistic
// (Final, Exec, Native, Public)
// Parameters:
// EPlayerStat                             PlayerStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCheatManager::UpdateStatistic(EPlayerStat PlayerStat, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "UpdateStatistic");

	Params::RBCheatManager_UpdateStatistic Parms{};

	Parms.PlayerStat = PlayerStat;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ViewMode_Design
// (Final, Exec, Native, Public)

void URBCheatManager::ViewMode_Design()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ViewMode_Design");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ViewMode_Lit
// (Final, Exec, Native, Public)

void URBCheatManager::ViewMode_Lit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ViewMode_Lit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ViewMode_Lit_DetailLighting
// (Final, Exec, Native, Public)

void URBCheatManager::ViewMode_Lit_DetailLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ViewMode_Lit_DetailLighting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCheatManager.ViewMode_Wireframe
// (Final, Exec, Native, Public)

void URBCheatManager::ViewMode_Wireframe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCheatManager", "ViewMode_Wireframe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNotificationUserWidget.Accept
// (Native, Public, BlueprintCallable)

void URBNotificationUserWidget::Accept()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Accept");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNotificationUserWidget.Block
// (Native, Public, BlueprintCallable)

void URBNotificationUserWidget::Block()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Block");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNotificationUserWidget.Event_Accepted
// (Event, Public, BlueprintEvent)

void URBNotificationUserWidget::Event_Accepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_Accepted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNotificationUserWidget.Event_Blocked
// (Event, Public, BlueprintEvent)

void URBNotificationUserWidget::Event_Blocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_Blocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNotificationUserWidget.Event_Hide
// (Event, Public, BlueprintEvent)

void URBNotificationUserWidget::Event_Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_Hide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNotificationUserWidget.Event_Refused
// (Event, Public, BlueprintEvent)

void URBNotificationUserWidget::Event_Refused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_Refused");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNotificationUserWidget.Event_Show
// (Event, Public, BlueprintEvent)

void URBNotificationUserWidget::Event_Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_Show");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNotificationUserWidget.Event_UpdateDisplayTime
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_TotalDisplayTime                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNotificationUserWidget::Event_UpdateDisplayTime(float DisplayTime, float Param_TotalDisplayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Event_UpdateDisplayTime");

	Params::RBNotificationUserWidget_Event_UpdateDisplayTime Parms{};

	Parms.DisplayTime = DisplayTime;
	Parms.Param_TotalDisplayTime = Param_TotalDisplayTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNotificationUserWidget.Hidden
// (Final, Native, Public, BlueprintCallable)

void URBNotificationUserWidget::Hidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Hidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNotificationUserWidget.Hide
// (Native, Public, BlueprintCallable)

void URBNotificationUserWidget::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNotificationUserWidget.Refuse
// (Native, Public, BlueprintCallable)

void URBNotificationUserWidget::Refuse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNotificationUserWidget", "Refuse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChemicalZone.OnActorEnterZone
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChemicalZone::OnActorEnterZone(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChemicalZone", "OnActorEnterZone");

	Params::RBChemicalZone_OnActorEnterZone Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChemicalZone.OnActorExitZone
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChemicalZone::OnActorExitZone(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChemicalZone", "OnActorExitZone");

	Params::RBChemicalZone_OnActorExitZone Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChemicalZone.OnRep_Enabled
// (Final, Native, Private)

void ARBChemicalZone::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChemicalZone", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChemicalZone.SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChemicalZone::SetEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChemicalZone", "SetEnabled");

	Params::RBChemicalZone_SetEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.GetLocalPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBChessBoardPanelComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBChessBoardPanelComponent* ARBChessBoard::GetLocalPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetLocalPanel");

	Params::RBChessBoard_GetLocalPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetLocalPositionForCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        Coord                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBChessBoard::GetLocalPositionForCoord(const struct FIntPoint& Coord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetLocalPositionForCoord");

	Params::RBChessBoard_GetLocalPositionForCoord Parms{};

	Parms.Coord = std::move(Coord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetMatchesLost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetMatchesLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetMatchesLost");

	Params::RBChessBoard_GetMatchesLost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetMatchesWon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetMatchesWon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetMatchesWon");

	Params::RBChessBoard_GetMatchesWon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetOpponentMatchesLost
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetOpponentMatchesLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetOpponentMatchesLost");

	Params::RBChessBoard_GetOpponentMatchesLost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetOpponentMatchesWon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetOpponentMatchesWon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetOpponentMatchesWon");

	Params::RBChessBoard_GetOpponentMatchesWon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetOpponentPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBChessBoardPanelComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBChessBoardPanelComponent* ARBChessBoard::GetOpponentPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetOpponentPanel");

	Params::RBChessBoard_GetOpponentPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetOpponentPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* ARBChessBoard::GetOpponentPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetOpponentPlayer");

	Params::RBChessBoard_GetOpponentPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetOpponentRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetOpponentRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetOpponentRating");

	Params::RBChessBoard_GetOpponentRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetPossibleCoordsForPiece
// (Final, Native, Public)
// Parameters:
// class URBChessPieceComponent*           ChessPiece                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntPoint>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntPoint> ARBChessBoard::GetPossibleCoordsForPiece(class URBChessPieceComponent* ChessPiece)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetPossibleCoordsForPiece");

	Params::RBChessBoard_GetPossibleCoordsForPiece Parms{};

	Parms.ChessPiece = ChessPiece;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetPromotingCoords
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntPoint>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntPoint> ARBChessBoard::GetPromotingCoords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetPromotingCoords");

	Params::RBChessBoard_GetPromotingCoords Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBChessBoard::GetRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetRating");

	Params::RBChessBoard_GetRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetTeamChessPanelComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EChessTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBChessBoardPanelComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBChessBoardPanelComponent* ARBChessBoard::GetTeamChessPanelComponent(EChessTeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetTeamChessPanelComponent");

	Params::RBChessBoard_GetTeamChessPanelComponent Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.GetTeamRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EChessTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBChessBoard::GetTeamRemainingTime(EChessTeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "GetTeamRemainingTime");

	Params::RBChessBoard_GetTeamRemainingTime Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.IsEndReasonDrawType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EChessGameEndReason                     EndReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBChessBoard::IsEndReasonDrawType(EChessGameEndReason EndReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "IsEndReasonDrawType");

	Params::RBChessBoard_IsEndReasonDrawType Parms{};

	Parms.EndReason = EndReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.IsGameInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBChessBoard::IsGameInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "IsGameInProgress");

	Params::RBChessBoard_IsGameInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoard.Multicast_BroadcastMatchEndMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        WinnerPtr                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        LoserPtr                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDraw                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChessBoard::Multicast_BroadcastMatchEndMessage(class ARBPlayer* WinnerPtr, class ARBPlayer* LoserPtr, bool bIsDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "Multicast_BroadcastMatchEndMessage");

	Params::RBChessBoard_Multicast_BroadcastMatchEndMessage Parms{};

	Parms.WinnerPtr = WinnerPtr;
	Parms.LoserPtr = LoserPtr;
	Parms.bIsDraw = bIsDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.Multicast_BroadcastMatchStartMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Player1Ptr                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player2Ptr                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChessBoard::Multicast_BroadcastMatchStartMessage(class ARBPlayer* Player1Ptr, class ARBPlayer* Player2Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "Multicast_BroadcastMatchStartMessage");

	Params::RBChessBoard_Multicast_BroadcastMatchStartMessage Parms{};

	Parms.Player1Ptr = Player1Ptr;
	Parms.Player2Ptr = Player2Ptr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.Multicast_PlayerDropPieceAt
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// EChessTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        TargetLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBChessBoard::Multicast_PlayerDropPieceAt(EChessTeam Team, const struct FIntPoint& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "Multicast_PlayerDropPieceAt");

	Params::RBChessBoard_Multicast_PlayerDropPieceAt Parms{};

	Parms.Team = Team;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_ChessBoardSideA
// (Final, Native, Public)

void ARBChessBoard::OnRep_ChessBoardSideA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_ChessBoardSideA");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_ChessClockData
// (Final, Native, Public)

void ARBChessBoard::OnRep_ChessClockData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_ChessClockData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_ChessGameEndReason
// (Final, Native, Public)

void ARBChessBoard::OnRep_ChessGameEndReason()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_ChessGameEndReason");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_ChessGameState
// (Final, Native, Public)

void ARBChessBoard::OnRep_ChessGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_ChessGameState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_ChessGameTurnType
// (Final, Native, Public)

void ARBChessBoard::OnRep_ChessGameTurnType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_ChessGameTurnType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_LastMoveCoords
// (Final, Native, Public)

void ARBChessBoard::OnRep_LastMoveCoords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_LastMoveCoords");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_Stats
// (Final, Native, Private)

void ARBChessBoard::OnRep_Stats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_Stats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_Team
// (Final, Native, Public)

void ARBChessBoard::OnRep_Team()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_Team");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.OnRep_TeamTurn
// (Final, Native, Public)

void ARBChessBoard::OnRep_TeamTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "OnRep_TeamTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoard.RegisterDebugPiecesData
// (Final, Native, Public, BlueprintCallable)

void ARBChessBoard::RegisterDebugPiecesData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoard", "RegisterDebugPiecesData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.BP_ChessGamePlayerAnimStateChanged
// (Event, Public, BlueprintEvent)

void URBChessBoardPanelComponent::BP_ChessGamePlayerAnimStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "BP_ChessGamePlayerAnimStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBChessBoardPanelComponent.Event_PlayerDropPieceAt
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                        Coords                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::Event_PlayerDropPieceAt(const struct FVector2D& Coords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "Event_PlayerDropPieceAt");

	Params::RBChessBoardPanelComponent_Event_PlayerDropPieceAt Parms{};

	Parms.Coords = std::move(Coords);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBChessBoardPanelComponent.Event_PlayerEnteredGame
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::Event_PlayerEnteredGame(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "Event_PlayerEnteredGame");

	Params::RBChessBoardPanelComponent_Event_PlayerEnteredGame Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBChessBoardPanelComponent.Event_PlayerLeftGame
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::Event_PlayerLeftGame(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "Event_PlayerLeftGame");

	Params::RBChessBoardPanelComponent_Event_PlayerLeftGame Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBChessBoardPanelComponent.Event_ShowMoveLeavesOwnKingChecked
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBChessPieceComponent*           KingPiece                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::Event_ShowMoveLeavesOwnKingChecked(class URBChessPieceComponent* KingPiece)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "Event_ShowMoveLeavesOwnKingChecked");

	Params::RBChessBoardPanelComponent_Event_ShowMoveLeavesOwnKingChecked Parms{};

	Parms.KingPiece = KingPiece;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBChessBoardPanelComponent.GetHoldingPiece
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBChessPieceComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBChessPieceComponent* URBChessBoardPanelComponent::GetHoldingPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "GetHoldingPiece");

	Params::RBChessBoardPanelComponent_GetHoldingPiece Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.GetLocalPosFromCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        Coords                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D URBChessBoardPanelComponent::GetLocalPosFromCoord(const struct FIntPoint& Coords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "GetLocalPosFromCoord");

	Params::RBChessBoardPanelComponent_GetLocalPosFromCoord Parms{};

	Parms.Coords = std::move(Coords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.GetLocalPosFromProjPos
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ProjWorldPos                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D URBChessBoardPanelComponent::GetLocalPosFromProjPos(const struct FVector& ProjWorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "GetLocalPosFromProjPos");

	Params::RBChessBoardPanelComponent_GetLocalPosFromProjPos Parms{};

	Parms.ProjWorldPos = std::move(ProjWorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.GetWorldPosFromCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        Coords                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBChessBoardPanelComponent::GetWorldPosFromCoord(const struct FIntPoint& Coords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "GetWorldPosFromCoord");

	Params::RBChessBoardPanelComponent_GetWorldPosFromCoord Parms{};

	Parms.Coords = std::move(Coords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.GetWSFocusedLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bUseReplicatedValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBChessBoardPanelComponent::GetWSFocusedLocation(bool bUseReplicatedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "GetWSFocusedLocation");

	Params::RBChessBoardPanelComponent_GetWSFocusedLocation Parms{};

	Parms.bUseReplicatedValue = bUseReplicatedValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.IsPlayer1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBChessBoardPanelComponent::IsPlayer1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "IsPlayer1");

	Params::RBChessBoardPanelComponent_IsPlayer1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessBoardPanelComponent.OnChessGameStateChanged
// (Final, Native, Public)
// Parameters:
// EChessGameState                         NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::OnChessGameStateChanged(EChessGameState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnChessGameStateChanged");

	Params::RBChessBoardPanelComponent_OnChessGameStateChanged Parms{};

	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.OnHoldingPieceChangedCallback
// (Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::OnHoldingPieceChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnHoldingPieceChangedCallback");

	Params::RBChessBoardPanelComponent_OnHoldingPieceChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.OnRep_ChessGamePlayerAnimState
// (Final, Native, Public)

void URBChessBoardPanelComponent::OnRep_ChessGamePlayerAnimState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnRep_ChessGamePlayerAnimState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.OnRep_HoldingPiece
// (Final, Native, Public)

void URBChessBoardPanelComponent::OnRep_HoldingPiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnRep_HoldingPiece");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.OnRep_Turn
// (Final, Native, Public)

void URBChessBoardPanelComponent::OnRep_Turn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnRep_Turn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.OnTurnChangedCallback
// (Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::OnTurnChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "OnTurnChangedCallback");

	Params::RBChessBoardPanelComponent_OnTurnChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessBoardPanelComponent.SetChessGamePlayerAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EChessGamePlayerAnimState               NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBChessBoardPanelComponent::SetChessGamePlayerAnimState(EChessGamePlayerAnimState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessBoardPanelComponent", "SetChessGamePlayerAnimState");

	Params::RBChessBoardPanelComponent_SetChessGamePlayerAnimState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialBoxComponent.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBFloorMaterialBoxComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialBoxComponent", "BeginOverlap");

	Params::RBFloorMaterialBoxComponent_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialBoxComponent.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFloorMaterialBoxComponent::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialBoxComponent", "BP_SetEnabled");

	Params::RBFloorMaterialBoxComponent_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialBoxComponent.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFloorMaterialBoxComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialBoxComponent", "EndOverlap");

	Params::RBFloorMaterialBoxComponent_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFloorMaterialBoxComponent.OnRep_Enabled
// (Final, Native, Public)

void URBFloorMaterialBoxComponent::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFloorMaterialBoxComponent", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessPieceComponent.GetCoordinates
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FIntPoint                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FIntPoint URBChessPieceComponent::GetCoordinates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessPieceComponent", "GetCoordinates");

	Params::RBChessPieceComponent_GetCoordinates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChessPieceComponent.OnRep_PieceData
// (Final, Native, Private)

void URBChessPieceComponent::OnRep_PieceData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessPieceComponent", "OnRep_PieceData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessPieceComponent.UpdatePosition
// (Final, Native, Public, BlueprintCallable)

void URBChessPieceComponent::UpdatePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessPieceComponent", "UpdatePosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBChessSpectatorPanelComponent.Multicast_PlayerTaunt
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URBChessSpectatorPanelComponent::Multicast_PlayerTaunt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChessSpectatorPanelComponent", "Multicast_PlayerTaunt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialChainingUpgradeMenu.BP_Refresh
// (Event, Public, BlueprintEvent)

void URBTrialChainingUpgradeMenu::BP_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "BP_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrialChainingUpgradeMenu.OnAcquiredItemsChanged
// (Final, Native, Protected)

void URBTrialChainingUpgradeMenu::OnAcquiredItemsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "OnAcquiredItemsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialChainingUpgradeMenu.OnCurrentLoadoutChanged
// (Final, Native, Protected)

void URBTrialChainingUpgradeMenu::OnCurrentLoadoutChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "OnCurrentLoadoutChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialChainingUpgradeMenu.PurchaseItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialChainingUpgradeMenu::PurchaseItem(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "PurchaseItem");

	Params::RBTrialChainingUpgradeMenu_PurchaseItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialChainingUpgradeMenu.PurchaseNextSkillUpgrade
// (Final, Native, Public, BlueprintCallable)

void URBTrialChainingUpgradeMenu::PurchaseNextSkillUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "PurchaseNextSkillUpgrade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialChainingUpgradeMenu.CanAccessUpgradeMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialChainingUpgradeMenu::CanAccessUpgradeMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "CanAccessUpgradeMenu");

	Params::RBTrialChainingUpgradeMenu_CanAccessUpgradeMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialChainingUpgradeMenu.GetTrialChainingUpgradeChoiceCost
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBTrialChainingUpgradeMenu::GetTrialChainingUpgradeChoiceCost(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "GetTrialChainingUpgradeChoiceCost");

	Params::RBTrialChainingUpgradeMenu_GetTrialChainingUpgradeChoiceCost Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialChainingUpgradeMenu.IsATrialChainingUpgradeChoice
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialChainingUpgradeMenu::IsATrialChainingUpgradeChoice(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialChainingUpgradeMenu", "IsATrialChainingUpgradeChoice");

	Params::RBTrialChainingUpgradeMenu_IsATrialChainingUpgradeChoice Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBChunkInstallManager.GetChunkInstallationStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Percent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBChunkInstallManager::GetChunkInstallationStatus(float* Percent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChunkInstallManager", "GetChunkInstallationStatus");

	Params::RBChunkInstallManager_GetChunkInstallationStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Percent != nullptr)
		*Percent = Parms.Percent;

	return Parms.ReturnValue;
}


// Function OPP.RBChunkInstallManager.IsChunkInstallationCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBChunkInstallManager::IsChunkInstallationCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBChunkInstallManager", "IsChunkInstallationCompleted");

	Params::RBChunkInstallManager_IsChunkInstallationCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCinematicZoneComponent.OnActiveSkillActorChanged
// (Final, Native, Private)
// Parameters:
// class ARBActiveSkill*                   ActiveSkillActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCinematicZoneComponent::OnActiveSkillActorChanged(class ARBActiveSkill* ActiveSkillActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCinematicZoneComponent", "OnActiveSkillActorChanged");

	Params::RBCinematicZoneComponent_OnActiveSkillActorChanged Parms{};

	Parms.ActiveSkillActor = ActiveSkillActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCinematicZoneComponent.OnPlayerCustomizationChanged
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        RBPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCinematicZoneComponent::OnPlayerCustomizationChanged(class ARBPlayer* RBPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCinematicZoneComponent", "OnPlayerCustomizationChanged");

	Params::RBCinematicZoneComponent_OnPlayerCustomizationChanged Parms{};

	Parms.RBPlayer = RBPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCinematicZoneComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCinematicZoneComponent::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCinematicZoneComponent", "SetEnabled");

	Params::RBCinematicZoneComponent_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLockable.Lock
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBLockable::Lock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLockable", "Lock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLockable.OnLocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBLockable::OnLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLockable", "OnLocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLockable.OnUnlocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBLockable::OnUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLockable", "OnUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLockable.Unlock
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBLockable::Unlock(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLockable", "Unlock");

	Params::RBLockable_Unlock Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLockable.IsLocked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBLockable::IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLockable", "IsLocked");

	Params::RBLockable_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBClueable.GetAssociatedInvestigationComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URBPlayerInvestigationZoneComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerInvestigationZoneComponent* IRBClueable::GetAssociatedInvestigationComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBClueable", "GetAssociatedInvestigationComponent");

	Params::RBClueable_GetAssociatedInvestigationComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBClueable.GetClue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FClueData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FClueData IRBClueable::GetClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBClueable", "GetClue");

	Params::RBClueable_GetClue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBClueable.SetClue
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FClueData                        ClueData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IRBClueable::SetClue(const struct FClueData& ClueData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBClueable", "SetClue");

	Params::RBClueable_SetClue Parms{};

	Parms.ClueData = std::move(ClueData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXManager.BP_StartAdditiveFOVAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      FOVCurve                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFXManager::BP_StartAdditiveFOVAnim(const class UCurveFloat* FOVCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXManager", "BP_StartAdditiveFOVAnim");

	Params::RBFXManager_BP_StartAdditiveFOVAnim Parms{};

	Parms.FOVCurve = FOVCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXManager.DisableGameplayEffectsFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ControlName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFXManager::DisableGameplayEffectsFor(class FName ControlName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXManager", "DisableGameplayEffectsFor");

	Params::RBFXManager_DisableGameplayEffectsFor Parms{};

	Parms.ControlName = ControlName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXManager.EnableGameplayEffectsFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ControlName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFXManager::EnableGameplayEffectsFor(class FName ControlName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXManager", "EnableGameplayEffectsFor");

	Params::RBFXManager_EnableGameplayEffectsFor Parms{};

	Parms.ControlName = ControlName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXManager.SetBrightnessCalibrationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHDR                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFXManager::SetBrightnessCalibrationMode(bool bEnable, bool bHDR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXManager", "SetBrightnessCalibrationMode");

	Params::RBFXManager_SetBrightnessCalibrationMode Parms{};

	Parms.bEnable = bEnable;
	Parms.bHDR = bHDR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXManager.BP_AreGameplayEffectsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBFXManager::BP_AreGameplayEffectsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXManager", "BP_AreGameplayEffectsEnabled");

	Params::RBFXManager_BP_AreGameplayEffectsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCollectibleDocumentsConfig.GetCollectibleDocumentDefinition
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBCollectibleDocumentDefinitionRowReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBCollectibleDocumentDefinitionRow URBCollectibleDocumentsConfig::GetCollectibleDocumentDefinition(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentsConfig", "GetCollectibleDocumentDefinition");

	Params::RBCollectibleDocumentsConfig_GetCollectibleDocumentDefinition Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroup
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBCollectibleDocumentGroupRowReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBCollectibleDocumentGroupRow URBCollectibleDocumentsConfig::GetDocumentGroup(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentsConfig", "GetDocumentGroup");

	Params::RBCollectibleDocumentsConfig_GetDocumentGroup Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroupDocuments
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRBCollectibleDocumentDefinitionRow>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBCollectibleDocumentDefinitionRow> URBCollectibleDocumentsConfig::GetDocumentGroupDocuments(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentsConfig", "GetDocumentGroupDocuments");

	Params::RBCollectibleDocumentsConfig_GetDocumentGroupDocuments Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroups
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRBCollectibleDocumentGroupRow>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBCollectibleDocumentGroupRow> URBCollectibleDocumentsConfig::GetDocumentGroups() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentsConfig", "GetDocumentGroups");

	Params::RBCollectibleDocumentsConfig_GetDocumentGroups Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTutorialManager.OnObjectiveCoordinatorStateChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTutorialManager::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTutorialManager", "OnObjectiveCoordinatorStateChanged");

	Params::RBTutorialManager_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTutorialManager.OnPlayerRevived
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTutorialManager::OnPlayerRevived(class ARBPlayer* InstigatorActor, class ARBPlayer* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTutorialManager", "OnPlayerRevived");

	Params::RBTutorialManager_OnPlayerRevived Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCollectibleDocumentPickup.Event_OnWorldPopulateFinished
// (Event, Protected, BlueprintEvent)

void ARBCollectibleDocumentPickup::Event_OnWorldPopulateFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentPickup", "Event_OnWorldPopulateFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCollectibleDocumentPickup.Multicast_OnDocumentPickedUp
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        RBPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstInteraction                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasAcquired                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCollectibleDocumentPickup::Multicast_OnDocumentPickedUp(class ARBPlayer* RBPlayer, bool bFirstInteraction, bool bWasAcquired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentPickup", "Multicast_OnDocumentPickedUp");

	Params::RBCollectibleDocumentPickup_Multicast_OnDocumentPickedUp Parms{};

	Parms.RBPlayer = RBPlayer;
	Parms.bFirstInteraction = bFirstInteraction;
	Parms.bWasAcquired = bWasAcquired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCollectibleDocumentPickup.OnRep_ProfileIdsInteracted
// (Final, Native, Private)

void ARBCollectibleDocumentPickup::OnRep_ProfileIdsInteracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentPickup", "OnRep_ProfileIdsInteracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCollectibleDocumentPickup.GetDocumentId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ARBCollectibleDocumentPickup::GetDocumentId(class ARBPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectibleDocumentPickup", "GetDocumentId");

	Params::RBCollectibleDocumentPickup_GetDocumentId Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCollectItemsCoordinator.Multicast_OnPickupCollected
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCollectItemsCoordinator::Multicast_OnPickupCollected(class ARBPlayer* Player, class ARBPickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectItemsCoordinator", "Multicast_OnPickupCollected");

	Params::RBCollectItemsCoordinator_Multicast_OnPickupCollected Parms{};

	Parms.Player = Player;
	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCollectItemsCoordinator.OnPlayerCollectItem
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCollectItemsCoordinator::OnPlayerCollectItem(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCollectItemsCoordinator", "OnPlayerCollectItem");

	Params::RBCollectItemsCoordinator_OnPlayerCollectItem Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.ApplyChanges
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBinding::ApplyChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "ApplyChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.CancelNewBinding
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBinding::CancelNewBinding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "CancelNewBinding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.CaptureNewBinding
// (Final, Native, Public)
// Parameters:
// class URBMenuControlBindingEntry*       Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuControlBinding::CaptureNewBinding(class URBMenuControlBindingEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "CaptureNewBinding");

	Params::RBMenuControlBinding_CaptureNewBinding Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.ConfirmNewBinding
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBinding::ConfirmNewBinding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "ConfirmNewBinding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.Event_DuplicateBindingFound
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBMenuControlBindingEntry*       DuplicateEntry                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuControlBinding::Event_DuplicateBindingFound(class URBMenuControlBindingEntry* DuplicateEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "Event_DuplicateBindingFound");

	Params::RBMenuControlBinding_Event_DuplicateBindingFound Parms{};

	Parms.DuplicateEntry = DuplicateEntry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuControlBinding.Event_OnBindingCaptureEnded
// (Event, Public, BlueprintEvent)

void URBMenuControlBinding::Event_OnBindingCaptureEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "Event_OnBindingCaptureEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuControlBinding.Event_UpdateRebindStatus
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsRebindInProgress                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuControlBinding::Event_UpdateRebindStatus(bool IsRebindInProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "Event_UpdateRebindStatus");

	Params::RBMenuControlBinding_Event_UpdateRebindStatus Parms{};

	Parms.IsRebindInProgress = IsRebindInProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuControlBinding.HasAnyUnsavedChanges
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuControlBinding::HasAnyUnsavedChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "HasAnyUnsavedChanges");

	Params::RBMenuControlBinding_HasAnyUnsavedChanges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuControlBinding.InitBindingEntries
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBinding::InitBindingEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "InitBindingEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.OnInputKey
// (Final, Native, Public)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuControlBinding::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "OnInputKey");

	Params::RBMenuControlBinding_OnInputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.EventType = EventType;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBinding.SetToDefaults
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBinding::SetToDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBinding", "SetToDefaults");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomManager.BP_ForceRandomization
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBRandomManager::BP_ForceRandomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomManager", "BP_ForceRandomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomManager.BP_Randomize
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBRandomManager::BP_Randomize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomManager", "BP_Randomize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBConditionalRandomManager.OnRandomManagerRandomizationDone
// (Final, Native, Public)

void ARBConditionalRandomManager::OnRandomManagerRandomizationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBConditionalRandomManager", "OnRandomManagerRandomizationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBContainerSpawnLocationComponent.Editor_CreateAllItemDisplayMeshes
// (Final, Native, Public)

void URBContainerSpawnLocationComponent::Editor_CreateAllItemDisplayMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContainerSpawnLocationComponent", "Editor_CreateAllItemDisplayMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSubtitleVisibilityInterface.ShouldHideSubtitles
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBSubtitleVisibilityInterface::ShouldHideSubtitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSubtitleVisibilityInterface", "ShouldHideSubtitles");

	Params::RBSubtitleVisibilityInterface_ShouldHideSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBContinuousMovementSoundComponent.ResetMovementDelta
// (Final, Native, Public, BlueprintCallable)

void URBContinuousMovementSoundComponent::ResetMovementDelta()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBContinuousMovementSoundComponent", "ResetMovementDelta");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFaceAnimTalkerInterface.StopFacialAnim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBFaceAnimTalkerInterface::StopFacialAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFaceAnimTalkerInterface", "StopFacialAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFaceAnimTalkerInterface.TryPlayFacialAnim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBFaceAnimTalkerInterface::TryPlayFacialAnim(const class FString& LineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFaceAnimTalkerInterface", "TryPlayFacialAnim");

	Params::RBFaceAnimTalkerInterface_TryPlayFacialAnim Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBFaceAnimTalkerInterface.FindFaceAnimSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           LineId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* IRBFaceAnimTalkerInterface::FindFaceAnimSequence(const class FString& LineId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFaceAnimTalkerInterface", "FindFaceAnimSequence");

	Params::RBFaceAnimTalkerInterface_FindFaceAnimSequence Parms{};

	Parms.LineId = std::move(LineId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBFaceAnimTalkerInterface.GetFaceFXSkeletalMeshComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* IRBFaceAnimTalkerInterface::GetFaceFXSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFaceAnimTalkerInterface", "GetFaceFXSkeletalMeshComponent");

	Params::RBFaceAnimTalkerInterface_GetFaceFXSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBFaceAnimTalkerInterface.GetVoiceComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class URBSoundComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSoundComponent* IRBFaceAnimTalkerInterface::GetVoiceComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFaceAnimTalkerInterface", "GetVoiceComponent");

	Params::RBFaceAnimTalkerInterface_GetVoiceComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeLobby.OnPawnKilled
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameModeLobby::OnPawnKilled(class ARBPawn* InstigatorActor, class ARBPawn* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeLobby", "OnPawnKilled");

	Params::RBGameModeLobby_OnPawnKilled Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeLobby.StartRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBLobbyPlayerController*         RBLobbyPlayerController                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameModeLobby::StartRelease(class ARBLobbyPlayerController* RBLobbyPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeLobby", "StartRelease");

	Params::RBGameModeLobby_StartRelease Parms{};

	Parms.RBLobbyPlayerController = RBLobbyPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBConveyorBelt.SetInteractible_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInteractible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBConveyorBelt::SetInteractible_Server(bool bInteractible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBConveyorBelt", "SetInteractible_Server");

	Params::RBConveyorBelt_SetInteractible_Server Parms{};

	Parms.bInteractible = bInteractible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBConveyorBelt.StartFollowingActors_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBConveyorBelt::StartFollowingActors_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBConveyorBelt", "StartFollowingActors_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBConveyorBelt.StopFollowingActors_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBConveyorBelt::StopFollowingActors_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBConveyorBelt", "StopFollowingActors_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyGamePanelComponent.Event_PlayerEnteredGame
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLobbyGamePanelComponent::Event_PlayerEnteredGame(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGamePanelComponent", "Event_PlayerEnteredGame");

	Params::RBLobbyGamePanelComponent_Event_PlayerEnteredGame Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyGamePanelComponent.Event_PlayerLeftGame
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLobbyGamePanelComponent::Event_PlayerLeftGame(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGamePanelComponent", "Event_PlayerLeftGame");

	Params::RBLobbyGamePanelComponent_Event_PlayerLeftGame Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyGamePanelComponent.OnLobbyGameStateChanged
// (Final, Native, Public)
// Parameters:
// ELobbyGameState                         NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLobbyGamePanelComponent::OnLobbyGameStateChanged(ELobbyGameState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGamePanelComponent", "OnLobbyGameStateChanged");

	Params::RBLobbyGamePanelComponent_OnLobbyGameStateChanged Parms{};

	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGamePanelComponent.GetPlayerMatchData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIsLocalPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStroopPlayerMatchData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStroopPlayerMatchData URBStroopGamePanelComponent::GetPlayerMatchData(bool bIsLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGamePanelComponent", "GetPlayerMatchData");

	Params::RBStroopGamePanelComponent_GetPlayerMatchData Parms{};

	Parms.bIsLocalPlayer = bIsLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStroopGamePanelComponent.Multicast_OptionChosen
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBStroopGameButton*              Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRightAnswer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBStroopGamePanelComponent::Multicast_OptionChosen(class ARBStroopGameButton* Button, bool bRightAnswer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGamePanelComponent", "Multicast_OptionChosen");

	Params::RBStroopGamePanelComponent_Multicast_OptionChosen Parms{};

	Parms.Button = Button;
	Parms.bRightAnswer = bRightAnswer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGamePanelComponent.SetButtonsSpinningState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSpinning                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBStroopGamePanelComponent::SetButtonsSpinningState(bool bSpinning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGamePanelComponent", "SetButtonsSpinningState");

	Params::RBStroopGamePanelComponent_SetButtonsSpinningState Parms{};

	Parms.bSpinning = bSpinning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGamePanelComponent.GetButtonAnswer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBStroopGameButton*              Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStroopGameColor                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStroopGameColor URBStroopGamePanelComponent::GetButtonAnswer(class ARBStroopGameButton* Button) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGamePanelComponent", "GetButtonAnswer");

	Params::RBStroopGamePanelComponent_GetButtonAnswer Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHackPanelComponent.BP_OnUnlockAnimationDone
// (Final, Native, Public, BlueprintCallable)

void URBHackPanelComponent::BP_OnUnlockAnimationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "BP_OnUnlockAnimationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.BP_TemporaryDisable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::BP_TemporaryDisable(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "BP_TemporaryDisable");

	Params::RBHackPanelComponent_BP_TemporaryDisable Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnBrokenByProjectile
// (Net, Native, Event, NetMulticast, Public)

void URBHackPanelComponent::Multicast_OnBrokenByProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnBrokenByProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnPanelSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnPanelSucceeded");

	Params::RBHackPanelComponent_Multicast_OnPanelSucceeded Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnStageFailed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_OnStageFailed(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnStageFailed");

	Params::RBHackPanelComponent_Multicast_OnStageFailed Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnStageNeutral
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_OnStageNeutral(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnStageNeutral");

	Params::RBHackPanelComponent_Multicast_OnStageNeutral Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnStageSoftFail
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_OnStageSoftFail(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnStageSoftFail");

	Params::RBHackPanelComponent_Multicast_OnStageSoftFail Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnStageStarted
// (Net, Native, Event, NetMulticast, Public)

void URBHackPanelComponent::Multicast_OnStageStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnStageStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_OnStageSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_OnStageSucceeded(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_OnStageSucceeded");

	Params::RBHackPanelComponent_Multicast_OnStageSucceeded Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.Multicast_SetInteractionPawnTimestamp
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   InteractionPawnTimeStamp                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_NeedleRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::Multicast_SetInteractionPawnTimestamp(float InteractionPawnTimeStamp, float Param_NeedleRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "Multicast_SetInteractionPawnTimestamp");

	Params::RBHackPanelComponent_Multicast_SetInteractionPawnTimestamp Parms{};

	Parms.InteractionPawnTimeStamp = InteractionPawnTimeStamp;
	Parms.Param_NeedleRatio = Param_NeedleRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnLastRatioChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::OnLastRatioChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnLastRatioChangedCallback");

	Params::RBHackPanelComponent_OnLastRatioChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnNumberOfTripLeftChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::OnNumberOfTripLeftChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnNumberOfTripLeftChangedCallback");

	Params::RBHackPanelComponent_OnNumberOfTripLeftChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnRep_LastRatio
// (Final, Native, Private)

void URBHackPanelComponent::OnRep_LastRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnRep_LastRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnRep_NumberOfTripLeft
// (Final, Native, Private)

void URBHackPanelComponent::OnRep_NumberOfTripLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnRep_NumberOfTripLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnRep_QuadrantStates
// (Final, Native, Private)

void URBHackPanelComponent::OnRep_QuadrantStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnRep_QuadrantStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnRep_StageStartedPawnTimestamp
// (Final, Native, Private)

void URBHackPanelComponent::OnRep_StageStartedPawnTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnRep_StageStartedPawnTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.OnStageStartedPawnTimestampChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHackPanelComponent::OnStageStartedPawnTimestampChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "OnStageStartedPawnTimestampChangedCallback");

	Params::RBHackPanelComponent_OnStageStartedPawnTimestampChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHackPanelComponent.BP_GetNumberOfStageLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBHackPanelComponent::BP_GetNumberOfStageLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHackPanelComponent", "BP_GetNumberOfStageLeft");

	Params::RBHackPanelComponent_BP_GetNumberOfStageLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSplineFollowingActor.BP_ForceRefreshTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRefreshTickState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingActor::BP_ForceRefreshTransform(bool bRefreshTickState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_ForceRefreshTransform");

	Params::RBSplineFollowingActor_BP_ForceRefreshTransform Parms{};

	Parms.bRefreshTickState = bRefreshTickState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingActor.BP_OnCurrentSplineCompChanged
// (Event, Public, BlueprintEvent)

void ARBSplineFollowingActor::BP_OnCurrentSplineCompChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_OnCurrentSplineCompChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSplineFollowingActor.BP_OnPingPongExtremityEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingActor::BP_OnPingPongExtremityEvent(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_OnPingPongExtremityEvent");

	Params::RBSplineFollowingActor_BP_OnPingPongExtremityEvent Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSplineFollowingActor.BP_OnStartedMoving
// (Event, Public, BlueprintEvent)

void ARBSplineFollowingActor::BP_OnStartedMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_OnStartedMoving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSplineFollowingActor.BP_OnStoppedMoving
// (Event, Public, BlueprintEvent)

void ARBSplineFollowingActor::BP_OnStoppedMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_OnStoppedMoving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSplineFollowingActor.BP_SetCurrentSplineComp
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 NewSplineComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingActor::BP_SetCurrentSplineComp(class USplineComponent* NewSplineComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "BP_SetCurrentSplineComp");

	Params::RBSplineFollowingActor_BP_SetCurrentSplineComp Parms{};

	Parms.NewSplineComp = NewSplineComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingActor.FindDefaultSplineComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* ARBSplineFollowingActor::FindDefaultSplineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "FindDefaultSplineComponent");

	Params::RBSplineFollowingActor_FindDefaultSplineComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSplineFollowingActor.OnNetworkSyncInitialValueChanged
// (Final, Native, Public)
// Parameters:
// class URBNetworkSyncComponent*          NetworkSyncComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingActor::OnNetworkSyncInitialValueChanged(class URBNetworkSyncComponent* NetworkSyncComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "OnNetworkSyncInitialValueChanged");

	Params::RBSplineFollowingActor_OnNetworkSyncInitialValueChanged Parms{};

	Parms.NetworkSyncComponent = NetworkSyncComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingActor.OnNetworkSyncPlayStateChanged
// (Final, Native, Public)
// Parameters:
// class URBNetworkSyncComponent*          NetworkSyncComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingActor::OnNetworkSyncPlayStateChanged(class URBNetworkSyncComponent* NetworkSyncComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "OnNetworkSyncPlayStateChanged");

	Params::RBSplineFollowingActor_OnNetworkSyncPlayStateChanged Parms{};

	Parms.NetworkSyncComponent = NetworkSyncComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingActor.OnRep_CurrentSplineComp
// (Final, Native, Public)

void ARBSplineFollowingActor::OnRep_CurrentSplineComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingActor", "OnRep_CurrentSplineComp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBConveyorFollowingActor.RefreshSplineData_Server
// (Final, Native, Public)

void ARBConveyorFollowingActor::RefreshSplineData_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBConveyorFollowingActor", "RefreshSplineData_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTasksWidget.ConsumeTaskReward
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTasksWidget::ConsumeTaskReward(const class FName& TaskId, int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "ConsumeTaskReward");

	Params::RBTasksWidget_ConsumeTaskReward Parms{};

	Parms.TaskId = TaskId;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTasksWidget.Event_Build
// (Event, Public, BlueprintEvent)

void URBTasksWidget::Event_Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "Event_Build");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTasksWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBTasksWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTasksWidget.OnTaskProgressionEntriesChanged
// (Final, Native, Private)

void URBTasksWidget::OnTaskProgressionEntriesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "OnTaskProgressionEntriesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTasksWidget.CanConsumeRewards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTasksWidget::CanConsumeRewards() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "CanConsumeRewards");

	Params::RBTasksWidget_CanConsumeRewards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetActiveGroupIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> URBTasksWidget::GetActiveGroupIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetActiveGroupIds");

	Params::RBTasksWidget_GetActiveGroupIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetDaysUntilRefresh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBTasksWidget::GetDaysUntilRefresh(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetDaysUntilRefresh");

	Params::RBTasksWidget_GetDaysUntilRefresh Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetGroupIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> URBTasksWidget::GetGroupIcon(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetGroupIcon");

	Params::RBTasksWidget_GetGroupIcon Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetGroupName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText URBTasksWidget::GetGroupName(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetGroupName");

	Params::RBTasksWidget_GetGroupName Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetHoursUntilRefresh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBTasksWidget::GetHoursUntilRefresh(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetHoursUntilRefresh");

	Params::RBTasksWidget_GetHoursUntilRefresh Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetTaskProgression
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBTaskProgressionEntry          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRBTaskProgressionEntry URBTasksWidget::GetTaskProgression(const class FName& TaskId, int32 Seed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetTaskProgression");

	Params::RBTasksWidget_GetTaskProgression Parms{};

	Parms.TaskId = TaskId;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GetTasks
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRBTaskMenuEntry>   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FRBTaskMenuEntry> URBTasksWidget::GetTasks(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GetTasks");

	Params::RBTasksWidget_GetTasks Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.GroupHasRefreshTimer
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTasksWidget::GroupHasRefreshTimer(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "GroupHasRefreshTimer");

	Params::RBTasksWidget_GroupHasRefreshTimer Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTasksWidget.HasCompletedTasksPendingConsume
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTasksWidget::HasCompletedTasksPendingConsume(const class FName& GroupID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksWidget", "HasCompletedTasksPendingConsume");

	Params::RBTasksWidget_HasCompletedTasksPendingConsume Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnAccumulatedInteractionTimeChanged
// (Event, Public, BlueprintEvent)

void URBLargeObjectInteractionPanelComponent::Event_OnAccumulatedInteractionTimeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "Event_OnAccumulatedInteractionTimeChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnLargeObjectDoAction
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBLargePickup*                   LargeObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectInteractionPanelComponent::Event_OnLargeObjectDoAction(class ARBLargePickup* LargeObject, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "Event_OnLargeObjectDoAction");

	Params::RBLargeObjectInteractionPanelComponent_Event_OnLargeObjectDoAction Parms{};

	Parms.LargeObject = LargeObject;
	Parms.Interactor = Interactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnNumberOfCompletedInteractionsChanged
// (Event, Public, BlueprintEvent)

void URBLargeObjectInteractionPanelComponent::Event_OnNumberOfCompletedInteractionsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "Event_OnNumberOfCompletedInteractionsChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnTossIntoFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBLargePickup*                   LargeObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectInteractionPanelComponent::Event_OnTossIntoFinished(class ARBLargePickup* LargeObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "Event_OnTossIntoFinished");

	Params::RBLargeObjectInteractionPanelComponent_Event_OnTossIntoFinished Parms{};

	Parms.LargeObject = LargeObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnAccumulatedInteractionTimeChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectInteractionPanelComponent::OnAccumulatedInteractionTimeChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnAccumulatedInteractionTimeChangedCallback");

	Params::RBLargeObjectInteractionPanelComponent_OnAccumulatedInteractionTimeChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnInteractionTimeStartedPawnTimestampChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectInteractionPanelComponent::OnInteractionTimeStartedPawnTimestampChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnInteractionTimeStartedPawnTimestampChangedCallback");

	Params::RBLargeObjectInteractionPanelComponent_OnInteractionTimeStartedPawnTimestampChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnNumberOfCompletedInteractionsChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLargeObjectInteractionPanelComponent::OnNumberOfCompletedInteractionsChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnNumberOfCompletedInteractionsChangedCallback");

	Params::RBLargeObjectInteractionPanelComponent_OnNumberOfCompletedInteractionsChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_AccumulatedInteractionTime
// (Final, Native, Private)

void URBLargeObjectInteractionPanelComponent::OnRep_AccumulatedInteractionTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnRep_AccumulatedInteractionTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_InteractionTimeStartedPawnTimestamp
// (Final, Native, Private)

void URBLargeObjectInteractionPanelComponent::OnRep_InteractionTimeStartedPawnTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnRep_InteractionTimeStartedPawnTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_NumberOfCompletedInteractions
// (Final, Native, Private)

void URBLargeObjectInteractionPanelComponent::OnRep_NumberOfCompletedInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnRep_NumberOfCompletedInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_UsedLargeObjectRefs
// (Final, Native, Private)

void URBLargeObjectInteractionPanelComponent::OnRep_UsedLargeObjectRefs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "OnRep_UsedLargeObjectRefs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.GetInteractionDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBLargeObjectInteractionPanelComponent::GetInteractionDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "GetInteractionDuration");

	Params::RBLargeObjectInteractionPanelComponent_GetInteractionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.GetLargeObjectRef
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBLargePickup*                   Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* URBLargeObjectInteractionPanelComponent::GetLargeObjectRef(class ARBLargePickup* Pickup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "GetLargeObjectRef");

	Params::RBLargeObjectInteractionPanelComponent_GetLargeObjectRef Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.GetProgressRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBLargeObjectInteractionPanelComponent::GetProgressRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "GetProgressRatio");

	Params::RBLargeObjectInteractionPanelComponent_GetProgressRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.GetSpecialMoveAnimation
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFirstPerson                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBLargeObjectInteractionPanelComponent::GetSpecialMoveAnimation(class ARBPawn* Pawn, bool bIsFirstPerson) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "GetSpecialMoveAnimation");

	Params::RBLargeObjectInteractionPanelComponent_GetSpecialMoveAnimation Parms{};

	Parms.Pawn = Pawn;
	Parms.bIsFirstPerson = bIsFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargeObjectInteractionPanelComponent.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLargeObjectInteractionPanelComponent::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeObjectInteractionPanelComponent", "IsCompleted");

	Params::RBLargeObjectInteractionPanelComponent_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableComponent.CanOperate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOperatableComponent::CanOperate(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableComponent", "CanOperate");

	Params::RBOperatableComponent_CanOperate Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableComponent.GetOperateTransform
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform URBOperatableComponent::GetOperateTransform(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableComponent", "GetOperateTransform");

	Params::RBOperatableComponent_GetOperateTransform Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableComponent.GetOperatorLoopAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBOperatableComponent::GetOperatorLoopAnimation(const class ARBPawn* Pawn, bool bFirstPerson) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableComponent", "GetOperatorLoopAnimation");

	Params::RBOperatableComponent_GetOperatorLoopAnimation Parms{};

	Parms.Pawn = Pawn;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableComponent.GetOperatorStartAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBOperatableComponent::GetOperatorStartAnimation(const class ARBPawn* Pawn, bool bFirstPerson) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableComponent", "GetOperatorStartAnimation");

	Params::RBOperatableComponent_GetOperatorStartAnimation Parms{};

	Parms.Pawn = Pawn;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableComponent.GetOperatorStopAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* URBOperatableComponent::GetOperatorStopAnimation(const class ARBPawn* Pawn, bool bFirstPerson) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableComponent", "GetOperatorStopAnimation");

	Params::RBOperatableComponent_GetOperatorStopAnimation Parms{};

	Parms.Pawn = Pawn;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCoopOperatableComponent.Event_DelayedReleaseButtonServerTimestampChanged
// (Event, Public, BlueprintEvent)

void URBCoopOperatableComponent::Event_DelayedReleaseButtonServerTimestampChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "Event_DelayedReleaseButtonServerTimestampChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCoopOperatableComponent.Event_OnCoopOperatableActiveStateChanged
// (Event, Public, BlueprintEvent)

void URBCoopOperatableComponent::Event_OnCoopOperatableActiveStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "Event_OnCoopOperatableActiveStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCoopOperatableComponent.OnCoopOperatableActiveChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCoopOperatableComponent::OnCoopOperatableActiveChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "OnCoopOperatableActiveChangedCallback");

	Params::RBCoopOperatableComponent_OnCoopOperatableActiveChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCoopOperatableComponent.OnRep_CoopOperatableActive
// (Final, Native, Public)

void URBCoopOperatableComponent::OnRep_CoopOperatableActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "OnRep_CoopOperatableActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCoopOperatableComponent.OnRep_DelayedReleaseButtonServerTimestamp
// (Final, Native, Public)

void URBCoopOperatableComponent::OnRep_DelayedReleaseButtonServerTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "OnRep_DelayedReleaseButtonServerTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCoopOperatableComponent.SetLinkedCoopOperatableComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBCoopOperatableComponent*       Cmp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCoopOperatableComponent::SetLinkedCoopOperatableComponent(class URBCoopOperatableComponent* Cmp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "SetLinkedCoopOperatableComponent");

	Params::RBCoopOperatableComponent_SetLinkedCoopOperatableComponent Parms{};

	Parms.Cmp = Cmp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBCoopOperatableComponent::GetDelayedReleaseTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "GetDelayedReleaseTimeLeft");

	Params::RBCoopOperatableComponent_GetDelayedReleaseTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeftRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBCoopOperatableComponent::GetDelayedReleaseTimeLeftRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "GetDelayedReleaseTimeLeftRatio");

	Params::RBCoopOperatableComponent_GetDelayedReleaseTimeLeftRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCoopOperatableComponent.GetLinkedCoopOperatableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBCoopOperatableComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCoopOperatableComponent* URBCoopOperatableComponent::GetLinkedCoopOperatableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "GetLinkedCoopOperatableComponent");

	Params::RBCoopOperatableComponent_GetLinkedCoopOperatableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCoopOperatableComponent.ShouldActivateDelayedRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCoopOperatableComponent::ShouldActivateDelayedRelease() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCoopOperatableComponent", "ShouldActivateDelayedRelease");

	Params::RBCoopOperatableComponent_ShouldActivateDelayedRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameMode.BP_GetCurrentStageID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBStageID                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBStageID ARBGameMode::BP_GetCurrentStageID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "BP_GetCurrentStageID");

	Params::RBGameMode_BP_GetCurrentStageID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameMode.Cheat_DisableStageEnding
// (Final, Native, Public, BlueprintCallable)

void ARBGameMode::Cheat_DisableStageEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "Cheat_DisableStageEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.Cheat_ForceFailStage
// (Final, Native, Public, BlueprintCallable)

void ARBGameMode::Cheat_ForceFailStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "Cheat_ForceFailStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.Cheat_ForceGamePhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameMode::Cheat_ForceGamePhase(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "Cheat_ForceGamePhase");

	Params::RBGameMode_Cheat_ForceGamePhase Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.Cheat_ForceMissionID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             TrialId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameMode::Cheat_ForceMissionID(const struct FRBMissionID& MissionID, class FName TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "Cheat_ForceMissionID");

	Params::RBGameMode_Cheat_ForceMissionID Parms{};

	Parms.MissionID = std::move(MissionID);
	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.OnGameStatePostInit
// (Final, Native, Private)

void ARBGameMode::OnGameStatePostInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "OnGameStatePostInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.OnObjectiveCoordinatorStateChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameMode::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "OnObjectiveCoordinatorStateChanged");

	Params::RBGameMode_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.OnPawnKilled
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameMode::OnPawnKilled(class ARBPawn* InstigatorActor, class ARBPawn* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "OnPawnKilled");

	Params::RBGameMode_OnPawnKilled Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.SetBackupPlayerRespawnPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RespawnPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameMode::SetBackupPlayerRespawnPoint(class AActor* RespawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "SetBackupPlayerRespawnPoint");

	Params::RBGameMode_SetBackupPlayerRespawnPoint Parms{};

	Parms.RespawnPoint = RespawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameMode.GetObjectiveNarrativeScreenChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBNarrativeScreenChannel*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBNarrativeScreenChannel* ARBGameMode::GetObjectiveNarrativeScreenChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "GetObjectiveNarrativeScreenChannel");

	Params::RBGameMode_GetObjectiveNarrativeScreenChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameMode.GetPlayersReadyToRespawn
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBController*>            OutPlayers                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBGameMode::GetPlayersReadyToRespawn(TArray<class ARBController*>* OutPlayers) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "GetPlayersReadyToRespawn");

	Params::RBGameMode_GetPlayersReadyToRespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPlayers != nullptr)
		*OutPlayers = std::move(Parms.OutPlayers);
}


// Function OPP.RBGameMode.HasAnyPlayerExitedStartingSAS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameMode::HasAnyPlayerExitedStartingSAS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "HasAnyPlayerExitedStartingSAS");

	Params::RBGameMode_HasAnyPlayerExitedStartingSAS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameMode.IsStageReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameMode::IsStageReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "IsStageReady");

	Params::RBGameMode_IsStageReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameMode.IsStageStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameMode::IsStageStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameMode", "IsStageStarted");

	Params::RBGameMode_IsStageStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnQuestItemRuntimeInfosChanged
// (Event, Protected, BlueprintEvent)

void ARBUseQuestItemsObjectiveCoordinator::Event_OnQuestItemRuntimeInfosChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "Event_OnQuestItemRuntimeInfosChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnSpawnObjectiveItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        NewObjectiveItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::Event_OnSpawnObjectiveItem(class AActor* Spawner, class ARBPickup* NewObjectiveItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "Event_OnSpawnObjectiveItem");

	Params::RBUseQuestItemsObjectiveCoordinator_Event_OnSpawnObjectiveItem Parms{};

	Parms.Spawner = Spawner;
	Parms.NewObjectiveItem = NewObjectiveItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPanelInteractionCompletedChanged
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnPanelInteractionCompletedChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnPanelInteractionCompletedChanged");

	Params::RBUseQuestItemsObjectiveCoordinator_OnPanelInteractionCompletedChanged Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPawnKilled
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Subject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnPawnKilled(class ARBPawn* InstigatorActor, class ARBPawn* Subject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnPawnKilled");

	Params::RBUseQuestItemsObjectiveCoordinator_OnPawnKilled Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.Subject = Subject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDisconnect
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnPlayerDisconnect(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnPlayerDisconnect");

	Params::RBUseQuestItemsObjectiveCoordinator_OnPlayerDisconnect Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDoAction
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnPlayerDoAction");

	Params::RBUseQuestItemsObjectiveCoordinator_OnPlayerDoAction Parms{};

	Parms.Player = Player;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerStoppedOperating
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnPlayerStoppedOperating(class ARBPawn* Pawn, class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnPlayerStoppedOperating");

	Params::RBUseQuestItemsObjectiveCoordinator_OnPlayerStoppedOperating Parms{};

	Parms.Pawn = Pawn;
	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemDropped_Server
// (Native, Protected)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnQuestItemDropped_Server(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnQuestItemDropped_Server");

	Params::RBUseQuestItemsObjectiveCoordinator_OnQuestItemDropped_Server Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemPickedUp_Server
// (Native, Protected)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUseQuestItemsObjectiveCoordinator::OnQuestItemPickedUp_Server(class ARBPawn* Pawn, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnQuestItemPickedUp_Server");

	Params::RBUseQuestItemsObjectiveCoordinator_OnQuestItemPickedUp_Server Parms{};

	Parms.Pawn = Pawn;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUseQuestItemsObjectiveCoordinator.OnRep_QuestItemRuntimeInfos
// (Native, Protected)

void ARBUseQuestItemsObjectiveCoordinator::OnRep_QuestItemRuntimeInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUseQuestItemsObjectiveCoordinator", "OnRep_QuestItemRuntimeInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBItemSpawningManager.RequestCollectableSpawning
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARBPickup>            CollectableClass                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberToSpawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceBetweenItems                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollectablePriority                    Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnAsMuchAsPossible                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBItemSpawningManager::RequestCollectableSpawning(class AActor* Requester, const TSubclassOf<class ARBPickup>& CollectableClass, int32 NumberToSpawn, float DistanceBetweenItems, ECollectablePriority Priority, bool bSpawnAsMuchAsPossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBItemSpawningManager", "RequestCollectableSpawning");

	Params::RBItemSpawningManager_RequestCollectableSpawning Parms{};

	Parms.Requester = Requester;
	Parms.CollectableClass = CollectableClass;
	Parms.NumberToSpawn = NumberToSpawn;
	Parms.DistanceBetweenItems = DistanceBetweenItems;
	Parms.Priority = Priority;
	Parms.bSpawnAsMuchAsPossible = bSpawnAsMuchAsPossible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBItemSpawningManager.GetItemClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemType                               ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARBPickup>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ARBPickup> ARBItemSpawningManager::GetItemClass(EItemType ItemType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBItemSpawningManager", "GetItemClass");

	Params::RBItemSpawningManager_GetItemClass Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_ClueGathered
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FClueData                        ClueData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::Multicast_ClueGathered(const struct FClueData& ClueData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_ClueGathered");

	Params::RBCorpseSearchObjectiveCoordinator_Multicast_ClueGathered Parms{};

	Parms.ClueData = std::move(ClueData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_CorpseClueGathered
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URBPlayerInvestigationZoneComponent*InvestigationComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::Multicast_CorpseClueGathered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_CorpseClueGathered");

	Params::RBCorpseSearchObjectiveCoordinator_Multicast_CorpseClueGathered Parms{};

	Parms.InvestigationComponent = InvestigationComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_GateUnlocked
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBCorpseSearchObjectiveCoordinator::Multicast_GateUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_GateUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyDropped
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBCorpseSearchObjectiveCoordinator::Multicast_KeyDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_KeyDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyPickedUp
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FClueData                        ClueData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFirstTimePickedUp                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::Multicast_KeyPickedUp(const struct FClueData& ClueData, const bool bFirstTimePickedUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_KeyPickedUp");

	Params::RBCorpseSearchObjectiveCoordinator_Multicast_KeyPickedUp Parms{};

	Parms.ClueData = std::move(ClueData);
	Parms.bFirstTimePickedUp = bFirstTimePickedUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_OnEmptyCorpseInteractionDone
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::Multicast_OnEmptyCorpseInteractionDone(class ARBPawn* RBPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "Multicast_OnEmptyCorpseInteractionDone");

	Params::RBCorpseSearchObjectiveCoordinator_Multicast_OnEmptyCorpseInteractionDone Parms{};

	Parms.RBPawn = RBPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.OnClueDiscovered
// (Final, Native, Public)
// Parameters:
// class URBPlayerInvestigationZoneComponent*InvestigationComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::OnClueDiscovered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "OnClueDiscovered");

	Params::RBCorpseSearchObjectiveCoordinator_OnClueDiscovered Parms{};

	Parms.InvestigationComponent = InvestigationComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.OnCorpseClueDiscovered
// (Final, Native, Public)
// Parameters:
// class URBPlayerInvestigationZoneComponent*InvestigationComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::OnCorpseClueDiscovered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "OnCorpseClueDiscovered");

	Params::RBCorpseSearchObjectiveCoordinator_OnCorpseClueDiscovered Parms{};

	Parms.InvestigationComponent = InvestigationComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.OnEmptyCorpseInteractionDone
// (Final, Native, Public)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCorpseSearchObjectiveCoordinator::OnEmptyCorpseInteractionDone(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "OnEmptyCorpseInteractionDone");

	Params::RBCorpseSearchObjectiveCoordinator_OnEmptyCorpseInteractionDone Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueObjectiveIconFromClueName
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class FName                             ClueName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush ARBCorpseSearchObjectiveCoordinator::GetClueObjectiveIconFromClueName(const class FName& ClueName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "GetClueObjectiveIconFromClueName");

	Params::RBCorpseSearchObjectiveCoordinator_GetClueObjectiveIconFromClueName Parms{};

	Parms.ClueName = ClueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueTextFromClueName
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class FName                             ClueName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBCorpseSearchObjectiveCoordinator::GetClueTextFromClueName(const class FName& ClueName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCorpseSearchObjectiveCoordinator", "GetClueTextFromClueName");

	Params::RBCorpseSearchObjectiveCoordinator_GetClueTextFromClueName Parms{};

	Parms.ClueName = ClueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCounterInterface.GetCounter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IRBCounterInterface::GetCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCounterInterface", "GetCounter");

	Params::RBCounterInterface_GetCounter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCounterInterface.SetCounter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBCounterInterface::SetCounter(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCounterInterface", "SetCounter");

	Params::RBCounterInterface_SetCounter Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGarageDoor.ConstructGarageDoor
// (Final, Native, Public, BlueprintCallable)

void ARBGarageDoor::ConstructGarageDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "ConstructGarageDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGarageDoor.Event_OnJackHoldingStart
// (Event, Public, BlueprintEvent)

void ARBGarageDoor::Event_OnJackHoldingStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "Event_OnJackHoldingStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGarageDoor.Event_OnJackHoldingStop
// (Event, Public, BlueprintEvent)

void ARBGarageDoor::Event_OnJackHoldingStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "Event_OnJackHoldingStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGarageDoor.GetCoopIconOffset
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBGarageDoor::GetCoopIconOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "GetCoopIconOffset");

	Params::RBGarageDoor_GetCoopIconOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGarageDoor.OnRep_HasJack
// (Event, Public, BlueprintEvent)

void ARBGarageDoor::OnRep_HasJack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "OnRep_HasJack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGarageDoor.HasJack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGarageDoor::HasJack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGarageDoor", "HasJack");

	Params::RBGarageDoor_HasJack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCrouchUnderMarker.SetBlocksNavMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlocks                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCrouchUnderMarker::SetBlocksNavMesh(bool bBlocks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCrouchUnderMarker", "SetBlocksNavMesh");

	Params::RBCrouchUnderMarker_SetBlocksNavMesh Parms{};

	Parms.bBlocks = bBlocks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCrouchUnderMarker.SetEnabled
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCrouchUnderMarker::SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCrouchUnderMarker", "SetEnabled");

	Params::RBCrouchUnderMarker_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.AddStageIntroTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::AddStageIntroTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "AddStageIntroTime");

	Params::RBHUD_AddStageIntroTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.BP_AddWorldIcon
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IntroDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldIconType                          IconType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShowDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::BP_AddWorldIcon(class FName ID, float IntroDuration, float FadeInDuration, float FadeOutDuration, EWorldIconType IconType, float ShowDuration, class AActor* Actor, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_AddWorldIcon");

	Params::RBHUD_BP_AddWorldIcon Parms{};

	Parms.ID = ID;
	Parms.IntroDuration = IntroDuration;
	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeOutDuration = FadeOutDuration;
	Parms.IconType = IconType;
	Parms.ShowDuration = ShowDuration;
	Parms.Actor = Actor;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.BP_GetWorldIconNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBHUD::BP_GetWorldIconNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_GetWorldIconNum");

	Params::RBHUD_BP_GetWorldIconNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.BP_RemoveWorldIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::BP_RemoveWorldIcon(class FName ID, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_RemoveWorldIcon");

	Params::RBHUD_BP_RemoveWorldIcon Parms{};

	Parms.ID = ID;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.BP_SetAlwaysDisplayGotoIcons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    AlwaysDisplayGotoIcons                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::BP_SetAlwaysDisplayGotoIcons(bool AlwaysDisplayGotoIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_SetAlwaysDisplayGotoIcons");

	Params::RBHUD_BP_SetAlwaysDisplayGotoIcons Parms{};

	Parms.AlwaysDisplayGotoIcons = AlwaysDisplayGotoIcons;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.BP_SetMinigameProgressHUDOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ProgressOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::BP_SetMinigameProgressHUDOwner(class AActor* ProgressOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_SetMinigameProgressHUDOwner");

	Params::RBHUD_BP_SetMinigameProgressHUDOwner Parms{};

	Parms.ProgressOwner = ProgressOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.BP_ShouldDrawWorldIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutsideOfRange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHUD::BP_ShouldDrawWorldIcon(int32 Param_Index, bool bOutsideOfRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_ShouldDrawWorldIcon");

	Params::RBHUD_BP_ShouldDrawWorldIcon Parms{};

	Parms.Param_Index = Param_Index;
	Parms.bOutsideOfRange = bOutsideOfRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.BP_TryClearMinigameProgressHUDOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ProgressOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::BP_TryClearMinigameProgressHUDOwner(class AActor* ProgressOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_TryClearMinigameProgressHUDOwner");

	Params::RBHUD_BP_TryClearMinigameProgressHUDOwner Parms{};

	Parms.ProgressOwner = ProgressOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.DisableIconTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWorldIconType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::DisableIconTypes(EWorldIconType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "DisableIconTypes");

	Params::RBHUD_DisableIconTypes Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.EnableIconTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWorldIconType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::EnableIconTypes(EWorldIconType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "EnableIconTypes");

	Params::RBHUD_EnableIconTypes Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBHUD.OnAddToSimulatedMouseLocation__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// struct FVector2D                        Amount                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnAddToSimulatedMouseLocation__DelegateSignature(const struct FVector2D& Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnAddToSimulatedMouseLocation__DelegateSignature");

	Params::RBHUD_OnAddToSimulatedMouseLocation__DelegateSignature Parms{};

	Parms.Amount = std::move(Amount);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnDrawHud__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnDrawHud__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnDrawHud__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnHideHUDTutorial__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnHideHUDTutorial__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHideHUDTutorial__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnHideInventoryWheel__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnHideInventoryWheel__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHideInventoryWheel__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnHideTalkWheel__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnHideTalkWheel__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHideTalkWheel__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnHideTutorialMessage__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnHideTutorialMessage__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHideTutorialMessage__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnHudActionProgressChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   NewProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActionProgressContext                  Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnHudActionProgressChanged__DelegateSignature(float NewProgress, EActionProgressContext Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHudActionProgressChanged__DelegateSignature");

	Params::RBHUD_OnHudActionProgressChanged__DelegateSignature Parms{};

	Parms.NewProgress = NewProgress;
	Parms.Context = Context;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnHudUserConfigChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnHudUserConfigChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnHudUserConfigChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnInventoryWheelIndexChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnInventoryWheelIndexChanged__DelegateSignature(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnInventoryWheelIndexChanged__DelegateSignature");

	Params::RBHUD_OnInventoryWheelIndexChanged__DelegateSignature Parms{};

	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUD.OnLeaveSpectatorMode
// (Final, Native, Public)

void ARBHUD::OnLeaveSpectatorMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnLeaveSpectatorMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.OnLocalPlayerInit
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnLocalPlayerInit(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnLocalPlayerInit");

	Params::RBHUD_OnLocalPlayerInit Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBHUD.OnMinigameProgressHUDOwnerChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           ProgressOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnMinigameProgressHUDOwnerChanged__DelegateSignature(class AActor* ProgressOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnMinigameProgressHUDOwnerChanged__DelegateSignature");

	Params::RBHUD_OnMinigameProgressHUDOwnerChanged__DelegateSignature Parms{};

	Parms.ProgressOwner = ProgressOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnRequestDisplayObjectiveHUD__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnRequestDisplayObjectiveHUD__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnRequestDisplayObjectiveHUD__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnShowEndOfStageScreen__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FEndStageInfo                    ScreenInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBHUD::OnShowEndOfStageScreen__DelegateSignature(const struct FEndStageInfo& ScreenInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowEndOfStageScreen__DelegateSignature");

	Params::RBHUD_OnShowEndOfStageScreen__DelegateSignature Parms{};

	Parms.ScreenInfo = std::move(ScreenInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnShowGameMessage__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class FText                             GameMessage                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGameMessageCategory                    MessageCategory                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameMessageAudioParams          AudioParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBHUD::OnShowGameMessage__DelegateSignature(const class FText& GameMessage, const EGameMessageCategory MessageCategory, const struct FGameMessageAudioParams& AudioParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowGameMessage__DelegateSignature");

	Params::RBHUD_OnShowGameMessage__DelegateSignature Parms{};

	Parms.GameMessage = std::move(GameMessage);
	Parms.MessageCategory = MessageCategory;
	Parms.AudioParams = std::move(AudioParams);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnShowHUDTutorial__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHUDTutorialTextData             TutorialData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBHUD::OnShowHUDTutorial__DelegateSignature(const struct FHUDTutorialTextData& TutorialData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowHUDTutorial__DelegateSignature");

	Params::RBHUD_OnShowHUDTutorial__DelegateSignature Parms{};

	Parms.TutorialData = std::move(TutorialData);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnShowInventoryWheel__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EInventoryWheelMode                     Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnShowInventoryWheel__DelegateSignature(EInventoryWheelMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowInventoryWheel__DelegateSignature");

	Params::RBHUD_OnShowInventoryWheel__DelegateSignature Parms{};

	Parms.Mode = Mode;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnShowTalkWheel__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnShowTalkWheel__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowTalkWheel__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.OnShowTutorialMessage__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBHUD::OnShowTutorialMessage__DelegateSignature(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnShowTutorialMessage__DelegateSignature");

	Params::RBHUD_OnShowTutorialMessage__DelegateSignature Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUD.OnStageEnded
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsRestarting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool IsRestarting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnStageEnded");

	Params::RBHUD_OnStageEnded Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.IsRestarting = IsRestarting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.OnStartSpectatingPlayer
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnStartSpectatingPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnStartSpectatingPlayer");

	Params::RBHUD_OnStartSpectatingPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBHUD.OnToggledPsychosisDebug__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::OnToggledPsychosisDebug__DelegateSignature(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnToggledPsychosisDebug__DelegateSignature");

	Params::RBHUD_OnToggledPsychosisDebug__DelegateSignature Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBHUD.OnUpdateInventoryDisplay__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBHUD::OnUpdateInventoryDisplay__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "OnUpdateInventoryDisplay__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBHUD.PlayerActionStatusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPlayerActionStatus                     Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::PlayerActionStatusChanged__DelegateSignature(EPlayerActionStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "PlayerActionStatusChanged__DelegateSignature");

	Params::RBHUD_PlayerActionStatusChanged__DelegateSignature Parms{};

	Parms.Status = Status;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUD.SetForcedConsideredInSASForHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsForcedConsideredInSAS                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHUD::SetForcedConsideredInSASForHUD(bool bIsForcedConsideredInSAS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "SetForcedConsideredInSASForHUD");

	Params::RBHUD_SetForcedConsideredInSASForHUD Parms{};

	Parms.bIsForcedConsideredInSAS = bIsForcedConsideredInSAS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.StopTransitionFeedback
// (Final, Native, Public, BlueprintCallable)

void ARBHUD::StopTransitionFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "StopTransitionFeedback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUD.UpdateWorldIconProjection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutsideOfRange                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutsideRangeDirectionAngle                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBHUD::UpdateWorldIconProjection(int32 Param_Index, int32 SizeX, int32 SizeY, bool* bOutsideOfRange, float* OutsideRangeDirectionAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "UpdateWorldIconProjection");

	Params::RBHUD_UpdateWorldIconProjection Parms{};

	Parms.Param_Index = Param_Index;
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutsideOfRange != nullptr)
		*bOutsideOfRange = Parms.bOutsideOfRange;

	if (OutsideRangeDirectionAngle != nullptr)
		*OutsideRangeDirectionAngle = Parms.OutsideRangeDirectionAngle;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.BP_GetMaxTextCharacterWidth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBHUD::BP_GetMaxTextCharacterWidth(const class FString& String) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_GetMaxTextCharacterWidth");

	Params::RBHUD_BP_GetMaxTextCharacterWidth Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.BP_GetPsychosisDebugHudEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHUD::BP_GetPsychosisDebugHudEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "BP_GetPsychosisDebugHudEnabled");

	Params::RBHUD_BP_GetPsychosisDebugHudEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.GetActionProgress
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActionProgressContext                  Context                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBHUD::GetActionProgress(const EActionProgressContext Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "GetActionProgress");

	Params::RBHUD_GetActionProgress Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.GetMinigameProgressHUDOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARBHUD::GetMinigameProgressHUDOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "GetMinigameProgressHUDOwner");

	Params::RBHUD_GetMinigameProgressHUDOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.GetStageIntroRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBHUD::GetStageIntroRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "GetStageIntroRemainingTime");

	Params::RBHUD_GetStageIntroRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUD.ShouldDisplayExtraInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHUD::ShouldDisplayExtraInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUD", "ShouldDisplayExtraInfo");

	Params::RBHUD_ShouldDisplayExtraInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCurrencyItem.OnClientInitReplicated
// (Final, Native, Private)

void ARBCurrencyItem::OnClientInitReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyItem", "OnClientInitReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCurrencyItem.OnRep_ProfileIdsInteracted
// (Final, Native, Private)

void ARBCurrencyItem::OnRep_ProfileIdsInteracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyItem", "OnRep_ProfileIdsInteracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCurrencyItem.OnSpectatingPlayerChanged
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBCurrencyItem::OnSpectatingPlayerChanged(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyItem", "OnSpectatingPlayerChanged");

	Params::RBCurrencyItem_OnSpectatingPlayerChanged Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCurrencyPackMenu.CancelPurchase
// (Final, Native, Public, BlueprintCallable)

void URBCurrencyPackMenu::CancelPurchase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "CancelPurchase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCurrencyPackMenu.Event_CompletedPurchase
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCurrencyPackMenuItem            Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBCurrencyPackMenu::Event_CompletedPurchase(const struct FCurrencyPackMenuItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "Event_CompletedPurchase");

	Params::RBCurrencyPackMenu_Event_CompletedPurchase Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCurrencyPackMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBCurrencyPackMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCurrencyPackMenu.Purchase
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCurrencyPackMenuItem            Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBCurrencyPackMenu::Purchase(const struct FCurrencyPackMenuItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "Purchase");

	Params::RBCurrencyPackMenu_Purchase Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCurrencyPackMenu.CanCancelPurchase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCurrencyPackMenu::CanCancelPurchase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "CanCancelPurchase");

	Params::RBCurrencyPackMenu_CanCancelPurchase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCurrencyPackMenu.GetCurrencyPackItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FCurrencyPackMenuItem>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FCurrencyPackMenuItem> URBCurrencyPackMenu::GetCurrencyPackItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "GetCurrencyPackItems");

	Params::RBCurrencyPackMenu_GetCurrencyPackItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCurrencyPackMenu.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCurrencyPackMenu::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "IsDataPending");

	Params::RBCurrencyPackMenu_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCurrencyPackMenu.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCurrencyPackMenu::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCurrencyPackMenu", "IsOperationPending");

	Params::RBCurrencyPackMenu_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHallucinationManager.BP_ReplaceSpectreConfig
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class URBSpectreCfg*                    Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHallucinationManager::BP_ReplaceSpectreConfig(class URBSpectreCfg* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "BP_ReplaceSpectreConfig");

	Params::RBHallucinationManager_BP_ReplaceSpectreConfig Parms{};

	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHallucinationManager.BP_SetBracketsConfigOverride
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class URBPsychosisBraketsCfg*           Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHallucinationManager::BP_SetBracketsConfigOverride(class URBPsychosisBraketsCfg* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "BP_SetBracketsConfigOverride");

	Params::RBHallucinationManager_BP_SetBracketsConfigOverride Parms{};

	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHallucinationManager.Event_HallucinationStarted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHallucinationData               HalluData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBHallucinationManager::Event_HallucinationStarted(const struct FHallucinationData& HalluData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "Event_HallucinationStarted");

	Params::RBHallucinationManager_Event_HallucinationStarted Parms{};

	Parms.HalluData = std::move(HalluData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHallucinationManager.Event_HallucinationStopped
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHallucinationData               HalluData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBHallucinationManager::Event_HallucinationStopped(const struct FHallucinationData& HalluData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "Event_HallucinationStopped");

	Params::RBHallucinationManager_Event_HallucinationStopped Parms{};

	Parms.HalluData = std::move(HalluData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHallucinationManager.Event_Init
// (Event, Public, BlueprintEvent)

void ARBHallucinationManager::Event_Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "Event_Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHallucinationManager.Multicast_ReplaceSpectreConfig
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URBSpectreCfg*                    Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHallucinationManager::Multicast_ReplaceSpectreConfig(class URBSpectreCfg* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "Multicast_ReplaceSpectreConfig");

	Params::RBHallucinationManager_Multicast_ReplaceSpectreConfig Parms{};

	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHallucinationManager.Multicast_SetBracketsConfigOverride
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class URBPsychosisBraketsCfg*           Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHallucinationManager::Multicast_SetBracketsConfigOverride(class URBPsychosisBraketsCfg* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "Multicast_SetBracketsConfigOverride");

	Params::RBHallucinationManager_Multicast_SetBracketsConfigOverride Parms{};

	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHallucinationManager.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHallucinationManager::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "OnGamePhaseUpdated");

	Params::RBHallucinationManager_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHallucinationManager.GetMaxBracketAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBHallucinationManager::GetMaxBracketAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHallucinationManager", "GetMaxBracketAmount");

	Params::RBHallucinationManager_GetMaxBracketAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCutsceneMenu.EndCutscene
// (Final, Native, Public, BlueprintCallable)

void URBCutsceneMenu::EndCutscene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCutsceneMenu", "EndCutscene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCutsceneMenu.Event_EndCutsceneRequested
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBCutsceneMenu::Event_EndCutsceneRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCutsceneMenu", "Event_EndCutsceneRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBCutsceneMenu.Event_ShowSkipPrompt
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldStartHideTimer                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCutsceneMenu::Event_ShowSkipPrompt(bool bShouldStartHideTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCutsceneMenu", "Event_ShowSkipPrompt");

	Params::RBCutsceneMenu_Event_ShowSkipPrompt Parms{};

	Parms.bShouldStartHideTimer = bShouldStartHideTimer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBCutsceneMenu.OnInputKey
// (Final, Native, Public)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBCutsceneMenu::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCutsceneMenu", "OnInputKey");

	Params::RBCutsceneMenu_OnInputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.EventType = EventType;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.BP_Damage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDamageableComponent::BP_Damage(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "BP_Damage");

	Params::RBDamageableComponent_BP_Damage Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.BP_SetCanBeDamaged
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanBeDamagedValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDamageableComponent::BP_SetCanBeDamaged(bool bCanBeDamagedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "BP_SetCanBeDamaged");

	Params::RBDamageableComponent_BP_SetCanBeDamaged Parms{};

	Parms.bCanBeDamagedValue = bCanBeDamagedValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.ForceDurability_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param_Durability                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDamageableComponent::ForceDurability_Server(float Param_Durability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "ForceDurability_Server");

	Params::RBDamageableComponent_ForceDurability_Server Parms{};

	Parms.Param_Durability = Param_Durability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.OnRep_CanBeDamaged
// (Final, Native, Private)

void URBDamageableComponent::OnRep_CanBeDamaged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "OnRep_CanBeDamaged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.OnRep_Durability
// (Final, Native, Private)

void URBDamageableComponent::OnRep_Durability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "OnRep_Durability");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.OnRep_NumberOfHits
// (Final, Native, Private)

void URBDamageableComponent::OnRep_NumberOfHits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "OnRep_NumberOfHits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.OnRep_NumberOfProjectileHit
// (Final, Native, Private)

void URBDamageableComponent::OnRep_NumberOfProjectileHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "OnRep_NumberOfProjectileHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageableComponent.BP_GetDurabilityRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBDamageableComponent::BP_GetDurabilityRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "BP_GetDurabilityRatio");

	Params::RBDamageableComponent_BP_GetDurabilityRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageableComponent.CanBeDamaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBDamageableComponent::CanBeDamaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "CanBeDamaged");

	Params::RBDamageableComponent_CanBeDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageableComponent.GetDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBDamageableComponent::GetDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "GetDurability");

	Params::RBDamageableComponent_GetDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageableComponent.GetMaxDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBDamageableComponent::GetMaxDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "GetMaxDurability");

	Params::RBDamageableComponent_GetMaxDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageableComponent.GetNumberOfHits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBDamageableComponent::GetNumberOfHits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "GetNumberOfHits");

	Params::RBDamageableComponent_GetNumberOfHits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageableComponent.IsDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBDamageableComponent::IsDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageableComponent", "IsDestroyed");

	Params::RBDamageableComponent_IsDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDamageBoxComponent.ComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBDamageBoxComponent::ComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageBoxComponent", "ComponentBeginOverlap");

	Params::RBDamageBoxComponent_ComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageBoxComponent.IsDamageEnabledChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDamageBoxComponent::IsDamageEnabledChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageBoxComponent", "IsDamageEnabledChangedCallback");

	Params::RBDamageBoxComponent_IsDamageEnabledChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageBoxComponent.OnRep_IsDamageEnabled
// (Final, Native, Public)

void URBDamageBoxComponent::OnRep_IsDamageEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageBoxComponent", "OnRep_IsDamageEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDamageBoxComponent.BP_GetHurtingPlayers
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBPlayer*>                OutHurtingPlayers                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBDamageBoxComponent::BP_GetHurtingPlayers(TArray<class ARBPlayer*>* OutHurtingPlayers) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageBoxComponent", "BP_GetHurtingPlayers");

	Params::RBDamageBoxComponent_BP_GetHurtingPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHurtingPlayers != nullptr)
		*OutHurtingPlayers = std::move(Parms.OutHurtingPlayers);
}


// Function OPP.RBDamageBoxComponent.IsDamageEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBDamageBoxComponent::IsDamageEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDamageBoxComponent", "IsDamageEnabled");

	Params::RBDamageBoxComponent_IsDamageEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDarknessVolume.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBDarknessVolume::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDarknessVolume", "BeginOverlap");

	Params::RBDarknessVolume_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDarknessVolume.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDarknessVolume::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDarknessVolume", "BP_SetEnabled");

	Params::RBDarknessVolume_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDarknessVolume.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDarknessVolume::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDarknessVolume", "EndOverlap");

	Params::RBDarknessVolume_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDarknessVolume.OnRep_CurrentlyEnabled
// (Final, Native, Public)

void ARBDarknessVolume::OnRep_CurrentlyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDarknessVolume", "OnRep_CurrentlyEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDarknessVolume.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDarknessVolume::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDarknessVolume", "IsEnabled");

	Params::RBDarknessVolume_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGhostAnimInstance.BP_ClearGhost
// (Event, Protected, BlueprintEvent)

void URBGhostAnimInstance::BP_ClearGhost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGhostAnimInstance", "BP_ClearGhost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGhostAnimInstance.BP_InitializeGhost
// (Event, Protected, BlueprintEvent)

void URBGhostAnimInstance::BP_InitializeGhost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGhostAnimInstance", "BP_InitializeGhost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGhostAnimInstance.FinishGhost
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EGhostFinishReason                      FinishReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GhostFinishCustomReason                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGhostAnimInstance::FinishGhost(EGhostFinishReason FinishReason, int32 GhostFinishCustomReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGhostAnimInstance", "FinishGhost");

	Params::RBGhostAnimInstance_FinishGhost Parms{};

	Parms.FinishReason = FinishReason;
	Parms.GhostFinishCustomReason = GhostFinishCustomReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGhostAnimInstance.GetInteractableActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URBGhostAnimInstance::GetInteractableActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGhostAnimInstance", "GetInteractableActor");

	Params::RBGhostAnimInstance_GetInteractableActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGhostAnimInstance.OnGhostAnimNotify
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EGhostAnimEvent                         AnimEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimEventName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGhostAnimInstance::OnGhostAnimNotify(EGhostAnimEvent AnimEvent, const class FName& AnimEventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGhostAnimInstance", "OnGhostAnimNotify");

	Params::RBGhostAnimInstance_OnGhostAnimNotify Parms{};

	Parms.AnimEvent = AnimEvent;
	Parms.AnimEventName = AnimEventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDeadBodySpawnLocationComponent.BP_GetCurrentDeadBodyAnimSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* URBDeadBodySpawnLocationComponent::BP_GetCurrentDeadBodyAnimSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodySpawnLocationComponent", "BP_GetCurrentDeadBodyAnimSequence");

	Params::RBDeadBodySpawnLocationComponent_BP_GetCurrentDeadBodyAnimSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDeadBodySpawnLocationComponent.BP_IsPlayingJumpScareAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBDeadBodySpawnLocationComponent::BP_IsPlayingJumpScareAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodySpawnLocationComponent", "BP_IsPlayingJumpScareAnim");

	Params::RBDeadBodySpawnLocationComponent_BP_IsPlayingJumpScareAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDeadBodyContainer.BP_ApplyRandomCustomization
// (Final, Native, Public, BlueprintCallable)

void ARBDeadBodyContainer::BP_ApplyRandomCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "BP_ApplyRandomCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeadBodyContainer.Event_OnCustomizationChanged
// (Event, Public, BlueprintEvent)

void ARBDeadBodyContainer::Event_OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "Event_OnCustomizationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeadBodyContainer.Event_OnMovedDeadBodySequenceChanged
// (Event, Public, BlueprintEvent)

void ARBDeadBodyContainer::Event_OnMovedDeadBodySequenceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "Event_OnMovedDeadBodySequenceChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeadBodyContainer.Event_OnNotifyPlayRigSequence
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAnimationAsset*                  AnimToPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDeadBodyContainer::Event_OnNotifyPlayRigSequence(class UAnimationAsset* AnimToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "Event_OnNotifyPlayRigSequence");

	Params::RBDeadBodyContainer_Event_OnNotifyPlayRigSequence Parms{};

	Parms.AnimToPlay = AnimToPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBDeadBodyContainer.OnRep_MovedDeadBodySequence
// (Final, Native, Protected)

void ARBDeadBodyContainer::OnRep_MovedDeadBodySequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "OnRep_MovedDeadBodySequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeadBodyContainer.SetSkeletalMeshTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDeadBodyContainer::SetSkeletalMeshTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadBodyContainer", "SetSkeletalMeshTickEnabled");

	Params::RBDeadBodyContainer_SetSkeletalMeshTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeadRepulsionBoxComponent.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDeadRepulsionBoxComponent::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeadRepulsionBoxComponent", "BP_SetEnabled");

	Params::RBDeadRepulsionBoxComponent_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameProgressHUDOwner.GetHUDMinigameProgressRatio
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRBMinigameProgressHUDOwner::GetHUDMinigameProgressRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameProgressHUDOwner", "GetHUDMinigameProgressRatio");

	Params::RBMinigameProgressHUDOwner_GetHUDMinigameProgressRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.TestForceActive
// (Native, Event, Public, BlueprintEvent)

void IRBDecodable::TestForceActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "TestForceActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecodable.TestForceInactive
// (Native, Event, Public, BlueprintEvent)

void IRBDecodable::TestForceInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "TestForceInactive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecodable.TestForceNextClue
// (Native, Event, Public, BlueprintEvent)

void IRBDecodable::TestForceNextClue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "TestForceNextClue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecodable.GetCode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IRBDecodable::GetCode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "GetCode");

	Params::RBDecodable_GetCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.GetDecoderProximity
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          EyeLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EyeForward                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDecoderProximityType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDecoderProximityType IRBDecodable::GetDecoderProximity(const struct FVector& EyeLocation, const struct FVector& EyeForward) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "GetDecoderProximity");

	Params::RBDecodable_GetDecoderProximity Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.EyeForward = std::move(EyeForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.GetPerfectPlayerLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IRBDecodable::GetPerfectPlayerLocation(class ARBPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "GetPerfectPlayerLocation");

	Params::RBDecodable_GetPerfectPlayerLocation Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.GetProjectionForward
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          EyeLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EyeForward                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IRBDecodable::GetProjectionForward(const struct FVector& EyeLocation, const struct FVector& EyeForward) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "GetProjectionForward");

	Params::RBDecodable_GetProjectionForward Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.EyeForward = std::move(EyeForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.GetProjectionOrigin
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          EyeLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EyeForward                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IRBDecodable::GetProjectionOrigin(const struct FVector& EyeLocation, const struct FVector& EyeForward) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "GetProjectionOrigin");

	Params::RBDecodable_GetProjectionOrigin Parms{};

	Parms.EyeLocation = std::move(EyeLocation);
	Parms.EyeForward = std::move(EyeForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.IsDecodableEnabled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBDecodable::IsDecodableEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "IsDecodableEnabled");

	Params::RBDecodable_IsDecodableEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecodable.IsFullyDecodable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBDecodable::IsFullyDecodable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecodable", "IsFullyDecodable");

	Params::RBDecodable_IsFullyDecodable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecoderItem.BP_OnEquipped
// (Event, Protected, BlueprintEvent)

void ARBDecoderItem::BP_OnEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "BP_OnEquipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDecoderItem.BP_OnHoldStateChanged
// (Event, Protected, BlueprintEvent)

void ARBDecoderItem::BP_OnHoldStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "BP_OnHoldStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDecoderItem.BP_OnProximityLevelChanged
// (Event, Protected, BlueprintEvent)

void ARBDecoderItem::BP_OnProximityLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "BP_OnProximityLevelChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDecoderItem.BP_OnUnequipped
// (Event, Protected, BlueprintEvent)

void ARBDecoderItem::BP_OnUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "BP_OnUnequipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDecoderItem.OnButtonHeldChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDecoderItem::OnButtonHeldChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnButtonHeldChangedCallback");

	Params::RBDecoderItem_OnButtonHeldChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.OnClosestDecodableChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDecoderItem::OnClosestDecodableChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnClosestDecodableChangedCallback");

	Params::RBDecoderItem_OnClosestDecodableChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.OnProximityLevelChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDecoderItem::OnProximityLevelChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnProximityLevelChangedCallback");

	Params::RBDecoderItem_OnProximityLevelChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.OnRep_ButtonHeld
// (Final, Native, Private)

void ARBDecoderItem::OnRep_ButtonHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnRep_ButtonHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.OnRep_ClosestDecodable
// (Final, Native, Private)

void ARBDecoderItem::OnRep_ClosestDecodable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnRep_ClosestDecodable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.OnRep_ProximityLevel
// (Final, Native, Private)

void ARBDecoderItem::OnRep_ProximityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "OnRep_ProximityLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDecoderItem.BP_IsHolding
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDecoderItem::BP_IsHolding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "BP_IsHolding");

	Params::RBDecoderItem_BP_IsHolding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecoderItem.GetClosestDecodable
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ARBDecoderItem::GetClosestDecodable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "GetClosestDecodable");

	Params::RBDecoderItem_GetClosestDecodable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecoderItem.GetProximityLevel
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDecoderProximityType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDecoderProximityType ARBDecoderItem::GetProximityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "GetProximityLevel");

	Params::RBDecoderItem_GetProximityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDecoderItem.IsHoldingButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBDecoderItem::IsHoldingButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDecoderItem", "IsHoldingButton");

	Params::RBDecoderItem_IsHoldingButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWireTriggerTrap.BP_ForceArmedState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bArmed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::BP_ForceArmedState(bool bArmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_ForceArmedState");

	Params::RBWireTriggerTrap_BP_ForceArmedState Parms{};

	Parms.bArmed = bArmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.BP_LinkTrap
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBTrapTriggerable*               Trap                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::BP_LinkTrap(class ARBTrapTriggerable* Trap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_LinkTrap");

	Params::RBWireTriggerTrap_BP_LinkTrap Parms{};

	Parms.Trap = Trap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBWireTriggerTrap.BP_OnArmed
// (Event, Public, BlueprintEvent)

void ARBWireTriggerTrap::BP_OnArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_OnArmed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBWireTriggerTrap.BP_OnDisarmed
// (Event, Public, BlueprintEvent)

void ARBWireTriggerTrap::BP_OnDisarmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_OnDisarmed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBWireTriggerTrap.BP_OnTrapBatteryStateChanged
// (Event, Public, BlueprintEvent)

void ARBWireTriggerTrap::BP_OnTrapBatteryStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_OnTrapBatteryStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBWireTriggerTrap.BP_TriggerTrap
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBWireTriggerTrap::BP_TriggerTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_TriggerTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnLinkDoorInteraction
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpening                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::OnLinkDoorInteraction(class ARBPawn* Pawn, bool bOpening)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnLinkDoorInteraction");

	Params::RBWireTriggerTrap_OnLinkDoorInteraction Parms{};

	Parms.Pawn = Pawn;
	Parms.bOpening = bOpening;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnLinkedDoorAction
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDoorActionType                         ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::OnLinkedDoorAction(class ARBPawn* Pawn, EDoorActionType ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnLinkedDoorAction");

	Params::RBWireTriggerTrap_OnLinkedDoorAction Parms{};

	Parms.Pawn = Pawn;
	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnRep_Enabled
// (Final, Native, Public)

void ARBWireTriggerTrap::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnRep_IsArmed
// (Final, Native, Public)

void ARBWireTriggerTrap::OnRep_IsArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnRep_IsArmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnRep_LinkedTraps
// (Final, Native, Public)

void ARBWireTriggerTrap::OnRep_LinkedTraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnRep_LinkedTraps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnRep_TrapBatteryState
// (Final, Native, Public)

void ARBWireTriggerTrap::OnRep_TrapBatteryState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnRep_TrapBatteryState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.OnRep_Triggered
// (Final, Native, Public)

void ARBWireTriggerTrap::OnRep_Triggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "OnRep_Triggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.SetIsTriggered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsTriggered                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::SetIsTriggered(bool bInIsTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "SetIsTriggered");

	Params::RBWireTriggerTrap_SetIsTriggered Parms{};

	Parms.bInIsTriggered = bInIsTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWireTriggerTrap.BP_IsTriggererOnWrongSide
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          OutTriggerer                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutIsOnWrongSide                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWireTriggerTrap::BP_IsTriggererOnWrongSide(class ARBPawn** OutTriggerer, bool* OutIsOnWrongSide) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "BP_IsTriggererOnWrongSide");

	Params::RBWireTriggerTrap_BP_IsTriggererOnWrongSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTriggerer != nullptr)
		*OutTriggerer = Parms.OutTriggerer;

	if (OutIsOnWrongSide != nullptr)
		*OutIsOnWrongSide = Parms.OutIsOnWrongSide;
}


// Function OPP.RBWireTriggerTrap.GetIsArmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBWireTriggerTrap::GetIsArmed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "GetIsArmed");

	Params::RBWireTriggerTrap_GetIsArmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWireTriggerTrap.GetIsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBWireTriggerTrap::GetIsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "GetIsEnabled");

	Params::RBWireTriggerTrap_GetIsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWireTriggerTrap.GetIsTriggered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBWireTriggerTrap::GetIsTriggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "GetIsTriggered");

	Params::RBWireTriggerTrap_GetIsTriggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWireTriggerTrap.GetTrapBatteryState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETrapBatteryState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETrapBatteryState ARBWireTriggerTrap::GetTrapBatteryState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWireTriggerTrap", "GetTrapBatteryState");

	Params::RBWireTriggerTrap_GetTrapBatteryState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDeployableSkillItem.Deploy_Server
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Param_Deployer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBDeployableSkillItem::Deploy_Server(class ARBPlayer* Param_Deployer, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Deploy_Server");

	Params::RBDeployableSkillItem_Deploy_Server Parms{};

	Parms.Param_Deployer = Param_Deployer;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeployableSkillItem.Event_EffectFinished
// (Event, Public, BlueprintEvent)

void ARBDeployableSkillItem::Event_EffectFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Event_EffectFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeployableSkillItem.Event_OnActivate
// (Event, Public, BlueprintEvent)

void ARBDeployableSkillItem::Event_OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Event_OnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeployableSkillItem.Event_OnDeployed
// (Event, Public, BlueprintEvent)

void ARBDeployableSkillItem::Event_OnDeployed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Event_OnDeployed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeployableSkillItem.Event_OnExpiredUnactivated
// (Event, Public, BlueprintEvent)

void ARBDeployableSkillItem::Event_OnExpiredUnactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Event_OnExpiredUnactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeployableSkillItem.Event_OnPlaced
// (Event, Public, BlueprintEvent)

void ARBDeployableSkillItem::Event_OnPlaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Event_OnPlaced");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDeployableSkillItem.Multicast_OnDeploy
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPlayer*                        Param_Deployer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBDeployableSkillItem::Multicast_OnDeploy(class ARBPlayer* Param_Deployer, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "Multicast_OnDeploy");

	Params::RBDeployableSkillItem_Multicast_OnDeploy Parms{};

	Parms.Param_Deployer = Param_Deployer;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeployableSkillItem.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBDeployableSkillItem::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "OnComponentBeginOverlap");

	Params::RBDeployableSkillItem_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeployableSkillItem.OnDeployDelayFinished_Server
// (Final, Native, Protected)

void ARBDeployableSkillItem::OnDeployDelayFinished_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "OnDeployDelayFinished_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeployableSkillItem.OnRep_State
// (Final, Native, Protected)

void ARBDeployableSkillItem::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDeployableSkillItem.GetImpactRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBDeployableSkillItem::GetImpactRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "GetImpactRadius");

	Params::RBDeployableSkillItem_GetImpactRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDeployableSkillItem.GetMinDeployTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBDeployableSkillItem::GetMinDeployTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "GetMinDeployTime");

	Params::RBDeployableSkillItem_GetMinDeployTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDeployableSkillItem.GetZoneDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBDeployableSkillItem::GetZoneDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDeployableSkillItem", "GetZoneDuration");

	Params::RBDeployableSkillItem_GetZoneDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHittableActor.OnBreak
// (Native, Protected)
// Parameters:
// class URBDamageableComponent*           DamageComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHittableActor::OnBreak(class URBDamageableComponent* DamageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHittableActor", "OnBreak");

	Params::RBHittableActor_OnBreak Parms{};

	Parms.DamageComponent = DamageComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHittableActor.OnDamaged
// (Native, Protected)
// Parameters:
// class URBDamageableComponent*           DamageComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDestroyed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHittableActor::OnDamaged(class URBDamageableComponent* DamageComponent, bool bIsDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHittableActor", "OnDamaged");

	Params::RBHittableActor_OnDamaged Parms{};

	Parms.DamageComponent = DamageComponent;
	Parms.bIsDestroyed = bIsDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleActor.BP_BreakInSphere
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageSoundMaterial                    DamageSoundMaterial                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayBreakSound                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDestructibleActor::BP_BreakInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float Strength, ERadialImpulseFalloff Falloff, EDamageSoundMaterial DamageSoundMaterial, bool bPlayBreakSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleActor", "BP_BreakInSphere");

	Params::RBDestructibleActor_BP_BreakInSphere Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.DamageSoundMaterial = DamageSoundMaterial;
	Parms.bPlayBreakSound = bPlayBreakSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleActor.BP_DisplaceInSphere
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageSoundMaterial                    DamageSoundMaterial                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDestructibleActor::BP_DisplaceInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float Strength, ERadialImpulseFalloff Falloff, EDamageSoundMaterial DamageSoundMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleActor", "BP_DisplaceInSphere");

	Params::RBDestructibleActor_BP_DisplaceInSphere Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.DamageSoundMaterial = DamageSoundMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.BP_BreakBones
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class FName>                     BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::BP_BreakBones(const TArray<class FName>& BoneNames, const struct FVector& Direction, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "BP_BreakBones");

	Params::RBDestructibleComponent_BP_BreakBones Parms{};

	Parms.BoneNames = std::move(BoneNames);
	Parms.Direction = std::move(Direction);
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.BP_BreakInSphere
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::BP_BreakInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float Strength, ERadialImpulseFalloff Falloff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "BP_BreakInSphere");

	Params::RBDestructibleComponent_BP_BreakInSphere Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.BP_BreakNearBone
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::BP_BreakNearBone(class FName BoneName, const struct FVector& Direction, float Radius, float Strength, ERadialImpulseFalloff Falloff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "BP_BreakNearBone");

	Params::RBDestructibleComponent_BP_BreakNearBone Parms{};

	Parms.BoneName = BoneName;
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.BP_Displacement
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::BP_Displacement(const struct FVector& Origin, const struct FVector& Direction, float Radius, float Strength, ERadialImpulseFalloff Falloff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "BP_Displacement");

	Params::RBDestructibleComponent_BP_Displacement Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.OnNumberOfHitsChanged
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::OnNumberOfHitsChanged(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "OnNumberOfHitsChanged");

	Params::RBDestructibleComponent_OnNumberOfHitsChanged Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.OnRep_InitialTransforms
// (Final, Native, Private)

void URBDestructibleComponent::OnRep_InitialTransforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "OnRep_InitialTransforms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.OnRep_NumberOfHits
// (Final, Native, Private)

void URBDestructibleComponent::OnRep_NumberOfHits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "OnRep_NumberOfHits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.ScheduleSleepComponent
// (Final, Native, Public, BlueprintCallable)

void URBDestructibleComponent::ScheduleSleepComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "ScheduleSleepComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.SnapToState
// (Native, Public, BlueprintCallable)

void URBDestructibleComponent::SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "SnapToState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDestructibleComponent.WakeComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOneFrame                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBDestructibleComponent::WakeComponent(bool bOneFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleComponent", "WakeComponent");

	Params::RBDestructibleComponent_WakeComponent Parms{};

	Parms.bOneFrame = bOneFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLinearInventory.Event_OnIsInCooldownChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBActiveSkill*                   ActiveSkill                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInCooldown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::Event_OnIsInCooldownChanged(class ARBActiveSkill* ActiveSkill, bool bIsInCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_OnIsInCooldownChanged");

	Params::RBHUDLinearInventory_Event_OnIsInCooldownChanged Parms{};

	Parms.ActiveSkill = ActiveSkill;
	Parms.bIsInCooldown = bIsInCooldown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDLinearInventory.Event_Refresh
// (Event, Public, BlueprintEvent)
// Parameters:
// EInventoryUpdateEventType               EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::Event_Refresh(EInventoryUpdateEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_Refresh");

	Params::RBHUDLinearInventory_Event_Refresh Parms{};

	Parms.EventType = EventType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDLinearInventory.Event_RefreshASRestriction
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsRestricted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::Event_RefreshASRestriction(bool IsRestricted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_RefreshASRestriction");

	Params::RBHUDLinearInventory_Event_RefreshASRestriction Parms{};

	Parms.IsRestricted = IsRestricted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDLinearInventory.Event_RefreshDarknessIndicator
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    NewDarknessState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::Event_RefreshDarknessIndicator(bool NewDarknessState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_RefreshDarknessIndicator");

	Params::RBHUDLinearInventory_Event_RefreshDarknessIndicator Parms{};

	Parms.NewDarknessState = NewDarknessState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDLinearInventory.Event_RefreshPrompts
// (Event, Public, BlueprintEvent)

void URBHUDLinearInventory::Event_RefreshPrompts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_RefreshPrompts");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDLinearInventory.Event_UpdateEquippedItem
// (Event, Public, BlueprintEvent)

void URBHUDLinearInventory::Event_UpdateEquippedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "Event_UpdateEquippedItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDLinearInventory.OnActiveSkillRestrictionChanged
// (Final, Native, Public)
// Parameters:
// bool                                    IsRestricted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::OnActiveSkillRestrictionChanged(bool IsRestricted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "OnActiveSkillRestrictionChanged");

	Params::RBHUDLinearInventory_OnActiveSkillRestrictionChanged Parms{};

	Parms.IsRestricted = IsRestricted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDLinearInventory.OnInventoryUpdated
// (Final, Native, Public)
// Parameters:
// EInventoryUpdateEventType               EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDLinearInventory::OnInventoryUpdated(EInventoryUpdateEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDLinearInventory", "OnInventoryUpdated");

	Params::RBHUDLinearInventory_OnInventoryUpdated Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDPlayerPingIconWidget.SetupIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerPingIconWidget::SetupIcon(class UTexture2D* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerPingIconWidget", "SetupIcon");

	Params::RBHUDPlayerPingIconWidget_SetupIcon Parms{};

	Parms.Icon = Icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerPingIconWidget.IsSharedWithObjectiveIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDPlayerPingIconWidget::IsSharedWithObjectiveIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerPingIconWidget", "IsSharedWithObjectiveIcon");

	Params::RBHUDPlayerPingIconWidget_IsSharedWithObjectiveIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.AddExtraCustomizationMeshesForSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           baseSlotSkeletalCompoment                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USkeletalMesh*>            ExtraMeshes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USkeletalMeshComponent*>   OutNewComponents                                       (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::AddExtraCustomizationMeshesForSlot(class USkeletalMeshComponent* baseSlotSkeletalCompoment, const TArray<class USkeletalMesh*>& ExtraMeshes, EPlayerCustomizationSlot Slot, TArray<class USkeletalMeshComponent*>* OutNewComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "AddExtraCustomizationMeshesForSlot");

	Params::RBPawnCustomizationManager_AddExtraCustomizationMeshesForSlot Parms{};

	Parms.baseSlotSkeletalCompoment = baseSlotSkeletalCompoment;
	Parms.ExtraMeshes = std::move(ExtraMeshes);
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewComponents != nullptr)
		*OutNewComponents = std::move(Parms.OutNewComponents);
}


// Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::ApplyPlayerCustomization(class AActor* CustomizationOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "ApplyPlayerCustomization");

	Params::RBPawnCustomizationManager_ApplyPlayerCustomization Parms{};

	Parms.CustomizationOwner = CustomizationOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomizationWithOutfitOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOutfit*           Outfit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::ApplyPlayerCustomizationWithOutfitOverride(class AActor* CustomizationOwner, class URBCustomizationOutfit* Outfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "ApplyPlayerCustomizationWithOutfitOverride");

	Params::RBPawnCustomizationManager_ApplyPlayerCustomizationWithOutfitOverride Parms{};

	Parms.CustomizationOwner = CustomizationOwner;
	Parms.Outfit = Outfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.ApplySpecificPlayerCustomization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       RBPlayerCustomizationInfo                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::ApplySpecificPlayerCustomization(class AActor* CustomizationOwner, const struct FRBPlayerCustomizationInfo& RBPlayerCustomizationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "ApplySpecificPlayerCustomization");

	Params::RBPawnCustomizationManager_ApplySpecificPlayerCustomization Parms{};

	Parms.CustomizationOwner = CustomizationOwner;
	Parms.RBPlayerCustomizationInfo = std::move(RBPlayerCustomizationInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Cmp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class UMaterialInstanceConstant*>MaterialOverrideMap                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSetMasterPoseComponent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::UpdateSkeletalMeshComponent(class USkeletalMeshComponent* Cmp, class USkeletalMesh* Mesh, const TMap<class FString, class UMaterialInstanceConstant*>& MaterialOverrideMap, bool bSetMasterPoseComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "UpdateSkeletalMeshComponent");

	Params::RBPawnCustomizationManager_UpdateSkeletalMeshComponent Parms{};

	Parms.Cmp = Cmp;
	Parms.Mesh = Mesh;
	Parms.MaterialOverrideMap = std::move(MaterialOverrideMap);
	Parms.bSetMasterPoseComponent = bSetMasterPoseComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponentFromCustomizationOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Cmp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::UpdateSkeletalMeshComponentFromCustomizationOption(class USkeletalMeshComponent* Cmp, class URBPlayerCustomizationOption* Option, bool bIsFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "UpdateSkeletalMeshComponentFromCustomizationOption");

	Params::RBPawnCustomizationManager_UpdateSkeletalMeshComponentFromCustomizationOption Parms{};

	Parms.Cmp = Cmp;
	Parms.Option = Option;
	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.UpdateStaticMeshComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Cmp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class UMaterialInstanceConstant*>MaterialOverrideMap                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::UpdateStaticMeshComponent(class UStaticMeshComponent* Cmp, class UStaticMesh* Mesh, const TMap<class FString, class UMaterialInstanceConstant*>& MaterialOverrideMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPawnCustomizationManager", "UpdateStaticMeshComponent");

	Params::RBPawnCustomizationManager_UpdateStaticMeshComponent Parms{};

	Parms.Cmp = Cmp;
	Parms.Mesh = Mesh;
	Parms.MaterialOverrideMap = std::move(MaterialOverrideMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::CancelAllLoadCustomizationResources(class AActor* CustomizationOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "CancelAllLoadCustomizationResources");

	Params::RBPawnCustomizationManager_CancelAllLoadCustomizationResources Parms{};

	Parms.CustomizationOwner = CustomizationOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResourcesOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPawnCustomizationRequestType           RequestType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::CancelAllLoadCustomizationResourcesOfType(class AActor* CustomizationOwner, EPawnCustomizationRequestType RequestType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "CancelAllLoadCustomizationResourcesOfType");

	Params::RBPawnCustomizationManager_CancelAllLoadCustomizationResourcesOfType Parms{};

	Parms.CustomizationOwner = CustomizationOwner;
	Parms.RequestType = RequestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.CancelLoadCustomizationResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RequestID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPawnCustomizationManager::CancelLoadCustomizationResources(int32 RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "CancelLoadCustomizationResources");

	Params::RBPawnCustomizationManager_CancelLoadCustomizationResources Parms{};

	Parms.RequestID = RequestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPawnCustomizationManager.LoadCustomResources
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           RequestOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ResourcesToLoad                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPawnCustomizationManager::LoadCustomResources(class AActor* RequestOwner, const TArray<struct FSoftObjectPath>& ResourcesToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "LoadCustomResources");

	Params::RBPawnCustomizationManager_LoadCustomResources Parms{};

	Parms.RequestOwner = RequestOwner;
	Parms.ResourcesToLoad = std::move(ResourcesToLoad);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.LoadNPCGruntResources
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           GruntOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGruntCustomizationMeshesConfig  CustomizationMeshesConfig                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSelectedGruntCustomizationMeshesInfoCustomizationMeshesInfo                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPawnCustomizationManager::LoadNPCGruntResources(class AActor* GruntOwner, const struct FGruntCustomizationMeshesConfig& CustomizationMeshesConfig, const struct FSelectedGruntCustomizationMeshesInfo& CustomizationMeshesInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "LoadNPCGruntResources");

	Params::RBPawnCustomizationManager_LoadNPCGruntResources Parms{};

	Parms.GruntOwner = GruntOwner;
	Parms.CustomizationMeshesConfig = std::move(CustomizationMeshesConfig);
	Parms.CustomizationMeshesInfo = std::move(CustomizationMeshesInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.LoadPawnCustomizationResources
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           PlayerCustomizationOwner                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ResourcesToLoad                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPawnCustomizationRequestType           RequestType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPawnCustomizationManager::LoadPawnCustomizationResources(class AActor* PlayerCustomizationOwner, const TArray<struct FSoftObjectPath>& ResourcesToLoad, EPawnCustomizationRequestType RequestType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "LoadPawnCustomizationResources");

	Params::RBPawnCustomizationManager_LoadPawnCustomizationResources Parms{};

	Parms.PlayerCustomizationOwner = PlayerCustomizationOwner;
	Parms.ResourcesToLoad = std::move(ResourcesToLoad);
	Parms.RequestType = RequestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PlayerCustomizationOwner                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPawnCustomizationManager::LoadPlayerCustomizationResources(class AActor* PlayerCustomizationOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "LoadPlayerCustomizationResources");

	Params::RBPawnCustomizationManager_LoadPlayerCustomizationResources Parms{};

	Parms.PlayerCustomizationOwner = PlayerCustomizationOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResourcesWithOutfitOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PlayerCustomizationOwner                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOutfit*           Outfit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPawnCustomizationManager::LoadPlayerCustomizationResourcesWithOutfitOverride(class AActor* PlayerCustomizationOwner, class URBCustomizationOutfit* Outfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "LoadPlayerCustomizationResourcesWithOutfitOverride");

	Params::RBPawnCustomizationManager_LoadPlayerCustomizationResourcesWithOutfitOverride Parms{};

	Parms.PlayerCustomizationOwner = PlayerCustomizationOwner;
	Parms.Outfit = Outfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.IsRequestActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           CustomizationOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPawnCustomizationRequestType           RequestType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPawnCustomizationManager::IsRequestActive(class AActor* CustomizationOwner, EPawnCustomizationRequestType RequestType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "IsRequestActive");

	Params::RBPawnCustomizationManager_IsRequestActive Parms{};

	Parms.CustomizationOwner = CustomizationOwner;
	Parms.RequestType = RequestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPawnCustomizationManager.IsRequestIDActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   RequestID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPawnCustomizationManager::IsRequestIDActive(int32 RequestID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPawnCustomizationManager", "IsRequestIDActive");

	Params::RBPawnCustomizationManager_IsRequestIDActive Parms{};

	Parms.RequestID = RequestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDestructibleWall.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewActiveValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDestructibleWall::SetActive(bool bNewActiveValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDestructibleWall", "SetActive");

	Params::RBDestructibleWall_SetActive Parms{};

	Parms.bNewActiveValue = bNewActiveValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInvestigationPoint.Event_OnInvestigate
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInvestigationPoint::Event_OnInvestigate(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInvestigationPoint", "Event_OnInvestigate");

	Params::RBInvestigationPoint_Event_OnInvestigate Parms{};

	Parms.bot = bot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBUIBlueprintLibrary.BP_GetRHIName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGraphicsRHI                            Version                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBUIBlueprintLibrary::BP_GetRHIName(EGraphicsRHI Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "BP_GetRHIName");

	Params::RBUIBlueprintLibrary_BP_GetRHIName Parms{};

	Parms.Version = Version;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.BP_IsInteractingWithCursorEnabledPanelComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayer*                        RBPlayer                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::BP_IsInteractingWithCursorEnabledPanelComponent(const class ARBPlayer* RBPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "BP_IsInteractingWithCursorEnabledPanelComponent");

	Params::RBUIBlueprintLibrary_BP_IsInteractingWithCursorEnabledPanelComponent Parms{};

	Parms.RBPlayer = RBPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.BP_IsQuestGiverUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ARBQuestGiver*                    QuestGiver                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::BP_IsQuestGiverUnlocked(const class ARBQuestGiver* QuestGiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "BP_IsQuestGiverUnlocked");

	Params::RBUIBlueprintLibrary_BP_IsQuestGiverUnlocked Parms{};

	Parms.QuestGiver = QuestGiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.ClearMenuFocusAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::ClearMenuFocusAction(class UWidget* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ClearMenuFocusAction");

	Params::RBUIBlueprintLibrary_ClearMenuFocusAction Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.ClearUpgradesRecentlyBought
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::ClearUpgradesRecentlyBought()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ClearUpgradesRecentlyBought");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.CustomizationCategoryContainsSameItems
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECustomizationMenuCategory              Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomizationMenuCategory              Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::CustomizationCategoryContainsSameItems(ECustomizationMenuCategory Source, ECustomizationMenuCategory Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "CustomizationCategoryContainsSameItems");

	Params::RBUIBlueprintLibrary_CustomizationCategoryContainsSameItems Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.FilterRecentlyBoughtUpdates
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EItemProgressionCategory                Category                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActiveSkillType                        AssociatedActiveSkillType                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfileUpgradeCategory                 ProfileUpgradeCategory                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPerkCategory                           PerkCategory                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> URBUIBlueprintLibrary::FilterRecentlyBoughtUpdates(const EItemProgressionCategory Category, const EActiveSkillType AssociatedActiveSkillType, const EProfileUpgradeCategory ProfileUpgradeCategory, const EPerkCategory PerkCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "FilterRecentlyBoughtUpdates");

	Params::RBUIBlueprintLibrary_FilterRecentlyBoughtUpdates Parms{};

	Parms.Category = Category;
	Parms.AssociatedActiveSkillType = AssociatedActiveSkillType;
	Parms.ProfileUpgradeCategory = ProfileUpgradeCategory;
	Parms.PerkCategory = PerkCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.ForceTooltipRefresh
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::ForceTooltipRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ForceTooltipRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.FormatPlayerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBUIBlueprintLibrary::FormatPlayerName(const class FString& DisplayName, int32 MaxLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "FormatPlayerName");

	Params::RBUIBlueprintLibrary_FormatPlayerName Parms{};

	Parms.DisplayName = std::move(DisplayName);
	Parms.MaxLength = MaxLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.FormatTextForDecorator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   HeightOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBUIBlueprintLibrary::FormatTextForDecorator(const class FText& Message, int32 HeightOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "FormatTextForDecorator");

	Params::RBUIBlueprintLibrary_FormatTextForDecorator Parms{};

	Parms.Message = std::move(Message);
	Parms.HeightOverride = HeightOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             UpgradeOnlineId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBUIBlueprintLibrary::FormatUpgradeEffectText(const class FName& UpgradeOnlineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "FormatUpgradeEffectText");

	Params::RBUIBlueprintLibrary_FormatUpgradeEffectText Parms{};

	Parms.UpgradeOnlineId = UpgradeOnlineId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectTexts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             UpgradeOnlineId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> URBUIBlueprintLibrary::FormatUpgradeEffectTexts(const class FName& UpgradeOnlineId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "FormatUpgradeEffectTexts");

	Params::RBUIBlueprintLibrary_FormatUpgradeEffectTexts Parms{};

	Parms.UpgradeOnlineId = UpgradeOnlineId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetCurrencyReward
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRBGeneratedRewardData           RewardData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBUIBlueprintLibrary::GetCurrencyReward(const struct FRBGeneratedRewardData& RewardData, ECurrencyType CurrencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetCurrencyReward");

	Params::RBUIBlueprintLibrary_GetCurrencyReward Parms{};

	Parms.RewardData = std::move(RewardData);
	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetGamepadInputTextureFromKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* URBUIBlueprintLibrary::GetGamepadInputTextureFromKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetGamepadInputTextureFromKey");

	Params::RBUIBlueprintLibrary_GetGamepadInputTextureFromKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetGamepadSpecificData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class URBGamepadSpecificData*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class URBGamepadSpecificData* URBUIBlueprintLibrary::GetGamepadSpecificData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetGamepadSpecificData");

	Params::RBUIBlueprintLibrary_GetGamepadSpecificData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetLocalCellMenuCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URBUIBlueprintLibrary::GetLocalCellMenuCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetLocalCellMenuCharacter");

	Params::RBUIBlueprintLibrary_GetLocalCellMenuCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetMatchmakingRegionName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBUIBlueprintLibrary::GetMatchmakingRegionName(const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetMatchmakingRegionName");

	Params::RBUIBlueprintLibrary_GetMatchmakingRegionName Parms{};

	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetPlayerCustomizationInfoForPreview
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PreviewedOnlineItemId                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBUIBlueprintLibrary::GetPlayerCustomizationInfoForPreview(const class FName& PreviewedOnlineItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetPlayerCustomizationInfoForPreview");

	Params::RBUIBlueprintLibrary_GetPlayerCustomizationInfoForPreview Parms{};

	Parms.PreviewedOnlineItemId = PreviewedOnlineItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetPlayerDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBUIBlueprintLibrary::GetPlayerDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetPlayerDisplayName");

	Params::RBUIBlueprintLibrary_GetPlayerDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.GetPsychosisColorData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPsychosisColorData        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPsychosisColorData URBUIBlueprintLibrary::GetPsychosisColorData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "GetPsychosisColorData");

	Params::RBUIBlueprintLibrary_GetPsychosisColorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasAnyNewShopItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsCustomizingFemale                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasAnyNewShopItem(bool IsCustomizingFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasAnyNewShopItem");

	Params::RBUIBlueprintLibrary_HasAnyNewShopItem Parms{};

	Parms.IsCustomizingFemale = IsCustomizingFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasNewShopItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECustomizationMenuCategory              Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasNewShopItem(ECustomizationMenuCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasNewShopItem");

	Params::RBUIBlueprintLibrary_HasNewShopItem Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasPlayedMenuTutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TutorialId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasPlayedMenuTutorial(class FName TutorialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasPlayedMenuTutorial");

	Params::RBUIBlueprintLibrary_HasPlayedMenuTutorial Parms{};

	Parms.TutorialId = TutorialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasPlayedNPCUnlockAnnouncement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasPlayedNPCUnlockAnnouncement(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasPlayedNPCUnlockAnnouncement");

	Params::RBUIBlueprintLibrary_HasPlayedNPCUnlockAnnouncement Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasPlayedTutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TutorialId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasPlayedTutorial(class FName TutorialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasPlayedTutorial");

	Params::RBUIBlueprintLibrary_HasPlayedTutorial Parms{};

	Parms.TutorialId = TutorialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasPlayedVoicelineForLastLevelGained
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUILevelInfo                     LevelInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasPlayedVoicelineForLastLevelGained(const struct FUILevelInfo& LevelInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasPlayedVoicelineForLastLevelGained");

	Params::RBUIBlueprintLibrary_HasPlayedVoicelineForLastLevelGained Parms{};

	Parms.LevelInfo = std::move(LevelInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasRecentlyBoughtAnyUpgrade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasRecentlyBoughtAnyUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasRecentlyBoughtAnyUpgrade");

	Params::RBUIBlueprintLibrary_HasRecentlyBoughtAnyUpgrade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasRecentlyBoughtUpgradeOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EItemProgressionCategory                Category                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActiveSkillType                        AssociatedActiveSkillType                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfileUpgradeCategory                 ProfileUpgradeCategory                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPerkCategory                           PerkCategory                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasRecentlyBoughtUpgradeOfType(const EItemProgressionCategory Category, const EActiveSkillType AssociatedActiveSkillType, const EProfileUpgradeCategory ProfileUpgradeCategory, const EPerkCategory PerkCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasRecentlyBoughtUpgradeOfType");

	Params::RBUIBlueprintLibrary_HasRecentlyBoughtUpgradeOfType Parms{};

	Parms.Category = Category;
	Parms.AssociatedActiveSkillType = AssociatedActiveSkillType;
	Parms.ProfileUpgradeCategory = ProfileUpgradeCategory;
	Parms.PerkCategory = PerkCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasSeenDocument
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasSeenDocument(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasSeenDocument");

	Params::RBUIBlueprintLibrary_HasSeenDocument Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasUnseenAcquiredDocument
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasUnseenAcquiredDocument()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasUnseenAcquiredDocument");

	Params::RBUIBlueprintLibrary_HasUnseenAcquiredDocument Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HasVisitedNPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::HasVisitedNPC(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HasVisitedNPC");

	Params::RBUIBlueprintLibrary_HasVisitedNPC Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.HideTutorial
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::HideTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "HideTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.IsMetaNPCUnlocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsMetaNPCUnlocked(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsMetaNPCUnlocked");

	Params::RBUIBlueprintLibrary_IsMetaNPCUnlocked Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.IsReplayingMenuTutorials
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsReplayingMenuTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsReplayingMenuTutorials");

	Params::RBUIBlueprintLibrary_IsReplayingMenuTutorials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsShippingBuild");

	Params::RBUIBlueprintLibrary_IsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.IsShowingLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsShowingLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsShowingLoadingScreen");

	Params::RBUIBlueprintLibrary_IsShowingLoadingScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.IsUsingAnalogPeekControlScheme
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsUsingAnalogPeekControlScheme()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsUsingAnalogPeekControlScheme");

	Params::RBUIBlueprintLibrary_IsUsingAnalogPeekControlScheme Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.IsWiderInputTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::IsWiderInputTexture(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "IsWiderInputTexture");

	Params::RBUIBlueprintLibrary_IsWiderInputTexture Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.NormalizedScoreToRating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerTrialRating                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerTrialRating URBUIBlueprintLibrary::NormalizedScoreToRating(float Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "NormalizedScoreToRating");

	Params::RBUIBlueprintLibrary_NormalizedScoreToRating Parms{};

	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.NormalizedScoreToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBUIBlueprintLibrary::NormalizedScoreToText(float Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "NormalizedScoreToText");

	Params::RBUIBlueprintLibrary_NormalizedScoreToText Parms{};

	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.ParseTVChannelTextIntoLines
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> URBUIBlueprintLibrary::ParseTVChannelTextIntoLines(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ParseTVChannelTextIntoLines");

	Params::RBUIBlueprintLibrary_ParseTVChannelTextIntoLines Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.PushHUDTutorial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHUDTutorialTextData             HUDTutorialTextData                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::PushHUDTutorial(const struct FHUDTutorialTextData& HUDTutorialTextData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "PushHUDTutorial");

	Params::RBUIBlueprintLibrary_PushHUDTutorial Parms{};

	Parms.HUDTutorialTextData = std::move(HUDTutorialTextData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.PushProgramTutorials
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::PushProgramTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "PushProgramTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.PushReleaseTutorials
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::PushReleaseTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "PushReleaseTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.RemoveUpgradeFromRecentlyBought
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::RemoveUpgradeFromRecentlyBought(const class FName& OnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "RemoveUpgradeFromRecentlyBought");

	Params::RBUIBlueprintLibrary_RemoveUpgradeFromRecentlyBought Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.ResetMenuTutorials
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::ResetMenuTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ResetMenuTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.ResetNonMenuTutorials
// (Final, Native, Static, Public, BlueprintCallable)

void URBUIBlueprintLibrary::ResetNonMenuTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ResetNonMenuTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SaveThumbnailForCellItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URBPlayerCellItemDefinition*>RbPlayerCellItems                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ForceCleanCategory                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SaveThumbnailForCellItems(const TArray<class URBPlayerCellItemDefinition*>& RbPlayerCellItems, const bool ForceCleanCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SaveThumbnailForCellItems");

	Params::RBUIBlueprintLibrary_SaveThumbnailForCellItems Parms{};

	Parms.RbPlayerCellItems = std::move(RbPlayerCellItems);
	Parms.ForceCleanCategory = ForceCleanCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOptions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URBPlayerCustomizationOption*>RbCustomizationOptions                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ForceCleanCategory                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SaveThumbnailForOptions(const TArray<class URBPlayerCustomizationOption*>& RbCustomizationOptions, const bool ForceCleanCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SaveThumbnailForOptions");

	Params::RBUIBlueprintLibrary_SaveThumbnailForOptions Parms{};

	Parms.RbCustomizationOptions = std::move(RbCustomizationOptions);
	Parms.ForceCleanCategory = ForceCleanCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOutfits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class URBCustomizationOutfit*>   RbCustomizationOutfits                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ForceCleanCategory                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SaveThumbnailForOutfits(const TArray<class URBCustomizationOutfit*>& RbCustomizationOutfits, const bool ForceCleanCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SaveThumbnailForOutfits");

	Params::RBUIBlueprintLibrary_SaveThumbnailForOutfits Parms{};

	Parms.RbCustomizationOutfits = std::move(RbCustomizationOutfits);
	Parms.ForceCleanCategory = ForceCleanCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetHasSeenDocument
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetHasSeenDocument(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetHasSeenDocument");

	Params::RBUIBlueprintLibrary_SetHasSeenDocument Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetHasSeenItemInMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetHasSeenItemInMenu(const class FName& OnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetHasSeenItemInMenu");

	Params::RBUIBlueprintLibrary_SetHasSeenItemInMenu Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetHasVisitedNPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetHasVisitedNPC(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetHasVisitedNPC");

	Params::RBUIBlueprintLibrary_SetHasVisitedNPC Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetLastLevelGainedVoicelinePlayed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUILevelInfo                     LevelInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetLastLevelGainedVoicelinePlayed(const struct FUILevelInfo& LevelInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetLastLevelGainedVoicelinePlayed");

	Params::RBUIBlueprintLibrary_SetLastLevelGainedVoicelinePlayed Parms{};

	Parms.LevelInfo = std::move(LevelInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetMenuFocusAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWidget*                          Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Action                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetMenuFocusAction(class UWidget* Source, const class FName& Action, const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetMenuFocusAction");

	Params::RBUIBlueprintLibrary_SetMenuFocusAction Parms{};

	Parms.Source = Source;
	Parms.Action = Action;
	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetMenuTutorialPlayed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetMenuTutorialPlayed(class FName TutorialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetMenuTutorialPlayed");

	Params::RBUIBlueprintLibrary_SetMenuTutorialPlayed Parms{};

	Parms.TutorialId = TutorialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetMinigameProgressHUDOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ProgressOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetMinigameProgressHUDOwner(class AActor* ProgressOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetMinigameProgressHUDOwner");

	Params::RBUIBlueprintLibrary_SetMinigameProgressHUDOwner Parms{};

	Parms.ProgressOwner = ProgressOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetNPCUnlockAnnouncementPlayed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetNPCUnlockAnnouncementPlayed(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetNPCUnlockAnnouncementPlayed");

	Params::RBUIBlueprintLibrary_SetNPCUnlockAnnouncementPlayed Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetShouldReplayMenuTutorials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldReplay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetShouldReplayMenuTutorials(bool ShouldReplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetShouldReplayMenuTutorials");

	Params::RBUIBlueprintLibrary_SetShouldReplayMenuTutorials Parms{};

	Parms.ShouldReplay = ShouldReplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.SetTutorialPlayed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TutorialId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::SetTutorialPlayed(class FName TutorialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "SetTutorialPlayed");

	Params::RBUIBlueprintLibrary_SetTutorialPlayed Parms{};

	Parms.TutorialId = TutorialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.ShouldDisplayGenericPlatformIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EProfilePlatform                        Platform                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::ShouldDisplayGenericPlatformIcon(EProfilePlatform Platform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ShouldDisplayGenericPlatformIcon");

	Params::RBUIBlueprintLibrary_ShouldDisplayGenericPlatformIcon Parms{};

	Parms.Platform = Platform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.ShowContextualTutorial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             TutorialText                                           (Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::ShowContextualTutorial(const class FText& TutorialText, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ShowContextualTutorial");

	Params::RBUIBlueprintLibrary_ShowContextualTutorial Parms{};

	Parms.TutorialText = std::move(TutorialText);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.ShowTextChatNofitication
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::ShowTextChatNofitication(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "ShowTextChatNofitication");

	Params::RBUIBlueprintLibrary_ShowTextChatNofitication Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.TryClearMinigameProgressHUDOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ProgressOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::TryClearMinigameProgressHUDOwner(class AActor* ProgressOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "TryClearMinigameProgressHUDOwner");

	Params::RBUIBlueprintLibrary_TryClearMinigameProgressHUDOwner Parms{};

	Parms.ProgressOwner = ProgressOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.UpdateLastLevelGainedInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUILevelInfo                     LevelInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBUIBlueprintLibrary::UpdateLastLevelGainedInfo(const struct FUILevelInfo& LevelInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "UpdateLastLevelGainedInfo");

	Params::RBUIBlueprintLibrary_UpdateLastLevelGainedInfo Parms{};

	Parms.LevelInfo = std::move(LevelInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUIBlueprintLibrary.WasSeenInMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::WasSeenInMenu(const class FName& OnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "WasSeenInMenu");

	Params::RBUIBlueprintLibrary_WasSeenInMenu Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBUIBlueprintLibrary.WasUpgradeRecentlyBought
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBUIBlueprintLibrary::WasUpgradeRecentlyBought(const class FName& OnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBUIBlueprintLibrary", "WasUpgradeRecentlyBought");

	Params::RBUIBlueprintLibrary_WasUpgradeRecentlyBought Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoorReplaceClass.OnReplacedDoor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBDoorReplaceClass::OnReplacedDoor(class ARBDoor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorReplaceClass", "OnReplacedDoor");

	Params::RBDoorReplaceClass_OnReplacedDoor Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoorBlockableInterface.ModulateBashDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   In_damage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Out_damage                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBDoorBlockableInterface::ModulateBashDamage(const class ARBPawn* Pawn, float In_damage, float* Out_damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockableInterface", "ModulateBashDamage");

	Params::RBDoorBlockableInterface_ModulateBashDamage Parms{};

	Parms.Pawn = Pawn;
	Parms.In_damage = In_damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_damage != nullptr)
		*Out_damage = Parms.Out_damage;
}


// Function OPP.RBDoorBlockableInterface.OnRemoveDoorBlockable
// (Native, Event, Public, BlueprintEvent)

void IRBDoorBlockableInterface::OnRemoveDoorBlockable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockableInterface", "OnRemoveDoorBlockable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoorBlockableInterface.SetDoorBlockableOwner
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBDoorBlockableInterface::SetDoorBlockableOwner(class ARBPawn* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockableInterface", "SetDoorBlockableOwner");

	Params::RBDoorBlockableInterface_SetDoorBlockableOwner Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBItemActiveSkill.OnItemDeployed
// (Final, Native, Protected)
// Parameters:
// class ARBDeployableSkillItem*           ThrownItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBItemActiveSkill::OnItemDeployed(class ARBDeployableSkillItem* ThrownItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBItemActiveSkill", "OnItemDeployed");

	Params::RBItemActiveSkill_OnItemDeployed Parms{};

	Parms.ThrownItem = ThrownItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBItemActiveSkill.OnItemThrown
// (Final, Native, Protected)
// Parameters:
// class ARBThrowableWeapon*               ThrownItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBItemActiveSkill::OnItemThrown(class ARBThrowableWeapon* ThrownItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBItemActiveSkill", "OnItemThrown");

	Params::RBItemActiveSkill_OnItemThrown Parms{};

	Parms.ThrownItem = ThrownItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.IsExperimentStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsExperimentStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsExperimentStarted");

	Params::RBGameState_IsExperimentStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsStagePrepared
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsStagePrepared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsStagePrepared");

	Params::RBGameState_IsStagePrepared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsStageReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsStageReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsStageReady");

	Params::RBGameState_IsStageReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsStageStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsStageStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsStageStarted");

	Params::RBGameState_IsStageStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.Multicast_ApplyStageReset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<class FString>                   StageLevels                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBGameState::Multicast_ApplyStageReset(const TArray<class FString>& StageLevels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "Multicast_ApplyStageReset");

	Params::RBGameState_Multicast_ApplyStageReset Parms{};

	Parms.StageLevels = std::move(StageLevels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.Multicast_ScareStinger
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class AActor*                           ScareActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    StingerEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameState::Multicast_ScareStinger(class AActor* ScareActor, class UAkAudioEvent* StingerEvent, const struct FVector& Location, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "Multicast_ScareStinger");

	Params::RBGameState_Multicast_ScareStinger Parms{};

	Parms.ScareActor = ScareActor;
	Parms.StingerEvent = StingerEvent;
	Parms.Location = std::move(Location);
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnClientPopulateFinished
// (Final, Native, Public)

void ARBGameState::OnClientPopulateFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnClientPopulateFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_BombTimeLeft
// (Final, Native, Public)

void ARBGameState::OnRep_BombTimeLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_BombTimeLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_BombTriggered
// (Final, Native, Public)

void ARBGameState::OnRep_BombTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_BombTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_CanPlayerRespawn
// (Final, Native, Public)

void ARBGameState::OnRep_CanPlayerRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_CanPlayerRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_CurrentSASList
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class ARBSAS*>                   OldSASValues                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBGameState::OnRep_CurrentSASList(const TArray<class ARBSAS*>& OldSASValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_CurrentSASList");

	Params::RBGameState_OnRep_CurrentSASList Parms{};

	Parms.OldSASValues = std::move(OldSASValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_CurrentServerNarrativeMusicInfo
// (Final, Native, Public)

void ARBGameState::OnRep_CurrentServerNarrativeMusicInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_CurrentServerNarrativeMusicInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_EndOfStageDamageTime
// (Final, Native, Public)

void ARBGameState::OnRep_EndOfStageDamageTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_EndOfStageDamageTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_GameDifficulty
// (Final, Native, Public)

void ARBGameState::OnRep_GameDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_GameDifficulty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_GamePhase
// (Final, Native, Public)

void ARBGameState::OnRep_GamePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_GamePhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_GameStageInfo
// (Final, Native, Public)

void ARBGameState::OnRep_GameStageInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_GameStageInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_LevelMusicPaused
// (Final, Native, Public)

void ARBGameState::OnRep_LevelMusicPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_LevelMusicPaused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_ResetTimerSkipped
// (Final, Native, Private)

void ARBGameState::OnRep_ResetTimerSkipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_ResetTimerSkipped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.OnRep_TrialChainingInfo
// (Final, Native, Public)

void ARBGameState::OnRep_TrialChainingInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "OnRep_TrialChainingInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.SetDrugSequenceCompleted
// (Final, Native, Public, BlueprintCallable)

void ARBGameState::SetDrugSequenceCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "SetDrugSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameState.WaitingForPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::WaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "WaitingForPlayers");

	Params::RBGameState_WaitingForPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetBombTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBGameState::GetBombTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetBombTimeLeft");

	Params::RBGameState_GetBombTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetCurrentSAS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSAS*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBSAS* ARBGameState::GetCurrentSAS(ETeam Team) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetCurrentSAS");

	Params::RBGameState_GetCurrentSAS Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetCurrentSASList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBSAS*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBSAS*> ARBGameState::GetCurrentSASList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetCurrentSASList");

	Params::RBGameState_GetCurrentSASList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetGameStageInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBGameStageInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBGameStageInfo ARBGameState::GetGameStageInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetGameStageInfo");

	Params::RBGameState_GetGameStageInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetMissionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBMissionID               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBMissionID ARBGameState::GetMissionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetMissionID");

	Params::RBGameState_GetMissionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetStageID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBStageID                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBStageID ARBGameState::GetStageID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetStageID");

	Params::RBGameState_GetStageID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.GetTrialId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ARBGameState::GetTrialId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "GetTrialId");

	Params::RBGameState_GetTrialId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsDrugSequenceCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsDrugSequenceCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsDrugSequenceCompleted");

	Params::RBGameState_IsDrugSequenceCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsEndOfStageDamageStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsEndOfStageDamageStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsEndOfStageDamageStarted");

	Params::RBGameState_IsEndOfStageDamageStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsExperimentCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsExperimentCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsExperimentCompleted");

	Params::RBGameState_IsExperimentCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsExperimentSuccess
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsExperimentSuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsExperimentSuccess");

	Params::RBGameState_IsExperimentSuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.IsSoloGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::IsSoloGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "IsSoloGame");

	Params::RBGameState_IsSoloGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameState.WasResetTimerSkipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameState::WasResetTimerSkipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameState", "WasResetTimerSkipped");

	Params::RBGameState_WasResetTimerSkipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStateAdversarial.GetWinningTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeam ARBGameStateAdversarial::GetWinningTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStateAdversarial", "GetWinningTeam");

	Params::RBGameStateAdversarial_GetWinningTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBDoorBlockerSkill.OnBlockingActorDestroyed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Blocker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoorBlockerSkill::OnBlockingActorDestroyed(class AActor* Blocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockerSkill", "OnBlockingActorDestroyed");

	Params::RBDoorBlockerSkill_OnBlockingActorDestroyed Parms{};

	Parms.Blocker = Blocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoorBlockerSkillItem.OnRep_TargetDoor
// (Final, Native, Private)

void ARBDoorBlockerSkillItem::OnRep_TargetDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockerSkillItem", "OnRep_TargetDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDoorBlockerSkillItem.OnTargetDoorChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDoorBlockerSkillItem::OnTargetDoorChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDoorBlockerSkillItem", "OnTargetDoorChangedCallback");

	Params::RBDoorBlockerSkillItem_OnTargetDoorChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.BP_OnHoldingPawnChanged
// (Event, Public, BlueprintEvent)

void ARBLargePickup::BP_OnHoldingPawnChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "BP_OnHoldingPawnChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBLargePickup.BP_OnPlayAnimSequence
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAnimSequence*                    Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::BP_OnPlayAnimSequence(class UAnimSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "BP_OnPlayAnimSequence");

	Params::RBLargePickup_BP_OnPlayAnimSequence Parms{};

	Parms.Sequence = Sequence;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLargePickup.BP_OnTrapTriggered
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPsychosis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::BP_OnTrapTriggered(bool bPsychosis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "BP_OnTrapTriggered");

	Params::RBLargePickup_BP_OnTrapTriggered Parms{};

	Parms.bPsychosis = bPsychosis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLargePickup.BP_SetDesiredTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DesiredTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::BP_SetDesiredTransform(const struct FTransform& DesiredTransform, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "BP_SetDesiredTransform");

	Params::RBLargePickup_BP_SetDesiredTransform Parms{};

	Parms.DesiredTransform = std::move(DesiredTransform);
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.DispatchUpdatePosition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBLargePickup::DispatchUpdatePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "DispatchUpdatePosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.Event_OnUsedOnInteractible
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::Event_OnUsedOnInteractible(class ARBPawn* Interactor, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "Event_OnUsedOnInteractible");

	Params::RBLargePickup_Event_OnUsedOnInteractible Parms{};

	Parms.Interactor = Interactor;
	Parms.Interactible = Interactible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLargePickup.Multicast_ForceUpdatePosition
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ARBLargePickup::Multicast_ForceUpdatePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "Multicast_ForceUpdatePosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.Multicast_TriggerTrap
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bPsychosis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::Multicast_TriggerTrap(bool bPsychosis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "Multicast_TriggerTrap");

	Params::RBLargePickup_Multicast_TriggerTrap Parms{};

	Parms.bPsychosis = bPsychosis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnHideAfterUse
// (Final, Native, Protected)

void ARBLargePickup::OnHideAfterUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnHideAfterUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnHoldingPawnChangedCallback
// (Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::OnHoldingPawnChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnHoldingPawnChangedCallback");

	Params::RBLargePickup_OnHoldingPawnChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnPickupTransformChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::OnPickupTransformChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnPickupTransformChangedCallback");

	Params::RBLargePickup_OnPickupTransformChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnRep_HoldingPawn
// (Final, Native, Protected)

void ARBLargePickup::OnRep_HoldingPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnRep_HoldingPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnRep_PickupTransform
// (Final, Native, Protected)

void ARBLargePickup::OnRep_PickupTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnRep_PickupTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnRep_Toss
// (Final, Native, Protected)

void ARBLargePickup::OnRep_Toss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnRep_Toss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnRep_UsedOnObject
// (Final, Native, Protected)

void ARBLargePickup::OnRep_UsedOnObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnRep_UsedOnObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnUsedOnObjectChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargePickup::OnUsedOnObjectChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnUsedOnObjectChangedCallback");

	Params::RBLargePickup_OnUsedOnObjectChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnWorldFullyLoaded_Implementation
// (Native, Public)

void ARBLargePickup::OnWorldFullyLoaded_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnWorldFullyLoaded_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.OnWorldPopulateFinished_Implementation
// (Native, Public)

void ARBLargePickup::OnWorldPopulateFinished_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "OnWorldPopulateFinished_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargePickup.BP_ShouldPlayAnimAfterAdjustPosition
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::BP_ShouldPlayAnimAfterAdjustPosition(const class ARBPawn* Pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "BP_ShouldPlayAnimAfterAdjustPosition");

	Params::RBLargePickup_BP_ShouldPlayAnimAfterAdjustPosition Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.GetCustomDropInteractionText
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Out_CustomInteractionText                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::GetCustomDropInteractionText(const class ARBPlayer* Player, class FText* Out_CustomInteractionText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "GetCustomDropInteractionText");

	Params::RBLargePickup_GetCustomDropInteractionText Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_CustomInteractionText != nullptr)
		*Out_CustomInteractionText = std::move(Parms.Out_CustomInteractionText);

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.GetCustomPickupInteractionText
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Out_CustomInteractionText                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::GetCustomPickupInteractionText(const class ARBPlayer* Player, class FText* Out_CustomInteractionText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "GetCustomPickupInteractionText");

	Params::RBLargePickup_GetCustomPickupInteractionText Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_CustomInteractionText != nullptr)
		*Out_CustomInteractionText = std::move(Parms.Out_CustomInteractionText);

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.GetHoldingPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPawn* ARBLargePickup::GetHoldingPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "GetHoldingPawn");

	Params::RBLargePickup_GetHoldingPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.GetHoldingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayer* ARBLargePickup::GetHoldingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "GetHoldingPlayer");

	Params::RBLargePickup_GetHoldingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.GetUsedOnObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBLargeObjectInteractionPanelComponent* ARBLargePickup::GetUsedOnObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "GetUsedOnObject");

	Params::RBLargePickup_GetUsedOnObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.IsConsideredActiveForObjective
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::IsConsideredActiveForObjective() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "IsConsideredActiveForObjective");

	Params::RBLargePickup_IsConsideredActiveForObjective Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.IsUsable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::IsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "IsUsable");

	Params::RBLargePickup_IsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.IsUsedOnObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::IsUsedOnObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "IsUsedOnObject");

	Params::RBLargePickup_IsUsedOnObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLargePickup.ShouldBPTick
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLargePickup::ShouldBPTick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargePickup", "ShouldBPTick");

	Params::RBLargePickup_ShouldBPTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHotPotato.Event_OnIsDamageTimerActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsDamageTimerActive                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotato::Event_OnIsDamageTimerActiveChanged(bool IsDamageTimerActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "Event_OnIsDamageTimerActiveChanged");

	Params::RBHotPotato_Event_OnIsDamageTimerActiveChanged Parms{};

	Parms.IsDamageTimerActive = IsDamageTimerActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHotPotato.Event_OnObjectiveProgressChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotato::Event_OnObjectiveProgressChanged(float NewProgress, float OldProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "Event_OnObjectiveProgressChanged");

	Params::RBHotPotato_Event_OnObjectiveProgressChanged Parms{};

	Parms.NewProgress = NewProgress;
	Parms.OldProgress = OldProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHotPotato.Event_OnStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHotPotatoState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotato::Event_OnStateChanged(EHotPotatoState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "Event_OnStateChanged");

	Params::RBHotPotato_Event_OnStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHotPotato.OnRep_HotPotatoState
// (Native, Protected)

void ARBHotPotato::OnRep_HotPotatoState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "OnRep_HotPotatoState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotato.OnRep_IsDamageTimerActive
// (Native, Protected)

void ARBHotPotato::OnRep_IsDamageTimerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "OnRep_IsDamageTimerActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotato.OnRep_ObjectiveProgress
// (Native, Protected)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotato::OnRep_ObjectiveProgress(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "OnRep_ObjectiveProgress");

	Params::RBHotPotato_OnRep_ObjectiveProgress Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotato.IsHotPotatoActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHotPotato::IsHotPotatoActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "IsHotPotatoActivated");

	Params::RBHotPotato_IsHotPotatoActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHotPotato.IsHotPotatoCompletedOrExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHotPotato::IsHotPotatoCompletedOrExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "IsHotPotatoCompletedOrExpired");

	Params::RBHotPotato_IsHotPotatoCompletedOrExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHotPotato.IsHotPotatoEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBHotPotato::IsHotPotatoEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotato", "IsHotPotatoEnabled");

	Params::RBHotPotato_IsHotPotatoEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleChanged
// (Event, Public, BlueprintEvent)

void URBSwitchMatchPanelComponent::Event_OnCurrentPuzzleChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "Event_OnCurrentPuzzleChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleReset
// (Event, Public, BlueprintEvent)

void URBSwitchMatchPanelComponent::Event_OnCurrentPuzzleReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "Event_OnCurrentPuzzleReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchMatchPanelComponent.Event_OnNumbersOfInteractionChanged
// (Event, Public, BlueprintEvent)

void URBSwitchMatchPanelComponent::Event_OnNumbersOfInteractionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "Event_OnNumbersOfInteractionChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchMatchPanelComponent.Event_OnPanelSuccessStateChanged
// (Event, Public, BlueprintEvent)

void URBSwitchMatchPanelComponent::Event_OnPanelSuccessStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "Event_OnPanelSuccessStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchMatchPanelComponent.InitializePanel_Server
// (Final, Native, Public)

void URBSwitchMatchPanelComponent::InitializePanel_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "InitializePanel_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnCompletedGameplayCallback
// (Final, Native, Protected)

void URBSwitchMatchPanelComponent::OnCompletedGameplayCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnCompletedGameplayCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnCurrentNumberOfInteractionCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSwitchMatchPanelComponent::OnCurrentNumberOfInteractionCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnCurrentNumberOfInteractionCallback");

	Params::RBSwitchMatchPanelComponent_OnCurrentNumberOfInteractionCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentNumberOfInteraction
// (Final, Native, Protected)

void URBSwitchMatchPanelComponent::OnRep_CurrentNumberOfInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnRep_CurrentNumberOfInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentPuzzle
// (Final, Native, Protected)

void URBSwitchMatchPanelComponent::OnRep_CurrentPuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnRep_CurrentPuzzle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnRep_IsCompleted
// (Final, Native, Protected)

void URBSwitchMatchPanelComponent::OnRep_IsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnRep_IsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchPanelComponent.OnRep_ResetUntilServerTimestamp
// (Final, Native, Protected)

void URBSwitchMatchPanelComponent::OnRep_ResetUntilServerTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchPanelComponent", "OnRep_ResetUntilServerTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDressablePipe.ApplyMaterial
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBDressablePipe::ApplyMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDressablePipe", "ApplyMaterial");

	Params::RBDressablePipe_ApplyMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.BP_ActivateDynamicObstacle
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBDynamicObstacle::BP_ActivateDynamicObstacle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "BP_ActivateDynamicObstacle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.BP_Reset
// (Final, Native, Public, BlueprintCallable)

void ARBDynamicObstacle::BP_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "BP_Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.Event_OnDynamicObstacleDestroyed
// (Event, Public, BlueprintEvent)

void ARBDynamicObstacle::Event_OnDynamicObstacleDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "Event_OnDynamicObstacleDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBDynamicObstacle.IsActivatedChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBDynamicObstacle::IsActivatedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "IsActivatedChangedCallback");

	Params::RBDynamicObstacle_IsActivatedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.Multicast_ForceActivateDynamicObstacle
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBDynamicObstacle::Multicast_ForceActivateDynamicObstacle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "Multicast_ForceActivateDynamicObstacle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.OnRep_DynamicObstacleDestroyed
// (Final, Native, Public)

void ARBDynamicObstacle::OnRep_DynamicObstacleDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "OnRep_DynamicObstacleDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.OnRep_Enabled
// (Final, Native, Public)

void ARBDynamicObstacle::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBDynamicObstacle.OnRep_IsActivated
// (Final, Native, Private)

void ARBDynamicObstacle::OnRep_IsActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBDynamicObstacle", "OnRep_IsActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyGame.GetLocalPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBLobbyGamePanelComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBLobbyGamePanelComponent* ARBLobbyGame::GetLocalPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "GetLocalPanel");

	Params::RBLobbyGame_GetLocalPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyGame.GetOpponentPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBLobbyGamePanelComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBLobbyGamePanelComponent* ARBLobbyGame::GetOpponentPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "GetOpponentPanel");

	Params::RBLobbyGame_GetOpponentPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyGame.IsGameInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyGame::IsGameInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "IsGameInProgress");

	Params::RBLobbyGame_IsGameInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyGame.OnRep_LobbyGameEndReason
// (Final, Native, Public)

void ARBLobbyGame::OnRep_LobbyGameEndReason()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "OnRep_LobbyGameEndReason");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyGame.OnRep_LobbyGameState
// (Final, Native, Public)

void ARBLobbyGame::OnRep_LobbyGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "OnRep_LobbyGameState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyGame.OnRep_Winner
// (Final, Native, Public)

void ARBLobbyGame::OnRep_Winner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyGame", "OnRep_Winner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.GetPlayerRoundDataFromPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBStroopGamePanelComponent*      Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStroopPlayerMatchData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStroopPlayerMatchData ARBStroopGame::GetPlayerRoundDataFromPanel(class URBStroopGamePanelComponent* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "GetPlayerRoundDataFromPanel");

	Params::RBStroopGame_GetPlayerRoundDataFromPanel Parms{};

	Parms.Panel = Panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStroopGame.OnRep_Disturbances
// (Final, Native, Public)

void ARBStroopGame::OnRep_Disturbances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_Disturbances");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.OnRep_Player1RoundData
// (Final, Native, Public)

void ARBStroopGame::OnRep_Player1RoundData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_Player1RoundData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.OnRep_Player2RoundData
// (Final, Native, Public)

void ARBStroopGame::OnRep_Player2RoundData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_Player2RoundData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.OnRep_Score
// (Final, Native, Public)

void ARBStroopGame::OnRep_Score()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_Score");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.OnRep_StroopGameTurn
// (Final, Native, Public)

void ARBStroopGame::OnRep_StroopGameTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_StroopGameTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.OnRep_StroopRoundData
// (Final, Native, Public)

void ARBStroopGame::OnRep_StroopRoundData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "OnRep_StroopRoundData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.SetDisturbanceActivation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivePlayer1                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivePlayer2                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGame::SetDisturbanceActivation(int32 Param_Index, bool bActivePlayer1, bool bActivePlayer2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "SetDisturbanceActivation");

	Params::RBStroopGame_SetDisturbanceActivation Parms{};

	Parms.Param_Index = Param_Index;
	Parms.bActivePlayer1 = bActivePlayer1;
	Parms.bActivePlayer2 = bActivePlayer2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGame.GetButtonSelectionIndexesFromMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStroopButtonSelectionMode              Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ARBStroopGame::GetButtonSelectionIndexesFromMode(EStroopButtonSelectionMode Mode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "GetButtonSelectionIndexesFromMode");

	Params::RBStroopGame_GetButtonSelectionIndexesFromMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStroopGame.GetPlayerScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBStroopGamePanelComponent*      Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBStroopGame::GetPlayerScore(class URBStroopGamePanelComponent* Panel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGame", "GetPlayerScore");

	Params::RBStroopGame_GetPlayerScore Parms{};

	Parms.Panel = Panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEastermanQuestGiver.UpdateIconStatus
// (Final, Native, Public, BlueprintCallable)

void ARBEastermanQuestGiver::UpdateIconStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEastermanQuestGiver", "UpdateIconStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromCustomLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FinalCapsuleGroundOffset                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromCustomLocation(const struct FVector& Location, float FinalCapsuleGroundOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "Editor_SetSettingFromCustomLocation");

	Params::RBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromCustomLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.FinalCapsuleGroundOffset = FinalCapsuleGroundOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Interactable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FinalCapsuleGroundOffset                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromPlayerInteraction(class UObject* Interactable, ESpecialMove SpecialMove, float FinalCapsuleGroundOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "Editor_SetSettingFromPlayerInteraction");

	Params::RBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromPlayerInteraction Parms{};

	Parms.Interactable = Interactable;
	Parms.SpecialMove = SpecialMove;
	Parms.FinalCapsuleGroundOffset = FinalCapsuleGroundOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FinalCapsuleGroundOffset                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromPlayerLocation(float FinalCapsuleGroundOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "Editor_SetSettingFromPlayerLocation");

	Params::RBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromPlayerLocation Parms{};

	Parms.FinalCapsuleGroundOffset = FinalCapsuleGroundOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.Event_OnPostEditorLoad
// (Event, Public, BlueprintEvent)

void URBEditorClearanceCollisionBoxComponent::Event_OnPostEditorLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "Event_OnPostEditorLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.OnEditorPostLoad
// (Final, Native, Public, BlueprintCallable)

void URBEditorClearanceCollisionBoxComponent::OnEditorPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "OnEditorPostLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearanceBottomLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBEditorClearanceCollisionBoxComponent::GetClearanceBottomLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "GetClearanceBottomLocation");

	Params::RBEditorClearanceCollisionBoxComponent_GetClearanceBottomLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearancePlayerLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBEditorClearanceCollisionBoxComponent::GetClearancePlayerLocation(const class ARBPawn* Pawn, struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorClearanceCollisionBoxComponent", "GetClearancePlayerLocation");

	Params::RBEditorClearanceCollisionBoxComponent_GetClearancePlayerLocation Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function OPP.RBFrequencyMatchKnobComponent.Event_OnCurrentRatioChanged
// (Event, Public, BlueprintEvent)

void URBFrequencyMatchKnobComponent::Event_OnCurrentRatioChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "Event_OnCurrentRatioChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBFrequencyMatchKnobComponent.Event_OnIsCompletedChanged
// (Event, Public, BlueprintEvent)

void URBFrequencyMatchKnobComponent::Event_OnIsCompletedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "Event_OnIsCompletedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBFrequencyMatchKnobComponent.Event_OnLocallyFocusedChanged
// (Event, Public, BlueprintEvent)

void URBFrequencyMatchKnobComponent::Event_OnLocallyFocusedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "Event_OnLocallyFocusedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBFrequencyMatchKnobComponent.Event_OnPlayerOnKnobChanged
// (Event, Public, BlueprintEvent)

void URBFrequencyMatchKnobComponent::Event_OnPlayerOnKnobChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "Event_OnPlayerOnKnobChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBFrequencyMatchKnobComponent.Multicast_InitializeKnobPosition
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, BlueprintCallable)
// Parameters:
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFrequencyMatchKnobComponent::Multicast_InitializeKnobPosition(float Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "Multicast_InitializeKnobPosition");

	Params::RBFrequencyMatchKnobComponent_Multicast_InitializeKnobPosition Parms{};

	Parms.Ratio = Ratio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchKnobComponent.OnPlayerOnKnobChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBFrequencyMatchKnobComponent::OnPlayerOnKnobChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "OnPlayerOnKnobChangedCallback");

	Params::RBFrequencyMatchKnobComponent_OnPlayerOnKnobChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchKnobComponent.OnRep_CurrentRatio
// (Final, Native, Public)

void URBFrequencyMatchKnobComponent::OnRep_CurrentRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "OnRep_CurrentRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchKnobComponent.OnRep_IsCompleted
// (Final, Native, Public)

void URBFrequencyMatchKnobComponent::OnRep_IsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "OnRep_IsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchKnobComponent.OnRep_PlayerOnKnob
// (Final, Native, Public)

void URBFrequencyMatchKnobComponent::OnRep_PlayerOnKnob()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "OnRep_PlayerOnKnob");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchKnobComponent.GetCurrentRatioForDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBFrequencyMatchKnobComponent::GetCurrentRatioForDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "GetCurrentRatioForDisplay");

	Params::RBFrequencyMatchKnobComponent_GetCurrentRatioForDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBFrequencyMatchKnobComponent.GetIsCompletedForDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBFrequencyMatchKnobComponent::GetIsCompletedForDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "GetIsCompletedForDisplay");

	Params::RBFrequencyMatchKnobComponent_GetIsCompletedForDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBFrequencyMatchKnobComponent.IsLocallyFocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBFrequencyMatchKnobComponent::IsLocallyFocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchKnobComponent", "IsLocallyFocused");

	Params::RBFrequencyMatchKnobComponent_IsLocallyFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWaypoint.Event_OnReached
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWaypoint::Event_OnReached(class ARBBot* bot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaypoint", "Event_OnReached");

	Params::RBWaypoint_Event_OnReached Parms{};

	Parms.bot = bot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBWaypoint.BP_IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBWaypoint::BP_IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaypoint", "BP_IsEnabled");

	Params::RBWaypoint_BP_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEditorMapCheckable.BP_MapCheck
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EMapCheckType                           CheckType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutErrorMsg                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBEditorMapCheckable::BP_MapCheck(EMapCheckType CheckType, class FString* OutErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorMapCheckable", "BP_MapCheck");

	Params::RBEditorMapCheckable_BP_MapCheck Parms{};

	Parms.CheckType = CheckType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutErrorMsg != nullptr)
		*OutErrorMsg = std::move(Parms.OutErrorMsg);

	return Parms.ReturnValue;
}


// Function OPP.RBEditorMapCheckable.BP_PrepareMapCheck
// (Native, Event, Public, BlueprintEvent)

void IRBEditorMapCheckable::BP_PrepareMapCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorMapCheckable", "BP_PrepareMapCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.Break_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBGeneratorMultiObjectiveActor::Break_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Break_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.Event_OnBreak
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ARBGeneratorMultiObjectiveActor::Event_OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Event_OnBreak");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGeneratorMultiObjectiveActor.Event_OnCompletionStateChanged
// (Event, Public, BlueprintEvent)

void ARBGeneratorMultiObjectiveActor::Event_OnCompletionStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Event_OnCompletionStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGeneratorMultiObjectiveActor.Event_OnInteractibleStateChanged
// (Event, Public, BlueprintEvent)

void ARBGeneratorMultiObjectiveActor::Event_OnInteractibleStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Event_OnInteractibleStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGeneratorMultiObjectiveActor.Event_OnPreFueledStateChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ARBGeneratorMultiObjectiveActor::Event_OnPreFueledStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Event_OnPreFueledStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGeneratorMultiObjectiveActor.Multicast_OnBreak
// (Net, Native, Event, NetMulticast, Public)

void ARBGeneratorMultiObjectiveActor::Multicast_OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "Multicast_OnBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.OnGeneratorRunningElapsed
// (Final, Native, Private)

void ARBGeneratorMultiObjectiveActor::OnGeneratorRunningElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "OnGeneratorRunningElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.OnPanelStateChanged_Server
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGeneratorMultiObjectiveActor::OnPanelStateChanged_Server(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "OnPanelStateChanged_Server");

	Params::RBGeneratorMultiObjectiveActor_OnPanelStateChanged_Server Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsCompleted
// (Final, Native, Protected)

void ARBGeneratorMultiObjectiveActor::OnRep_IsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "OnRep_IsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsInteractible
// (Final, Native, Protected)

void ARBGeneratorMultiObjectiveActor::OnRep_IsInteractible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "OnRep_IsInteractible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.OnRep_PreFueled
// (Final, Native, Protected)

void ARBGeneratorMultiObjectiveActor::OnRep_PreFueled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "OnRep_PreFueled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.ForceComplete
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, Const)

void ARBGeneratorMultiObjectiveActor::ForceComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "ForceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorMultiObjectiveActor.IsCrankCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGeneratorMultiObjectiveActor::IsCrankCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "IsCrankCompleted");

	Params::RBGeneratorMultiObjectiveActor_IsCrankCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGeneratorMultiObjectiveActor.IsGasReservoirFilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGeneratorMultiObjectiveActor::IsGasReservoirFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "IsGasReservoirFilled");

	Params::RBGeneratorMultiObjectiveActor_IsGasReservoirFilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGeneratorMultiObjectiveActor.IsLeftElectricPanelCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGeneratorMultiObjectiveActor::IsLeftElectricPanelCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "IsLeftElectricPanelCompleted");

	Params::RBGeneratorMultiObjectiveActor_IsLeftElectricPanelCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGeneratorMultiObjectiveActor.IsRightElectricPanelCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGeneratorMultiObjectiveActor::IsRightElectricPanelCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorMultiObjectiveActor", "IsRightElectricPanelCompleted");

	Params::RBGeneratorMultiObjectiveActor_IsRightElectricPanelCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEditorUtilityInterface.FixUp
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBEditorUtilityInterface::FixUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "FixUp");

	Params::RBEditorUtilityInterface_FixUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEditorUtilityInterface.OnEditorPostLoad
// (Native, Event, Public, BlueprintEvent)

void IRBEditorUtilityInterface::OnEditorPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "OnEditorPostLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.OnPostActorsPasted
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   PastedActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void IRBEditorUtilityInterface::OnPostActorsPasted(const TArray<class AActor*>& PastedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "OnPostActorsPasted");

	Params::RBEditorUtilityInterface_OnPostActorsPasted Parms{};

	Parms.PastedActors = std::move(PastedActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.PostAddedToLevel
// (Native, Event, Public, BlueprintEvent)

void IRBEditorUtilityInterface::PostAddedToLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "PostAddedToLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.PostDuplicated
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           DuplicationParent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBEditorUtilityInterface::PostDuplicated(class AActor* DuplicationParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "PostDuplicated");

	Params::RBEditorUtilityInterface_PostDuplicated Parms{};

	Parms.DuplicationParent = DuplicationParent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.PostEditChange
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             PropertyName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBEditorUtilityInterface::PostEditChange(const class FName& PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "PostEditChange");

	Params::RBEditorUtilityInterface_PostEditChange Parms{};

	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.PostEditMove
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFinished                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBEditorUtilityInterface::PostEditMove(bool bFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "PostEditMove");

	Params::RBEditorUtilityInterface_PostEditMove Parms{};

	Parms.bFinished = bFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEditorUtilityInterface.TickSelected
// (Native, Event, Public, BlueprintEvent)

void IRBEditorUtilityInterface::TickSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEditorUtilityInterface", "TickSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetPawnPushingIntentRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetPawnPushingIntentRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetPawnPushingIntentRatio");

	Params::RBElectricalSawPanelComponent_BP_GetPawnPushingIntentRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetSawAccumulatedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetSawAccumulatedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetSawAccumulatedDistance");

	Params::RBElectricalSawPanelComponent_BP_GetSawAccumulatedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetSawCurrentOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetSawCurrentOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetSawCurrentOffset");

	Params::RBElectricalSawPanelComponent_BP_GetSawCurrentOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetSawMovingSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetSawMovingSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetSawMovingSpeed");

	Params::RBElectricalSawPanelComponent_BP_GetSawMovingSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetSawOffsetRatioForSide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetSawOffsetRatioForSide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetSawOffsetRatioForSide");

	Params::RBElectricalSawPanelComponent_BP_GetSawOffsetRatioForSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_GetSawPushDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectricalSawPanelComponent::BP_GetSawPushDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_GetSawPushDelta");

	Params::RBElectricalSawPanelComponent_BP_GetSawPushDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricalSawPanelComponent.BP_IsSawConsideredMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBElectricalSawPanelComponent::BP_IsSawConsideredMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricalSawPanelComponent", "BP_IsSawConsideredMoving");

	Params::RBElectricalSawPanelComponent_BP_IsSawConsideredMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGlobalUIConfig.GetRandomRewardPoolDisplayDetails
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RandomRewardPoolId                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomRewardPoolDisplayDetailsReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FRandomRewardPoolDisplayDetails URBGlobalUIConfig::GetRandomRewardPoolDisplayDetails(const class FName& RandomRewardPoolId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGlobalUIConfig", "GetRandomRewardPoolDisplayDetails");

	Params::RBGlobalUIConfig_GetRandomRewardPoolDisplayDetails Parms{};

	Parms.RandomRewardPoolId = RandomRewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGlobalUIConfig.GetNPCSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMetaNPCSettings           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMetaNPCSettings URBGlobalUIConfig::GetNPCSettings(EMetaNPCType NPCType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGlobalUIConfig", "GetNPCSettings");

	Params::RBGlobalUIConfig_GetNPCSettings Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectricFloorTrapComponent.BP_BreakTrap
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBElectricFloorTrapComponent::BP_BreakTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricFloorTrapComponent", "BP_BreakTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectricFloorTrapComponent.ElectricFloorTrapStateChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBElectricFloorTrapComponent::ElectricFloorTrapStateChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricFloorTrapComponent", "ElectricFloorTrapStateChangedCallback");

	Params::RBElectricFloorTrapComponent_ElectricFloorTrapStateChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectricFloorTrapComponent.OnNPCBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBElectricFloorTrapComponent::OnNPCBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricFloorTrapComponent", "OnNPCBeginOverlap");

	Params::RBElectricFloorTrapComponent_OnNPCBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectricFloorTrapComponent.OnRep_ElectricFloorTrapState
// (Final, Native, Public)

void URBElectricFloorTrapComponent::OnRep_ElectricFloorTrapState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectricFloorTrapComponent", "OnRep_ElectricFloorTrapState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTalkWheel.Event_RefreshSlices
// (Event, Public, BlueprintEvent)

void URBTalkWheel::Event_RefreshSlices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTalkWheel", "Event_RefreshSlices");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBElectrocutionDevice.Event_OnActivePanelAdded
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBElectrocutionSwitchPanelComponent*Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBElectrocutionDevice::Event_OnActivePanelAdded(class URBElectrocutionSwitchPanelComponent* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnActivePanelAdded");

	Params::RBElectrocutionDevice_Event_OnActivePanelAdded Parms{};

	Parms.Panel = Panel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBElectrocutionDevice.Event_OnActivePanelRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBElectrocutionSwitchPanelComponent*Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBElectrocutionDevice::Event_OnActivePanelRemoved(class URBElectrocutionSwitchPanelComponent* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnActivePanelRemoved");

	Params::RBElectrocutionDevice_Event_OnActivePanelRemoved Parms{};

	Parms.Panel = Panel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBElectrocutionDevice.Event_OnCompletedChanged
// (Event, Public, BlueprintEvent)

void ARBElectrocutionDevice::Event_OnCompletedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnCompletedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBElectrocutionDevice.Event_OnCurrentVoltageChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentVoltage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBElectrocutionDevice::Event_OnCurrentVoltageChanged(float CurrentVoltage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnCurrentVoltageChanged");

	Params::RBElectrocutionDevice_Event_OnCurrentVoltageChanged Parms{};

	Parms.CurrentVoltage = CurrentVoltage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBElectrocutionDevice.Event_OnPlayerOverloading
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBElectrocutionSwitchPanelComponent*Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBElectrocutionDevice::Event_OnPlayerOverloading(class URBElectrocutionSwitchPanelComponent* Panel, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnPlayerOverloading");

	Params::RBElectrocutionDevice_Event_OnPlayerOverloading Parms{};

	Parms.Panel = Panel;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBElectrocutionDevice.Event_OnStartedChanged
// (Event, Public, BlueprintEvent)

void ARBElectrocutionDevice::Event_OnStartedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "Event_OnStartedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBElectrocutionDevice.OnRep_OnCompletedChanged
// (Final, Native, Protected)

void ARBElectrocutionDevice::OnRep_OnCompletedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "OnRep_OnCompletedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionDevice.OnRep_OnStartedChanged
// (Final, Native, Protected)

void ARBElectrocutionDevice::OnRep_OnStartedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "OnRep_OnStartedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionDevice.GetCurrentVoltageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBElectrocutionDevice::GetCurrentVoltageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "GetCurrentVoltageRatio");

	Params::RBElectrocutionDevice_GetCurrentVoltageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionDevice.GetLinkedCoordinator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBElectrocutionObjectiveCoordinator*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBElectrocutionObjectiveCoordinator* ARBElectrocutionDevice::GetLinkedCoordinator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "GetLinkedCoordinator");

	Params::RBElectrocutionDevice_GetLinkedCoordinator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionDevice.GetNumberOfActivePlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBElectrocutionDevice::GetNumberOfActivePlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionDevice", "GetNumberOfActivePlayers");

	Params::RBElectrocutionDevice_GetNumberOfActivePlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBElectrocutionObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionObjectiveCoordinator", "OnPanelPawnInteractingChangedEvent");

	Params::RBElectrocutionObjectiveCoordinator_OnPanelPawnInteractingChangedEvent Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionObjectiveCoordinator.OnRep_CurrentVoltage
// (Final, Native, Protected)

void ARBElectrocutionObjectiveCoordinator::OnRep_CurrentVoltage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionObjectiveCoordinator", "OnRep_CurrentVoltage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionObjectiveCoordinator.GetCurrentVoltageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBElectrocutionObjectiveCoordinator::GetCurrentVoltageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionObjectiveCoordinator", "GetCurrentVoltageRatio");

	Params::RBElectrocutionObjectiveCoordinator_GetCurrentVoltageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionObjectiveCoordinator.GetNumberOfActivePlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBElectrocutionObjectiveCoordinator::GetNumberOfActivePlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionObjectiveCoordinator", "GetNumberOfActivePlayers");

	Params::RBElectrocutionObjectiveCoordinator_GetNumberOfActivePlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.CloseWWW
// (Final, Native, Public, BlueprintCallable)

void URBWWWControlMenu::CloseWWW()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "CloseWWW");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.Event_OnPlaybackSpeedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SpeedIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::Event_OnPlaybackSpeedChanged(int32 SpeedIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "Event_OnPlaybackSpeedChanged");

	Params::RBWWWControlMenu_Event_OnPlaybackSpeedChanged Parms{};

	Parms.SpeedIdx = SpeedIdx;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBWWWControlMenu.GetPlaybackInfoText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBWWWControlMenu::GetPlaybackInfoText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "GetPlaybackInfoText");

	Params::RBWWWControlMenu_GetPlaybackInfoText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.GetPlaybackTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBWWWControlMenu::GetPlaybackTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "GetPlaybackTime");

	Params::RBWWWControlMenu_GetPlaybackTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.GetWWWPlaybackSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWWWPlaybackSpeed                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWWWPlaybackSpeed URBWWWControlMenu::GetWWWPlaybackSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "GetWWWPlaybackSpeed");

	Params::RBWWWControlMenu_GetWWWPlaybackSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBWWWControlMenu::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "IsPlaying");

	Params::RBWWWControlMenu_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.OnPlayControlButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForward                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWWWPlaybackSpeed                       PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::OnPlayControlButton(bool bForward, EWWWPlaybackSpeed PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "OnPlayControlButton");

	Params::RBWWWControlMenu_OnPlayControlButton Parms{};

	Parms.bForward = bForward;
	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.SetPlaybackTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PlaybackTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::SetPlaybackTime(float PlaybackTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "SetPlaybackTime");

	Params::RBWWWControlMenu_SetPlaybackTime Parms{};

	Parms.PlaybackTime = PlaybackTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.SetShowAIDirectorInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldShow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::SetShowAIDirectorInfo(bool bShouldShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "SetShowAIDirectorInfo");

	Params::RBWWWControlMenu_SetShowAIDirectorInfo Parms{};

	Parms.bShouldShow = bShouldShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.SetShowGameEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldShow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::SetShowGameEvents(bool bShouldShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "SetShowGameEvents");

	Params::RBWWWControlMenu_SetShowGameEvents Parms{};

	Parms.bShouldShow = bShouldShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.SetTrackDrawOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWWWTrackDrawSelection                  DrawSelection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWWWTrackDrawLength                     DrawLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::SetTrackDrawOptions(EWWWTrackDrawSelection DrawSelection, EWWWTrackDrawLength DrawLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "SetTrackDrawOptions");

	Params::RBWWWControlMenu_SetTrackDrawOptions Parms{};

	Parms.DrawSelection = DrawSelection;
	Parms.DrawLength = DrawLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.SetWWWPlaybackSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWWWPlaybackSpeed                       PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWWWControlMenu::SetWWWPlaybackSpeed(EWWWPlaybackSpeed PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "SetWWWPlaybackSpeed");

	Params::RBWWWControlMenu_SetWWWPlaybackSpeed Parms{};

	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWWWControlMenu.ShouldShowAIDirectorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBWWWControlMenu::ShouldShowAIDirectorInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "ShouldShowAIDirectorInfo");

	Params::RBWWWControlMenu_ShouldShowAIDirectorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.ShouldShowGameEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBWWWControlMenu::ShouldShowGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "ShouldShowGameEvents");

	Params::RBWWWControlMenu_ShouldShowGameEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWWWControlMenu.TogglePlayPause
// (Final, Native, Public, BlueprintCallable)

void URBWWWControlMenu::TogglePlayPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWWWControlMenu", "TogglePlayPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnActiveStateChanged
// (Event, Public, BlueprintEvent)

void URBElectrocutionSwitchPanelComponent::Event_OnActiveStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "Event_OnActiveStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnSwitchStateChanged
// (Event, Public, BlueprintEvent)

void URBElectrocutionSwitchPanelComponent::Event_OnSwitchStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "Event_OnSwitchStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBElectrocutionSwitchPanelComponent.OnRep_SwitchState
// (Final, Native, Private)

void URBElectrocutionSwitchPanelComponent::OnRep_SwitchState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "OnRep_SwitchState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBElectrocutionSwitchPanelComponent.GetActiveToOverloadedRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectrocutionSwitchPanelComponent::GetActiveToOverloadedRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "GetActiveToOverloadedRatio");

	Params::RBElectrocutionSwitchPanelComponent_GetActiveToOverloadedRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionSwitchPanelComponent.GetSwitchActiveRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBElectrocutionSwitchPanelComponent::GetSwitchActiveRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "GetSwitchActiveRatio");

	Params::RBElectrocutionSwitchPanelComponent_GetSwitchActiveRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBElectrocutionSwitchPanelComponent.IsInActiveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBElectrocutionSwitchPanelComponent::IsInActiveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBElectrocutionSwitchPanelComponent", "IsInActiveState");

	Params::RBElectrocutionSwitchPanelComponent_IsInActiveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPopUpWidget.BP_AdjustToAnchor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBPopUpAnchorWidget*             AnchorWidget                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsePopupCenter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPopUpWidget::BP_AdjustToAnchor(class URBPopUpAnchorWidget* AnchorWidget, bool bUsePopupCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpWidget", "BP_AdjustToAnchor");

	Params::RBPopUpWidget_BP_AdjustToAnchor Parms{};

	Parms.AnchorWidget = AnchorWidget;
	Parms.bUsePopupCenter = bUsePopupCenter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpConfirmWidget.BP_Confirm
// (Final, Native, Public, BlueprintCallable)

void URBPopUpConfirmWidget::BP_Confirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpConfirmWidget", "BP_Confirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpConfirmWidget.Event_InitializePopup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TitleText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ConfirmText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPopUpConfirmWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpConfirmWidget", "Event_InitializePopup");

	Params::RBPopUpConfirmWidget_Event_InitializePopup Parms{};

	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);
	Parms.ConfirmText = std::move(ConfirmText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBErrorConfirmPopUpWidget.InitializeErrorPopup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ErrorCauseMessage                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ErrorCodeString                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBErrorConfirmPopUpWidget::InitializeErrorPopup(const class FText& Message, const class FText& ErrorCauseMessage, const class FString& ErrorCodeString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBErrorConfirmPopUpWidget", "InitializeErrorPopup");

	Params::RBErrorConfirmPopUpWidget_InitializeErrorPopup Parms{};

	Parms.Message = std::move(Message);
	Parms.ErrorCauseMessage = std::move(ErrorCauseMessage);
	Parms.ErrorCodeString = std::move(ErrorCodeString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerComponent.GetOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Out_Actors                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBGameplayTriggerComponent::GetOverlappingActors(TArray<class AActor*>* Out_Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerComponent", "GetOverlappingActors");

	Params::RBGameplayTriggerComponent_GetOverlappingActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_Actors != nullptr)
		*Out_Actors = std::move(Parms.Out_Actors);
}


// Function OPP.RBGameplayTriggerComponent.OnActorOverlapped
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameplayTriggerComponent::OnActorOverlapped(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerComponent", "OnActorOverlapped");

	Params::RBGameplayTriggerComponent_OnActorOverlapped Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerComponent.OnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBGameplayTriggerComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerComponent", "OnComponentBeginOverlap");

	Params::RBGameplayTriggerComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerComponent.OnTriggeredChanged
// (Final, Native, Private)

void URBGameplayTriggerComponent::OnTriggeredChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerComponent", "OnTriggeredChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameplayTriggerComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerComponent", "IsEnabled");

	Params::RBGameplayTriggerComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBEvalCorridor.Event_OnLocalPlayerEntered
// (Event, Public, BlueprintEvent)

void ARBEvalCorridor::Event_OnLocalPlayerEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridor", "Event_OnLocalPlayerEntered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEvalCorridor.Event_OnLocalPlayerExited
// (Event, Public, BlueprintEvent)

void ARBEvalCorridor::Event_OnLocalPlayerExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridor", "Event_OnLocalPlayerExited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEvalCorridor.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBEvalCorridor::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridor", "OnComponentBeginOverlap");

	Params::RBEvalCorridor_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridor.OnComponentEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBEvalCorridor::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridor", "OnComponentEndOverlap");

	Params::RBEvalCorridor_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridor.OnPlayerInitReplicated
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBEvalCorridor::OnPlayerInitReplicated(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridor", "OnPlayerInitReplicated");

	Params::RBEvalCorridor_OnPlayerInitReplicated Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorEntrance.Event_OnLocallyClosedChanged
// (Event, Public, BlueprintEvent)

void ARBEvalCorridorEntrance::Event_OnLocallyClosedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorEntrance", "Event_OnLocallyClosedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEvalCorridorEntrance.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBEvalCorridorEntrance::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorEntrance", "OnComponentBeginOverlap");

	Params::RBEvalCorridorEntrance_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorExit.Event_OnLocalPlayerEntered
// (Event, Public, BlueprintEvent)

void ARBEvalCorridorExit::Event_OnLocalPlayerEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorExit", "Event_OnLocalPlayerEntered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEvalCorridorExit.Event_OnLocalPlayerExited
// (Event, Public, BlueprintEvent)

void ARBEvalCorridorExit::Event_OnLocalPlayerExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorExit", "Event_OnLocalPlayerExited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBEvalCorridorExit.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBEvalCorridorExit::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorExit", "OnComponentBeginOverlap");

	Params::RBEvalCorridorExit_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorExit.OnComponentEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBEvalCorridorExit::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorExit", "OnComponentEndOverlap");

	Params::RBEvalCorridorExit_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEvalCorridorHelperComponent::BP_ScheduleCollisionEnabled(class ARBPlayer* Player, bool bEnabled, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorHelperComponent", "BP_ScheduleCollisionEnabled");

	Params::RBEvalCorridorHelperComponent_BP_ScheduleCollisionEnabled Parms{};

	Parms.Player = Player;
	Parms.bEnabled = bEnabled;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabledLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEvalCorridorHelperComponent::BP_ScheduleCollisionEnabledLocalPlayer(bool bEnabled, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorHelperComponent", "BP_ScheduleCollisionEnabledLocalPlayer");

	Params::RBEvalCorridorHelperComponent_BP_ScheduleCollisionEnabledLocalPlayer Parms{};

	Parms.bEnabled = bEnabled;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBEvalCorridorHelperComponent.Multicast_ScheduleCollisionEnabledForPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExecutionTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipLocalPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBEvalCorridorHelperComponent::Multicast_ScheduleCollisionEnabledForPlayer(class ARBPlayer* Player, bool bEnabled, float ExecutionTime, bool bSkipLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBEvalCorridorHelperComponent", "Multicast_ScheduleCollisionEnabledForPlayer");

	Params::RBEvalCorridorHelperComponent_Multicast_ScheduleCollisionEnabledForPlayer Parms{};

	Parms.Player = Player;
	Parms.bEnabled = bEnabled;
	Parms.ExecutionTime = ExecutionTime;
	Parms.bSkipLocalPlayer = bSkipLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuestItemSpawner.CanSpawnMoreQuestItems
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBQuestItemSpawner::CanSpawnMoreQuestItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestItemSpawner", "CanSpawnMoreQuestItems");

	Params::RBQuestItemSpawner_CanSpawnMoreQuestItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBQuestItemSpawner.CleanQuestItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBQuestItemSpawner::CleanQuestItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestItemSpawner", "CleanQuestItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuestItemSpawner.GetSpecificObjectiveActorTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* IRBQuestItemSpawner::GetSpecificObjectiveActorTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestItemSpawner", "GetSpecificObjectiveActorTarget");

	Params::RBQuestItemSpawner_GetSpecificObjectiveActorTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBQuestItemSpawner.SpawnQuestItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class ARBPickup>            SpecificItemClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* IRBQuestItemSpawner::SpawnQuestItem(TSubclassOf<class ARBPickup> SpecificItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuestItemSpawner", "SpawnQuestItem");

	Params::RBQuestItemSpawner_SpawnQuestItem Parms{};

	Parms.SpecificItemClass = SpecificItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExitStageObjectiveCoordinator.Event_OnExitStageObjectiveStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EExitStageObjectiveState                Param_ObjectiveState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::Event_OnExitStageObjectiveStateChanged(EExitStageObjectiveState Param_ObjectiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "Event_OnExitStageObjectiveStateChanged");

	Params::RBExitStageObjectiveCoordinator_Event_OnExitStageObjectiveStateChanged Parms{};

	Parms.Param_ObjectiveState = Param_ObjectiveState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBExitStageObjectiveCoordinator.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnGamePhaseUpdated");

	Params::RBExitStageObjectiveCoordinator_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnOperatingFinished
// (Final, Native, Private)
// Parameters:
// class URBOperatableComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnOperatingFinished(class URBOperatableComponent* Component, class ARBPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnOperatingFinished");

	Params::RBExitStageObjectiveCoordinator_OnOperatingFinished Parms{};

	Parms.Component = Component;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnPawnKilled
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnPawnKilled(class ARBPawn* InstigatorActor, class ARBPawn* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnPawnKilled");

	Params::RBExitStageObjectiveCoordinator_OnPawnKilled Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnPawnRespawned
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnPawnRespawned(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnPawnRespawned");

	Params::RBExitStageObjectiveCoordinator_OnPawnRespawned Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnPlayerRevived
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnPlayerRevived(class ARBPlayer* InstigatorActor, class ARBPlayer* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnPlayerRevived");

	Params::RBExitStageObjectiveCoordinator_OnPlayerRevived Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnPlayerSimpleDoAction
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExitStageObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnPlayerSimpleDoAction");

	Params::RBExitStageObjectiveCoordinator_OnPlayerSimpleDoAction Parms{};

	Parms.Player = Player;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExitStageObjectiveCoordinator.OnRep_ObjectiveState
// (Final, Native, Private)

void ARBExitStageObjectiveCoordinator::OnRep_ObjectiveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExitStageObjectiveCoordinator", "OnRep_ObjectiveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReleaseExitStageObjectiveCoordinator.OnCreditsMenuPopped
// (Final, Native, Private)

void ARBReleaseExitStageObjectiveCoordinator::OnCreditsMenuPopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseExitStageObjectiveCoordinator", "OnCreditsMenuPopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.CancelMatchCountdown
// (Final, Native, Public, BlueprintCallable)

void URBExperimentBoardMenu::CancelMatchCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "CancelMatchCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBExperimentBoardMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExperimentBoardMenu.OnMatchSettingsUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "OnMatchSettingsUpdated");

	Params::RBExperimentBoardMenu_OnMatchSettingsUpdated Parms{};

	Parms.MatchSettings = std::move(MatchSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.OnMatchStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchState                      MatchState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "OnMatchStateUpdated");

	Params::RBExperimentBoardMenu_OnMatchStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchState = std::move(MatchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.SaveMatchSettings
// (Final, Native, Public, BlueprintCallable)

void URBExperimentBoardMenu::SaveMatchSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "SaveMatchSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.SetMissionName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MissionName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::SetMissionName(const class FName& MissionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "SetMissionName");

	Params::RBExperimentBoardMenu_SetMissionName Parms{};

	Parms.MissionName = MissionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.SetStageName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StageName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::SetStageName(const class FName& StageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "SetStageName");

	Params::RBExperimentBoardMenu_SetStageName Parms{};

	Parms.StageName = StageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.SetTrialChainId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TrialChainId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::SetTrialChainId(const class FName& TrialChainId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "SetTrialChainId");

	Params::RBExperimentBoardMenu_SetTrialChainId Parms{};

	Parms.TrialChainId = TrialChainId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.SetTrialId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentBoardMenu::SetTrialId(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "SetTrialId");

	Params::RBExperimentBoardMenu_SetTrialId Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.StartMatchCountdown
// (Final, Native, Public, BlueprintCallable)

void URBExperimentBoardMenu::StartMatchCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "StartMatchCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentBoardMenu.CanCancelMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentBoardMenu::CanCancelMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "CanCancelMatch");

	Params::RBExperimentBoardMenu_CanCancelMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentBoardMenu.CanStartMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentBoardMenu::CanStartMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "CanStartMatch");

	Params::RBExperimentBoardMenu_CanStartMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentBoardMenu.GetMatchCurrentPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentBoardMenu::GetMatchCurrentPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "GetMatchCurrentPlayerCount");

	Params::RBExperimentBoardMenu_GetMatchCurrentPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentBoardMenu.GetMatchSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMatchSettings             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMatchSettings URBExperimentBoardMenu::GetMatchSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "GetMatchSettings");

	Params::RBExperimentBoardMenu_GetMatchSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentBoardMenu.IsMatchOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentBoardMenu::IsMatchOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentBoardMenu", "IsMatchOwner");

	Params::RBExperimentBoardMenu_IsMatchOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHitNPCObjectiveCoordinator.Event_OnNPCHit
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHeadshot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHitNPCObjectiveCoordinator::Event_OnNPCHit(class ARBNPC* NPC, bool bHeadshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHitNPCObjectiveCoordinator", "Event_OnNPCHit");

	Params::RBHitNPCObjectiveCoordinator_Event_OnNPCHit Parms{};

	Parms.NPC = NPC;
	Parms.bHeadshot = bHeadshot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHitNPCObjectiveCoordinator.Multicast_OnNextRoundStarted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ARBHitNPCObjectiveCoordinator::Multicast_OnNextRoundStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHitNPCObjectiveCoordinator", "Multicast_OnNextRoundStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHitNPCObjectiveCoordinator.OnNPCHitByProjectile
// (Final, Native, Protected)
// Parameters:
// class ARBNPC*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Thrower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsHeadshot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHitNPCObjectiveCoordinator::OnNPCHitByProjectile(class ARBNPC* Target, class ARBPawn* Thrower, class AActor* Projectile, bool bIsHeadshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHitNPCObjectiveCoordinator", "OnNPCHitByProjectile");

	Params::RBHitNPCObjectiveCoordinator_OnNPCHitByProjectile Parms{};

	Parms.Target = Target;
	Parms.Thrower = Thrower;
	Parms.Projectile = Projectile;
	Parms.bIsHeadshot = bIsHeadshot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHitNPCObjectiveCoordinator.OnRep_CurrentRoundCompletion
// (Final, Native, Protected)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHitNPCObjectiveCoordinator::OnRep_CurrentRoundCompletion(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHitNPCObjectiveCoordinator", "OnRep_CurrentRoundCompletion");

	Params::RBHitNPCObjectiveCoordinator_OnRep_CurrentRoundCompletion Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskConditionContext_ProjectileHit.OnProjectilePawnHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class ARBProjectile*                    RBProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskConditionContext_ProjectileHit::OnProjectilePawnHit(class ARBProjectile* RBProjectile, class ARBPawn* RBPawn, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskConditionContext_ProjectileHit", "OnProjectilePawnHit");

	Params::RBTaskConditionContext_ProjectileHit_OnProjectilePawnHit Parms{};

	Parms.RBProjectile = RBProjectile;
	Parms.RBPawn = RBPawn;
	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPhotoFinishEntry.Event_Setup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FEndStagePlayerInfo              Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPhotoFinishEntry::Event_Setup(const struct FEndStagePlayerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPhotoFinishEntry", "Event_Setup");

	Params::RBPhotoFinishEntry_Event_Setup Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBExperimentResultScreen.ClearOverheadEntries
// (Final, Native, Public, BlueprintCallable)

void URBExperimentResultScreen::ClearOverheadEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "ClearOverheadEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.ClearSocialMenuScene
// (Final, Native, Public, BlueprintCallable)

void URBExperimentResultScreen::ClearSocialMenuScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "ClearSocialMenuScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBExperimentResultScreen::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExperimentResultScreen.Event_StartAnimations
// (Event, Public, BlueprintEvent)

void URBExperimentResultScreen::Event_StartAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "Event_StartAnimations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExperimentResultScreen.Event_UpdateReadyState
// (Event, Public, BlueprintEvent)

void URBExperimentResultScreen::Event_UpdateReadyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "Event_UpdateReadyState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExperimentResultScreen.InitSocialMenuScene
// (Final, Native, Public, BlueprintCallable)

void URBExperimentResultScreen::InitSocialMenuScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "InitSocialMenuScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.Leave
// (Final, Native, Public, BlueprintCallable)

void URBExperimentResultScreen::Leave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "Leave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.OnDrawHud
// (Final, Native, Private)

void URBExperimentResultScreen::OnDrawHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "OnDrawHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentResultScreen::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "OnGamePhaseUpdated");

	Params::RBExperimentResultScreen_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.OnLeaving
// (Final, Native, Private)
// Parameters:
// EPlayerLeaveTarget                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentResultScreen::OnLeaving(EPlayerLeaveTarget Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "OnLeaving");

	Params::RBExperimentResultScreen_OnLeaving Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.OnLobbyGameSessionAvailable
// (Final, Native, Private)

void URBExperimentResultScreen::OnLobbyGameSessionAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "OnLobbyGameSessionAvailable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.OnPlayerLeftGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBExperimentResultScreen::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "OnPlayerLeftGame");

	Params::RBExperimentResultScreen_OnPlayerLeftGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.VoteForRetry
// (Final, Native, Public, BlueprintCallable)

void URBExperimentResultScreen::VoteForRetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "VoteForRetry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExperimentResultScreen.CanLeave
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::CanLeave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "CanLeave");

	Params::RBExperimentResultScreen_CanLeave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.GetLoadingPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentResultScreen::GetLoadingPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "GetLoadingPercentage");

	Params::RBExperimentResultScreen_GetLoadingPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.GetRetrySecondsRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentResultScreen::GetRetrySecondsRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "GetRetrySecondsRemaining");

	Params::RBExperimentResultScreen_GetRetrySecondsRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.GetRetryTrialVotes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentResultScreen::GetRetryTrialVotes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "GetRetryTrialVotes");

	Params::RBExperimentResultScreen_GetRetryTrialVotes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.GetRetryTrialVotesNecessary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentResultScreen::GetRetryTrialVotesNecessary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "GetRetryTrialVotesNecessary");

	Params::RBExperimentResultScreen_GetRetryTrialVotesNecessary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.GetSecondsRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBExperimentResultScreen::GetSecondsRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "GetSecondsRemaining");

	Params::RBExperimentResultScreen_GetSecondsRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.HasRetryTrialVotePassed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::HasRetryTrialVotePassed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "HasRetryTrialVotePassed");

	Params::RBExperimentResultScreen_HasRetryTrialVotePassed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.HasTrialToChain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::HasTrialToChain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "HasTrialToChain");

	Params::RBExperimentResultScreen_HasTrialToChain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.IsRetryFeatureEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::IsRetryFeatureEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "IsRetryFeatureEnabled");

	Params::RBExperimentResultScreen_IsRetryFeatureEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.IsRetryTrialVoteInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::IsRetryTrialVoteInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "IsRetryTrialVoteInProgress");

	Params::RBExperimentResultScreen_IsRetryTrialVoteInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.IsReturningToLobbyWithParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::IsReturningToLobbyWithParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "IsReturningToLobbyWithParty");

	Params::RBExperimentResultScreen_IsReturningToLobbyWithParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.IsStageSuccess
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::IsStageSuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "IsStageSuccess");

	Params::RBExperimentResultScreen_IsStageSuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExperimentResultScreen.IsTrialChainingActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBExperimentResultScreen::IsTrialChainingActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExperimentResultScreen", "IsTrialChainingActive");

	Params::RBExperimentResultScreen_IsTrialChainingActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBExplosiveTrap.BP_ForceExplode
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBExplosiveTrap::BP_ForceExplode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "BP_ForceExplode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.Event_ActiveChanged
// (Event, Public, BlueprintEvent)

void ARBExplosiveTrap::Event_ActiveChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Event_ActiveChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExplosiveTrap.Event_Disable
// (Event, Public, BlueprintEvent)

void ARBExplosiveTrap::Event_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Event_Disable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExplosiveTrap.Event_Explode
// (Event, Public, BlueprintEvent)

void ARBExplosiveTrap::Event_Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Event_Explode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExplosiveTrap.Event_SnapToState
// (Event, Public, BlueprintEvent)

void ARBExplosiveTrap::Event_SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Event_SnapToState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBExplosiveTrap.Multicast_Disable
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBExplosiveTrap::Multicast_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Multicast_Disable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.Multicast_Explode
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBExplosiveTrap::Multicast_Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "Multicast_Explode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.OnComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBExplosiveTrap::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "OnComponentBeginOverlap");

	Params::RBExplosiveTrap_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.OnComponentEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBExplosiveTrap::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "OnComponentEndOverlap");

	Params::RBExplosiveTrap_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.OnRep_Exploded
// (Final, Native, Protected)

void ARBExplosiveTrap::OnRep_Exploded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "OnRep_Exploded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBExplosiveTrap.OnRep_ExplosionRatio
// (Final, Native, Protected)

void ARBExplosiveTrap::OnRep_ExplosionRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBExplosiveTrap", "OnRep_ExplosionRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.Multicast_OnPumpInputAction
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// ETimingInputResultType                  Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFirePumpObjectiveCoordinator::Multicast_OnPumpInputAction(ETimingInputResultType Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "Multicast_OnPumpInputAction");

	Params::RBFirePumpObjectiveCoordinator_Multicast_OnPumpInputAction Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnPanelActiveChangedEvent_Server
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFirePumpObjectiveCoordinator::OnPanelActiveChangedEvent_Server(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnPanelActiveChangedEvent_Server");

	Params::RBFirePumpObjectiveCoordinator_OnPanelActiveChangedEvent_Server Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnPumpInput_Server
// (Final, Native, Protected)
// Parameters:
// class URBZoneTimingPanelComponent*      Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimingInputResultType                  Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFirePumpObjectiveCoordinator::OnPumpInput_Server(class URBZoneTimingPanelComponent* Panel, class ARBPlayer* Player, int32 TargetIndex, float Timestamp, ETimingInputResultType Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnPumpInput_Server");

	Params::RBFirePumpObjectiveCoordinator_OnPumpInput_Server Parms{};

	Parms.Panel = Panel;
	Parms.Player = Player;
	Parms.TargetIndex = TargetIndex;
	Parms.Timestamp = Timestamp;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnPumpInteractionEvent_Server
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFirePumpObjectiveCoordinator::OnPumpInteractionEvent_Server(class ARBPawn* Interactor, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnPumpInteractionEvent_Server");

	Params::RBFirePumpObjectiveCoordinator_OnPumpInteractionEvent_Server Parms{};

	Parms.Interactor = Interactor;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnRep_FireProgressRatio
// (Final, Native, Private)

void ARBFirePumpObjectiveCoordinator::OnRep_FireProgressRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnRep_FireProgressRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnRep_WaterValveSectionData
// (Final, Native, Private)

void ARBFirePumpObjectiveCoordinator::OnRep_WaterValveSectionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnRep_WaterValveSectionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.OnValveInitialInteraction_Server
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBFirePumpObjectiveCoordinator::OnValveInitialInteraction_Server(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "OnValveInitialInteraction_Server");

	Params::RBFirePumpObjectiveCoordinator_OnValveInitialInteraction_Server Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFirePumpObjectiveCoordinator.SelectAllLinkedActors
// (Final, Native, Protected)

void ARBFirePumpObjectiveCoordinator::SelectAllLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFirePumpObjectiveCoordinator", "SelectAllLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFootStepGridComponent.ClearAllData
// (Final, Native, Public)

void URBFootStepGridComponent::ClearAllData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFootStepGridComponent", "ClearAllData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFootStepGridComponent.ClearCurrentData
// (Final, Native, Public)

void URBFootStepGridComponent::ClearCurrentData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFootStepGridComponent", "ClearCurrentData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchPanelComponent.OnCompletedGameplayCallback
// (Final, Native, Protected)

void URBFrequencyMatchPanelComponent::OnCompletedGameplayCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchPanelComponent", "OnCompletedGameplayCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFrequencyMatchPanelComponent.OnRep_IsCompleted
// (Final, Native, Protected)

void URBFrequencyMatchPanelComponent::OnRep_IsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFrequencyMatchPanelComponent", "OnRep_IsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXControlActor.BP_Activate
// (Final, Native, Public, BlueprintCallable)

void ARBFXControlActor::BP_Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXControlActor", "BP_Activate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBFXControlActor.BP_Deactivate
// (Final, Native, Public, BlueprintCallable)

void ARBFXControlActor::BP_Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBFXControlActor", "BP_Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameCondition_Blueprint.Event_EvaluateCondition
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameCondition_Blueprint::Event_EvaluateCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameCondition_Blueprint", "Event_EvaluateCondition");

	Params::RBGameCondition_Blueprint_Event_EvaluateCondition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeMainMenu.GetMainMenuProgressionDetails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMainMenuProgressionDetailsReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMainMenuProgressionDetails ARBGameModeMainMenu::GetMainMenuProgressionDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "GetMainMenuProgressionDetails");

	Params::RBGameModeMainMenu_GetMainMenuProgressionDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeMainMenu.OnDisclaimerAcknowledged
// (Final, Native, Private, BlueprintCallable)

void ARBGameModeMainMenu::OnDisclaimerAcknowledged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnDisclaimerAcknowledged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.OnInputKey
// (Final, Native, Private)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameModeMainMenu::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnInputKey");

	Params::RBGameModeMainMenu_OnInputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.EventType = EventType;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.OnMenuButtonClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMainMenuButton                         Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameModeMainMenu::OnMenuButtonClicked(EMainMenuButton Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnMenuButtonClicked");

	Params::RBGameModeMainMenu_OnMenuButtonClicked Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.OnMenuTransitionOutDone
// (Final, Native, Private)

void ARBGameModeMainMenu::OnMenuTransitionOutDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnMenuTransitionOutDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.OnOperationStatusChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bPending                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameModeMainMenu::OnOperationStatusChanged(bool bPending, bool bSucceeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnOperationStatusChanged");

	Params::RBGameModeMainMenu_OnOperationStatusChanged Parms{};

	Parms.bPending = bPending;
	Parms.bSucceeded = bSucceeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.OnOptionsMenuAcknowledged
// (Final, Native, Private, BlueprintCallable)

void ARBGameModeMainMenu::OnOptionsMenuAcknowledged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "OnOptionsMenuAcknowledged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.RejoinParty
// (Final, Native, Public, BlueprintCallable)

void ARBGameModeMainMenu::RejoinParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "RejoinParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.RejoinSoloGameSession
// (Final, Native, Public, BlueprintCallable)

void ARBGameModeMainMenu::RejoinSoloGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "RejoinSoloGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameModeMainMenu.CanPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameModeMainMenu::CanPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "CanPlay");

	Params::RBGameModeMainMenu_CanPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeMainMenu.CanRejoinParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameModeMainMenu::CanRejoinParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "CanRejoinParty");

	Params::RBGameModeMainMenu_CanRejoinParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeMainMenu.CanRejoinSoloGameSession
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameModeMainMenu::CanRejoinSoloGameSession() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "CanRejoinSoloGameSession");

	Params::RBGameModeMainMenu_CanRejoinSoloGameSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameModeMainMenu.IsPlayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameModeMainMenu::IsPlayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameModeMainMenu", "IsPlayEnabled");

	Params::RBGameModeMainMenu_IsPlayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameplayTriggerVolume.BP_Reset
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBGameplayTriggerVolume::BP_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerVolume", "BP_Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerVolume.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameplayTriggerVolume::BP_SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerVolume", "BP_SetEnabled");

	Params::RBGameplayTriggerVolume_BP_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerVolume.OnTriggeredEventBypass
// (Final, Native, Public)
// Parameters:
// class URBGameplayTriggerComponent*      Trigger                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGameplayTriggerVolume::OnTriggeredEventBypass(class URBGameplayTriggerComponent* Trigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerVolume", "OnTriggeredEventBypass");

	Params::RBGameplayTriggerVolume_OnTriggeredEventBypass Parms{};

	Parms.Trigger = Trigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameplayTriggerVolume.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGameplayTriggerVolume::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameplayTriggerVolume", "IsEnabled");

	Params::RBGameplayTriggerVolume_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.FindBestTrialInfoFromDetails
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRBTrialInfoRow            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBTrialInfoRow URBGameStructureConfig::FindBestTrialInfoFromDetails(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "FindBestTrialInfoFromDetails");

	Params::RBGameStructureConfig_FindBestTrialInfoFromDetails Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetMissionID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             StageName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MissionName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBMissionID                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBMissionID URBGameStructureConfig::GetMissionID(const class FName& StageName, const class FName& MissionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetMissionID");

	Params::RBGameStructureConfig_GetMissionID Parms{};

	Parms.StageName = StageName;
	Parms.MissionName = MissionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetProgramInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBProgramInfoRow          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBProgramInfoRow URBGameStructureConfig::GetProgramInfo(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetProgramInfo");

	Params::RBGameStructureConfig_GetProgramInfo Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetPrograms
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRBProgramInfoRow>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBProgramInfoRow> URBGameStructureConfig::GetPrograms() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetPrograms");

	Params::RBGameStructureConfig_GetPrograms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetProgramTrials
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRBTrialInfoRow>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBTrialInfoRow> URBGameStructureConfig::GetProgramTrials(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetProgramTrials");

	Params::RBGameStructureConfig_GetProgramTrials Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetStageInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             StageID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBStageInfo*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBStageInfo* URBGameStructureConfig::GetStageInfo(const class FName& StageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetStageInfo");

	Params::RBGameStructureConfig_GetStageInfo Parms{};

	Parms.StageID = StageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetTrialChainInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialChainId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBTrialChainRuntimeInfo   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBTrialChainRuntimeInfo URBGameStructureConfig::GetTrialChainInfo(const class FName& TrialChainId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetTrialChainInfo");

	Params::RBGameStructureConfig_GetTrialChainInfo Parms{};

	Parms.TrialChainId = TrialChainId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetTrialChains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRBTrialChainRuntimeInfo> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBTrialChainRuntimeInfo> URBGameStructureConfig::GetTrialChains() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetTrialChains");

	Params::RBGameStructureConfig_GetTrialChains Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetTrialInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBTrialInfoRow            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBTrialInfoRow URBGameStructureConfig::GetTrialInfo(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetTrialInfo");

	Params::RBGameStructureConfig_GetTrialInfo Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetTrials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRBTrialInfoRow>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBTrialInfoRow> URBGameStructureConfig::GetTrials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetTrials");

	Params::RBGameStructureConfig_GetTrials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetVariatorInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBVariatorInfo*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBVariatorInfo* URBGameStructureConfig::GetVariatorInfo(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetVariatorInfo");

	Params::RBGameStructureConfig_GetVariatorInfo Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.GetVariatorInfos
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     IdList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class URBVariatorInfo*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URBVariatorInfo*> URBGameStructureConfig::GetVariatorInfos(const TArray<class FName>& IdList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "GetVariatorInfos");

	Params::RBGameStructureConfig_GetVariatorInfos Parms{};

	Parms.IdList = std::move(IdList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameStructureConfig.IsReleaseTrial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameStructureConfig::IsReleaseTrial(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameStructureConfig", "IsReleaseTrial");

	Params::RBGameStructureConfig_IsReleaseTrial Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.ApplyVoiceChatAudioSettings
// (Final, Native, Public, BlueprintCallable)

void URBGameUserPreferences::ApplyVoiceChatAudioSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "ApplyVoiceChatAudioSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.Block
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::Block(const struct FProfileId& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "Block");

	Params::RBGameUserPreferences_Block Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.GetGlobalVoiceChatVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetGlobalVoiceChatVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetGlobalVoiceChatVolume");

	Params::RBGameUserPreferences_GetGlobalVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetPlayerVoiceChatVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetPlayerVoiceChatVolume(const struct FProfileId& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetPlayerVoiceChatVolume");

	Params::RBGameUserPreferences_GetPlayerVoiceChatVolume Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.SaveSettings
// (Final, Native, Public, BlueprintCallable)

void URBGameUserPreferences::SaveSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SaveSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetAllowPartyMemberInvites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Param_bAllowPartyMemberInvites                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetAllowPartyMemberInvites(bool Param_bAllowPartyMemberInvites)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetAllowPartyMemberInvites");

	Params::RBGameUserPreferences_SetAllowPartyMemberInvites Parms{};

	Parms.Param_bAllowPartyMemberInvites = Param_bAllowPartyMemberInvites;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetAutoHideItemInHandEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAutoHideItemInHand                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetAutoHideItemInHandEnabled(bool bInAutoHideItemInHand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetAutoHideItemInHandEnabled");

	Params::RBGameUserPreferences_SetAutoHideItemInHandEnabled Parms{};

	Parms.bInAutoHideItemInHand = bInAutoHideItemInHand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetBrightnessSettingsToDefaults
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHDR                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetBrightnessSettingsToDefaults(bool bHDR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetBrightnessSettingsToDefaults");

	Params::RBGameUserPreferences_SetBrightnessSettingsToDefaults Parms{};

	Parms.bHDR = bHDR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetConsolePerformanceModeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetConsolePerformanceModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetConsolePerformanceModeEnabled");

	Params::RBGameUserPreferences_SetConsolePerformanceModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetEnableCrossPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableCrossPlay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetEnableCrossPlay(bool bEnableCrossPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetEnableCrossPlay");

	Params::RBGameUserPreferences_SetEnableCrossPlay Parms{};

	Parms.bEnableCrossPlay = bEnableCrossPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetEnableRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetEnableRegion(const class FString& Region, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetEnableRegion");

	Params::RBGameUserPreferences_SetEnableRegion Parms{};

	Parms.Region = std::move(Region);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetEnableVoiceChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnableVoiceChat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetEnableVoiceChat(bool bInEnableVoiceChat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetEnableVoiceChat");

	Params::RBGameUserPreferences_SetEnableVoiceChat Parms{};

	Parms.bInEnableVoiceChat = bInEnableVoiceChat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetForceFeedbackEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetForceFeedbackEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetForceFeedbackEnabled");

	Params::RBGameUserPreferences_SetForceFeedbackEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetGlobalVoiceChatVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetGlobalVoiceChatVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetGlobalVoiceChatVolume");

	Params::RBGameUserPreferences_SetGlobalVoiceChatVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetHDRPaperwhite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Paperwhite                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetHDRPaperwhite(int32 Paperwhite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetHDRPaperwhite");

	Params::RBGameUserPreferences_SetHDRPaperwhite Parms{};

	Parms.Paperwhite = Paperwhite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetHDRUILevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetHDRUILevel(float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetHDRUILevel");

	Params::RBGameUserPreferences_SetHDRUILevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetInteractToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bToggle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepadOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetInteractToggle(bool bToggle, bool bIsGamepadOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetInteractToggle");

	Params::RBGameUserPreferences_SetInteractToggle Parms{};

	Parms.bToggle = bToggle;
	Parms.bIsGamepadOption = bIsGamepadOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetLookSensitivityMultiplier
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetLookSensitivityMultiplier(const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetLookSensitivityMultiplier");

	Params::RBGameUserPreferences_SetLookSensitivityMultiplier Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param_MasterVolume                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApply                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetMasterVolume(float Param_MasterVolume, bool bApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetMasterVolume");

	Params::RBGameUserPreferences_SetMasterVolume Parms{};

	Parms.Param_MasterVolume = Param_MasterVolume;
	Parms.bApply = bApply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMicrophoneVolume                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetMicrophoneVolume(float InMicrophoneVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetMicrophoneVolume");

	Params::RBGameUserPreferences_SetMicrophoneVolume Parms{};

	Parms.InMicrophoneVolume = InMicrophoneVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetMotionBlurEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetMotionBlurEnabled");

	Params::RBGameUserPreferences_SetMotionBlurEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMusicVolume                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApply                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetMusicVolume(float InMusicVolume, bool bApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetMusicVolume");

	Params::RBGameUserPreferences_SetMusicVolume Parms{};

	Parms.InMusicVolume = InMusicVolume;
	Parms.bApply = bApply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetNormalizedBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetNormalizedBrightness(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetNormalizedBrightness");

	Params::RBGameUserPreferences_SetNormalizedBrightness Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetPartyInviteFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_PartyInviteFilter                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetPartyInviteFilter(int32 Param_PartyInviteFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetPartyInviteFilter");

	Params::RBGameUserPreferences_SetPartyInviteFilter Parms{};

	Parms.Param_PartyInviteFilter = Param_PartyInviteFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetPartyPrivacy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPartyPrivacy                           Privacy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetPartyPrivacy(EPartyPrivacy Privacy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetPartyPrivacy");

	Params::RBGameUserPreferences_SetPartyPrivacy Parms{};

	Parms.Privacy = Privacy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetPlayerVoiceChatVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetPlayerVoiceChatVolume(const struct FProfileId& ProfileId, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetPlayerVoiceChatVolume");

	Params::RBGameUserPreferences_SetPlayerVoiceChatVolume Parms{};

	Parms.ProfileId = std::move(ProfileId);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetSFXVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSFXVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApply                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetSFXVolume(float InSFXVolume, bool bApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetSFXVolume");

	Params::RBGameUserPreferences_SetSFXVolume Parms{};

	Parms.InSFXVolume = InSFXVolume;
	Parms.bApply = bApply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetShowHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetShowHud(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetShowHud");

	Params::RBGameUserPreferences_SetShowHud Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetShowSubtitles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetShowSubtitles(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetShowSubtitles");

	Params::RBGameUserPreferences_SetShowSubtitles Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetStickyRunEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInStickyRun                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepadOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetStickyRunEnabled(bool bInStickyRun, bool bIsGamepadOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetStickyRunEnabled");

	Params::RBGameUserPreferences_SetStickyRunEnabled Parms{};

	Parms.bInStickyRun = bInStickyRun;
	Parms.bIsGamepadOption = bIsGamepadOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetSubtitleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIFontSize                             Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetSubtitleSize(EUIFontSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetSubtitleSize");

	Params::RBGameUserPreferences_SetSubtitleSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetTutorialSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIFontSize                             Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetTutorialSize(EUIFontSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetTutorialSize");

	Params::RBGameUserPreferences_SetTutorialSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.SetUsePushToTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInUsePushTotalk                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::SetUsePushToTalk(bool bInUsePushTotalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "SetUsePushToTalk");

	Params::RBGameUserPreferences_SetUsePushToTalk Parms{};

	Parms.bInUsePushTotalk = bInUsePushTotalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.UnBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGameUserPreferences::UnBlock(const struct FProfileId& ProfileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "UnBlock");

	Params::RBGameUserPreferences_UnBlock Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGameUserPreferences.AllowPartyMemberInvites
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::AllowPartyMemberInvites() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "AllowPartyMemberInvites");

	Params::RBGameUserPreferences_AllowPartyMemberInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.CrossPlayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::CrossPlayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "CrossPlayEnabled");

	Params::RBGameUserPreferences_CrossPlayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetAllowFriendRequestNotifications
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetAllowFriendRequestNotifications() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetAllowFriendRequestNotifications");

	Params::RBGameUserPreferences_GetAllowFriendRequestNotifications Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetAudioLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBGameUserPreferences::GetAudioLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetAudioLanguage");

	Params::RBGameUserPreferences_GetAudioLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetCrosshairDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetCrosshairDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetCrosshairDisplay");

	Params::RBGameUserPreferences_GetCrosshairDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetDarknessDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetDarknessDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetDarknessDisplay");

	Params::RBGameUserPreferences_GetDarknessDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetEffectsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetEffectsVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetEffectsVolume");

	Params::RBGameUserPreferences_GetEffectsVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetEnableVoiceChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetEnableVoiceChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetEnableVoiceChat");

	Params::RBGameUserPreferences_GetEnableVoiceChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetFriendsOnlineStatusNotifications
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetFriendsOnlineStatusNotifications() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetFriendsOnlineStatusNotifications");

	Params::RBGameUserPreferences_GetFriendsOnlineStatusNotifications Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetHealthDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetHealthDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetHealthDisplay");

	Params::RBGameUserPreferences_GetHealthDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetInterfacePreset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetInterfacePreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetInterfacePreset");

	Params::RBGameUserPreferences_GetInterfacePreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetInventoryDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetInventoryDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetInventoryDisplay");

	Params::RBGameUserPreferences_GetInventoryDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetLookSensitivityMultiplier
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBGameUserPreferences::GetLookSensitivityMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetLookSensitivityMultiplier");

	Params::RBGameUserPreferences_GetLookSensitivityMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetMasterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetMasterVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetMasterVolume");

	Params::RBGameUserPreferences_GetMasterVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetMicrophoneVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetMicrophoneVolume");

	Params::RBGameUserPreferences_GetMicrophoneVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetMusicVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBGameUserPreferences::GetMusicVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetMusicVolume");

	Params::RBGameUserPreferences_GetMusicVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetNoiseDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetNoiseDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetNoiseDisplay");

	Params::RBGameUserPreferences_GetNoiseDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetObjectiveDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetObjectiveDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetObjectiveDisplay");

	Params::RBGameUserPreferences_GetObjectiveDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetPartyInviteFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetPartyInviteFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetPartyInviteFilter");

	Params::RBGameUserPreferences_GetPartyInviteFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetPartyPrivacy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPartyPrivacy                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPartyPrivacy URBGameUserPreferences::GetPartyPrivacy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetPartyPrivacy");

	Params::RBGameUserPreferences_GetPartyPrivacy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetSanityDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetSanityDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetSanityDisplay");

	Params::RBGameUserPreferences_GetSanityDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetSecondaryObjectiveDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetSecondaryObjectiveDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetSecondaryObjectiveDisplay");

	Params::RBGameUserPreferences_GetSecondaryObjectiveDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetShowSubtitles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetShowSubtitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetShowSubtitles");

	Params::RBGameUserPreferences_GetShowSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetStaminaDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetStaminaDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetStaminaDisplay");

	Params::RBGameUserPreferences_GetStaminaDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetSubtitlesBackground
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetSubtitlesBackground() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetSubtitlesBackground");

	Params::RBGameUserPreferences_GetSubtitlesBackground Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetSubtitleSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUIFontSize                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIFontSize URBGameUserPreferences::GetSubtitleSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetSubtitleSize");

	Params::RBGameUserPreferences_GetSubtitleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetSubtitlesLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBGameUserPreferences::GetSubtitlesLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetSubtitlesLanguage");

	Params::RBGameUserPreferences_GetSubtitlesLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetTeammateStatusHUDDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetTeammateStatusHUDDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetTeammateStatusHUDDisplay");

	Params::RBGameUserPreferences_GetTeammateStatusHUDDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetTeammateStatusInWorldDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetTeammateStatusInWorldDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetTeammateStatusInWorldDisplay");

	Params::RBGameUserPreferences_GetTeammateStatusInWorldDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetTeammateStatusOutsideViewDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetTeammateStatusOutsideViewDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetTeammateStatusOutsideViewDisplay");

	Params::RBGameUserPreferences_GetTeammateStatusOutsideViewDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetTextLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBGameUserPreferences::GetTextLanguage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetTextLanguage");

	Params::RBGameUserPreferences_GetTextLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetTutorialSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUIFontSize                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIFontSize URBGameUserPreferences::GetTutorialSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetTutorialSize");

	Params::RBGameUserPreferences_GetTutorialSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetUsePushToTalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::GetUsePushToTalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetUsePushToTalk");

	Params::RBGameUserPreferences_GetUsePushToTalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorHangover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetVoiceActivityDetectorHangover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetVoiceActivityDetectorHangover");

	Params::RBGameUserPreferences_GetVoiceActivityDetectorHangover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorNoiseFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetVoiceActivityDetectorNoiseFloor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetVoiceActivityDetectorNoiseFloor");

	Params::RBGameUserPreferences_GetVoiceActivityDetectorNoiseFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetVoiceActivityDetectorSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetVoiceActivityDetectorSensitivity");

	Params::RBGameUserPreferences_GetVoiceActivityDetectorSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.GetVoiceChatOverlayDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBGameUserPreferences::GetVoiceChatOverlayDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "GetVoiceChatOverlayDisplay");

	Params::RBGameUserPreferences_GetVoiceChatOverlayDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsAutoHideItemInHandEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsAutoHideItemInHandEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsAutoHideItemInHandEnabled");

	Params::RBGameUserPreferences_IsAutoHideItemInHandEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsBindingInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BindingName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsBindingInverted(class FName BindingName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsBindingInverted");

	Params::RBGameUserPreferences_IsBindingInverted Parms{};

	Parms.BindingName = BindingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsBlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FProfileId                       ProfileId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsBlocked(const struct FProfileId& ProfileId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsBlocked");

	Params::RBGameUserPreferences_IsBlocked Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsForceFeedbackEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsForceFeedbackEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsForceFeedbackEnabled");

	Params::RBGameUserPreferences_IsForceFeedbackEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsInteractToggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsGamepadOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsInteractToggle(bool bIsGamepadOption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsInteractToggle");

	Params::RBGameUserPreferences_IsInteractToggle Parms{};

	Parms.bIsGamepadOption = bIsGamepadOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsMotionBlurEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsMotionBlurEnabled");

	Params::RBGameUserPreferences_IsMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsRegionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsRegionEnabled(const class FString& Region) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsRegionEnabled");

	Params::RBGameUserPreferences_IsRegionEnabled Parms{};

	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsStickyRunEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsGamepadOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsStickyRunEnabled(bool bIsGamepadOption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsStickyRunEnabled");

	Params::RBGameUserPreferences_IsStickyRunEnabled Parms{};

	Parms.bIsGamepadOption = bIsGamepadOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.IsVoiceActivityDetectorAuto
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::IsVoiceActivityDetectorAuto() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "IsVoiceActivityDetectorAuto");

	Params::RBGameUserPreferences_IsVoiceActivityDetectorAuto Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.ShouldShowHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::ShouldShowHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "ShouldShowHud");

	Params::RBGameUserPreferences_ShouldShowHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGameUserPreferences.ShouldShowSubtitles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBGameUserPreferences::ShouldShowSubtitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGameUserPreferences", "ShouldShowSubtitles");

	Params::RBGameUserPreferences_ShouldShowSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGasTrapComponent.EnabledChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGasTrapComponent::EnabledChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "EnabledChangedCallback");

	Params::RBGasTrapComponent_EnabledChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.OnRep_ScheduledEnabled
// (Final, Native, Private)

void URBGasTrapComponent::OnRep_ScheduledEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "OnRep_ScheduledEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.OnTrapBeginOverlap_Server
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBGasTrapComponent::OnTrapBeginOverlap_Server(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "OnTrapBeginOverlap_Server");

	Params::RBGasTrapComponent_OnTrapBeginOverlap_Server Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.OnTrapEndOverlap_Server
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBGasTrapComponent::OnTrapEndOverlap_Server(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "OnTrapEndOverlap_Server");

	Params::RBGasTrapComponent_OnTrapEndOverlap_Server Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.SnapToState
// (Final, Native, Private, BlueprintCallable)

void URBGasTrapComponent::SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "SnapToState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.TriggerGasTrap_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBGasTrapComponent::TriggerGasTrap_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "TriggerGasTrap_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGasTrapComponent.UntriggerGasTrap_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBGasTrapComponent::UntriggerGasTrap_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGasTrapComponent", "UntriggerGasTrap_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargeInteractObjectiveCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnInteractibleAddedToWorld");

	Params::RBLargeInteractObjectiveCoordinator_OnInteractibleAddedToWorld Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction
// (Native, Protected)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*LargeObjectPanel                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargeInteractObjectiveCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* LargeObjectPanel, class ARBLargePickup* LargePickup, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnLargeObjectInteractionDoAction");

	Params::RBLargeInteractObjectiveCoordinator_OnLargeObjectInteractionDoAction Parms{};

	Parms.LargeObjectPanel = LargeObjectPanel;
	Parms.LargePickup = LargePickup;
	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargeInteractObjectiveCoordinator::OnLargePickupUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnLargePickupUsedOnObject");

	Params::RBLargeInteractObjectiveCoordinator_OnLargePickupUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLargeInteractObjectiveCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnPickupHolderChanged");

	Params::RBLargeInteractObjectiveCoordinator_OnPickupHolderChanged Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups
// (Final, Native, Protected)

void ARBLargeInteractObjectiveCoordinator::OnRep_AvailableLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnRep_AvailableLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_LockingLargePickupsActors
// (Final, Native, Protected)

void ARBLargeInteractObjectiveCoordinator::OnRep_LockingLargePickupsActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "OnRep_LockingLargePickupsActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLargeInteractObjectiveCoordinator.GetAvailableLargePickups
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBLargePickup*>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBLargePickup*> ARBLargeInteractObjectiveCoordinator::GetAvailableLargePickups() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLargeInteractObjectiveCoordinator", "GetAvailableLargePickups");

	Params::RBLargeInteractObjectiveCoordinator_GetAvailableLargePickups Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGeneratorObjectiveCoordinator.OnGeneratorCompletedStateChanged
// (Final, Native, Public)
// Parameters:
// class ARBGeneratorMultiObjectiveActor*  Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBGeneratorObjectiveCoordinator::OnGeneratorCompletedStateChanged(class ARBGeneratorMultiObjectiveActor* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorObjectiveCoordinator", "OnGeneratorCompletedStateChanged");

	Params::RBGeneratorObjectiveCoordinator_OnGeneratorCompletedStateChanged Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorObjectiveCoordinator.OnRep_AllGeneratorRefueled
// (Final, Native, Private)

void ARBGeneratorObjectiveCoordinator::OnRep_AllGeneratorRefueled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorObjectiveCoordinator", "OnRep_AllGeneratorRefueled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBGeneratorObjectiveCoordinator.AreAllGeneratorFueled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBGeneratorObjectiveCoordinator::AreAllGeneratorFueled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGeneratorObjectiveCoordinator", "AreAllGeneratorFueled");

	Params::RBGeneratorObjectiveCoordinator_AreAllGeneratorFueled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBGroupStatusWidget.Event_Refresh
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBGroupStatusWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBGroupStatusWidget.GetEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class URBGroupStatusEntryWidget*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class URBGroupStatusEntryWidget*> URBGroupStatusWidget::GetEntries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBGroupStatusWidget", "GetEntries");

	Params::RBGroupStatusWidget_GetEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHingedSceneComponent.OnComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBHingedSceneComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHingedSceneComponent", "OnComponentBeginOverlap");

	Params::RBHingedSceneComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHingedSceneComponent.OnComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHingedSceneComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHingedSceneComponent", "OnComponentEndOverlap");

	Params::RBHingedSceneComponent_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoSpawner.Event_OnPotatoCompleted
// (Event, Public, BlueprintEvent)

void ARBHotPotatoSpawner::Event_OnPotatoCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "Event_OnPotatoCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHotPotatoSpawner.Event_OnPotatoMoved
// (Event, Public, BlueprintEvent)

void ARBHotPotatoSpawner::Event_OnPotatoMoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "Event_OnPotatoMoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHotPotatoSpawner.Event_OnSpawnedHotPotato
// (Event, Public, BlueprintEvent)

void ARBHotPotatoSpawner::Event_OnSpawnedHotPotato()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "Event_OnSpawnedHotPotato");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHotPotatoSpawner.OnHotPotatoStateChanged
// (Final, Native, Protected)
// Parameters:
// class ARBHotPotato*                     HotPotato                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHotPotatoState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotatoSpawner::OnHotPotatoStateChanged(class ARBHotPotato* HotPotato, EHotPotatoState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "OnHotPotatoStateChanged");

	Params::RBHotPotatoSpawner_OnHotPotatoStateChanged Parms{};

	Parms.HotPotato = HotPotato;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoSpawner.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBHotPotatoSpawner::OnPickupHolderChanged(class ARBPawn* Pawn, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "OnPickupHolderChanged");

	Params::RBHotPotatoSpawner_OnPickupHolderChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoCompleted
// (Final, Native, Protected)

void ARBHotPotatoSpawner::OnRep_HasPotatoCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "OnRep_HasPotatoCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoMoved
// (Final, Native, Protected)

void ARBHotPotatoSpawner::OnRep_HasPotatoMoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "OnRep_HasPotatoMoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHotPotatoSpawner.OnRep_SpawnedHotPotato
// (Final, Native, Protected)

void ARBHotPotatoSpawner::OnRep_SpawnedHotPotato()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHotPotatoSpawner", "OnRep_SpawnedHotPotato");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDHealthBar.SetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDHealthBar::SetPlayer(class ARBPlayer* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDHealthBar", "SetPlayer");

	Params::RBHUDHealthBar_SetPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDInventoryItemEntry.DisplaySwap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldShow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDInventoryItemEntry::DisplaySwap(bool bShouldShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDInventoryItemEntry", "DisplaySwap");

	Params::RBHUDInventoryItemEntry_DisplaySwap Parms{};

	Parms.bShouldShow = bShouldShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDInventoryItemEntry.SetEquippedItem
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDInventoryItemEntry::SetEquippedItem(bool bEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDInventoryItemEntry", "SetEquippedItem");

	Params::RBHUDInventoryItemEntry_SetEquippedItem Parms{};

	Parms.bEquipped = bEquipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDObjectiveInWorld.GetStalkerCompletingTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URBHUDObjectiveInWorld::GetStalkerCompletingTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDObjectiveInWorld", "GetStalkerCompletingTargets");

	Params::RBHUDObjectiveInWorld_GetStalkerCompletingTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDObjectiveInWorld.UpdateIconImage
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBHUDObjectiveInWorld::UpdateIconImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDObjectiveInWorld", "UpdateIconImage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDObjectiveInWorld.IsOwningActorPinged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBHUDObjectiveInWorld::IsOwningActorPinged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDObjectiveInWorld", "IsOwningActorPinged");

	Params::RBHUDObjectiveInWorld_IsOwningActorPinged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBHUDPlayerInfo.OnBatteryLevelChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewBatteryLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnBatteryLevelChanged(float NewBatteryLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnBatteryLevelChanged");

	Params::RBHUDPlayerInfo_OnBatteryLevelChanged Parms{};

	Parms.NewBatteryLevel = NewBatteryLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnHealthUpdated
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncreased                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnHealthUpdated(float NewHealth, bool bIncreased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnHealthUpdated");

	Params::RBHUDPlayerInfo_OnHealthUpdated Parms{};

	Parms.NewHealth = NewHealth;
	Parms.bIncreased = bIncreased;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnMaxBatteryChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnMaxBatteryChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnMaxBatteryChanged");

	Params::RBHUDPlayerInfo_OnMaxBatteryChanged Parms{};

	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnMaxHealthChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnMaxHealthChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnMaxHealthChanged");

	Params::RBHUDPlayerInfo_OnMaxHealthChanged Parms{};

	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnMaxStaminaChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnMaxStaminaChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnMaxStaminaChanged");

	Params::RBHUDPlayerInfo_OnMaxStaminaChanged Parms{};

	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnPlayerStatusChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerIndicatorType                    PlayerIndicatorType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnPlayerStatusChanged(EPlayerIndicatorType PlayerIndicatorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnPlayerStatusChanged");

	Params::RBHUDPlayerInfo_OnPlayerStatusChanged Parms{};

	Parms.PlayerIndicatorType = PlayerIndicatorType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnPsychosisChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewPsychosis                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldPsychosis                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnPsychosisChanged(int32 NewPsychosis, int32 OldPsychosis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnPsychosisChanged");

	Params::RBHUDPlayerInfo_OnPsychosisChanged Parms{};

	Parms.NewPsychosis = NewPsychosis;
	Parms.OldPsychosis = OldPsychosis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnStaminaChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewStamina                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsExhausted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnStaminaChanged(float NewStamina, bool bIsExhausted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnStaminaChanged");

	Params::RBHUDPlayerInfo_OnStaminaChanged Parms{};

	Parms.NewStamina = NewStamina;
	Parms.bIsExhausted = bIsExhausted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.OnWatchedPlayerChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        OldPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::OnWatchedPlayerChanged(class ARBPlayer* OldPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "OnWatchedPlayerChanged");

	Params::RBHUDPlayerInfo_OnWatchedPlayerChanged Parms{};

	Parms.OldPlayer = OldPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDPlayerInfo.SetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDPlayerInfo::SetPlayer(class ARBPlayer* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDPlayerInfo", "SetPlayer");

	Params::RBHUDPlayerInfo_SetPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDStaminaBar.SetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayer*                        NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDStaminaBar::SetPlayer(class ARBPlayer* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDStaminaBar", "SetPlayer");

	Params::RBHUDStaminaBar_SetPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBHUDWidget.BP_ClearAllObjectives
// (Event, Public, BlueprintEvent)

void URBHUDWidget::BP_ClearAllObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "BP_ClearAllObjectives");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_ForceUpdateSwapIcons
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_ForceUpdateSwapIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ForceUpdateSwapIcons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_HideBadgeProgress
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_HideBadgeProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_HideBadgeProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_HideInteractionMessage
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_HideInteractionMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_HideInteractionMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_HideInventoryWheel
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_HideInventoryWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_HideInventoryWheel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_HideTalkWheel
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_HideTalkWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_HideTalkWheel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_HideTaskProgress
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_HideTaskProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_HideTaskProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_OnHudModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHudMode                                NewHudMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_OnHudModeChanged(EHudMode NewHudMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_OnHudModeChanged");

	Params::RBHUDWidget_Event_OnHudModeChanged Parms{};

	Parms.NewHudMode = NewHudMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_OnHUDOpacityChanged
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_OnHUDOpacityChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_OnHUDOpacityChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_OnPlayAsPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_OnPlayAsPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_OnPlayAsPlayer");

	Params::RBHUDWidget_Event_OnPlayAsPlayer Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_OnResetHud
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_OnResetHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_OnResetHud");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_OnSpectateNewPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_OnSpectateNewPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_OnSpectateNewPlayer");

	Params::RBHUDWidget_Event_OnSpectateNewPlayer Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_ShowBadgeProgress
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRBBadgeHudProgressDisplayDetailsProgress                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_ShowBadgeProgress(const struct FRBBadgeHudProgressDisplayDetails& Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowBadgeProgress");

	Params::RBHUDWidget_Event_ShowBadgeProgress Parms{};

	Parms.Progress = std::move(Progress);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_ShowInteractionMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGameMessageCategory                    GameMessageCategory                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_ShowInteractionMessage(const class FText& Message, const EGameMessageCategory GameMessageCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowInteractionMessage");

	Params::RBHUDWidget_Event_ShowInteractionMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.GameMessageCategory = GameMessageCategory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_ShowInventoryWheel
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_ShowInventoryWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowInventoryWheel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_ShowObjectiveIntroMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ObjectiveText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_ShowObjectiveIntroMessage(const class FText& ObjectiveText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowObjectiveIntroMessage");

	Params::RBHUDWidget_Event_ShowObjectiveIntroMessage Parms{};

	Parms.ObjectiveText = std::move(ObjectiveText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_ShowTalkWheel
// (Event, Public, BlueprintEvent)

void URBHUDWidget::Event_ShowTalkWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowTalkWheel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBHUDWidget.Event_ShowTaskProgress
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRBTaskHudProgressDisplayDetails Progress                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_ShowTaskProgress(const struct FRBTaskHudProgressDisplayDetails& Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_ShowTaskProgress");

	Params::RBHUDWidget_Event_ShowTaskProgress Parms{};

	Parms.Progress = std::move(Progress);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBHUDWidget.Event_StartTransitionFeedback
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   blackoutDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBHUDWidget::Event_StartTransitionFeedback(float blackoutDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBHUDWidget", "Event_StartTransitionFeedback");

	Params::RBHUDWidget_Event_StartTransitionFeedback Parms{};

	Parms.blackoutDuration = blackoutDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBImposter.Event_SetCustomization
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRBPlayerCustomizationInfo       NewCustomization                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBImposter::Event_SetCustomization(const struct FRBPlayerCustomizationInfo& NewCustomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBImposter", "Event_SetCustomization");

	Params::RBImposter_Event_SetCustomization Parms{};

	Parms.NewCustomization = std::move(NewCustomization);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBImposter.OnRep_CustomizationInfo
// (Final, Native, Public)

void ARBImposter::OnRep_CustomizationInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBImposter", "OnRep_CustomizationInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBImposter.OnRep_OverheadDetails
// (Final, Native, Public)

void ARBImposter::OnRep_OverheadDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBImposter", "OnRep_OverheadDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBImposter.BP_GetCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBPlayerCustomizationInfo ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerCustomizationInfo ARBImposter::BP_GetCustomizationInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBImposter", "BP_GetCustomizationInfo");

	Params::RBImposter_BP_GetCustomizationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInputIcon.ForceRefreshIcon
// (Event, Public, BlueprintEvent)

void URBInputIcon::ForceRefreshIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInputIcon", "ForceRefreshIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelActiveChangedEvent
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractivePanelObjectiveCoordinator::OnPanelActiveChangedEvent(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractivePanelObjectiveCoordinator", "OnPanelActiveChangedEvent");

	Params::RBInteractivePanelObjectiveCoordinator_OnPanelActiveChangedEvent Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBInteractivePanelObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInteractivePanelObjectiveCoordinator", "OnPanelPawnInteractingChangedEvent");

	Params::RBInteractivePanelObjectiveCoordinator_OnPanelPawnInteractingChangedEvent Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.BP_UseInventoryItemPredicted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPickup*                        Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          InteractorPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBInventoryItemInteractionPanelComponent::BP_UseInventoryItemPredicted(class ARBPickup* Pickup, class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "BP_UseInventoryItemPredicted");

	Params::RBInventoryItemInteractionPanelComponent_BP_UseInventoryItemPredicted Parms{};

	Parms.Pickup = Pickup;
	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.GetItemFromPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPawn*                          InteractorPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* URBInventoryItemInteractionPanelComponent::GetItemFromPlayer(class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "GetItemFromPlayer");

	Params::RBInventoryItemInteractionPanelComponent_GetItemFromPlayer Parms{};

	Parms.InteractorPawn = InteractorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsRequired
// (Final, Native, Public)

void URBInventoryItemInteractionPanelComponent::OnRep_NumberOfItemsRequired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "OnRep_NumberOfItemsRequired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsUsed
// (Final, Native, Public)

void URBInventoryItemInteractionPanelComponent::OnRep_NumberOfItemsUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "OnRep_NumberOfItemsUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_OverrideItemClass
// (Final, Native, Public)

void URBInventoryItemInteractionPanelComponent::OnRep_OverrideItemClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "OnRep_OverrideItemClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBInventoryItemInteractionPanelComponent.GetItemDropRef
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* URBInventoryItemInteractionPanelComponent::GetItemDropRef(class ARBPickup* Pickup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBInventoryItemInteractionPanelComponent", "GetItemDropRef");

	Params::RBInventoryItemInteractionPanelComponent_GetItemDropRef Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBJumpScareTriggerable.CanTriggerScareJump
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBJumpScareTriggerable::CanTriggerScareJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "CanTriggerScareJump");

	Params::RBJumpScareTriggerable_CanTriggerScareJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBJumpScareTriggerable.InitializeLinkedRoom
// (Final, Native, Public)
// Parameters:
// class URBRoomAssociationComponent*      RoomAssociationComponent                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBRoom*                          PreviousRoom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBRoom*                          NextRoom                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBJumpScareTriggerable::InitializeLinkedRoom(class URBRoomAssociationComponent* RoomAssociationComponent, class ARBRoom* PreviousRoom, class ARBRoom* NextRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "InitializeLinkedRoom");

	Params::RBJumpScareTriggerable_InitializeLinkedRoom Parms{};

	Parms.RoomAssociationComponent = RoomAssociationComponent;
	Parms.PreviousRoom = PreviousRoom;
	Parms.NextRoom = NextRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBJumpScareTriggerable.Multicast_SetIgnoreStinger
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBJumpScareTriggerable::Multicast_SetIgnoreStinger(bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "Multicast_SetIgnoreStinger");

	Params::RBJumpScareTriggerable_Multicast_SetIgnoreStinger Parms{};

	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBJumpScareTriggerable.OnRoomEntered
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBJumpScareTriggerable::OnRoomEntered(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "OnRoomEntered");

	Params::RBJumpScareTriggerable_OnRoomEntered Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBJumpScareTriggerable.OnTriggerBoxOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBJumpScareTriggerable::OnTriggerBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "OnTriggerBoxOverlap");

	Params::RBJumpScareTriggerable_OnTriggerBoxOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBJumpScareTriggerable.TryTriggerScareStinger
// (Final, Native, Public, BlueprintCallable)

void ARBJumpScareTriggerable::TryTriggerScareStinger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "TryTriggerScareStinger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBJumpScareTriggerable.GetScareStingerLocation
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBJumpScareTriggerable::GetScareStingerLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBJumpScareTriggerable", "GetScareStingerLocation");

	Params::RBJumpScareTriggerable_GetScareStingerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBKeyLockedRoomDevice.GetLinkedRollingGate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBTriggerableGate*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBTriggerableGate* IRBKeyLockedRoomDevice::GetLinkedRollingGate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomDevice", "GetLinkedRollingGate");

	Params::RBKeyLockedRoomDevice_GetLinkedRollingGate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBKeyLockedRoomDevice.SetLinkedRollingGate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBTriggerableGate*               RollingGate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBKeyLockedRoomDevice::SetLinkedRollingGate(class ARBTriggerableGate* RollingGate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBKeyLockedRoomDevice", "SetLinkedRollingGate");

	Params::RBKeyLockedRoomDevice_SetLinkedRollingGate Parms{};

	Parms.RollingGate = RollingGate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.BP_SetLightColor
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewColor                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLight::BP_SetLightColor(const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "BP_SetLightColor");

	Params::RBLight_BP_SetLightColor Parms{};

	Parms.NewColor = std::move(NewColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.GetOldLightValues
// (Final, Native, Public)

void ARBLight::GetOldLightValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "GetOldLightValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.OnBPConstruction
// (Native, Event, Public, BlueprintEvent)

void ARBLight::OnBPConstruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "OnBPConstruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.OnLightMode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NewLightMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLight::OnLightMode(int32 NewLightMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "OnLightMode");

	Params::RBLight_OnLightMode Parms{};

	Parms.NewLightMode = NewLightMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.OnRep_AnimationCurveData
// (Final, Native, Public)

void ARBLight::OnRep_AnimationCurveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "OnRep_AnimationCurveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.OnRep_Color
// (Final, Native, Public)

void ARBLight::OnRep_Color()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "OnRep_Color");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.OnRep_LightMode
// (Final, Native, Public)

void ARBLight::OnRep_LightMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "OnRep_LightMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.PlayAnimationCurve
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      NewAnimCurve                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Looping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLight::PlayAnimationCurve(class UCurveFloat* NewAnimCurve, bool Looping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "PlayAnimationCurve");

	Params::RBLight_PlayAnimationCurve Parms{};

	Parms.NewAnimCurve = NewAnimCurve;
	Parms.Looping = Looping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.UpdateAffectsWorld
// (Final, Native, Public)

void ARBLight::UpdateAffectsWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "UpdateAffectsWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLight.UpdateColors
// (Final, Native, Public)

void ARBLight::UpdateColors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLight", "UpdateColors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLoadingScreenWidget.BP_OnLoadingScreenOutroCompleted
// (Final, Native, Public, BlueprintCallable)

void URBLoadingScreenWidget::BP_OnLoadingScreenOutroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLoadingScreenWidget", "BP_OnLoadingScreenOutroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLoadingScreenWidget.Event_StartLoadingScreen
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    SkipIntro                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLoadingScreenWidget::Event_StartLoadingScreen(bool SkipIntro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLoadingScreenWidget", "Event_StartLoadingScreen");

	Params::RBLoadingScreenWidget_Event_StartLoadingScreen Parms{};

	Parms.SkipIntro = SkipIntro;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLoadingScreenWidget.Event_StopLoadingScreen
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    SkipOutro                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLoadingScreenWidget::Event_StopLoadingScreen(bool SkipOutro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLoadingScreenWidget", "Event_StopLoadingScreen");

	Params::RBLoadingScreenWidget_Event_StopLoadingScreen Parms{};

	Parms.SkipOutro = SkipOutro;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerState.Multicast_ClearGainedCurrencies
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayerState::Multicast_ClearGainedCurrencies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "Multicast_ClearGainedCurrencies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.Multicast_NotifyRemainingRespawnChanged
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::Multicast_NotifyRemainingRespawnChanged(int32 OldValue, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "Multicast_NotifyRemainingRespawnChanged");

	Params::RBPlayerState_Multicast_NotifyRemainingRespawnChanged Parms{};

	Parms.OldValue = OldValue;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBPlayerState.OnAcquiredItemsChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnAcquiredItemsChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnAcquiredItemsChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnActiveSkillActorInitialized__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnActiveSkillActorInitialized__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnActiveSkillActorInitialized__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnCurrenciesChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnCurrenciesChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnCurrenciesChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnCurrencyGained__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnCurrencyGained__DelegateSignature(ECurrencyType CurrencyType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnCurrencyGained__DelegateSignature");

	Params::RBPlayerState_OnCurrencyGained__DelegateSignature Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnCurrentLoadoutChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnCurrentLoadoutChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnCurrentLoadoutChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnDamagePlayer__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FDamageInfo                      DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDamageResult                    DamageResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayerState::OnDamagePlayer__DelegateSignature(const struct FDamageInfo& DamageInfo, const struct FDamageResult& DamageResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnDamagePlayer__DelegateSignature");

	Params::RBPlayerState_OnDamagePlayer__DelegateSignature Parms{};

	Parms.DamageInfo = std::move(DamageInfo);
	Parms.DamageResult = std::move(DamageResult);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnEnteredHidespot__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class URBHidespotComponent*             HidespotComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnEnteredHidespot__DelegateSignature(class URBHidespotComponent* HidespotComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnEnteredHidespot__DelegateSignature");

	Params::RBPlayerState_OnEnteredHidespot__DelegateSignature Parms{};

	Parms.HidespotComponent = HidespotComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerState.OnFeatureSwitchOverridesUpdated
// (Final, Native, Private)

void ARBPlayerState::OnFeatureSwitchOverridesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnFeatureSwitchOverridesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBPlayerState.OnInventoryUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnInventoryUpdated__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnInventoryUpdated__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnIsDeadChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsDead                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnIsDeadChanged__DelegateSignature(bool IsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnIsDeadChanged__DelegateSignature");

	Params::RBPlayerState_OnIsDeadChanged__DelegateSignature Parms{};

	Parms.IsDead = IsDead;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnIsSpectatorChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsSpectator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnIsSpectatorChanged__DelegateSignature(bool IsSpectator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnIsSpectatorChanged__DelegateSignature");

	Params::RBPlayerState_OnIsSpectatorChanged__DelegateSignature Parms{};

	Parms.IsSpectator = IsSpectator;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnItemAcquired__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnItemAcquired__DelegateSignature(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnItemAcquired__DelegateSignature");

	Params::RBPlayerState_OnItemAcquired__DelegateSignature Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerCustomizationUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FRBPlayerCustomizationInfo       Param_CustomizationInfo                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerCustomizationUpdated__DelegateSignature(const struct FRBPlayerCustomizationInfo& Param_CustomizationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerCustomizationUpdated__DelegateSignature");

	Params::RBPlayerState_OnPlayerCustomizationUpdated__DelegateSignature Parms{};

	Parms.Param_CustomizationInfo = std::move(Param_CustomizationInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerEvent__DelegateSignature(EPlayerEvent EventType, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerEvent__DelegateSignature");

	Params::RBPlayerState_OnPlayerEvent__DelegateSignature Parms{};

	Parms.EventType = EventType;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerHealthChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerHealthChanged__DelegateSignature(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerHealthChanged__DelegateSignature");

	Params::RBPlayerState_OnPlayerHealthChanged__DelegateSignature Parms{};

	Parms.NewHealth = NewHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerIndicatorUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPlayerIndicatorType                    Param_PlayerIndicatorType                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerIndicatorUpdated__DelegateSignature(EPlayerIndicatorType Param_PlayerIndicatorType, float TimeLeft, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerIndicatorUpdated__DelegateSignature");

	Params::RBPlayerState_OnPlayerIndicatorUpdated__DelegateSignature Parms{};

	Parms.Param_PlayerIndicatorType = Param_PlayerIndicatorType;
	Parms.TimeLeft = TimeLeft;
	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerLevelChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnPlayerLevelChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerLevelChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerMaxHealthChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   NewMaxHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerMaxHealthChanged__DelegateSignature(float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerMaxHealthChanged__DelegateSignature");

	Params::RBPlayerState_OnPlayerMaxHealthChanged__DelegateSignature Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerPartyStateUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerPartyStateUpdated__DelegateSignature(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerPartyStateUpdated__DelegateSignature");

	Params::RBPlayerState_OnPlayerPartyStateUpdated__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerProgressionReceived__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerProgressionReceived__DelegateSignature(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerProgressionReceived__DelegateSignature");

	Params::RBPlayerState_OnPlayerProgressionReceived__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerSASChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBSAS*                           Param_CurrentSAS                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerSASChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, class ARBSAS* Param_CurrentSAS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerSASChanged__DelegateSignature");

	Params::RBPlayerState_OnPlayerSASChanged__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.Param_CurrentSAS = Param_CurrentSAS;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerScoreChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Score                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_ScoreXp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnPlayerScoreChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, int32 Param_Score, int32 Param_ScoreXp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerScoreChanged__DelegateSignature");

	Params::RBPlayerState_OnPlayerScoreChanged__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.Param_Score = Param_Score;
	Parms.Param_ScoreXp = Param_ScoreXp;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerUpgradesChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnPlayerUpgradesChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerUpgradesChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnPlayerXpChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnPlayerXpChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnPlayerXpChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnProjectilePawnHit__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ARBProjectile*                    RBProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          RBPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnProjectilePawnHit__DelegateSignature(class ARBProjectile* RBProjectile, class ARBPawn* RBPawn, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnProjectilePawnHit__DelegateSignature");

	Params::RBPlayerState_OnProjectilePawnHit__DelegateSignature Parms{};

	Parms.RBProjectile = RBProjectile;
	Parms.RBPawn = RBPawn;
	Parms.HitLocation = std::move(HitLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnReadyForStageResetChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnReadyForStageResetChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnReadyForStageResetChanged__DelegateSignature");

	Params::RBPlayerState_OnReadyForStageResetChanged__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.IsReady = IsReady;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnRemainingLivesChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnRemainingLivesChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRemainingLivesChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayerState.OnRep_AcquiredCharacterItems
// (Final, Native, Private)

void ARBPlayerState::OnRep_AcquiredCharacterItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_AcquiredCharacterItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_AcquiredProfileItems
// (Final, Native, Private)

void ARBPlayerState::OnRep_AcquiredProfileItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_AcquiredProfileItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_AcquiredTrialChainingItems
// (Final, Native, Private)

void ARBPlayerState::OnRep_AcquiredTrialChainingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_AcquiredTrialChainingItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_ChainingUpgradePoints
// (Final, Native, Private)

void ARBPlayerState::OnRep_ChainingUpgradePoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_ChainingUpgradePoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_CurrencyEntries
// (Final, Native, Private)

void ARBPlayerState::OnRep_CurrencyEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_CurrencyEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_CurrentLoadout
// (Final, Native, Private)

void ARBPlayerState::OnRep_CurrentLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_CurrentLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_CurrentSAS
// (Final, Native, Public)

void ARBPlayerState::OnRep_CurrentSAS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_CurrentSAS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_CustomizationInfo
// (Final, Native, Private)

void ARBPlayerState::OnRep_CustomizationInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_CustomizationInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_HasBeenReplicated
// (Final, Native, Public)

void ARBPlayerState::OnRep_HasBeenReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_HasBeenReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_HasVoiceChatPrivilege
// (Final, Native, Private)

void ARBPlayerState::OnRep_HasVoiceChatPrivilege()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_HasVoiceChatPrivilege");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_InmateId
// (Final, Native, Private)

void ARBPlayerState::OnRep_InmateId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_InmateId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_IsDead
// (Final, Native, Public)

void ARBPlayerState::OnRep_IsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_IsDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_IsInMenu
// (Final, Native, Public)

void ARBPlayerState::OnRep_IsInMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_IsInMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_IsOnlineInitialized
// (Final, Native, Public)

void ARBPlayerState::OnRep_IsOnlineInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_IsOnlineInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_LastPossessedPlayer
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        OldLastPossessedPlayer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnRep_LastPossessedPlayer(class ARBPlayer* OldLastPossessedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_LastPossessedPlayer");

	Params::RBPlayerState_OnRep_LastPossessedPlayer Parms{};

	Parms.OldLastPossessedPlayer = OldLastPossessedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_LeaveTarget
// (Final, Native, Private)

void ARBPlayerState::OnRep_LeaveTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_LeaveTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_PartyState
// (Final, Native, Private)

void ARBPlayerState::OnRep_PartyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_PartyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_Platform
// (Final, Native, Protected)

void ARBPlayerState::OnRep_Platform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_Platform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_PlayerLevel
// (Final, Native, Private)
// Parameters:
// int32                                   OldPlayerLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnRep_PlayerLevel(int32 OldPlayerLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_PlayerLevel");

	Params::RBPlayerState_OnRep_PlayerLevel Parms{};

	Parms.OldPlayerLevel = OldPlayerLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_ReadyForStageReset
// (Final, Native, Private)

void ARBPlayerState::OnRep_ReadyForStageReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_ReadyForStageReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_ReleaseCount
// (Final, Native, Private)

void ARBPlayerState::OnRep_ReleaseCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_ReleaseCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_RemainingRespawns
// (Final, Native, Public)
// Parameters:
// int32                                   PreviousRemainingRespawns                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnRep_RemainingRespawns(int32 PreviousRemainingRespawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_RemainingRespawns");

	Params::RBPlayerState_OnRep_RemainingRespawns Parms{};

	Parms.PreviousRemainingRespawns = PreviousRemainingRespawns;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_RemainingSelfRevives
// (Final, Native, Public)
// Parameters:
// int32                                   PreviousRemainingSelfRevives                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnRep_RemainingSelfRevives(int32 PreviousRemainingSelfRevives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_RemainingSelfRevives");

	Params::RBPlayerState_OnRep_RemainingSelfRevives Parms{};

	Parms.PreviousRemainingSelfRevives = PreviousRemainingSelfRevives;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_Score
// (Final, Native, Private)

void ARBPlayerState::OnRep_Score()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_Score");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_Spectator
// (Final, Native, Public)

void ARBPlayerState::OnRep_Spectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_Spectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_TaskProgressionEntries
// (Final, Native, Private)

void ARBPlayerState::OnRep_TaskProgressionEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_TaskProgressionEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_UpgradeEffects
// (Final, Native, Private)

void ARBPlayerState::OnRep_UpgradeEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_UpgradeEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_VoiceChatEnabled
// (Final, Native, Public)

void ARBPlayerState::OnRep_VoiceChatEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_VoiceChatEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.OnRep_Xp
// (Final, Native, Private)

void ARBPlayerState::OnRep_Xp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnRep_Xp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBPlayerState.OnTaskCompleted__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnTaskCompleted__DelegateSignature(const class FName& TaskId, int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnTaskCompleted__DelegateSignature");

	Params::RBPlayerState_OnTaskCompleted__DelegateSignature Parms{};

	Parms.TaskId = TaskId;
	Parms.Seed = Seed;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnTaskProgressionEntriesChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnTaskProgressionEntriesChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnTaskProgressionEntriesChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnUnlockedItemsChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ARBPlayerState::OnUnlockedItemsChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnUnlockedItemsChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OPP.RBPlayerState.OnVoiceChatEnabledChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnVoiceChatEnabledChanged__DelegateSignature(class ARBPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnVoiceChatEnabledChanged__DelegateSignature");

	Params::RBPlayerState_OnVoiceChatEnabledChanged__DelegateSignature Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OPP.RBPlayerState.OnVoiceChatPrivilegeStatusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerState::OnVoiceChatPrivilegeStatusChanged__DelegateSignature(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "OnVoiceChatPrivilegeStatusChanged__DelegateSignature");

	Params::RBPlayerState_OnVoiceChatPrivilegeStatusChanged__DelegateSignature Parms{};

	Parms.RBPlayerState = RBPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerState.Server_OnPlayerReplicated
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBPlayerState::Server_OnPlayerReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "Server_OnPlayerReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.Server_SetClientPopulateStarted
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBPlayerState::Server_SetClientPopulateStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "Server_SetClientPopulateStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerState.AreItemsAcquired
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ItemIds                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::AreItemsAcquired(const TArray<class FName>& ItemIds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "AreItemsAcquired");

	Params::RBPlayerState_AreItemsAcquired Parms{};

	Parms.ItemIds = std::move(ItemIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.BP_GetUniqueID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl ARBPlayerState::BP_GetUniqueID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "BP_GetUniqueID");

	Params::RBPlayerState_BP_GetUniqueID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.BP_HasAcquiredActiveSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::BP_HasAcquiredActiveSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "BP_HasAcquiredActiveSkill");

	Params::RBPlayerState_BP_HasAcquiredActiveSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.BP_IsUpgradeAcquired
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             UpgradeID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::BP_IsUpgradeAcquired(const class FName& UpgradeID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "BP_IsUpgradeAcquired");

	Params::RBPlayerState_BP_IsUpgradeAcquired Parms{};

	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCharacterStartingReleaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetCharacterStartingReleaseCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCharacterStartingReleaseCount");

	Params::RBPlayerState_GetCharacterStartingReleaseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetCurrency(ECurrencyType CurrencyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCurrency");

	Params::RBPlayerState_GetCurrency Parms{};

	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBPlayerCustomizationInfo ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerCustomizationInfo ARBPlayerState::GetCustomizationInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCustomizationInfo");

	Params::RBPlayerState_GetCustomizationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCustomizationLegendaryOutfit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBCustomizationOutfit*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCustomizationOutfit* ARBPlayerState::GetCustomizationLegendaryOutfit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCustomizationLegendaryOutfit");

	Params::RBPlayerState_GetCustomizationLegendaryOutfit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCustomizationOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class URBPlayerCustomizationOption*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class URBPlayerCustomizationOption*> ARBPlayerState::GetCustomizationOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCustomizationOptions");

	Params::RBPlayerState_GetCustomizationOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetCustomizationOptionsBySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* ARBPlayerState::GetCustomizationOptionsBySlot(EPlayerCustomizationSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetCustomizationOptionsBySlot");

	Params::RBPlayerState_GetCustomizationOptionsBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetExperimentTimePlayedSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetExperimentTimePlayedSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetExperimentTimePlayedSeconds");

	Params::RBPlayerState_GetExperimentTimePlayedSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetFullPlayerId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBPlayerState::GetFullPlayerId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetFullPlayerId");

	Params::RBPlayerState_GetFullPlayerId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetGainedCurrencies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<ECurrencyType, int32>        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<ECurrencyType, int32> ARBPlayerState::GetGainedCurrencies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetGainedCurrencies");

	Params::RBPlayerState_GetGainedCurrencies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetInmateId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetInmateId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetInmateId");

	Params::RBPlayerState_GetInmateId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetLeaveTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerLeaveTarget                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerLeaveTarget ARBPlayerState::GetLeaveTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetLeaveTarget");

	Params::RBPlayerState_GetLeaveTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetNormalizedScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayerState::GetNormalizedScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetNormalizedScore");

	Params::RBPlayerState_GetNormalizedScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPartyId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBPlayerState::GetPartyId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPartyId");

	Params::RBPlayerState_GetPartyId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPartyMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetPartyMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPartyMemberCount");

	Params::RBPlayerState_GetPartyMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfilePlatform                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfilePlatform ARBPlayerState::GetPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPlatform");

	Params::RBPlayerState_GetPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPlatformId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBPlayerState::GetPlatformId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPlatformId");

	Params::RBPlayerState_GetPlatformId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPlayerIconCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBPlayerIconCustomizationOption* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerIconCustomizationOption* ARBPlayerState::GetPlayerIconCustomizationOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPlayerIconCustomizationOption");

	Params::RBPlayerState_GetPlayerIconCustomizationOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetPlayerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPlayerLevel");

	Params::RBPlayerState_GetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetPlayerLoadout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBPlayerLoadout           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerLoadout ARBPlayerState::GetPlayerLoadout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetPlayerLoadout");

	Params::RBPlayerState_GetPlayerLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetProfileId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FProfileId                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FProfileId ARBPlayerState::GetProfileId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetProfileId");

	Params::RBPlayerState_GetProfileId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetReleaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetReleaseCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetReleaseCount");

	Params::RBPlayerState_GetReleaseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetSelectedActiveSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActiveSkillType ARBPlayerState::GetSelectedActiveSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetSelectedActiveSkill");

	Params::RBPlayerState_GetSelectedActiveSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetSkinColorType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESkinColorType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESkinColorType ARBPlayerState::GetSkinColorType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetSkinColorType");

	Params::RBPlayerState_GetSkinColorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeam ARBPlayerState::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetTeam");

	Params::RBPlayerState_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetTrialChainingAvailableEquippedRigUpgrade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARBPlayerState::GetTrialChainingAvailableEquippedRigUpgrade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetTrialChainingAvailableEquippedRigUpgrade");

	Params::RBPlayerState_GetTrialChainingAvailableEquippedRigUpgrade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetTrialChainingUpgradeChoice
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrialChainingUpgradeChoiceData  OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::GetTrialChainingUpgradeChoice(const class FName& ItemId, struct FTrialChainingUpgradeChoiceData* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetTrialChainingUpgradeChoice");

	Params::RBPlayerState_GetTrialChainingUpgradeChoice Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetTrialChainingUpgradeChoices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FTrialChainingUpgradeChoiceData>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FTrialChainingUpgradeChoiceData> ARBPlayerState::GetTrialChainingUpgradeChoices() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetTrialChainingUpgradeChoices");

	Params::RBPlayerState_GetTrialChainingUpgradeChoices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetUnlockedPerkSlots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPerkCategory                           PerkCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetUnlockedPerkSlots(EPerkCategory PerkCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetUnlockedPerkSlots");

	Params::RBPlayerState_GetUnlockedPerkSlots Parms{};

	Parms.PerkCategory = PerkCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetVoiceCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBVoiceCustomizationOption*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBVoiceCustomizationOption* ARBPlayerState::GetVoiceCustomizationOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetVoiceCustomizationOption");

	Params::RBPlayerState_GetVoiceCustomizationOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.GetXp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayerState::GetXp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "GetXp");

	Params::RBPlayerState_GetXp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.HasAttemptedTrial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::HasAttemptedTrial(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "HasAttemptedTrial");

	Params::RBPlayerState_HasAttemptedTrial Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.HasCompletedTrial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPerfect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::HasCompletedTrial(const class FName& ID, bool bPerfect) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "HasCompletedTrial");

	Params::RBPlayerState_HasCompletedTrial Parms{};

	Parms.ID = ID;
	Parms.bPerfect = bPerfect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.HasUpgradeEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::HasUpgradeEffect(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "HasUpgradeEffect");

	Params::RBPlayerState_HasUpgradeEffect Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.IsFemale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::IsFemale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "IsFemale");

	Params::RBPlayerState_IsFemale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.IsItemAcquired
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::IsItemAcquired(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "IsItemAcquired");

	Params::RBPlayerState_IsItemAcquired Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.IsLeaving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::IsLeaving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "IsLeaving");

	Params::RBPlayerState_IsLeaving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerState.IsPartyJoinable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerState::IsPartyJoinable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerState", "IsPartyJoinable");

	Params::RBPlayerState_IsPartyJoinable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetPlayerCell
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBPlayerCell*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerCell* ARBLobbyPlayerState::GetPlayerCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetPlayerCell");

	Params::RBLobbyPlayerState_GetPlayerCell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OPP.RBLobbyPlayerState.OnMatchSettingsUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchSettings                   Param_MatchSettings                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBLobbyPlayerState::OnMatchSettingsUpdated__DelegateSignature(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& Param_MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnMatchSettingsUpdated__DelegateSignature");

	Params::RBLobbyPlayerState_OnMatchSettingsUpdated__DelegateSignature Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.Param_MatchSettings = std::move(Param_MatchSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLobbyPlayerState.OnRep_EvalCorridor
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_EvalCorridor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_EvalCorridor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_FindPartyState
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_FindPartyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_FindPartyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_MatchSettings
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_MatchSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_MatchSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_MatchState
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_MatchState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_MatchState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_PlayerCell
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_PlayerCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_PlayerCell");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_PlayerCellCustomization
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_PlayerCellCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_PlayerCellCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.OnRep_PlayerReleaseAvailableServerTime
// (Final, Native, Private)

void ARBLobbyPlayerState::OnRep_PlayerReleaseAvailableServerTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "OnRep_PlayerReleaseAvailableServerTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.SetAllReadyToTravelToMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllReadyToTravelToMatch                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerState::SetAllReadyToTravelToMatch(bool bInAllReadyToTravelToMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "SetAllReadyToTravelToMatch");

	Params::RBLobbyPlayerState_SetAllReadyToTravelToMatch Parms{};

	Parms.bInAllReadyToTravelToMatch = bInAllReadyToTravelToMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.SetLeavingForMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInLeavingForMatch                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerState::SetLeavingForMatch(bool bInLeavingForMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "SetLeavingForMatch");

	Params::RBLobbyPlayerState_SetLeavingForMatch Parms{};

	Parms.bInLeavingForMatch = bInLeavingForMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.SetReadyToTravelToMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReadyToTravelToMatch                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLobbyPlayerState::SetReadyToTravelToMatch(bool bInReadyToTravelToMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "SetReadyToTravelToMatch");

	Params::RBLobbyPlayerState_SetReadyToTravelToMatch Parms{};

	Parms.bInReadyToTravelToMatch = bInReadyToTravelToMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLobbyPlayerState.CanFindPartyBeCanceled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::CanFindPartyBeCanceled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "CanFindPartyBeCanceled");

	Params::RBLobbyPlayerState_CanFindPartyBeCanceled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetEvalCorridor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBEvalCorridor*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBEvalCorridor* ARBLobbyPlayerState::GetEvalCorridor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetEvalCorridor");

	Params::RBLobbyPlayerState_GetEvalCorridor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetFindPartyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBLobbyPlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLobbyPlayerState* ARBLobbyPlayerState::GetFindPartyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetFindPartyOwner");

	Params::RBLobbyPlayerState_GetFindPartyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetMatchCancelationGracePeriodServerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBLobbyPlayerState::GetMatchCancelationGracePeriodServerTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetMatchCancelationGracePeriodServerTime");

	Params::RBLobbyPlayerState_GetMatchCancelationGracePeriodServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetMatchOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBLobbyPlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBLobbyPlayerState* ARBLobbyPlayerState::GetMatchOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetMatchOwner");

	Params::RBLobbyPlayerState_GetMatchOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetMatchSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMatchSettings             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMatchSettings ARBLobbyPlayerState::GetMatchSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetMatchSettings");

	Params::RBLobbyPlayerState_GetMatchSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetMatchStartServerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBLobbyPlayerState::GetMatchStartServerTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetMatchStartServerTime");

	Params::RBLobbyPlayerState_GetMatchStartServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetMatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMatchState                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMatchState ARBLobbyPlayerState::GetMatchState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetMatchState");

	Params::RBLobbyPlayerState_GetMatchState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetPlayerCellCustomization
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBPlayerCellCustomizationEntry>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBPlayerCellCustomizationEntry> ARBLobbyPlayerState::GetPlayerCellCustomization() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetPlayerCellCustomization");

	Params::RBLobbyPlayerState_GetPlayerCellCustomization Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetPlayerReleaseAvailableServerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBLobbyPlayerState::GetPlayerReleaseAvailableServerTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetPlayerReleaseAvailableServerTime");

	Params::RBLobbyPlayerState_GetPlayerReleaseAvailableServerTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.GetRecentTrialList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FEndStageInfo>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FEndStageInfo> ARBLobbyPlayerState::GetRecentTrialList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "GetRecentTrialList");

	Params::RBLobbyPlayerState_GetRecentTrialList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsAllReadyToTravelToMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsAllReadyToTravelToMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsAllReadyToTravelToMatch");

	Params::RBLobbyPlayerState_IsAllReadyToTravelToMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsFindingParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsFindingParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsFindingParty");

	Params::RBLobbyPlayerState_IsFindingParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsInEvalCorridor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsInEvalCorridor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsInEvalCorridor");

	Params::RBLobbyPlayerState_IsInEvalCorridor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsLeavingForMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsLeavingForMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsLeavingForMatch");

	Params::RBLobbyPlayerState_IsLeavingForMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsMatchCountdownStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsMatchCountdownStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsMatchCountdownStarted");

	Params::RBLobbyPlayerState_IsMatchCountdownStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLobbyPlayerState.IsReadyToTravelToMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBLobbyPlayerState::IsReadyToTravelToMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLobbyPlayerState", "IsReadyToTravelToMatch");

	Params::RBLobbyPlayerState_IsReadyToTravelToMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.ClearVisitedNPCs
// (Final, Native, Public, BlueprintCallable)

void URBLocalProfile::ClearVisitedNPCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "ClearVisitedNPCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.IncrementTrialsCompleted
// (Final, Native, Public, BlueprintCallable)

void URBLocalProfile::IncrementTrialsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "IncrementTrialsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.ResetStoryLineHistory
// (Final, Native, Public, BlueprintCallable)

void URBLocalProfile::ResetStoryLineHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "ResetStoryLineHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetHasBeenInProximityToReleaseBooth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetHasBeenInProximityToReleaseBooth(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetHasBeenInProximityToReleaseBooth");

	Params::RBLocalProfile_SetHasBeenInProximityToReleaseBooth Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetHasItemBeenDisplayedInMenu
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetHasItemBeenDisplayedInMenu(const class FName& OnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetHasItemBeenDisplayedInMenu");

	Params::RBLocalProfile_SetHasItemBeenDisplayedInMenu Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetHasSeenDisclaimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetHasSeenDisclaimer(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetHasSeenDisclaimer");

	Params::RBLocalProfile_SetHasSeenDisclaimer Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetHasVisitedNPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetHasVisitedNPC(EMetaNPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetHasVisitedNPC");

	Params::RBLocalProfile_SetHasVisitedNPC Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetHasVisitedReleaseBooth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetHasVisitedReleaseBooth(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetHasVisitedReleaseBooth");

	Params::RBLocalProfile_SetHasVisitedReleaseBooth Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetLastPlayedStoryline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StorylineLevelPlayed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FeatureSwitchPlayed                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetLastPlayedStoryline(EMetaNPCType NPCType, int32 StorylineLevelPlayed, const class FString& FeatureSwitchPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetLastPlayedStoryline");

	Params::RBLocalProfile_SetLastPlayedStoryline Parms{};

	Parms.NPCType = NPCType;
	Parms.StorylineLevelPlayed = StorylineLevelPlayed;
	Parms.FeatureSwitchPlayed = std::move(FeatureSwitchPlayed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetLastTrialEvaluationInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTrialEvaluationInfo             EvaluationInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBLocalProfile::SetLastTrialEvaluationInfo(const struct FTrialEvaluationInfo& EvaluationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetLastTrialEvaluationInfo");

	Params::RBLocalProfile_SetLastTrialEvaluationInfo Parms{};

	Parms.EvaluationInfo = std::move(EvaluationInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetProgramSeenInMenu
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetProgramSeenInMenu(const class FName& ProgramId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetProgramSeenInMenu");

	Params::RBLocalProfile_SetProgramSeenInMenu Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.SetTrialsCompletedCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TrialsCompletedCount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBLocalProfile::SetTrialsCompletedCount(int32 TrialsCompletedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "SetTrialsCompletedCount");

	Params::RBLocalProfile_SetTrialsCompletedCount Parms{};

	Parms.TrialsCompletedCount = TrialsCompletedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLocalProfile.GetLastTrialEvaluationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTrialEvaluationInfo       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTrialEvaluationInfo URBLocalProfile::GetLastTrialEvaluationInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "GetLastTrialEvaluationInfo");

	Params::RBLocalProfile_GetLastTrialEvaluationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.GetNextStorylineVO
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLobbyData*                     LobbyData                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StorylineLevelPlayed                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFallbackVO                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FeatureSwitchPlayed                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* URBLocalProfile::GetNextStorylineVO(EMetaNPCType NPCType, const class URBLobbyData* LobbyData, int32* StorylineLevelPlayed, bool* bIsFallbackVO, class FString* FeatureSwitchPlayed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "GetNextStorylineVO");

	Params::RBLocalProfile_GetNextStorylineVO Parms{};

	Parms.NPCType = NPCType;
	Parms.LobbyData = LobbyData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StorylineLevelPlayed != nullptr)
		*StorylineLevelPlayed = Parms.StorylineLevelPlayed;

	if (bIsFallbackVO != nullptr)
		*bIsFallbackVO = Parms.bIsFallbackVO;

	if (FeatureSwitchPlayed != nullptr)
		*FeatureSwitchPlayed = std::move(Parms.FeatureSwitchPlayed);

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.HasBeenInProximityToReleaseBooth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLocalProfile::HasBeenInProximityToReleaseBooth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "HasBeenInProximityToReleaseBooth");

	Params::RBLocalProfile_HasBeenInProximityToReleaseBooth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.HasItemBeenDisplayedInMenu
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             OnlineID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLocalProfile::HasItemBeenDisplayedInMenu(const class FName& OnlineID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "HasItemBeenDisplayedInMenu");

	Params::RBLocalProfile_HasItemBeenDisplayedInMenu Parms{};

	Parms.OnlineID = OnlineID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.HasProgramBeenSeenInMenu
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLocalProfile::HasProgramBeenSeenInMenu(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "HasProgramBeenSeenInMenu");

	Params::RBLocalProfile_HasProgramBeenSeenInMenu Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.HasVisitedNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMetaNPCType                            NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLocalProfile::HasVisitedNPC(EMetaNPCType NPCType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "HasVisitedNPC");

	Params::RBLocalProfile_HasVisitedNPC Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocalProfile.HasVisitedReleaseBooth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBLocalProfile::HasVisitedReleaseBooth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocalProfile", "HasVisitedReleaseBooth");

	Params::RBLocalProfile_HasVisitedReleaseBooth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBLocationHintBoard.Event_OnSelectedHintIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBLocationHintBoard::Event_OnSelectedHintIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocationHintBoard", "Event_OnSelectedHintIndex");

	Params::RBLocationHintBoard_Event_OnSelectedHintIndex Parms{};

	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBLocationHintBoard.OnRep_SelectedHintIndex
// (Final, Native, Protected)

void ARBLocationHintBoard::OnRep_SelectedHintIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLocationHintBoard", "OnRep_SelectedHintIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBLookAtInterface.GetLookAtLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutLookAtLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBLookAtInterface::GetLookAtLocation(struct FVector* OutLookAtLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBLookAtInterface", "GetLookAtLocation");

	Params::RBLookAtInterface_GetLookAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLookAtLocation != nullptr)
		*OutLookAtLocation = std::move(Parms.OutLookAtLocation);
}


// Function OPP.RBMatchAcceptanceNotificationUserWidget.GetPartyMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBMatchAcceptanceNotificationUserWidget::GetPartyMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMatchAcceptanceNotificationUserWidget", "GetPartyMemberCount");

	Params::RBMatchAcceptanceNotificationUserWidget_GetPartyMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuBrightnessCalibration.Event_SetToDefaults
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuBrightnessCalibration::Event_SetToDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuBrightnessCalibration", "Event_SetToDefaults");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuBrightnessCalibration.OnEntryHovered
// (Final, Native, Public)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuBrightnessCalibration::OnEntryHovered(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuBrightnessCalibration", "OnEntryHovered");

	Params::RBMenuBrightnessCalibration_OnEntryHovered Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuCharacter.Event_OnSetup
// (Event, Public, BlueprintEvent)

void ARBMenuCharacter::Event_OnSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "Event_OnSetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuCharacter.Event_OnVisibleChanged
// (Event, Public, BlueprintEvent)

void ARBMenuCharacter::Event_OnVisibleChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "Event_OnVisibleChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuCharacter.Event_RefreshPlayerActiveSkill
// (Event, Public, BlueprintEvent)

void ARBMenuCharacter::Event_RefreshPlayerActiveSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "Event_RefreshPlayerActiveSkill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuCharacter.Event_RefreshPlayerCustomization
// (Event, Public, BlueprintEvent)

void ARBMenuCharacter::Event_RefreshPlayerCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "Event_RefreshPlayerCustomization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuCharacter.GetActiveSkillType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EActiveSkillType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActiveSkillType ARBMenuCharacter::GetActiveSkillType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "GetActiveSkillType");

	Params::RBMenuCharacter_GetActiveSkillType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.IsWaitingForRessources
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuCharacter::IsWaitingForRessources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "IsWaitingForRessources");

	Params::RBMenuCharacter_IsWaitingForRessources Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.Setup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Param_bVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bUnknown                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       Param_CustomizationInfo                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EActiveSkillType                        Param_ActiveSkillType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESocialMenuSceneActorSlot               Param_Slot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayerState*                   Param_RBPlayerState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsFailureScene                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_HealthRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuCharacter::Setup(bool Param_bVisible, bool Param_bUnknown, const struct FRBPlayerCustomizationInfo& Param_CustomizationInfo, EActiveSkillType Param_ActiveSkillType, ESocialMenuSceneActorSlot Param_Slot, class ARBPlayerState* Param_RBPlayerState, bool bInIsFailureScene, float Param_HealthRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "Setup");

	Params::RBMenuCharacter_Setup Parms{};

	Parms.Param_bVisible = Param_bVisible;
	Parms.Param_bUnknown = Param_bUnknown;
	Parms.Param_CustomizationInfo = std::move(Param_CustomizationInfo);
	Parms.Param_ActiveSkillType = Param_ActiveSkillType;
	Parms.Param_Slot = Param_Slot;
	Parms.Param_RBPlayerState = Param_RBPlayerState;
	Parms.bInIsFailureScene = bInIsFailureScene;
	Parms.Param_HealthRatio = Param_HealthRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuCharacter.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Param_bVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMenuCharacter::SetVisible(bool Param_bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "SetVisible");

	Params::RBMenuCharacter_SetVisible Parms{};

	Parms.Param_bVisible = Param_bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuCharacter.GetAssociatedPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* ARBMenuCharacter::GetAssociatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "GetAssociatedPlayerState");

	Params::RBMenuCharacter_GetAssociatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.GetCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBPlayerCustomizationInfo ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerCustomizationInfo ARBMenuCharacter::GetCustomizationInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "GetCustomizationInfo");

	Params::RBMenuCharacter_GetCustomizationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.GetHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBMenuCharacter::GetHealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "GetHealthRatio");

	Params::RBMenuCharacter_GetHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.GetSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESocialMenuSceneActorSlot               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESocialMenuSceneActorSlot ARBMenuCharacter::GetSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "GetSlot");

	Params::RBMenuCharacter_GetSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.IsFailureScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuCharacter::IsFailureScene() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "IsFailureScene");

	Params::RBMenuCharacter_IsFailureScene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.IsUnknown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuCharacter::IsUnknown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "IsUnknown");

	Params::RBMenuCharacter_IsUnknown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuCharacter.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMenuCharacter::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuCharacter", "IsVisible");

	Params::RBMenuCharacter_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuControlBindingEntry.RefreshValue
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuControlBindingEntry::RefreshValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBindingEntry", "RefreshValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuControlBindingEntry.RevertCurrentChange
// (Final, Native, Public, BlueprintCallable)

void URBMenuControlBindingEntry::RevertCurrentChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBindingEntry", "RevertCurrentChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuControlBindingEntry.UpdateRebindStatus
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsRebindInProgress                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuControlBindingEntry::UpdateRebindStatus(bool bIsRebindInProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBindingEntry", "UpdateRebindStatus");

	Params::RBMenuControlBindingEntry_UpdateRebindStatus Parms{};

	Parms.bIsRebindInProgress = bIsRebindInProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuControlBindingEntry.HasValueChanged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuControlBindingEntry::HasValueChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuControlBindingEntry", "HasValueChanged");

	Params::RBMenuControlBindingEntry_HasValueChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuGamepadControlScheme.Event_UpdateDisplayedControlScheme
// (Event, Public, BlueprintEvent)

void URBMenuGamepadControlScheme::Event_UpdateDisplayedControlScheme()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuGamepadControlScheme", "Event_UpdateDisplayedControlScheme");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuGamepadControlScheme.OnOptionValueChanged
// (Final, Native, Private)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuGamepadControlScheme::OnOptionValueChanged(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuGamepadControlScheme", "OnOptionValueChanged");

	Params::RBMenuGamepadControlScheme_OnOptionValueChanged Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuGamepadControlScheme.UpdateApplyBtnVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasValueChanged                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuGamepadControlScheme::UpdateApplyBtnVisibility(bool HasValueChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuGamepadControlScheme", "UpdateApplyBtnVisibility");

	Params::RBMenuGamepadControlScheme_UpdateApplyBtnVisibility Parms{};

	Parms.HasValueChanged = HasValueChanged;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuGamepadControlScheme.ApplyEntriesChanges
// (Final, Native, Private, BlueprintCallable, Const)

void URBMenuGamepadControlScheme::ApplyEntriesChanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuGamepadControlScheme", "ApplyEntriesChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuGamepadControlScheme.RevertAllUnsavedChanges
// (Final, Native, Private, BlueprintCallable, Const)

void URBMenuGamepadControlScheme::RevertAllUnsavedChanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuGamepadControlScheme", "RevertAllUnsavedChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.BP_OnMenuTutorialSeen
// (Final, Native, Public, BlueprintCallable)

void URBMenuManager::BP_OnMenuTutorialSeen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_OnMenuTutorialSeen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.BP_PopMenuPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBMenuWidget*                    Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuManager::BP_PopMenuPage(class URBMenuWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_PopMenuPage");

	Params::RBMenuManager_BP_PopMenuPage Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.BP_PushMenuPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBMenuWidget*                    Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuManager::BP_PushMenuPage(class URBMenuWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_PushMenuPage");

	Params::RBMenuManager_BP_PushMenuPage Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.BP_ShowError
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             SecondaryMessage                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ErrorCode                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuManager::BP_ShowError(const class FText& Message, const class FText& SecondaryMessage, const class FString& ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_ShowError");

	Params::RBMenuManager_BP_ShowError Parms{};

	Parms.Message = std::move(Message);
	Parms.SecondaryMessage = std::move(SecondaryMessage);
	Parms.ErrorCode = std::move(ErrorCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.ClearTransitionStack
// (Final, Native, Public, BlueprintCallable)

void URBMenuManager::ClearTransitionStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "ClearTransitionStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.OnLoadingCutscenePopped
// (Final, Native, Public)

void URBMenuManager::OnLoadingCutscenePopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "OnLoadingCutscenePopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.SetSubtitlesEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuManager::SetSubtitlesEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "SetSubtitlesEnabled");

	Params::RBMenuManager_SetSubtitlesEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuManager.BP_GetCurrentPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBMenuWidget*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuWidget* URBMenuManager::BP_GetCurrentPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_GetCurrentPage");

	Params::RBMenuManager_BP_GetCurrentPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.BP_GetMenuPage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class URBMenuWidget>        MenuClass                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBMenuWidget*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuWidget* URBMenuManager::BP_GetMenuPage(const TSubclassOf<class URBMenuWidget>& MenuClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_GetMenuPage");

	Params::RBMenuManager_BP_GetMenuPage Parms{};

	Parms.MenuClass = MenuClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.BP_IsInMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuManager::BP_IsInMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_IsInMenu");

	Params::RBMenuManager_BP_IsInMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.BP_IsUsingGamepad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuManager::BP_IsUsingGamepad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "BP_IsUsingGamepad");

	Params::RBMenuManager_BP_IsUsingGamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.GetSubtitlesEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuManager::GetSubtitlesEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "GetSubtitlesEnabled");

	Params::RBMenuManager_GetSubtitlesEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.IsShowingLoadingCutsceneVideo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuManager::IsShowingLoadingCutsceneVideo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "IsShowingLoadingCutsceneVideo");

	Params::RBMenuManager_IsShowingLoadingCutsceneVideo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuManager.IsShowingLoadingScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuManager::IsShowingLoadingScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuManager", "IsShowingLoadingScreen");

	Params::RBMenuManager_IsShowingLoadingScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsDescription.UpdateDescription
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FOptionData                      OptionData                                             (Parm, NativeAccessSpecifierPublic)

void URBMenuOptionsDescription::UpdateDescription(const struct FOptionData& OptionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsDescription", "UpdateDescription");

	Params::RBMenuOptionsDescription_UpdateDescription Parms{};

	Parms.OptionData = std::move(OptionData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsEntry.CanBeDisplayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsEntry::CanBeDisplayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "CanBeDisplayed");

	Params::RBMenuOptionsEntry_CanBeDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.CanBeEdited
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsEntry::CanBeEdited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "CanBeEdited");

	Params::RBMenuOptionsEntry_CanBeEdited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.ChangeOptionValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LeftClicked                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::ChangeOptionValue(float Value, bool LeftClicked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "ChangeOptionValue");

	Params::RBMenuOptionsEntry_ChangeOptionValue Parms{};

	Parms.Value = Value;
	Parms.LeftClicked = LeftClicked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsEntry.DownplayEntry
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuOptionsEntry::DownplayEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "DownplayEntry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptionsEntry.Event_RefreshEntry
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuOptionsEntry::Event_RefreshEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "Event_RefreshEntry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptionsEntry.Event_UpdateSliderValue
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TextOverride                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::Event_UpdateSliderValue(float Value, const class FText& TextOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "Event_UpdateSliderValue");

	Params::RBMenuOptionsEntry_Event_UpdateSliderValue Parms{};

	Parms.Value = Value;
	Parms.TextOverride = std::move(TextOverride);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsEntry.Event_UpdateSubButtonText
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::Event_UpdateSubButtonText(const class FText& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "Event_UpdateSubButtonText");

	Params::RBMenuOptionsEntry_Event_UpdateSubButtonText Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsEntry.Event_UpdateTextValue
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::Event_UpdateTextValue(const class FText& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "Event_UpdateTextValue");

	Params::RBMenuOptionsEntry_Event_UpdateTextValue Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsEntry.Event_UpdateTitle
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             NewTitle                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::Event_UpdateTitle(const class FText& NewTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "Event_UpdateTitle");

	Params::RBMenuOptionsEntry_Event_UpdateTitle Parms{};

	Parms.NewTitle = std::move(NewTitle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsEntry.GetCurrentIndexOfOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBMenuOptionsEntry::GetCurrentIndexOfOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "GetCurrentIndexOfOption");

	Params::RBMenuOptionsEntry_GetCurrentIndexOfOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.GetMaxCountForOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBMenuOptionsEntry::GetMaxCountForOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "GetMaxCountForOption");

	Params::RBMenuOptionsEntry_GetMaxCountForOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.GetSliderMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBMenuOptionsEntry::GetSliderMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "GetSliderMax");

	Params::RBMenuOptionsEntry_GetSliderMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.GetSliderMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBMenuOptionsEntry::GetSliderMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "GetSliderMin");

	Params::RBMenuOptionsEntry_GetSliderMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.GetStepSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBMenuOptionsEntry::GetStepSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "GetStepSize");

	Params::RBMenuOptionsEntry_GetStepSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.HighlightEntry
// (Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuOptionsEntry::HighlightEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "HighlightEntry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptionsEntry.IsSlider
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsEntry::IsSlider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "IsSlider");

	Params::RBMenuOptionsEntry_IsSlider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.IsSliderNormalised
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsEntry::IsSliderNormalised()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "IsSliderNormalised");

	Params::RBMenuOptionsEntry_IsSliderNormalised Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.IsSubButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsEntry::IsSubButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "IsSubButton");

	Params::RBMenuOptionsEntry_IsSubButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsEntry.OnResolutionOrWindowModeChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::OnResolutionOrWindowModeChanged(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "OnResolutionOrWindowModeChanged");

	Params::RBMenuOptionsEntry_OnResolutionOrWindowModeChanged Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsEntry.RefreshValue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ForceUpdateSlider                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::RefreshValue(bool ForceUpdateSlider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "RefreshValue");

	Params::RBMenuOptionsEntry_RefreshValue Parms{};

	Parms.ForceUpdateSlider = ForceUpdateSlider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsEntry.RevertCurrentChange
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsEntry::RevertCurrentChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "RevertCurrentChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsEntry.SetEntryToDefaults
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsTabReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsEntry::SetEntryToDefaults(bool bIsTabReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "SetEntryToDefaults");

	Params::RBMenuOptionsEntry_SetEntryToDefaults Parms{};

	Parms.bIsTabReset = bIsTabReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsEntry.UpdateValueChanged
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsEntry::UpdateValueChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsEntry", "UpdateValueChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.ApplyEntriesChanges
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URBMenuOptionsTab::ApplyEntriesChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "ApplyEntriesChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.ConfirmResolution
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::ConfirmResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "ConfirmResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.Event_AddRegionEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::Event_AddRegionEntry(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "Event_AddRegionEntry");

	Params::RBMenuOptionsTab_Event_AddRegionEntry Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsTab.Event_ResolutionChanged
// (Event, Public, BlueprintEvent)

void URBMenuOptionsTab::Event_ResolutionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "Event_ResolutionChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptionsTab.GetChangedOptions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   OptionsNames                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::GetChangedOptions(TArray<class FString>* OptionsNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "GetChangedOptions");

	Params::RBMenuOptionsTab_GetChangedOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OptionsNames != nullptr)
		*OptionsNames = std::move(Parms.OptionsNames);
}


// Function OPP.RBMenuOptionsTab.HasUnsavedChanges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMenuOptionsTab::HasUnsavedChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "HasUnsavedChanges");

	Params::RBMenuOptionsTab_HasUnsavedChanges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsTab.OnEntriesSet
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::OnEntriesSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnEntriesSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnEntryHovered
// (Final, Native, Public)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::OnEntryHovered(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnEntryHovered");

	Params::RBMenuOptionsTab_OnEntryHovered Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnHardwareBenchmarkEnded
// (Event, Public, BlueprintEvent)

void URBMenuOptionsTab::OnHardwareBenchmarkEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnHardwareBenchmarkEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuOptionsTab.OnHUDPresetChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsPreset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::OnHUDPresetChanged(bool bIsPreset, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnHUDPresetChanged");

	Params::RBMenuOptionsTab_OnHUDPresetChanged Parms{};

	Parms.bIsPreset = bIsPreset;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnlineCreateRegionsEntries
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class URBMenuOptionsEntry*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBMenuOptionsEntry* URBMenuOptionsTab::OnlineCreateRegionsEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnlineCreateRegionsEntries");

	Params::RBMenuOptionsTab_OnlineCreateRegionsEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMenuOptionsTab.OnOptionValueChanged
// (Final, Native, Public)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::OnOptionValueChanged(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnOptionValueChanged");

	Params::RBMenuOptionsTab_OnOptionValueChanged Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnQualityValueUpdated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPreset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::OnQualityValueUpdated(bool bIsPreset, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnQualityValueUpdated");

	Params::RBMenuOptionsTab_OnQualityValueUpdated Parms{};

	Parms.bIsPreset = bIsPreset;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnSubButtonClicked
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBMenuOptionsEntry*              Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuOptionsTab::OnSubButtonClicked(class URBMenuOptionsEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnSubButtonClicked");

	Params::RBMenuOptionsTab_OnSubButtonClicked Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMenuOptionsTab.OnTabUnhovered
// (Final, Native, Public)

void URBMenuOptionsTab::OnTabUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnTabUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.OnVoiceChatSettingsUpdated
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::OnVoiceChatSettingsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "OnVoiceChatSettingsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.RevertAllUnsavedChanges
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::RevertAllUnsavedChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "RevertAllUnsavedChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.RevertResolution
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::RevertResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "RevertResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.RunHardwareBenchmark
// (Final, Native, Public, BlueprintCallable)

void URBMenuOptionsTab::RunHardwareBenchmark()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "RunHardwareBenchmark");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuOptionsTab.SetToDefaults
// (Native, Public, BlueprintCallable)

void URBMenuOptionsTab::SetToDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuOptionsTab", "SetToDefaults");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabButton.BP_ClickButton
// (Final, Native, Public, BlueprintCallable)

void URBMenuTabButton::BP_ClickButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabButton", "BP_ClickButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMenuTabButton.Event_OnSelectedChanged
// (Event, Public, BlueprintEvent)

void URBMenuTabButton::Event_OnSelectedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabButton", "Event_OnSelectedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMenuTabButton.SetSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMenuTabButton::SetSelected(bool bInSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMenuTabButton", "SetSelected");

	Params::RBMenuTabButton_SetSelected Parms{};

	Parms.bInSelected = bInSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMicTestOptionsEntryWidget.OnEchoChannelStateChanged
// (Event, Public, BlueprintEvent)

void URBMicTestOptionsEntryWidget::OnEchoChannelStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMicTestOptionsEntryWidget", "OnEchoChannelStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBMicTestOptionsEntryWidget.StopMicrophoneTest
// (Final, Native, Public, BlueprintCallable)

void URBMicTestOptionsEntryWidget::StopMicrophoneTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMicTestOptionsEntryWidget", "StopMicrophoneTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMicTestOptionsEntryWidget.ToggleMicrophoneTest
// (Final, Native, Public, BlueprintCallable)

void URBMicTestOptionsEntryWidget::ToggleMicrophoneTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMicTestOptionsEntryWidget", "ToggleMicrophoneTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneTestState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBMicrophoneTestState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERBMicrophoneTestState URBMicTestOptionsEntryWidget::GetMicrophoneTestState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMicTestOptionsEntryWidget", "GetMicrophoneTestState");

	Params::RBMicTestOptionsEntryWidget_GetMicrophoneTestState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBMicTestOptionsEntryWidget::GetMicrophoneVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMicTestOptionsEntryWidget", "GetMicrophoneVolume");

	Params::RBMicTestOptionsEntryWidget_GetMicrophoneVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMinigameRoomsObjectiveCoordinator.OnMinigameRoomStateChanged
// (Final, Native, Protected)
// Parameters:
// class URBMinigameRoomComponent*         MinigameRoom                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMinigameRoomsObjectiveCoordinator::OnMinigameRoomStateChanged(class URBMinigameRoomComponent* MinigameRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomsObjectiveCoordinator", "OnMinigameRoomStateChanged");

	Params::RBMinigameRoomsObjectiveCoordinator_OnMinigameRoomStateChanged Parms{};

	Parms.MinigameRoom = MinigameRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomsObjectiveCoordinator.OnNumberOfItemUsedChanged
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMinigameRoomsObjectiveCoordinator::OnNumberOfItemUsedChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomsObjectiveCoordinator", "OnNumberOfItemUsedChanged");

	Params::RBMinigameRoomsObjectiveCoordinator_OnNumberOfItemUsedChanged Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMinigameRoomsObjectiveCoordinator.OnRep_CompletedMinigameRooms
// (Final, Native, Protected)

void ARBMinigameRoomsObjectiveCoordinator::OnRep_CompletedMinigameRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMinigameRoomsObjectiveCoordinator", "OnRep_CompletedMinigameRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterClosetReplaceClass.OnMonsterClosetReplaced_Server
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBMonsterCloset*                 MonsterCloset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReplacementSource                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBMonsterClosetReplaceClass::OnMonsterClosetReplaced_Server(class ARBMonsterCloset* MonsterCloset, class AActor* ReplacementSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterClosetReplaceClass", "OnMonsterClosetReplaced_Server");

	Params::RBMonsterClosetReplaceClass_OnMonsterClosetReplaced_Server Parms{};

	Parms.MonsterCloset = MonsterCloset;
	Parms.ReplacementSource = ReplacementSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.BP_FinishedClosing
// (Final, Native, Public, BlueprintCallable)

void ARBMonsterCloset::BP_FinishedClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "BP_FinishedClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.BP_FinishedOpening
// (Final, Native, Public, BlueprintCallable)

void ARBMonsterCloset::BP_FinishedOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "BP_FinishedOpening");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.BP_SetCurrentlyEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::BP_SetCurrentlyEnabled(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "BP_SetCurrentlyEnabled");

	Params::RBMonsterCloset_BP_SetCurrentlyEnabled Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.BP_Tick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBMonsterCloset::BP_Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "BP_Tick");

	Params::RBMonsterCloset_BP_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBMonsterCloset.Event_ApplyOpenState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_ApplyOpenState(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_ApplyOpenState");

	Params::RBMonsterCloset_Event_ApplyOpenState Parms{};

	Parms.bOpen = bOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Event_OnNPCEnter
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_OnNPCEnter(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_OnNPCEnter");

	Params::RBMonsterCloset_Event_OnNPCEnter Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Event_OnNPCExit
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_OnNPCExit(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_OnNPCExit");

	Params::RBMonsterCloset_Event_OnNPCExit Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Event_OnPlayerInClosetChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        OldPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_OnPlayerInClosetChanged(class ARBPlayer* OldPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_OnPlayerInClosetChanged");

	Params::RBMonsterCloset_Event_OnPlayerInClosetChanged Parms{};

	Parms.OldPlayer = OldPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Event_SetNPCSpawnWarningActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bWarningActive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_SetNPCSpawnWarningActive(bool bWarningActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_SetNPCSpawnWarningActive");

	Params::RBMonsterCloset_Event_SetNPCSpawnWarningActive Parms{};

	Parms.bWarningActive = bWarningActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Event_TriggerNPCSpawnAnnouncement
// (Event, Public, BlueprintEvent)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Event_TriggerNPCSpawnAnnouncement(ENPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Event_TriggerNPCSpawnAnnouncement");

	Params::RBMonsterCloset_Event_TriggerNPCSpawnAnnouncement Parms{};

	Parms.NPCType = NPCType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBMonsterCloset.Multicast_TriggerNPCSpawnAnnouncement
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ENPCType                                NPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::Multicast_TriggerNPCSpawnAnnouncement(ENPCType NPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "Multicast_TriggerNPCSpawnAnnouncement");

	Params::RBMonsterCloset_Multicast_TriggerNPCSpawnAnnouncement Parms{};

	Parms.NPCType = NPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnPlayerRespawnTransitionFinished
// (Final, Native, Protected)

void ARBMonsterCloset::OnPlayerRespawnTransitionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnPlayerRespawnTransitionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnRep_bSpawnWarningInProgress
// (Final, Native, Public)

void ARBMonsterCloset::OnRep_bSpawnWarningInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnRep_bSpawnWarningInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnRep_DynamicallyReplaced
// (Final, Native, Protected)

void ARBMonsterCloset::OnRep_DynamicallyReplaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnRep_DynamicallyReplaced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnRep_PlayerInCloset
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::OnRep_PlayerInCloset(class ARBPlayer* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnRep_PlayerInCloset");

	Params::RBMonsterCloset_OnRep_PlayerInCloset Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnRep_ShouldBeOpen
// (Final, Native, Public)

void ARBMonsterCloset::OnRep_ShouldBeOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnRep_ShouldBeOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnSpawningZoneBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBMonsterCloset::OnSpawningZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnSpawningZoneBeginOverlap");

	Params::RBMonsterCloset_OnSpawningZoneBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.OnSpawningZoneEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::OnSpawningZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "OnSpawningZoneEndOverlap");

	Params::RBMonsterCloset_OnSpawningZoneEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMonsterCloset.SetDoorCollisionsForPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBMonsterCloset::SetDoorCollisionsForPawn(class ARBPawn* Pawn, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMonsterCloset", "SetDoorCollisionsForPawn");

	Params::RBMonsterCloset_SetDoorCollisionsForPawn Parms{};

	Parms.Pawn = Pawn;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMovieSubtitlePlayer.Start
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBMovieSubtitles*                Param_MovieSubtitles                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMovieSubtitlePlayer::Start(const class URBMovieSubtitles* Param_MovieSubtitles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMovieSubtitlePlayer", "Start");

	Params::RBMovieSubtitlePlayer_Start Parms{};

	Parms.Param_MovieSubtitles = Param_MovieSubtitles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMovieSubtitlePlayer.Stop
// (Final, Native, Public, BlueprintCallable)

void URBMovieSubtitlePlayer::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMovieSubtitlePlayer", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMovieSubtitlePlayer.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeSeconds                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBMovieSubtitlePlayer::Update(float TimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMovieSubtitlePlayer", "Update");

	Params::RBMovieSubtitlePlayer_Update Parms{};

	Parms.TimeSeconds = TimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBMovieSubtitlePlayer.IsStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBMovieSubtitlePlayer::IsStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBMovieSubtitlePlayer", "IsStarted");

	Params::RBMovieSubtitlePlayer_IsStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationFinished
// (Final, Native, Public, BlueprintCallable)

void ARBNarrativeScreenChannel::BP_NotifyAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_NotifyAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationStarted
// (Final, Native, Public, BlueprintCallable)

void ARBNarrativeScreenChannel::BP_NotifyAnimationStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_NotifyAnimationStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.BP_PlayAnimation
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNarrativeScreenAnimationData    PlayingData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bQueueIfPlaying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceAllLinkedTVsOn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreenChannel::BP_PlayAnimation(const struct FNarrativeScreenAnimationData& PlayingData, bool bQueueIfPlaying, bool bForceAllLinkedTVsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_PlayAnimation");

	Params::RBNarrativeScreenChannel_BP_PlayAnimation Parms{};

	Parms.PlayingData = std::move(PlayingData);
	Parms.bQueueIfPlaying = bQueueIfPlaying;
	Parms.bForceAllLinkedTVsOn = bForceAllLinkedTVsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.BP_SetAllLinkedTVsOn
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreenChannel::BP_SetAllLinkedTVsOn(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_SetAllLinkedTVsOn");

	Params::RBNarrativeScreenChannel_BP_SetAllLinkedTVsOn Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.BP_StopAnimation
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearQueue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreenChannel::BP_StopAnimation(bool bClearQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_StopAnimation");

	Params::RBNarrativeScreenChannel_BP_StopAnimation Parms{};

	Parms.bClearQueue = bClearQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.Event_OnCurrentlyPlayingDataChanged
// (Event, Public, BlueprintEvent)

void ARBNarrativeScreenChannel::Event_OnCurrentlyPlayingDataChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "Event_OnCurrentlyPlayingDataChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenAdded
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNarrativeScreen*               LinkedScreen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreenChannel::Event_OnLinkedScreenAdded(class ARBNarrativeScreen* LinkedScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "Event_OnLinkedScreenAdded");

	Params::RBNarrativeScreenChannel_Event_OnLinkedScreenAdded Parms{};

	Parms.LinkedScreen = LinkedScreen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNarrativeScreen*               LinkedScreen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNarrativeScreenChannel::Event_OnLinkedScreenRemoved(class ARBNarrativeScreen* LinkedScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "Event_OnLinkedScreenRemoved");

	Params::RBNarrativeScreenChannel_Event_OnLinkedScreenRemoved Parms{};

	Parms.LinkedScreen = LinkedScreen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBNarrativeScreenChannel.OnRep_CurrentlyPlayingData
// (Final, Native, Public)

void ARBNarrativeScreenChannel::OnRep_CurrentlyPlayingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "OnRep_CurrentlyPlayingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNarrativeScreenChannel.BP_GetLinkedScreens
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBNarrativeScreen*>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBNarrativeScreen*> ARBNarrativeScreenChannel::BP_GetLinkedScreens() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "BP_GetLinkedScreens");

	Params::RBNarrativeScreenChannel_BP_GetLinkedScreens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNarrativeScreenChannel.IsCurrentlyPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBNarrativeScreenChannel::IsCurrentlyPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNarrativeScreenChannel", "IsCurrentlyPlaying");

	Params::RBNarrativeScreenChannel_IsCurrentlyPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNDAOverlayWidget.Event_Setup
// (Event, Public, BlueprintEvent)

void URBNDAOverlayWidget::Event_Setup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNDAOverlayWidget", "Event_Setup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNetworkSoundActor.OnRep_AssociatedSoundPlaying
// (Final, Native, Private)

void ARBNetworkSoundActor::OnRep_AssociatedSoundPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "OnRep_AssociatedSoundPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.OnRep_RTPCData
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FNetworkSoundActorRTPCData>OldRTPCData                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBNetworkSoundActor::OnRep_RTPCData(const TArray<struct FNetworkSoundActorRTPCData>& OldRTPCData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "OnRep_RTPCData");

	Params::RBNetworkSoundActor_OnRep_RTPCData Parms{};

	Parms.OldRTPCData = std::move(OldRTPCData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.OnRep_SwitchStateData
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FNetworkSoundActorSwitchStateData>OldSwitchStateData                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBNetworkSoundActor::OnRep_SwitchStateData(const TArray<struct FNetworkSoundActorSwitchStateData>& OldSwitchStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "OnRep_SwitchStateData");

	Params::RBNetworkSoundActor_OnRep_SwitchStateData Parms{};

	Parms.OldSwitchStateData = std::move(OldSwitchStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.PostAssociatedSound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNetworkSoundActor::PostAssociatedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "PostAssociatedSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.SetRTPC
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Param_Name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNetworkSoundActor::SetRTPC(class FName Param_Name, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "SetRTPC");

	Params::RBNetworkSoundActor_SetRTPC Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.SetSwitchState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Param_Name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNetworkSoundActor::SetSwitchState(class FName Param_Name, class FName State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "SetSwitchState");

	Params::RBNetworkSoundActor_SetSwitchState Parms{};

	Parms.Param_Name = Param_Name;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundActor.StopAssociatedSound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNetworkSoundActor::StopAssociatedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundActor", "StopAssociatedSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.OnRep_AssociatedSoundPlaying
// (Final, Native, Private)

void URBNetworkSoundComponent::OnRep_AssociatedSoundPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "OnRep_AssociatedSoundPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.OnRep_RTPCData
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FNetworkSoundComponentRTPCData>OldRTPCData                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBNetworkSoundComponent::OnRep_RTPCData(const TArray<struct FNetworkSoundComponentRTPCData>& OldRTPCData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "OnRep_RTPCData");

	Params::RBNetworkSoundComponent_OnRep_RTPCData Parms{};

	Parms.OldRTPCData = std::move(OldRTPCData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.OnRep_SwitchStateData
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FNetworkSoundComponentSwitchStateData>OldSwitchStateData                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBNetworkSoundComponent::OnRep_SwitchStateData(const TArray<struct FNetworkSoundComponentSwitchStateData>& OldSwitchStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "OnRep_SwitchStateData");

	Params::RBNetworkSoundComponent_OnRep_SwitchStateData Parms{};

	Parms.OldSwitchStateData = std::move(OldSwitchStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.PostAssociatedSound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBNetworkSoundComponent::PostAssociatedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "PostAssociatedSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.SetRTPC
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Param_Name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNetworkSoundComponent::SetRTPC(class FName Param_Name, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "SetRTPC");

	Params::RBNetworkSoundComponent_SetRTPC Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.SetSwitchState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Param_Name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNetworkSoundComponent::SetSwitchState(class FName Param_Name, class FName State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "SetSwitchState");

	Params::RBNetworkSoundComponent_SetSwitchState Parms{};

	Parms.Param_Name = Param_Name;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNetworkSoundComponent.StopAssociatedSound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBNetworkSoundComponent::StopAssociatedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNetworkSoundComponent", "StopAssociatedSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNewsWidget.Event_NextItem
// (Event, Public, BlueprintEvent)

void URBNewsWidget::Event_NextItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "Event_NextItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNewsWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBNewsWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNewsWidget.ExecuteCTA
// (Final, Native, Public, BlueprintCallable)

void URBNewsWidget::ExecuteCTA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "ExecuteCTA");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNewsWidget.PauseNewsAutoScroll
// (Final, Native, Public, BlueprintCallable)

void URBNewsWidget::PauseNewsAutoScroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "PauseNewsAutoScroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNewsWidget.ResumeNewsAutoScroll
// (Final, Native, Public, BlueprintCallable)

void URBNewsWidget::ResumeNewsAutoScroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "ResumeNewsAutoScroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNewsWidget.SetActiveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNewsWidget::SetActiveItem(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "SetActiveItem");

	Params::RBNewsWidget_SetActiveItem Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNewsWidget.GetBorderColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor URBNewsWidget::GetBorderColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetBorderColor");

	Params::RBNewsWidget_GetBorderColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetCurrentItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBNewsWidget::GetCurrentItemIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetCurrentItemIndex");

	Params::RBNewsWidget_GetCurrentItemIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBNewsWidget::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetDescription");

	Params::RBNewsWidget_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetHeaderBackgroundColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor URBNewsWidget::GetHeaderBackgroundColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetHeaderBackgroundColor");

	Params::RBNewsWidget_GetHeaderBackgroundColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetHeaderTextColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor URBNewsWidget::GetHeaderTextColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetHeaderTextColor");

	Params::RBNewsWidget_GetHeaderTextColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2DDynamic*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2DDynamic* URBNewsWidget::GetImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetImage");

	Params::RBNewsWidget_GetImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetNumItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBNewsWidget::GetNumItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetNumItems");

	Params::RBNewsWidget_GetNumItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBNewsWidget::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "GetTitle");

	Params::RBNewsWidget_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNewsWidget.HasCTA
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNewsWidget::HasCTA() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNewsWidget", "HasCTA");

	Params::RBNewsWidget_HasCTA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPCDebugIconWidget.GetAwarenessStateType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIAwarenessStateType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIAwarenessStateType URBNPCDebugIconWidget::GetAwarenessStateType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCDebugIconWidget", "GetAwarenessStateType");

	Params::RBNPCDebugIconWidget_GetAwarenessStateType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPCDebugIconWidget.GetMeterValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBNPCDebugIconWidget::GetMeterValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCDebugIconWidget", "GetMeterValue");

	Params::RBNPCDebugIconWidget_GetMeterValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPCSeparatorDoor.BP_ClearForcedTubeDirection_Internal
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNPCSeparatorDoor::BP_ClearForcedTubeDirection_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_ClearForcedTubeDirection_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.BP_ForceTubeDirection_Internal
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInsideToOutisde                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::BP_ForceTubeDirection_Internal(bool bInsideToOutisde)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_ForceTubeDirection_Internal");

	Params::RBNPCSeparatorDoor_BP_ForceTubeDirection_Internal Parms{};

	Parms.bInsideToOutisde = bInsideToOutisde;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.BP_SetDoorsCurrentDirection
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInsideToOutisde                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::BP_SetDoorsCurrentDirection(bool bInsideToOutisde)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_SetDoorsCurrentDirection");

	Params::RBNPCSeparatorDoor_BP_SetDoorsCurrentDirection Parms{};

	Parms.bInsideToOutisde = bInsideToOutisde;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.BP_SetDoorsRetracted_Internal
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::BP_SetDoorsRetracted_Internal(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_SetDoorsRetracted_Internal");

	Params::RBNPCSeparatorDoor_BP_SetDoorsRetracted_Internal Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.BP_SetLocked
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::BP_SetLocked(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_SetLocked");

	Params::RBNPCSeparatorDoor_BP_SetLocked Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.BP_SetMaxNumberOfPassages_Internal
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::BP_SetMaxNumberOfPassages_Internal(int32 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "BP_SetMaxNumberOfPassages_Internal");

	Params::RBNPCSeparatorDoor_BP_SetMaxNumberOfPassages_Internal Parms{};

	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.Event_OnIsRetractedChanged
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorDoor::Event_OnIsRetractedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "Event_OnIsRetractedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorDoor.Event_OnTubesInitialized
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorDoor::Event_OnTubesInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "Event_OnTubesInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorDoor.OnInsideSafetyComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::OnInsideSafetyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "OnInsideSafetyComponentBeginOverlap");

	Params::RBNPCSeparatorDoor_OnInsideSafetyComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.OnOutsideSafetyComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::OnOutsideSafetyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "OnOutsideSafetyComponentBeginOverlap");

	Params::RBNPCSeparatorDoor_OnOutsideSafetyComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.OnPlayerExitedTube
// (Final, Native, Private)
// Parameters:
// class ARBNPCSeparatorTube*              Tube                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorDoor::OnPlayerExitedTube(class ARBNPCSeparatorTube* Tube, class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "OnPlayerExitedTube");

	Params::RBNPCSeparatorDoor_OnPlayerExitedTube Parms{};

	Parms.Tube = Tube;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorDoor.OnRep_IsRetracted
// (Final, Native, Private)

void ARBNPCSeparatorDoor::OnRep_IsRetracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorDoor", "OnRep_IsRetracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_ClearForcedDirection
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNPCSeparatorTube::BP_ClearForcedDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_ClearForcedDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationFinished
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNPCSeparatorTube::BP_OnDoorAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_OnDoorAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationStarted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBNPCSeparatorTube::BP_OnDoorAnimationStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_OnDoorAnimationStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetDirection
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInsideToOutside                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetDirection(bool bInsideToOutside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetDirection");

	Params::RBNPCSeparatorTube_BP_SetDirection Parms{};

	Parms.bInsideToOutside = bInsideToOutside;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetForcedDirection
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInsideToOutside                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetForcedDirection(bool bInsideToOutside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetForcedDirection");

	Params::RBNPCSeparatorTube_BP_SetForcedDirection Parms{};

	Parms.bInsideToOutside = bInsideToOutside;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetIsLocked
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetIsLocked(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetIsLocked");

	Params::RBNPCSeparatorTube_BP_SetIsLocked Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetIsRetracted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetIsRetracted(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetIsRetracted");

	Params::RBNPCSeparatorTube_BP_SetIsRetracted Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetMaxNumberOfPassages
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MaxNumber                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetNumberOfPassages                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetMaxNumberOfPassages(int32 MaxNumber, bool bResetNumberOfPassages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetMaxNumberOfPassages");

	Params::RBNPCSeparatorTube_BP_SetMaxNumberOfPassages Parms{};

	Parms.MaxNumber = MaxNumber;
	Parms.bResetNumberOfPassages = bResetNumberOfPassages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.BP_SetTubeState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ESeparatorTubeState                     State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::BP_SetTubeState(ESeparatorTubeState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "BP_SetTubeState");

	Params::RBNPCSeparatorTube_BP_SetTubeState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.Event_OnIsLockedChanged
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorTube::Event_OnIsLockedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "Event_OnIsLockedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorTube.Event_OnIsRetractedChanged
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorTube::Event_OnIsRetractedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "Event_OnIsRetractedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorTube.Event_OnPlayersInsideChanged
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorTube::Event_OnPlayersInsideChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "Event_OnPlayersInsideChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorTube.Event_OnTubeStateChanged
// (Event, Public, BlueprintEvent)

void ARBNPCSeparatorTube::Event_OnTubeStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "Event_OnTubeStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCSeparatorTube.OnComponentBoxBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::OnComponentBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnComponentBoxBeginOverlap");

	Params::RBNPCSeparatorTube_OnComponentBoxBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnComponentBoxEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::OnComponentBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnComponentBoxEndOverlap");

	Params::RBNPCSeparatorTube_OnComponentBoxEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnComponentCapsuleBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::OnComponentCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnComponentCapsuleBeginOverlap");

	Params::RBNPCSeparatorTube_OnComponentCapsuleBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnComponentCapsuleEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCSeparatorTube::OnComponentCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnComponentCapsuleEndOverlap");

	Params::RBNPCSeparatorTube_OnComponentCapsuleEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnRep_Islocked
// (Final, Native, Private)

void ARBNPCSeparatorTube::OnRep_Islocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnRep_Islocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnRep_IsRetracted
// (Final, Native, Private)

void ARBNPCSeparatorTube::OnRep_IsRetracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnRep_IsRetracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnRep_PlayersInside
// (Final, Native, Private)

void ARBNPCSeparatorTube::OnRep_PlayersInside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnRep_PlayersInside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.OnRep_TubeState
// (Final, Native, Private)

void ARBNPCSeparatorTube::OnRep_TubeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "OnRep_TubeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCSeparatorTube.UpdateTubeState_Server
// (Final, Native, Public, BlueprintCallable)

void ARBNPCSeparatorTube::UpdateTubeState_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCSeparatorTube", "UpdateTubeState_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCShopUserWidget.Event_OnMetaNpcTypeChanged
// (Event, Public, BlueprintEvent)

void URBNPCShopUserWidget::Event_OnMetaNpcTypeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCShopUserWidget", "Event_OnMetaNpcTypeChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCShopUserWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBNPCShopUserWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCShopUserWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCShopUserWidget.OnRelevantDataChanged
// (Final, Native, Private)

void URBNPCShopUserWidget::OnRelevantDataChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCShopUserWidget", "OnRelevantDataChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCShopUserWidget.SetMetaNpcType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMetaNPCType                            MetaNPCType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNPCShopUserWidget::SetMetaNpcType(EMetaNPCType MetaNPCType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCShopUserWidget", "SetMetaNpcType");

	Params::RBNPCShopUserWidget_SetMetaNpcType Parms{};

	Parms.MetaNPCType = MetaNPCType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCShopUserWidget.GetMetaNPCType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMetaNPCType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMetaNPCType URBNPCShopUserWidget::GetMetaNPCType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCShopUserWidget", "GetMetaNPCType");

	Params::RBNPCShopUserWidget_GetMetaNPCType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNPCWeapon.EquippedBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBNPCWeapon::EquippedBy(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCWeapon", "EquippedBy");

	Params::RBNPCWeapon_EquippedBy Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNPCWeapon.Event_ActivateEffects
// (Event, Public, BlueprintEvent)

void ARBNPCWeapon::Event_ActivateEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCWeapon", "Event_ActivateEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCWeapon.Event_DeactivateEffects
// (Event, Public, BlueprintEvent)

void ARBNPCWeapon::Event_DeactivateEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCWeapon", "Event_DeactivateEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCWeapon.Event_OnHidden
// (Event, Public, BlueprintEvent)

void ARBNPCWeapon::Event_OnHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCWeapon", "Event_OnHidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNPCWeapon.Event_OnUnhidden
// (Event, Public, BlueprintEvent)

void ARBNPCWeapon::Event_OnUnhidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNPCWeapon", "Event_OnUnhidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBNVComponent.OnNVStateChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNVComponent::OnNVStateChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "OnNVStateChangedCallback");

	Params::RBNVComponent_OnNVStateChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNVComponent.OnRep_IsBatteryLow
// (Final, Native, Protected)

void URBNVComponent::OnRep_IsBatteryLow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "OnRep_IsBatteryLow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNVComponent.OnRep_NVState
// (Final, Native, Protected)

void URBNVComponent::OnRep_NVState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "OnRep_NVState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNVComponent.TurnOff
// (Final, Native, Public, BlueprintCallable)

void URBNVComponent::TurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "TurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNVComponent.TurnOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPowered                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBNVComponent::TurnOn(bool bPowered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "TurnOn");

	Params::RBNVComponent_TurnOn Parms{};

	Parms.bPowered = bPowered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBNVComponent.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENVState                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENVState URBNVComponent::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "GetCurrentState");

	Params::RBNVComponent_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNVComponent.IsBatteryLow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNVComponent::IsBatteryLow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "IsBatteryLow");

	Params::RBNVComponent_IsBatteryLow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBNVComponent.IsNVOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBNVComponent::IsNVOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBNVComponent", "IsNVOn");

	Params::RBNVComponent_IsNVOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoomAssociationComponent.BP_RefreshRoomAssociation
// (Final, Native, Public, BlueprintCallable)

void URBRoomAssociationComponent::BP_RefreshRoomAssociation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomAssociationComponent", "BP_RefreshRoomAssociation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomAssociationComponent.PrintInvalidRoomForLocationError
// (Final, Native, Public, Const)

void URBRoomAssociationComponent::PrintInvalidRoomForLocationError() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomAssociationComponent", "PrintInvalidRoomForLocationError");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveActorComponent.BP_ShouldIconBeForcedHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBObjectiveActorComponent::BP_ShouldIconBeForcedHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveActorComponent", "BP_ShouldIconBeForcedHidden");

	Params::RBObjectiveActorComponent_BP_ShouldIconBeForcedHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveManager.BP_CompleteSingleObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveManager::BP_CompleteSingleObjective(class ARBPawn* Player, class AActor* Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_CompleteSingleObjective");

	Params::RBObjectiveManager_BP_CompleteSingleObjective Parms{};

	Parms.Player = Player;
	Parms.Objective = Objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveManager.BP_GetIntroObjectiveIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* URBObjectiveManager::BP_GetIntroObjectiveIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_GetIntroObjectiveIcon");

	Params::RBObjectiveManager_BP_GetIntroObjectiveIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveManager.BP_PlayObjectiveScreenAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNarrativeScreenAnimationData    AnimData                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlayIntro                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveManager::BP_PlayObjectiveScreenAnim(const struct FNarrativeScreenAnimationData& AnimData, bool bPlayIntro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_PlayObjectiveScreenAnim");

	Params::RBObjectiveManager_BP_PlayObjectiveScreenAnim Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.bPlayIntro = bPlayIntro;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveManager.OnObjectiveCoordinatorStateChanged_Callback
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBObjectiveManager::OnObjectiveCoordinatorStateChanged_Callback(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "OnObjectiveCoordinatorStateChanged_Callback");

	Params::RBObjectiveManager_OnObjectiveCoordinatorStateChanged_Callback Parms{};

	Parms.Coordinator = Coordinator;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveManager.OnStageReady
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBObjectiveManager::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "OnStageReady");

	Params::RBObjectiveManager_OnStageReady Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveManager.OnStageStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBObjectiveManager::OnStageStarted(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "OnStageStarted");

	Params::RBObjectiveManager_OnStageStarted Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBObjectiveManager.BP_GetAllObjectiveCoordinators
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBBaseObjectiveCoordinator*>OutCoordinators                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBObjectiveManager::BP_GetAllObjectiveCoordinators(TArray<class ARBBaseObjectiveCoordinator*>* OutCoordinators) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_GetAllObjectiveCoordinators");

	Params::RBObjectiveManager_BP_GetAllObjectiveCoordinators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCoordinators != nullptr)
		*OutCoordinators = std::move(Parms.OutCoordinators);
}


// Function OPP.RBObjectiveManager.BP_GetFormattedCurrentObjectiveString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   MaxCharPerLine                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBObjectiveManager::BP_GetFormattedCurrentObjectiveString(int32 MaxCharPerLine) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_GetFormattedCurrentObjectiveString");

	Params::RBObjectiveManager_BP_GetFormattedCurrentObjectiveString Parms{};

	Parms.MaxCharPerLine = MaxCharPerLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveManager.BP_GetStartedObjectiveCoordinators
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBBaseObjectiveCoordinator*>OutCoordinators                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBObjectiveManager::BP_GetStartedObjectiveCoordinators(TArray<class ARBBaseObjectiveCoordinator*>* OutCoordinators) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_GetStartedObjectiveCoordinators");

	Params::RBObjectiveManager_BP_GetStartedObjectiveCoordinators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCoordinators != nullptr)
		*OutCoordinators = std::move(Parms.OutCoordinators);
}


// Function OPP.RBObjectiveManager.BP_HasStartedMainObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBObjectiveManager::BP_HasStartedMainObjective() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "BP_HasStartedMainObjective");

	Params::RBObjectiveManager_BP_HasStartedMainObjective Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveManager.GetCurrentQuestItemLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBObjectiveManager::GetCurrentQuestItemLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveManager", "GetCurrentQuestItemLimit");

	Params::RBObjectiveManager_GetCurrentQuestItemLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveRandomizable.GetObjectiveTypeIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IRBObjectiveRandomizable::GetObjectiveTypeIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveRandomizable", "GetObjectiveTypeIndex");

	Params::RBObjectiveRandomizable_GetObjectiveTypeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBObjectiveRandomizable.ShouldDiscardOtherObjectiveActorForRandomization
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBObjectiveRandomizable::ShouldDiscardOtherObjectiveActorForRandomization(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBObjectiveRandomizable", "ShouldDiscardOtherObjectiveActorForRandomization");

	Params::RBObjectiveRandomizable_ShouldDiscardOtherObjectiveActorForRandomization Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceLocation.OnRep_RandomState
// (Final, Native, Protected)

void ARBZoneDefenceLocation::OnRep_RandomState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceLocation", "OnRep_RandomState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneDefenceLocation.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBZoneDefenceLocation::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceLocation", "IsEnabled");

	Params::RBZoneDefenceLocation_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableInterface.OnTriggerableActivated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBOperatableInterface::OnTriggerableActivated(class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableInterface", "OnTriggerableActivated");

	Params::RBOperatableInterface_OnTriggerableActivated Parms{};

	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatableInterface.OnTriggerableDeactivated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBOperatableInterface::OnTriggerableDeactivated(class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableInterface", "OnTriggerableDeactivated");

	Params::RBOperatableInterface_OnTriggerableDeactivated Parms{};

	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatableInterface.GetProgressionRatio
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRBOperatableInterface::GetProgressionRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableInterface", "GetProgressionRatio");

	Params::RBOperatableInterface_GetProgressionRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableInterface.GetTriggerActionBehavior
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ETriggerableActionBehavior              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETriggerableActionBehavior IRBOperatableInterface::GetTriggerActionBehavior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableInterface", "GetTriggerActionBehavior");

	Params::RBOperatableInterface_GetTriggerActionBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableForObjectiveTrigger.GetLinkedTriggerable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARBTriggerable*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBTriggerable* IRBOperatableForObjectiveTrigger::GetLinkedTriggerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableForObjectiveTrigger", "GetLinkedTriggerable");

	Params::RBOperatableForObjectiveTrigger_GetLinkedTriggerable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableTriggerObjectiveCoordinator.OnPlayerCompletedOperatable
// (Final, Native, Protected)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBOperatableTriggerObjectiveCoordinator::OnPlayerCompletedOperatable(bool IsOn, class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableTriggerObjectiveCoordinator", "OnPlayerCompletedOperatable");

	Params::RBOperatableTriggerObjectiveCoordinator_OnPlayerCompletedOperatable Parms{};

	Parms.IsOn = IsOn;
	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatableTriggerObjectiveCoordinator.OnRep_AllSelectedOperatables
// (Final, Native, Protected)

void ARBOperatableTriggerObjectiveCoordinator::OnRep_AllSelectedOperatables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableTriggerObjectiveCoordinator", "OnRep_AllSelectedOperatables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBOperatableTriggerObjectiveCoordinator.GetLinkedTriggerable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBTriggerable*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBTriggerable* ARBOperatableTriggerObjectiveCoordinator::GetLinkedTriggerable(class AActor* Operatable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableTriggerObjectiveCoordinator", "GetLinkedTriggerable");

	Params::RBOperatableTriggerObjectiveCoordinator_GetLinkedTriggerable Parms{};

	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOperatableTriggerObjectiveCoordinator.GetRemainingOperatablesForTriggerable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutOperatables                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBOperatableTriggerObjectiveCoordinator::GetRemainingOperatablesForTriggerable(class ARBTriggerable* Triggerable, TArray<class AActor*>* OutOperatables) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOperatableTriggerObjectiveCoordinator", "GetRemainingOperatablesForTriggerable");

	Params::RBOperatableTriggerObjectiveCoordinator_GetRemainingOperatablesForTriggerable Parms{};

	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOperatables != nullptr)
		*OutOperatables = std::move(Parms.OutOperatables);
}


// Function OPP.RBOptionsMenu.CanEditCrossplaySetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOptionsMenu::CanEditCrossplaySetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOptionsMenu", "CanEditCrossplaySetting");

	Params::RBOptionsMenu_CanEditCrossplaySetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOptionsMenu.CanViewCrossplaySetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOptionsMenu::CanViewCrossplaySetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOptionsMenu", "CanViewCrossplaySetting");

	Params::RBOptionsMenu_CanViewCrossplaySetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOutlineComponent.BP_IsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBOutlineComponent::BP_IsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOutlineComponent", "BP_IsEnabled");

	Params::RBOutlineComponent_BP_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBOutlineComponent.BP_SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBOutlineComponent::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBOutlineComponent", "BP_SetEnabled");

	Params::RBOutlineComponent_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodeButtonComponent.OnRep_IsOn
// (Final, Native, Public)

void URBPasscodeButtonComponent::OnRep_IsOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeButtonComponent", "OnRep_IsOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodeButtonComponent.OnRep_Pressed
// (Final, Native, Public)

void URBPasscodeButtonComponent::OnRep_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeButtonComponent", "OnRep_Pressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodeButtonComponent.BP_IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPasscodeButtonComponent::BP_IsPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeButtonComponent", "BP_IsPressed");

	Params::RBPasscodeButtonComponent_BP_IsPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPasscodeNumberDecalActor.Event_OnActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPasscodeNumberDecalActor::Event_OnActiveChanged(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeNumberDecalActor", "Event_OnActiveChanged");

	Params::RBPasscodeNumberDecalActor_Event_OnActiveChanged Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPasscodeNumberDecalActor.Event_OnSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPasscodeNumberDecalActor::Event_OnSelected(bool bSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeNumberDecalActor", "Event_OnSelected");

	Params::RBPasscodeNumberDecalActor_Event_OnSelected Parms{};

	Parms.bSelected = bSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPasscodeNumberDecalActor.OnRep_DecalData
// (Final, Native, Private)

void ARBPasscodeNumberDecalActor::OnRep_DecalData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeNumberDecalActor", "OnRep_DecalData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodeNumberDecalActor.GetLinkedPuzzleRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBPuzzleRoomComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPuzzleRoomComponent* ARBPasscodeNumberDecalActor::GetLinkedPuzzleRoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeNumberDecalActor", "GetLinkedPuzzleRoom");

	Params::RBPasscodeNumberDecalActor_GetLinkedPuzzleRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPasscodeNumberDecalActor.IsPasscodeDebugging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPasscodeNumberDecalActor::IsPasscodeDebugging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodeNumberDecalActor", "IsPasscodeDebugging");

	Params::RBPasscodeNumberDecalActor_IsPasscodeDebugging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPasscodePadComponent.BP_SetOnStateOnAllButtons
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPasscodePadComponent::BP_SetOnStateOnAllButtons(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "BP_SetOnStateOnAllButtons");

	Params::RBPasscodePadComponent_BP_SetOnStateOnAllButtons Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodePadComponent.Multicast_OnPasscodePadValidation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bValid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPasscodePadComponent::Multicast_OnPasscodePadValidation(bool bValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "Multicast_OnPasscodePadValidation");

	Params::RBPasscodePadComponent_Multicast_OnPasscodePadValidation Parms{};

	Parms.bValid = bValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodePadComponent.OnRep_ButtonsPressed
// (Final, Native, Private)

void URBPasscodePadComponent::OnRep_ButtonsPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "OnRep_ButtonsPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodePadComponent.ReleaseAllButtons
// (Final, Native, Public)

void URBPasscodePadComponent::ReleaseAllButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "ReleaseAllButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodePadComponent.ValidatePad_Server
// (Final, Native, Public)

void URBPasscodePadComponent::ValidatePad_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "ValidatePad_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPasscodePadComponent.BP_GetPuzzleRoomTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPasscodePadComponent::BP_GetPuzzleRoomTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "BP_GetPuzzleRoomTimeLeft");

	Params::RBPasscodePadComponent_BP_GetPuzzleRoomTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPasscodePadComponent.IsSolved_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPasscodePadComponent::IsSolved_Server() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPasscodePadComponent", "IsSolved_Server");

	Params::RBPasscodePadComponent_IsSolved_Server Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPathBlockingVolume.DisablePathBlocking
// (Final, Native, Public, BlueprintCallable)

void ARBPathBlockingVolume::DisablePathBlocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPathBlockingVolume", "DisablePathBlocking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPathBlockingVolume.EnablePathBlocking
// (Final, Native, Public, BlueprintCallable)

void ARBPathBlockingVolume::EnablePathBlocking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPathBlockingVolume", "EnablePathBlocking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPathBlockingVolume.IsBlockingPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPathBlockingVolume::IsBlockingPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPathBlockingVolume", "IsBlockingPath");

	Params::RBPathBlockingVolume_IsBlockingPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPharmaSkill.Event_OnActiveLoudStart
// (Event, Public, BlueprintEvent)

void ARBPharmaSkill::Event_OnActiveLoudStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "Event_OnActiveLoudStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPharmaSkill.Event_OnActiveLoudStop
// (Event, Public, BlueprintEvent)

void ARBPharmaSkill::Event_OnActiveLoudStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "Event_OnActiveLoudStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPharmaSkill.Event_OnActiveOnPawn
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPharmaSkill::Event_OnActiveOnPawn(class ARBPawn* Pawn, bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "Event_OnActiveOnPawn");

	Params::RBPharmaSkill_Event_OnActiveOnPawn Parms{};

	Parms.Pawn = Pawn;
	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPharmaSkill.Event_OnActiveQuietStart
// (Event, Public, BlueprintEvent)

void ARBPharmaSkill::Event_OnActiveQuietStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "Event_OnActiveQuietStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPharmaSkill.Event_OnActiveQuietStop
// (Event, Public, BlueprintEvent)

void ARBPharmaSkill::Event_OnActiveQuietStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "Event_OnActiveQuietStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPharmaSkill.OnRep_PawnInRadiusInfos
// (Final, Native, Protected)

void ARBPharmaSkill::OnRep_PawnInRadiusInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "OnRep_PawnInRadiusInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPharmaSkill.BP_GetSkillRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPharmaSkill::BP_GetSkillRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPharmaSkill", "BP_GetSkillRadius");

	Params::RBPharmaSkill_BP_GetSkillRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPhysicsVolume.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPhysicsVolume::BP_SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPhysicsVolume", "BP_SetEnabled");

	Params::RBPhysicsVolume_BP_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnKilled_Server
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Subject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickupSearchObjectiveCoordinator::OnPawnKilled_Server(class ARBPawn* InstigatorActor, class ARBPawn* Subject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnPawnKilled_Server");

	Params::RBPickupSearchObjectiveCoordinator_OnPawnKilled_Server Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.Subject = Subject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnRespawned_Server
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickupSearchObjectiveCoordinator::OnPawnRespawned_Server(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnPawnRespawned_Server");

	Params::RBPickupSearchObjectiveCoordinator_OnPawnRespawned_Server Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerDisconnect_Server
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickupSearchObjectiveCoordinator::OnPlayerDisconnect_Server(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnPlayerDisconnect_Server");

	Params::RBPickupSearchObjectiveCoordinator_OnPlayerDisconnect_Server Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerPickedUpItem_Server
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickupSearchObjectiveCoordinator::OnPlayerPickedUpItem_Server(class ARBPlayer* Player, class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnPlayerPickedUpItem_Server");

	Params::RBPickupSearchObjectiveCoordinator_OnPlayerPickedUpItem_Server Parms{};

	Parms.Player = Player;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerRevived_Server
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPickupSearchObjectiveCoordinator::OnPlayerRevived_Server(class ARBPlayer* InstigatorActor, class ARBPlayer* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnPlayerRevived_Server");

	Params::RBPickupSearchObjectiveCoordinator_OnPlayerRevived_Server Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPickupSearchObjectiveCoordinator.OnRep_PickupObjectives
// (Final, Native, Public)

void ARBPickupSearchObjectiveCoordinator::OnRep_PickupObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPickupSearchObjectiveCoordinator", "OnRep_PickupObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPingComponent.GetPingItemName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBPingComponent::GetPingItemName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingComponent", "GetPingItemName");

	Params::RBPingComponent_GetPingItemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPingComponent.GetPingWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URBPingComponent::GetPingWorldLocation(const struct FHitResult& HitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingComponent", "GetPingWorldLocation");

	Params::RBPingComponent_GetPingWorldLocation Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPingComponent.GetPlayerPingData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPlayerPingData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerPingData URBPingComponent::GetPlayerPingData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingComponent", "GetPlayerPingData");

	Params::RBPingComponent_GetPlayerPingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPingComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPingComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPingComponent", "IsEnabled");

	Params::RBPingComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPipeModule.AddSplineMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineMeshComponent* ARBPipeModule::AddSplineMeshComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPipeModule", "AddSplineMeshComponent");

	Params::RBPipeModule_AddSplineMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPipeModule.AddStaticMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transforms                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ARBPipeModule::AddStaticMesh(const struct FTransform& Transforms, class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPipeModule", "AddStaticMesh");

	Params::RBPipeModule_AddStaticMesh Parms{};

	Parms.Transforms = std::move(Transforms);
	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPipeModule.DestroyConnectors
// (Final, Native, Public, BlueprintCallable)

void ARBPipeModule::DestroyConnectors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPipeModule", "DestroyConnectors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.AddPlayerSpecificUpgrade_Server
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRBGameplayAttributeModifierInfo ModifierInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::AddPlayerSpecificUpgrade_Server(const struct FRBGameplayAttributeModifierInfo& ModifierInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "AddPlayerSpecificUpgrade_Server");

	Params::RBPlayer_AddPlayerSpecificUpgrade_Server Parms{};

	Parms.ModifierInfo = std::move(ModifierInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.ApplyAudioResetStates
// (Final, Native, Public, BlueprintCallable)

void ARBPlayer::ApplyAudioResetStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "ApplyAudioResetStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ActivateCameraShake
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCameraShakeData                 ShakeData                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          SourceLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ActivateCameraShake(const struct FCameraShakeData& ShakeData, const struct FVector& SourceLocation, class UObject* ShakeOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ActivateCameraShake");

	Params::RBPlayer_BP_ActivateCameraShake Parms{};

	Parms.ShakeData = std::move(ShakeData);
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.ShakeOwner = ShakeOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_AddProgressivePsychosis
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PsychosisAmount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGas                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBypassPlayerReductions                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_AddProgressivePsychosis(float PsychosisAmount, bool bGas, bool bBypassPlayerReductions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_AddProgressivePsychosis");

	Params::RBPlayer_BP_AddProgressivePsychosis Parms{};

	Parms.PsychosisAmount = PsychosisAmount;
	Parms.bGas = bGas;
	Parms.bBypassPlayerReductions = bBypassPlayerReductions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_AddScoringPoints
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NbPoints                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_AddScoringPoints(int32 NbPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_AddScoringPoints");

	Params::RBPlayer_BP_AddScoringPoints Parms{};

	Parms.NbPoints = NbPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ClearProgressivePsychosis
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_ClearProgressivePsychosis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ClearProgressivePsychosis");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_DamagePlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EDamageType                             DmgType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DmgAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanKill                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanKnockdown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_DamagePlayer(EDamageType DmgType, class AActor* SrcActor, float DmgAmount, bool bCanKill, bool bCanKnockdown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_DamagePlayer");

	Params::RBPlayer_BP_DamagePlayer Parms{};

	Parms.DmgType = DmgType;
	Parms.SrcActor = SrcActor;
	Parms.DmgAmount = DmgAmount;
	Parms.bCanKill = bCanKill;
	Parms.bCanKnockdown = bCanKnockdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_Debug_AdjustPlayerPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RefActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetFwd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetSide                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_Debug_AdjustPlayerPosition(class AActor* RefActor, float OffsetFwd, float OffsetSide, float OffsetHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_Debug_AdjustPlayerPosition");

	Params::RBPlayer_BP_Debug_AdjustPlayerPosition Parms{};

	Parms.RefActor = RefActor;
	Parms.OffsetFwd = OffsetFwd;
	Parms.OffsetSide = OffsetSide;
	Parms.OffsetHeight = OffsetHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_FlagAsFakePlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_FlagAsFakePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_FlagAsFakePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceCrouchOnFakePlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_ForceCrouchOnFakePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceCrouchOnFakePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceDropHeldObjectives
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_ForceDropHeldObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceDropHeldObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceHitReaction
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bCancelInteraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerHitReactionType                  HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ForceHitReaction(bool bCancelInteraction, EPlayerHitReactionType HitReactionType, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceHitReaction");

	Params::RBPlayer_BP_ForceHitReaction Parms{};

	Parms.bCancelInteraction = bCancelInteraction;
	Parms.HitReactionType = HitReactionType;
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceInteractionOnFakePlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ForceInteractionOnFakePlayer(float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceInteractionOnFakePlayer");

	Params::RBPlayer_BP_ForceInteractionOnFakePlayer Parms{};

	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForcePickupItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPickup*                        Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ForcePickupItem(class ARBPickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForcePickupItem");

	Params::RBPlayer_BP_ForcePickupItem Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceSpecialAnimation
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCancelInteraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollisionEnabled                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ForceSpecialAnimation(bool bCancelInteraction, class AActor* TargetLocation, class UAnimSequence* Animation, bool bCollisionEnabled, float blendInTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceSpecialAnimation");

	Params::RBPlayer_BP_ForceSpecialAnimation Parms{};

	Parms.bCancelInteraction = bCancelInteraction;
	Parms.TargetLocation = TargetLocation;
	Parms.Animation = Animation;
	Parms.bCollisionEnabled = bCollisionEnabled;
	Parms.blendInTime = blendInTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceTradeOnFakePlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_ForceTradeOnFakePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceTradeOnFakePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_ForceWakeUpSequence
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPlayerStart*                   PlayerStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_ForceWakeUpSequence(class ARBPlayerStart* PlayerStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ForceWakeUpSequence");

	Params::RBPlayer_BP_ForceWakeUpSequence Parms{};

	Parms.PlayerStart = PlayerStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_GetNoStaminaConsumptionDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayer::BP_GetNoStaminaConsumptionDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetNoStaminaConsumptionDuration");

	Params::RBPlayer_BP_GetNoStaminaConsumptionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetPickupInFocus
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    OutIsSwap                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBPlayer::BP_GetPickupInFocus(bool* OutIsSwap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetPickupInFocus");

	Params::RBPlayer_BP_GetPickupInFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsSwap != nullptr)
		*OutIsSwap = Parms.OutIsSwap;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_HasInventoryItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARBPickup>            ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_HasInventoryItem(TSubclassOf<class ARBPickup> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_HasInventoryItem");

	Params::RBPlayer_BP_HasInventoryItem Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_InstaDown
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_InstaDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_InstaDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_InstaKill
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_InstaKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_InstaKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_OnTrapRoomFailed
// (Event, Public, BlueprintEvent)

void ARBPlayer::BP_OnTrapRoomFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_OnTrapRoomFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.BP_QuickTestServer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayer::BP_QuickTestServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_QuickTestServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_SetGodMode
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bGod                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_SetGodMode(bool bGod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_SetGodMode");

	Params::RBPlayer_BP_SetGodMode Parms{};

	Parms.bGod = bGod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_SetSpecialMoveCameraLimits
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MinYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_SetSpecialMoveCameraLimits(float MinYaw, float MaxYaw, float MinPitch, float MaxPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_SetSpecialMoveCameraLimits");

	Params::RBPlayer_BP_SetSpecialMoveCameraLimits Parms{};

	Parms.MinYaw = MinYaw;
	Parms.MaxYaw = MaxYaw;
	Parms.MinPitch = MinPitch;
	Parms.MaxPitch = MaxPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_StartDizziness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBDizzinessConfig*               ConfigAsset                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_StartDizziness(const class URBDizzinessConfig* ConfigAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_StartDizziness");

	Params::RBPlayer_BP_StartDizziness Parms{};

	Parms.ConfigAsset = ConfigAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_StartHallucination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHallucinationType                      HalluType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBHallucinationConfig*           Config                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_StartHallucination(EHallucinationType HalluType, const class URBHallucinationConfig* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_StartHallucination");

	Params::RBPlayer_BP_StartHallucination Parms{};

	Parms.HalluType = HalluType;
	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_StopCameraShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstantly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreOwnerCondition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_StopCameraShake(bool bInstantly, class UObject* ShakeOwner, bool bIgnoreOwnerCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_StopCameraShake");

	Params::RBPlayer_BP_StopCameraShake Parms{};

	Parms.bInstantly = bInstantly;
	Parms.ShakeOwner = ShakeOwner;
	Parms.bIgnoreOwnerCondition = bIgnoreOwnerCondition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_StopDizziness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFadeOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_StopDizziness(bool bFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_StopDizziness");

	Params::RBPlayer_BP_StopDizziness Parms{};

	Parms.bFadeOut = bFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_StopHallucination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFadeOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_StopHallucination(bool bFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_StopHallucination");

	Params::RBPlayer_BP_StopHallucination Parms{};

	Parms.bFadeOut = bFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.BP_TestHitReaction
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EPlayerHitReactionType                  HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::BP_TestHitReaction(EPlayerHitReactionType HitReactionType, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_TestHitReaction");

	Params::RBPlayer_BP_TestHitReaction Parms{};

	Parms.HitReactionType = HitReactionType;
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.ClearInventory_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIncludeActiveSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::ClearInventory_Server(bool bIncludeActiveSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "ClearInventory_Server");

	Params::RBPlayer_ClearInventory_Server Parms{};

	Parms.bIncludeActiveSkill = bIncludeActiveSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_DebugSimultaneousJumpForward
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_DebugSimultaneousJumpForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_DebugSimultaneousJumpForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_ForceNightVision
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bNVState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Client_ForceNightVision(bool bNVState, bool bDisableInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_ForceNightVision");

	Params::RBPlayer_Client_ForceNightVision Parms{};

	Parms.bNVState = bNVState;
	Parms.bDisableInput = bDisableInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_HideCustomInteractionMessage
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_HideCustomInteractionMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_HideCustomInteractionMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_OnRepossessed
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   PawnTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Client_OnRepossessed(float PawnTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_OnRepossessed");

	Params::RBPlayer_Client_OnRepossessed Parms{};

	Parms.PawnTime = PawnTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_PlayDisturbanceWarning
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_PlayDisturbanceWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_PlayDisturbanceWarning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_RemoveObjectiveIcon
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Client_RemoveObjectiveIcon(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_RemoveObjectiveIcon");

	Params::RBPlayer_Client_RemoveObjectiveIcon Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_ShowChemicalTutorial
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_ShowChemicalTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_ShowChemicalTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_ShowCustomInteractionMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             Message                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// EMessagePriority                        Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Client_ShowCustomInteractionMessage(const class FText& Message, EMessagePriority Priority, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_ShowCustomInteractionMessage");

	Params::RBPlayer_Client_ShowCustomInteractionMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.Priority = Priority;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_ShowPeriodicHazardTutorial
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bKnockedDown                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Client_ShowPeriodicHazardTutorial(bool bKnockedDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_ShowPeriodicHazardTutorial");

	Params::RBPlayer_Client_ShowPeriodicHazardTutorial Parms{};

	Parms.bKnockedDown = bKnockedDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_ShowPermanentDamageTutorial
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_ShowPermanentDamageTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_ShowPermanentDamageTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Client_TalkWheelThrottled
// (Net, NetReliable, Native, Event, Public, NetClient)

void ARBPlayer::Client_TalkWheelThrottled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Client_TalkWheelThrottled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Debug_ForceSASChairInteraction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class URBSASChairPanelComponent*        SasChairPanel                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Debug_ForceSASChairInteraction(class URBSASChairPanelComponent* SasChairPanel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Debug_ForceSASChairInteraction");

	Params::RBPlayer_Debug_ForceSASChairInteraction Parms{};

	Parms.SasChairPanel = SasChairPanel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Event_InitReplicated
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_InitReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_InitReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnActiveEffectAdded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FActiveEffectTrackingData        ActiveEffectTrackingDataEntry                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnActiveEffectAdded(const struct FActiveEffectTrackingData& ActiveEffectTrackingDataEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveEffectAdded");

	Params::RBPlayer_Event_OnActiveEffectAdded Parms{};

	Parms.ActiveEffectTrackingDataEntry = std::move(ActiveEffectTrackingDataEntry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnActiveEffectRemoved
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             EffectId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnActiveEffectRemoved(const class FName& EffectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveEffectRemoved");

	Params::RBPlayer_Event_OnActiveEffectRemoved Parms{};

	Parms.EffectId = EffectId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnActiveEffectsUpdated
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnActiveEffectsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveEffectsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnActiveEffectUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FActiveEffectTrackingData        ActiveEffectTrackingDataEntry                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnActiveEffectUpdated(const struct FActiveEffectTrackingData& ActiveEffectTrackingDataEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveEffectUpdated");

	Params::RBPlayer_Event_OnActiveEffectUpdated Parms{};

	Parms.ActiveEffectTrackingDataEntry = std::move(ActiveEffectTrackingDataEntry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnActiveSkillActorChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Param_ActiveSkillActor                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnActiveSkillActorChanged(class AActor* Param_ActiveSkillActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveSkillActorChanged");

	Params::RBPlayer_Event_OnActiveSkillActorChanged Parms{};

	Parms.Param_ActiveSkillActor = Param_ActiveSkillActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnActiveSkillRestrictionFinished
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnActiveSkillRestrictionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveSkillRestrictionFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnActiveSkillRestrictionStarted
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnActiveSkillRestrictionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnActiveSkillRestrictionStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnChemicalZoneEntered
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnChemicalZoneEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnChemicalZoneEntered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnChemicalZoneExited
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnChemicalZoneExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnChemicalZoneExited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnContinuousPsychosisGained
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnContinuousPsychosisGained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnContinuousPsychosisGained");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnCustomizationChanged
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnCustomizationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnHealthRestored
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnHealthRestored()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnHealthRestored");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnLastConsumedBatteryTypeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EItemType                               batteryType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnLastConsumedBatteryTypeChanged(EItemType batteryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnLastConsumedBatteryTypeChanged");

	Params::RBPlayer_Event_OnLastConsumedBatteryTypeChanged Parms{};

	Parms.batteryType = batteryType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnLocalLookAt
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnLocalLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnLocalLookAt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnNVAnimationNotify
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bWantsNvOn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENightVisionAnimNotifyType              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Event_OnNVAnimationNotify(bool bWantsNvOn, ENightVisionAnimNotifyType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnNVAnimationNotify");

	Params::RBPlayer_Event_OnNVAnimationNotify Parms{};

	Parms.bWantsNvOn = bWantsNvOn;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_OnPlayerAnimInstanceChanged
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnPlayerAnimInstanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnPlayerAnimInstanceChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnPlayerPerspectiveChanged
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnPlayerPerspectiveChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnPlayerPerspectiveChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnPlayerStateChanged
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnPlayerStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnPlayerStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnRemainingRespawnIncreased
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_OnRemainingRespawnIncreased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnRemainingRespawnIncreased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_OnWakeUp
// (Event, Protected, BlueprintEvent)

void ARBPlayer::Event_OnWakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_OnWakeUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_PlayHitReactionEffects
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FPlayerHitReactionParams         HitReaction                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          AttackLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitRelativeAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Event_PlayHitReactionEffects(const struct FPlayerHitReactionParams& HitReaction, const struct FVector& AttackLoc, float HitRelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_PlayHitReactionEffects");

	Params::RBPlayer_Event_PlayHitReactionEffects Parms{};

	Parms.HitReaction = std::move(HitReaction);
	Parms.AttackLoc = std::move(AttackLoc);
	Parms.HitRelativeAngle = HitRelativeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.Event_StartSpectatingLocally
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_StartSpectatingLocally()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_StartSpectatingLocally");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.Event_StopSpectatingLocally
// (Event, Public, BlueprintEvent)

void ARBPlayer::Event_StopSpectatingLocally()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Event_StopSpectatingLocally");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.ForceNightVision
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNVState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::ForceNightVision(bool bNVState, bool bDisableInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "ForceNightVision");

	Params::RBPlayer_ForceNightVision Parms{};

	Parms.bNVState = bNVState;
	Parms.bDisableInput = bDisableInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.LogPlayerEvent_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExplicitValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::LogPlayerEvent_Server(EPlayerEvent EventType, int32 ExplicitValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "LogPlayerEvent_Server");

	Params::RBPlayer_LogPlayerEvent_Server Parms{};

	Parms.EventType = EventType;
	Parms.ExplicitValue = ExplicitValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ActivateCameraShake
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FCameraShakeData                 ShakeData                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          SourceLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ActivateCameraShake(const struct FCameraShakeData& ShakeData, const struct FVector& SourceLocation, class UObject* ShakeOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ActivateCameraShake");

	Params::RBPlayer_Multicast_ActivateCameraShake Parms{};

	Parms.ShakeData = std::move(ShakeData);
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.ShakeOwner = ShakeOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_AddPingForDroppedItem
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPickup*                        DroppedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PingLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_AddPingForDroppedItem(class ARBPickup* DroppedItem, const struct FVector& PingLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_AddPingForDroppedItem");

	Params::RBPlayer_Multicast_AddPingForDroppedItem Parms{};

	Parms.DroppedItem = DroppedItem;
	Parms.PingLocation = std::move(PingLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_CancelStateOnDamage
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_CancelStateOnDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_CancelStateOnDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ChallengeArmWrestlingPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        ChallengedPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ChallengeArmWrestlingPlayer(class ARBPlayer* ChallengedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ChallengeArmWrestlingPlayer");

	Params::RBPlayer_Multicast_ChallengeArmWrestlingPlayer Parms{};

	Parms.ChallengedPlayer = ChallengedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_Cheat_ToggleInvisibleToBots
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_Cheat_ToggleInvisibleToBots(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_Cheat_ToggleInvisibleToBots");

	Params::RBPlayer_Multicast_Cheat_ToggleInvisibleToBots Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_Cheat_ToggleSilentForBots
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_Cheat_ToggleSilentForBots(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_Cheat_ToggleSilentForBots");

	Params::RBPlayer_Multicast_Cheat_ToggleSilentForBots Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_Command
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FString                           MulticastCommand                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_Command(const class FString& MulticastCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_Command");

	Params::RBPlayer_Multicast_Command Parms{};

	Parms.MulticastCommand = std::move(MulticastCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ConsumeInventoryItem
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPickup*                        PickupItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ConsumeInventoryItem(class ARBPickup* PickupItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ConsumeInventoryItem");

	Params::RBPlayer_Multicast_ConsumeInventoryItem Parms{};

	Parms.PickupItem = PickupItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ConsumeStaminaItem
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   StartPawnTimestamp                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NoStaminaConsumptionDuration                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StaminaRestoreAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementSpeedMultiplier                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ConsumeStaminaItem(float StartPawnTimestamp, float NoStaminaConsumptionDuration, float StaminaRestoreAmount, float MovementSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ConsumeStaminaItem");

	Params::RBPlayer_Multicast_ConsumeStaminaItem Parms{};

	Parms.StartPawnTimestamp = StartPawnTimestamp;
	Parms.NoStaminaConsumptionDuration = NoStaminaConsumptionDuration;
	Parms.StaminaRestoreAmount = StaminaRestoreAmount;
	Parms.MovementSpeedMultiplier = MovementSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DebugInventory
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DebugInventory(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DebugInventory");

	Params::RBPlayer_Multicast_DebugInventory Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DebugSimultaneousInteraction
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_DebugSimultaneousInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DebugSimultaneousInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DisplayDeadbodyIcon
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          DeadbodyLocation                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DisplayDeadbodyIcon(const struct FVector& DeadbodyLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DisplayDeadbodyIcon");

	Params::RBPlayer_Multicast_DisplayDeadbodyIcon Parms{};

	Parms.DeadbodyLocation = std::move(DeadbodyLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DoHealthRegenEffect
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_DoHealthRegenEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DoHealthRegenEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DoItemPickup
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPickup*                        PickupItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DoItemPickup(class ARBPickup* PickupItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DoItemPickup");

	Params::RBPlayer_Multicast_DoItemPickup Parms{};

	Parms.PickupItem = PickupItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DoShove
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FPlayerShoveData                 Param_PlayerShove                                      (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DoShove(const struct FPlayerShoveData& Param_PlayerShove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DoShove");

	Params::RBPlayer_Multicast_DoShove Parms{};

	Parms.Param_PlayerShove = std::move(Param_PlayerShove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DrawDebugBox
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DrawDebugBox(const struct FVector& Location, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DrawDebugBox");

	Params::RBPlayer_Multicast_DrawDebugBox Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = std::move(Extent);
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DrawDebugCapsule
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DrawDebugCapsule(const struct FVector& Location, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DrawDebugCapsule");

	Params::RBPlayer_Multicast_DrawDebugCapsule Parms{};

	Parms.Location = std::move(Location);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DrawDebugLine
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          LocationA                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationB                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DrawDebugLine(const struct FVector& LocationA, const struct FVector& LocationB, const struct FColor& Color, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DrawDebugLine");

	Params::RBPlayer_Multicast_DrawDebugLine Parms{};

	Parms.LocationA = std::move(LocationA);
	Parms.LocationB = std::move(LocationB);
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DrawDebugSphere
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DrawDebugSphere(const struct FVector& Location, float Radius, const struct FColor& Color, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DrawDebugSphere");

	Params::RBPlayer_Multicast_DrawDebugSphere Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_DrawStimulusDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStimulusType                           StimulusType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPerceived                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_DrawStimulusDebug(const struct FVector& Location, class AActor* SourceActor, EStimulusType StimulusType, float Range, bool bIsPerceived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_DrawStimulusDebug");

	Params::RBPlayer_Multicast_DrawStimulusDebug Parms{};

	Parms.Location = std::move(Location);
	Parms.SourceActor = SourceActor;
	Parms.StimulusType = StimulusType;
	Parms.Range = Range;
	Parms.bIsPerceived = bIsPerceived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_EnterGroundAndPoundVictim
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AmbushDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpaceBase*                  PlayerAnimBS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_EnterGroundAndPoundVictim(class ARBPawn* Attacker, const struct FVector& TargetPos, const struct FVector& AmbushDir, class UBlendSpaceBase* PlayerAnimBS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_EnterGroundAndPoundVictim");

	Params::RBPlayer_Multicast_EnterGroundAndPoundVictim Parms{};

	Parms.Attacker = Attacker;
	Parms.TargetPos = std::move(TargetPos);
	Parms.AmbushDir = std::move(AmbushDir);
	Parms.PlayerAnimBS = PlayerAnimBS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ExitGroundAndPound
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpecialMove                            PlayerSM                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageResultType                       DamageResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    PlayerExitAnimSeq                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ExitGroundAndPound(ESpecialMove PlayerSM, EDamageResultType DamageResult, class UAnimSequence* PlayerExitAnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ExitGroundAndPound");

	Params::RBPlayer_Multicast_ExitGroundAndPound Parms{};

	Parms.PlayerSM = PlayerSM;
	Parms.DamageResult = DamageResult;
	Parms.PlayerExitAnimSeq = PlayerExitAnimSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_FlagAsFakePlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_FlagAsFakePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_FlagAsFakePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_GainCurrency
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ECurrencyType                           CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_GainCurrency(ECurrencyType CurrencyType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_GainCurrency");

	Params::RBPlayer_Multicast_GainCurrency Parms{};

	Parms.CurrencyType = CurrencyType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_GetUpFromKnockedDown
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_GetUpFromKnockedDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_GetUpFromKnockedDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_GhostPawn
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// bool                                    bGhost                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CamLoc                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CamRot                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_GhostPawn(bool bGhost, const struct FVector& CamLoc, const struct FRotator& CamRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_GhostPawn");

	Params::RBPlayer_Multicast_GhostPawn Parms{};

	Parms.bGhost = bGhost;
	Parms.CamLoc = std::move(CamLoc);
	Parms.CamRot = std::move(CamRot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_HitReaction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FPlayerHitReactionParams         HitReaction                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSchedule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_HitReaction(const struct FPlayerHitReactionParams& HitReaction, bool bSchedule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_HitReaction");

	Params::RBPlayer_Multicast_HitReaction Parms{};

	Parms.HitReaction = std::move(HitReaction);
	Parms.bSchedule = bSchedule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_InteractDynamicObstacle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class ARBDynamicObstacle*               Obstacle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CharLocationRef                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MovementAcceleration                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_InteractDynamicObstacle(class ARBDynamicObstacle* Obstacle, const struct FVector& CharLocationRef, const struct FVector& MovementAcceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_InteractDynamicObstacle");

	Params::RBPlayer_Multicast_InteractDynamicObstacle Parms{};

	Parms.Obstacle = Obstacle;
	Parms.CharLocationRef = std::move(CharLocationRef);
	Parms.MovementAcceleration = std::move(MovementAcceleration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_OnAffectedByGas
// (Net, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_OnAffectedByGas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_OnAffectedByGas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_OnContinuousPsychosisGained
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_OnContinuousPsychosisGained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_OnContinuousPsychosisGained");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_OnExhaustedStateChanged
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bNewExhaustedState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_OnExhaustedStateChanged(bool bNewExhaustedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_OnExhaustedStateChanged");

	Params::RBPlayer_Multicast_OnExhaustedStateChanged Parms{};

	Parms.bNewExhaustedState = bNewExhaustedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_OnKnockedDown
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           KnockDownInstigator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_OnKnockedDown(class AActor* KnockDownInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_OnKnockedDown");

	Params::RBPlayer_Multicast_OnKnockedDown Parms{};

	Parms.KnockDownInstigator = KnockDownInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_OnTrapRoomFailed
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_OnTrapRoomFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_OnTrapRoomFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PerformStandardFatality
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FStandardFatalityData            FatalityData                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PerformStandardFatality(const struct FStandardFatalityData& FatalityData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PerformStandardFatality");

	Params::RBPlayer_Multicast_PerformStandardFatality Parms{};

	Parms.FatalityData = std::move(FatalityData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PickupLargeObject
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELargeObjectPickupSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PickupLargeObject(class ARBLargePickup* LargePickup, const struct FVector& Location, const struct FVector& Forward, ELargeObjectPickupSubtype Subtype)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PickupLargeObject");

	Params::RBPlayer_Multicast_PickupLargeObject Parms{};

	Parms.LargePickup = LargePickup;
	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);
	Parms.Subtype = Subtype;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PlayGrabbed
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FPairedTwoPhaseAnimData          AnimData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ARBNPC*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PlayGrabbed(const struct FPairedTwoPhaseAnimData& AnimData, class ARBNPC* Attacker, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PlayGrabbed");

	Params::RBPlayer_Multicast_PlayGrabbed Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.Attacker = Attacker;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PlayPulledFromHidespot
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FPairedTwoPhaseAnimData          AnimData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ARBNPC*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBHidespotComponent*             Hidespot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PlayPulledFromHidespot(const struct FPairedTwoPhaseAnimData& AnimData, class ARBNPC* Attacker, class URBHidespotComponent* Hidespot, const struct FVector& TargetPos, const struct FVector& TargetDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PlayPulledFromHidespot");

	Params::RBPlayer_Multicast_PlayPulledFromHidespot Parms{};

	Parms.AnimData = std::move(AnimData);
	Parms.Attacker = Attacker;
	Parms.Hidespot = Hidespot;
	Parms.TargetPos = std::move(TargetPos);
	Parms.TargetDir = std::move(TargetDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PlayUpperBodyAnimation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// EUpperBodyAnimationType                 AnimType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCameraRelative                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeftArm                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRightArm                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PlayUpperBodyAnimation(EUpperBodyAnimationType AnimType, bool bIsCameraRelative, bool bLeftArm, bool bRightArm, float PitchAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PlayUpperBodyAnimation");

	Params::RBPlayer_Multicast_PlayUpperBodyAnimation Parms{};

	Parms.AnimType = AnimType;
	Parms.bIsCameraRelative = bIsCameraRelative;
	Parms.bLeftArm = bLeftArm;
	Parms.bRightArm = bRightArm;
	Parms.PitchAngle = PitchAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_PutDownLargeObject
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPredicted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_PutDownLargeObject(class ARBLargePickup* LargePickup, const struct FVector& Location, const struct FQuat& Rotation, bool bPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_PutDownLargeObject");

	Params::RBPlayer_Multicast_PutDownLargeObject Parms{};

	Parms.LargePickup = LargePickup;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.bPredicted = bPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_QuickTest
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          TestLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_QuickTest(const struct FVector& TestLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_QuickTest");

	Params::RBPlayer_Multicast_QuickTest Parms{};

	Parms.TestLocation = std::move(TestLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_RemoveAllPings
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_RemoveAllPings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_RemoveAllPings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_RemovePing
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EPlayerPingType                         PingType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_RemovePing(EPlayerPingType PingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_RemovePing");

	Params::RBPlayer_Multicast_RemovePing Parms{};

	Parms.PingType = PingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ScheduleCoopMove
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FCoopMoveData                    CoopMoveData                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FScheduledSpecialMoveData        ScheduledSpecialMoveData                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ScheduleCoopMove(const struct FCoopMoveData& CoopMoveData, const struct FScheduledSpecialMoveData& ScheduledSpecialMoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ScheduleCoopMove");

	Params::RBPlayer_Multicast_ScheduleCoopMove Parms{};

	Parms.CoopMoveData = std::move(CoopMoveData);
	Parms.ScheduledSpecialMoveData = std::move(ScheduledSpecialMoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ScheduleStartCoopBash
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   PawnTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ScheduleStartCoopBash(float PawnTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ScheduleStartCoopBash");

	Params::RBPlayer_Multicast_ScheduleStartCoopBash Parms{};

	Parms.PawnTime = PawnTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SetCoopMoveOfferingState
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// ECoopMoveOfferState                     CoopMoveOfferingState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLedgeMarker*                   LedgeMarker                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SpecificPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECoopMoveType                           CoopMoveOfferingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBasicDirection                         BasicDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SetCoopMoveOfferingState(ECoopMoveOfferState CoopMoveOfferingState, class ARBLedgeMarker* LedgeMarker, class ARBPlayer* SpecificPlayer, ECoopMoveType CoopMoveOfferingType, EBasicDirection BasicDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SetCoopMoveOfferingState");

	Params::RBPlayer_Multicast_SetCoopMoveOfferingState Parms{};

	Parms.CoopMoveOfferingState = CoopMoveOfferingState;
	Parms.LedgeMarker = LedgeMarker;
	Parms.SpecificPlayer = SpecificPlayer;
	Parms.CoopMoveOfferingType = CoopMoveOfferingType;
	Parms.BasicDirection = BasicDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SetGodMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SetGodMode(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SetGodMode");

	Params::RBPlayer_Multicast_SetGodMode Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SetPainKillerEffectsDuration
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SetPainKillerEffectsDuration(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SetPainKillerEffectsDuration");

	Params::RBPlayer_Multicast_SetPainKillerEffectsDuration Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SetSpecialMoveCameraLimits
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   MinYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SetSpecialMoveCameraLimits(float MinYaw, float MaxYaw, float MinPitch, float MaxPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SetSpecialMoveCameraLimits");

	Params::RBPlayer_Multicast_SetSpecialMoveCameraLimits Parms{};

	Parms.MinYaw = MinYaw;
	Parms.MaxYaw = MaxYaw;
	Parms.MinPitch = MinPitch;
	Parms.MaxPitch = MaxPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SetTraversalData
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FTraversalMoveData               MoveData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SetTraversalData(const struct FTraversalMoveData& MoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SetTraversalData");

	Params::RBPlayer_Multicast_SetTraversalData Parms{};

	Parms.MoveData = std::move(MoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ShakeOffPushable
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          PushedDir                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_ShakeOffPushable(const struct FVector& PushedDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ShakeOffPushable");

	Params::RBPlayer_Multicast_ShakeOffPushable Parms{};

	Parms.PushedDir = std::move(PushedDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_SpecialAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FScheduledSpecialAnimData        SpecialAnimData                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EScriptedAnimationType                  ScriptedAnimType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_SpecialAnimation(const struct FScheduledSpecialAnimData& SpecialAnimData, EScriptedAnimationType ScriptedAnimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_SpecialAnimation");

	Params::RBPlayer_Multicast_SpecialAnimation Parms{};

	Parms.SpecialAnimData = std::move(SpecialAnimData);
	Parms.ScriptedAnimType = ScriptedAnimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StartDoorOperation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBDoor*                          Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StartDoorOperation(class ARBDoor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StartDoorOperation");

	Params::RBPlayer_Multicast_StartDoorOperation Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StartHallucination
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FHallucinationData               HalluData                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StartHallucination(const struct FHallucinationData& HalluData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StartHallucination");

	Params::RBPlayer_Multicast_StartHallucination Parms{};

	Parms.HalluData = std::move(HalluData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StartVolumetricFogLightmapFade
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bFadeIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StartVolumetricFogLightmapFade(bool bFadeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StartVolumetricFogLightmapFade");

	Params::RBPlayer_Multicast_StartVolumetricFogLightmapFade Parms{};

	Parms.bFadeIn = bFadeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StopAdrenaline
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   StopPawnTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StopAdrenaline(float StopPawnTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StopAdrenaline");

	Params::RBPlayer_Multicast_StopAdrenaline Parms{};

	Parms.StopPawnTime = StopPawnTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StopCameraShake
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bInstantly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ShakeOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreOwnerCondition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StopCameraShake(bool bInstantly, class UObject* ShakeOwner, bool bIgnoreOwnerCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StopCameraShake");

	Params::RBPlayer_Multicast_StopCameraShake Parms{};

	Parms.bInstantly = bInstantly;
	Parms.ShakeOwner = ShakeOwner;
	Parms.bIgnoreOwnerCondition = bIgnoreOwnerCondition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_StopHallucination
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EHallucinationType                      HalluType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHallucinationFadeOutType               FadeOutType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_StopHallucination(EHallucinationType HalluType, EHallucinationFadeOutType FadeOutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_StopHallucination");

	Params::RBPlayer_Multicast_StopHallucination Parms{};

	Parms.HalluType = HalluType;
	Parms.FadeOutType = FadeOutType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_TalkWheel
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// ETalkWheelAction                        Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurrentEyeLocation                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurrentEyeForward                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_TalkWheel(ETalkWheelAction Action, const struct FVector& CurrentEyeLocation, const struct FVector& CurrentEyeForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_TalkWheel");

	Params::RBPlayer_Multicast_TalkWheel Parms{};

	Parms.Action = Action;
	Parms.CurrentEyeLocation = std::move(CurrentEyeLocation);
	Parms.CurrentEyeForward = std::move(CurrentEyeForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_TeleportPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// float                                   TeleportPawnTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TeleportServerTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLoc                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRot                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsInstant                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdjustLocForFeets                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterruptAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Multicast_TeleportPlayer(float TeleportPawnTime, float TeleportServerTime, const struct FVector& NewLoc, const struct FRotator& NewRot, bool bIsInstant, bool bAdjustLocForFeets, bool bInterruptAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_TeleportPlayer");

	Params::RBPlayer_Multicast_TeleportPlayer Parms{};

	Parms.TeleportPawnTime = TeleportPawnTime;
	Parms.TeleportServerTime = TeleportServerTime;
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewRot = std::move(NewRot);
	Parms.bIsInstant = bIsInstant;
	Parms.bAdjustLocForFeets = bAdjustLocForFeets;
	Parms.bInterruptAction = bInterruptAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_ThrowWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_ThrowWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_ThrowWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Multicast_TriggerTraversalBlendToLocomotionMode
// (Net, Native, Event, NetMulticast, Public)

void ARBPlayer::Multicast_TriggerTraversalBlendToLocomotionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Multicast_TriggerTraversalBlendToLocomotionMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Muticast_OnPsychosisSpookActivated
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBPlayer::Muticast_OnPsychosisSpookActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Muticast_OnPsychosisSpookActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnAffectedByPsychosisGas_BP
// (Event, Public, BlueprintEvent)

void ARBPlayer::OnAffectedByPsychosisGas_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnAffectedByPsychosisGas_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.OnBleedingStateChanged
// (Event, Public, BlueprintEvent)

void ARBPlayer::OnBleedingStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnBleedingStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayer.OnConsumeItemPreviousInteractableChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnConsumeItemPreviousInteractableChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnConsumeItemPreviousInteractableChangedCallback");

	Params::RBPlayer_OnConsumeItemPreviousInteractableChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnCurrentEquippedItemChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnCurrentEquippedItemChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnCurrentEquippedItemChangedCallback");

	Params::RBPlayer_OnCurrentEquippedItemChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnCurrentLargePickupChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnCurrentLargePickupChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnCurrentLargePickupChangedCallback");

	Params::RBPlayer_OnCurrentLargePickupChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnEffectiveNumberOfPlayersChanged
// (Final, Native, Public)

void ARBPlayer::OnEffectiveNumberOfPlayersChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnEffectiveNumberOfPlayersChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnHoldConsumeActionItemChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnHoldConsumeActionItemChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnHoldConsumeActionItemChangedCallback");

	Params::RBPlayer_OnHoldConsumeActionItemChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnInventorySlotCountChanged
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnInventorySlotCountChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnInventorySlotCountChanged");

	Params::RBPlayer_OnInventorySlotCountChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnInventoryUpdated
// (Final, Native, Public)

void ARBPlayer::OnInventoryUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnInventoryUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnIsAimingThrowableChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnIsAimingThrowableChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnIsAimingThrowableChangedCallback");

	Params::RBPlayer_OnIsAimingThrowableChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnIsNVActiveChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnIsNVActiveChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnIsNVActiveChangedCallback");

	Params::RBPlayer_OnIsNVActiveChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnItemHeldChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnItemHeldChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnItemHeldChangedCallback");

	Params::RBPlayer_OnItemHeldChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnMaxHealthChanged
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnMaxHealthChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnMaxHealthChanged");

	Params::RBPlayer_OnMaxHealthChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnMaxNVBatteryChanged
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnMaxNVBatteryChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnMaxNVBatteryChanged");

	Params::RBPlayer_OnMaxNVBatteryChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnMaxStaminaChanged
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnMaxStaminaChanged(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnMaxStaminaChanged");

	Params::RBPlayer_OnMaxStaminaChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBPlayer.OnPlayerCustomizationChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ARBPlayer*                        RBPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnPlayerCustomizationChanged__DelegateSignature(class ARBPlayer* RBPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnPlayerCustomizationChanged__DelegateSignature");

	Params::RBPlayer_OnPlayerCustomizationChanged__DelegateSignature Parms{};

	Parms.RBPlayer = RBPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.OnPlayerUpgradesChanged
// (Final, Native, Public)

void ARBPlayer::OnPlayerUpgradesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnPlayerUpgradesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ActiveEffectTrackingDataEntries
// (Final, Native, Public)

void ARBPlayer::OnRep_ActiveEffectTrackingDataEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ActiveEffectTrackingDataEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ActivePuzzleRoom
// (Final, Native, Public)

void ARBPlayer::OnRep_ActivePuzzleRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ActivePuzzleRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ActiveSkillActor
// (Final, Native, Public)

void ARBPlayer::OnRep_ActiveSkillActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ActiveSkillActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ActiveSkillRestrictedPawnTime
// (Final, Native, Public)

void ARBPlayer::OnRep_ActiveSkillRestrictedPawnTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ActiveSkillRestrictedPawnTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_AutoHealthRegenInProgress
// (Final, Native, Public)

void ARBPlayer::OnRep_AutoHealthRegenInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_AutoHealthRegenInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_BleedingLeft
// (Final, Native, Public)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_BleedingLeft(float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_BleedingLeft");

	Params::RBPlayer_OnRep_BleedingLeft Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ChaseNPCs
// (Final, Native, Public)

void ARBPlayer::OnRep_ChaseNPCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ChaseNPCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ColdPawnTimestamp
// (Final, Native, Public)

void ARBPlayer::OnRep_ColdPawnTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ColdPawnTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ConsumeItemPreviousInteractable
// (Final, Native, Public)

void ARBPlayer::OnRep_ConsumeItemPreviousInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ConsumeItemPreviousInteractable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_CoopTrapDart
// (Final, Native, Protected)
// Parameters:
// class ARBTrapDart*                      LastTrapDart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_CoopTrapDart(class ARBTrapDart* LastTrapDart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_CoopTrapDart");

	Params::RBPlayer_OnRep_CoopTrapDart Parms{};

	Parms.LastTrapDart = LastTrapDart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_CurrentEquippedItem
// (Final, Native, Public)

void ARBPlayer::OnRep_CurrentEquippedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_CurrentEquippedItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_CurrentLargePickup
// (Final, Native, Public)

void ARBPlayer::OnRep_CurrentLargePickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_CurrentLargePickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_CurrentPsychosisBracket
// (Final, Native, Protected)
// Parameters:
// int32                                   OldPsychosisBracket                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_CurrentPsychosisBracket(int32 OldPsychosisBracket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_CurrentPsychosisBracket");

	Params::RBPlayer_OnRep_CurrentPsychosisBracket Parms{};

	Parms.OldPsychosisBracket = OldPsychosisBracket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_DamageBoostPawnTimestamps
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<float>                           OldDamageBoostPawnTimestamps                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_DamageBoostPawnTimestamps(const TArray<float>& OldDamageBoostPawnTimestamps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_DamageBoostPawnTimestamps");

	Params::RBPlayer_OnRep_DamageBoostPawnTimestamps Parms{};

	Parms.OldDamageBoostPawnTimestamps = std::move(OldDamageBoostPawnTimestamps);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_EffectivePsychosisMeter
// (Final, Native, Protected)
// Parameters:
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_EffectivePsychosisMeter(int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_EffectivePsychosisMeter");

	Params::RBPlayer_OnRep_EffectivePsychosisMeter Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_EquippedInventory
// (Final, Native, Public)

void ARBPlayer::OnRep_EquippedInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_EquippedInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_HoldConsumeActionItem
// (Final, Native, Public)

void ARBPlayer::OnRep_HoldConsumeActionItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_HoldConsumeActionItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_IgnorePlayerToPlayerCollisions
// (Final, Native, Public)

void ARBPlayer::OnRep_IgnorePlayerToPlayerCollisions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_IgnorePlayerToPlayerCollisions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_IsAimingThrowable
// (Final, Native, Public)

void ARBPlayer::OnRep_IsAimingThrowable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_IsAimingThrowable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_IsNVActive
// (Final, Native, Public)

void ARBPlayer::OnRep_IsNVActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_IsNVActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_ItemHeld
// (Final, Native, Public)

void ARBPlayer::OnRep_ItemHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_ItemHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_NVBattery
// (Final, Native, Public)

void ARBPlayer::OnRep_NVBattery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_NVBattery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_NVLensBrokenFXValue
// (Final, Native, Public)

void ARBPlayer::OnRep_NVLensBrokenFXValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_NVLensBrokenFXValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_PlayerCameraComponent
// (Final, Native, Public)

void ARBPlayer::OnRep_PlayerCameraComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_PlayerCameraComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_PlayerSpecificUpgrades
// (Final, Native, Public)

void ARBPlayer::OnRep_PlayerSpecificUpgrades()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_PlayerSpecificUpgrades");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_SavedEquippedItem
// (Final, Native, Public)

void ARBPlayer::OnRep_SavedEquippedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_SavedEquippedItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_SlideDownVolume
// (Final, Native, Public)
// Parameters:
// class ARBSlideDownVolume*               Param_SlideDownVolume                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_SlideDownVolume(class ARBSlideDownVolume* Param_SlideDownVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_SlideDownVolume");

	Params::RBPlayer_OnRep_SlideDownVolume Parms{};

	Parms.Param_SlideDownVolume = Param_SlideDownVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_SpawnedBombActor
// (Final, Native, Public)

void ARBPlayer::OnRep_SpawnedBombActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_SpawnedBombActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_Stamina
// (Final, Native, Public)
// Parameters:
// float                                   OldStamina                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_Stamina(float OldStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_Stamina");

	Params::RBPlayer_OnRep_Stamina Parms{};

	Parms.OldStamina = OldStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_StruggleAction_Helper_Timestamp
// (Final, Native, Public)
// Parameters:
// float                                   LastTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_StruggleAction_Helper_Timestamp(float LastTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_StruggleAction_Helper_Timestamp");

	Params::RBPlayer_OnRep_StruggleAction_Helper_Timestamp Parms{};

	Parms.LastTimestamp = LastTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_StruggleAction_Victim_Timestamp
// (Final, Native, Public)
// Parameters:
// float                                   LastTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_StruggleAction_Victim_Timestamp(float LastTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_StruggleAction_Victim_Timestamp");

	Params::RBPlayer_OnRep_StruggleAction_Victim_Timestamp Parms{};

	Parms.LastTimestamp = LastTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_StruggleRatio_Helper
// (Final, Native, Public)
// Parameters:
// float                                   LastStruggleRatio_Helper                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnRep_StruggleRatio_Helper(float LastStruggleRatio_Helper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_StruggleRatio_Helper");

	Params::RBPlayer_OnRep_StruggleRatio_Helper Parms{};

	Parms.LastStruggleRatio_Helper = LastStruggleRatio_Helper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_TemporaryDamage
// (Final, Native, Public)

void ARBPlayer::OnRep_TemporaryDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_TemporaryDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_TemporaryHealth
// (Final, Native, Public)

void ARBPlayer::OnRep_TemporaryHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_TemporaryHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_TradeItem
// (Final, Native, Public)

void ARBPlayer::OnRep_TradeItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_TradeItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_UINoiseMeterStrength
// (Final, Native, Public)

void ARBPlayer::OnRep_UINoiseMeterStrength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_UINoiseMeterStrength");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnRep_WantsNVActive
// (Final, Native, Public)

void ARBPlayer::OnRep_WantsNVActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnRep_WantsNVActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnSavedEquippedItemChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnSavedEquippedItemChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnSavedEquippedItemChangedCallback");

	Params::RBPlayer_OnSavedEquippedItemChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnShadowMeshCreated
// (Final, Native, Public, BlueprintCallable)

void ARBPlayer::OnShadowMeshCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnShadowMeshCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnTradeItemChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnTradeItemChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnTradeItemChangedCallback");

	Params::RBPlayer_OnTradeItemChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.OnWantsNVActiveChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::OnWantsNVActiveChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "OnWantsNVActiveChangedCallback");

	Params::RBPlayer_OnWantsNVActiveChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.RemovePlayerSpecificUpgrade_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModifierId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::RemovePlayerSpecificUpgrade_Server(class FName ModifierId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "RemovePlayerSpecificUpgrade_Server");

	Params::RBPlayer_RemovePlayerSpecificUpgrade_Server Parms{};

	Parms.ModifierId = ModifierId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_ActivateActiveSkill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_ActivateActiveSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_ActivateActiveSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_ChallengeArmWrestlingPlayer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARBPlayer*                        ChallengedPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_ChallengeArmWrestlingPlayer(class ARBPlayer* ChallengedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_ChallengeArmWrestlingPlayer");

	Params::RBPlayer_Server_ChallengeArmWrestlingPlayer Parms{};

	Parms.ChallengedPlayer = ChallengedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_DebugCoopMove
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bExceptLocal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Cheat_DebugCoopMove(bool bExceptLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_DebugCoopMove");

	Params::RBPlayer_Server_Cheat_DebugCoopMove Parms{};

	Parms.bExceptLocal = bExceptLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_DebugPuzzleRoom
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class URBPuzzleRoomComponent*           PuzzleRoom                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Cheat_DebugPuzzleRoom(class URBPuzzleRoomComponent* PuzzleRoom, bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_DebugPuzzleRoom");

	Params::RBPlayer_Server_Cheat_DebugPuzzleRoom Parms{};

	Parms.PuzzleRoom = PuzzleRoom;
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_DumpDebugInfo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Cheat_DumpDebugInfo(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_DumpDebugInfo");

	Params::RBPlayer_Server_Cheat_DumpDebugInfo Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_ToggleAnimationLog
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Cheat_ToggleAnimationLog(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_ToggleAnimationLog");

	Params::RBPlayer_Server_Cheat_ToggleAnimationLog Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_ToggleConditionalDebugActor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Cheat_ToggleConditionalDebugActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_ToggleConditionalDebugActor");

	Params::RBPlayer_Server_Cheat_ToggleConditionalDebugActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_ToggleInvisibleToBots
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_Cheat_ToggleInvisibleToBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_ToggleInvisibleToBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Cheat_ToggleSilentForBots
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_Cheat_ToggleSilentForBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Cheat_ToggleSilentForBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_CheatBleedSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_CheatBleedSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_CheatBleedSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_CheatHealSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_CheatHealSelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_CheatHealSelf");

	Params::RBPlayer_Server_CheatHealSelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_CheatHurtSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitReaction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HurtType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_CheatHurtSelf(float DamageAmount, bool bHitReaction, int32 HurtType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_CheatHurtSelf");

	Params::RBPlayer_Server_CheatHurtSelf Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.bHitReaction = bHitReaction;
	Parms.HurtType = HurtType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_CheatStunSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_CheatStunSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_CheatStunSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DeactivateActiveSkill
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DeactivateActiveSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DeactivateActiveSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Debug_PlayerServerLocations
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_Debug_PlayerServerLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Debug_PlayerServerLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_Debug_Teleport
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_Debug_Teleport(const struct FVector& Location, const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_Debug_Teleport");

	Params::RBPlayer_Server_Debug_Teleport Parms{};

	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugChase
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugChase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugDownSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugDownSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugDownSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugHitReaction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EPlayerHitReactionType                  HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RelativeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_DebugHitReaction(EPlayerHitReactionType HitReactionType, float RelativeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugHitReaction");

	Params::RBPlayer_Server_DebugHitReaction Parms{};

	Parms.HitReactionType = HitReactionType;
	Parms.RelativeAngle = RelativeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugInteractionDesync
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugInteractionDesync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugInteractionDesync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugJumpOver
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugJumpOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugJumpOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugKillSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugKillSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugKillSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugMovementAlwaysDesync
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugMovementAlwaysDesync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugMovementAlwaysDesync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugSimultaneousInteraction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugSimultaneousInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugSimultaneousInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_DebugSimultaneousJumpForward
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_DebugSimultaneousJumpForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_DebugSimultaneousJumpForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_ExitCustomInteractable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBCustomSpecialMoveInteractableActor*CustomInteractable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_ExitCustomInteractable(class ARBCustomSpecialMoveInteractableActor* CustomInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_ExitCustomInteractable");

	Params::RBPlayer_Server_ExitCustomInteractable Parms{};

	Parms.CustomInteractable = CustomInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_NotifyPanelUserReady
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_NotifyPanelUserReady(class URBInteractiblePanelComponent* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_NotifyPanelUserReady");

	Params::RBPlayer_Server_NotifyPanelUserReady Parms{};

	Parms.Panel = Panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_OnTortureInputPressed
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class URBTorturePanelComponent*         PanelCmp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InputPressed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_OnTortureInputPressed(class URBTorturePanelComponent* PanelCmp, float Timestamp, int32 InputPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_OnTortureInputPressed");

	Params::RBPlayer_Server_OnTortureInputPressed Parms{};

	Parms.PanelCmp = PanelCmp;
	Parms.Timestamp = Timestamp;
	Parms.InputPressed = InputPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_RemoveAllPings
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBPlayer::Server_RemoveAllPings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_RemoveAllPings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_RemovePing
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EPlayerPingType                         PingType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_RemovePing(EPlayerPingType PingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_RemovePing");

	Params::RBPlayer_Server_RemovePing Parms{};

	Parms.PingType = PingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_RequestExitSASChair
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_RequestExitSASChair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_RequestExitSASChair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_ScheduleHelperCollisionEnabled
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URBEvalCorridorHelperComponent*   CorridorHelper                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExecutionServerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_ScheduleHelperCollisionEnabled(class URBEvalCorridorHelperComponent* CorridorHelper, bool bEnable, float ExecutionServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_ScheduleHelperCollisionEnabled");

	Params::RBPlayer_Server_ScheduleHelperCollisionEnabled Parms{};

	Parms.CorridorHelper = CorridorHelper;
	Parms.bEnable = bEnable;
	Parms.ExecutionServerTime = ExecutionServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetEquippedInventoryItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetEquippedInventoryItem(class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetEquippedInventoryItem");

	Params::RBPlayer_Server_SetEquippedInventoryItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetGodMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetGodMode(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetGodMode");

	Params::RBPlayer_Server_SetGodMode Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetInteractiblePanelChildValue
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class URBInteractibleComponent*         PanelChild                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetInteractiblePanelChildValue(class URBInteractibleComponent* PanelChild, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetInteractiblePanelChildValue");

	Params::RBPlayer_Server_SetInteractiblePanelChildValue Parms{};

	Parms.PanelChild = PanelChild;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetLobbyGameInputAtLoc
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// bool                                    InputDown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetLobbyGameInputAtLoc(bool InputDown, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetLobbyGameInputAtLoc");

	Params::RBPlayer_Server_SetLobbyGameInputAtLoc Parms{};

	Parms.InputDown = InputDown;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetObjectiveActorSeen
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class URBObjectiveActorComponent*       ObjectiveActorComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetObjectiveActorSeen(class URBObjectiveActorComponent* ObjectiveActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetObjectiveActorSeen");

	Params::RBPlayer_Server_SetObjectiveActorSeen Parms{};

	Parms.ObjectiveActorComponent = ObjectiveActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetPlayerInputAtCoord
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// bool                                    InputDown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        Coord                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBChessPieceComponent*           Piece                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetPlayerInputAtCoord(bool InputDown, const struct FIntPoint& Coord, class URBChessPieceComponent* Piece)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetPlayerInputAtCoord");

	Params::RBPlayer_Server_SetPlayerInputAtCoord Parms{};

	Parms.InputDown = InputDown;
	Parms.Coord = std::move(Coord);
	Parms.Piece = Piece;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetSaveEquippedItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetSaveEquippedItem(class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetSaveEquippedItem");

	Params::RBPlayer_Server_SetSaveEquippedItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetSwitchPanelPartDesiredStatusValue
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ARBSwitchPanelPart*               PanelPart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetSwitchPanelPartDesiredStatusValue(class ARBSwitchPanelPart* PanelPart, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetSwitchPanelPartDesiredStatusValue");

	Params::RBPlayer_Server_SetSwitchPanelPartDesiredStatusValue Parms{};

	Parms.PanelPart = PanelPart;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetToggleInteractionSetting
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bToggle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetToggleInteractionSetting(bool bToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetToggleInteractionSetting");

	Params::RBPlayer_Server_SetToggleInteractionSetting Parms{};

	Parms.bToggle = bToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_SetWantsNVActive
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_SetWantsNVActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_SetWantsNVActive");

	Params::RBPlayer_Server_SetWantsNVActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_StopInteractingWithPanelChild
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_StopInteractingWithPanelChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_StopInteractingWithPanelChild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_StopTrading
// (Net, NetReliable, Native, Event, Public, NetServer)

void ARBPlayer::Server_StopTrading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_StopTrading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_TalkWheel
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// ETalkWheelAction                        Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurrentEyeLocation                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurrentEyeForward                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_TalkWheel(ETalkWheelAction Action, const struct FVector& CurrentEyeLocation, const struct FVector& CurrentEyeForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_TalkWheel");

	Params::RBPlayer_Server_TalkWheel Parms{};

	Parms.Action = Action;
	Parms.CurrentEyeLocation = std::move(CurrentEyeLocation);
	Parms.CurrentEyeForward = std::move(CurrentEyeForward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_TryDropItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ARBPickup*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_TryDropItem(class ARBPickup* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_TryDropItem");

	Params::RBPlayer_Server_TryDropItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_TryStartTrading
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ARBPlayer::Server_TryStartTrading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_TryStartTrading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_TrySwitchToItemTutorial
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   SpecialMoveIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialMove                            SpecialMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_TrySwitchToItemTutorial(int32 SpecialMoveIndex, ESpecialMove SpecialMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_TrySwitchToItemTutorial");

	Params::RBPlayer_Server_TrySwitchToItemTutorial Parms{};

	Parms.SpecialMoveIndex = SpecialMoveIndex;
	Parms.SpecialMove = SpecialMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_UpdateChessPanelMouseCursorPosition
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FVector2D                        NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_UpdateChessPanelMouseCursorPosition(const struct FVector2D& NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_UpdateChessPanelMouseCursorPosition");

	Params::RBPlayer_Server_UpdateChessPanelMouseCursorPosition Parms{};

	Parms.NewPosition = std::move(NewPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_UpdateLobbyGameMouseCursorPosition
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::Server_UpdateLobbyGameMouseCursorPosition(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_UpdateLobbyGameMouseCursorPosition");

	Params::RBPlayer_Server_UpdateLobbyGameMouseCursorPosition Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.Server_UpdateMeshOffsets
// (Net, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// struct FVector                          TranslationOffset                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationOffset                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBPlayer::Server_UpdateMeshOffsets(const struct FVector& TranslationOffset, const struct FRotator& RotationOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Server_UpdateMeshOffsets");

	Params::RBPlayer_Server_UpdateMeshOffsets Parms{};

	Parms.TranslationOffset = std::move(TranslationOffset);
	Parms.RotationOffset = std::move(RotationOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.SetLastConsumedBatteryType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EItemType                               batteryType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::SetLastConsumedBatteryType(EItemType batteryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "SetLastConsumedBatteryType");

	Params::RBPlayer_SetLastConsumedBatteryType Parms{};

	Parms.batteryType = batteryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.ShowItemHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPickup*                        Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::ShowItemHeld(class ARBPickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "ShowItemHeld");

	Params::RBPlayer_ShowItemHeld Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.TogglePlayerDepthTest
// (Final, Exec, Native, Public)

void ARBPlayer::TogglePlayerDepthTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "TogglePlayerDepthTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayer.UnderwaterStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsUnderwater                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayer::UnderwaterStateChanged(bool bIsUnderwater)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "UnderwaterStateChanged");

	Params::RBPlayer_UnderwaterStateChanged Parms{};

	Parms.bIsUnderwater = bIsUnderwater;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayer.BP_FindFirstInventoryItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_FindFirstInventoryItemIndex(EItemCategory Category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_FindFirstInventoryItemIndex");

	Params::RBPlayer_BP_FindFirstInventoryItemIndex Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_FindFirstInventoryItemIndexFromClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ARBPickup>            ItemClass                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowChildClasses                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_FindFirstInventoryItemIndexFromClass(const TSubclassOf<class ARBPickup>& ItemClass, bool bAllowChildClasses) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_FindFirstInventoryItemIndexFromClass");

	Params::RBPlayer_BP_FindFirstInventoryItemIndexFromClass Parms{};

	Parms.ItemClass = ItemClass;
	Parms.bAllowChildClasses = bAllowChildClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetCurrentStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayer::BP_GetCurrentStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetCurrentStamina");

	Params::RBPlayer_BP_GetCurrentStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetHealthF
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayer::BP_GetHealthF() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetHealthF");

	Params::RBPlayer_BP_GetHealthF Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetInventoryIndexFromItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_GetInventoryIndexFromItem(const class ARBPickup* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetInventoryIndexFromItem");

	Params::RBPlayer_BP_GetInventoryIndexFromItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetItemFromIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBPlayer::BP_GetItemFromIndex(int32 ItemIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetItemFromIndex");

	Params::RBPlayer_BP_GetItemFromIndex Parms{};

	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetItemIndexForSwap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPickup*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_GetItemIndexForSwap(EItemCategory Category, const class ARBPickup* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetItemIndexForSwap");

	Params::RBPlayer_BP_GetItemIndexForSwap Parms{};

	Parms.Category = Category;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetItemsForCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARBPickup*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARBPickup*> ARBPlayer::BP_GetItemsForCategory(EItemCategory Category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetItemsForCategory");

	Params::RBPlayer_BP_GetItemsForCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetLastConsumedBatteryType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemType ARBPlayer::BP_GetLastConsumedBatteryType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetLastConsumedBatteryType");

	Params::RBPlayer_BP_GetLastConsumedBatteryType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetMaxNumberOfItemForCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_GetMaxNumberOfItemForCategory(EItemCategory Category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetMaxNumberOfItemForCategory");

	Params::RBPlayer_BP_GetMaxNumberOfItemForCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_GetNumberOfItemForCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::BP_GetNumberOfItemForCategory(EItemCategory Category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_GetNumberOfItemForCategory");

	Params::RBPlayer_BP_GetNumberOfItemForCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_IsExhausted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_IsExhausted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_IsExhausted");

	Params::RBPlayer_BP_IsExhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_IsFlaggedAsFakePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_IsFlaggedAsFakePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_IsFlaggedAsFakePlayer");

	Params::RBPlayer_BP_IsFlaggedAsFakePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_IsNVBatteryRecharging
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_IsNVBatteryRecharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_IsNVBatteryRecharging");

	Params::RBPlayer_BP_IsNVBatteryRecharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_IsNVOn
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_IsNVOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_IsNVOn");

	Params::RBPlayer_BP_IsNVOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_IsUsingGamepad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_IsUsingGamepad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_IsUsingGamepad");

	Params::RBPlayer_BP_IsUsingGamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.BP_ShouldShowStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::BP_ShouldShowStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "BP_ShouldShowStamina");

	Params::RBPlayer_BP_ShouldShowStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.Get3PAnimInstanceClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class URBAnimInstance>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class URBAnimInstance> ARBPlayer::Get3PAnimInstanceClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "Get3PAnimInstanceClass");

	Params::RBPlayer_Get3PAnimInstanceClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetAllShadowMeshes
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> ARBPlayer::GetAllShadowMeshes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetAllShadowMeshes");

	Params::RBPlayer_GetAllShadowMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetBatteryBoostItemModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBGameplayAttributeModifierReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FRBGameplayAttributeModifier ARBPlayer::GetBatteryBoostItemModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetBatteryBoostItemModifier");

	Params::RBPlayer_GetBatteryBoostItemModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCoopMoveProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayer::GetCoopMoveProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCoopMoveProgress");

	Params::RBPlayer_GetCoopMoveProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentActiveSkillType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActiveSkillType ARBPlayer::GetCurrentActiveSkillType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentActiveSkillType");

	Params::RBPlayer_GetCurrentActiveSkillType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentEquippedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBPlayer::GetCurrentEquippedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentEquippedItem");

	Params::RBPlayer_GetCurrentEquippedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentEquippedItemDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FItemDefinition            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemDefinition ARBPlayer::GetCurrentEquippedItemDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentEquippedItemDefinition");

	Params::RBPlayer_GetCurrentEquippedItemDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentEquippedItemInventoryIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::GetCurrentEquippedItemInventoryIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentEquippedItemInventoryIndex");

	Params::RBPlayer_GetCurrentEquippedItemInventoryIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentEquippedItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemType ARBPlayer::GetCurrentEquippedItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentEquippedItemType");

	Params::RBPlayer_GetCurrentEquippedItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetCurrentEquippedOrHolsteredItemInventoryIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBPlayer::GetCurrentEquippedOrHolsteredItemInventoryIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetCurrentEquippedOrHolsteredItemInventoryIndex");

	Params::RBPlayer_GetCurrentEquippedOrHolsteredItemInventoryIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetGamePlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARBPlayer::GetGamePlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetGamePlayerName");

	Params::RBPlayer_GetGamePlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetHoldConsumeActionItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBPlayer::GetHoldConsumeActionItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetHoldConsumeActionItem");

	Params::RBPlayer_GetHoldConsumeActionItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetIsAimingThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::GetIsAimingThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetIsAimingThrowable");

	Params::RBPlayer_GetIsAimingThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetItemHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPickup* ARBPlayer::GetItemHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetItemHeld");

	Params::RBPlayer_GetItemHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetKnockoutBleedoutTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPlayer::GetKnockoutBleedoutTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetKnockoutBleedoutTime");

	Params::RBPlayer_GetKnockoutBleedoutTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetMainShadowMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ARBPlayer::GetMainShadowMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetMainShadowMesh");

	Params::RBPlayer_GetMainShadowMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetRBPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPlayerState* ARBPlayer::GetRBPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetRBPlayerState");

	Params::RBPlayer_GetRBPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetStaminaBoostItemModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRBGameplayAttributeModifierReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FRBGameplayAttributeModifier ARBPlayer::GetStaminaBoostItemModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetStaminaBoostItemModifier");

	Params::RBPlayer_GetStaminaBoostItemModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeam ARBPlayer::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetTeam");

	Params::RBPlayer_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.GetUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl ARBPlayer::GetUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "GetUniqueId");

	Params::RBPlayer_GetUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.HasHotPotato
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::HasHotPotato() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "HasHotPotato");

	Params::RBPlayer_HasHotPotato Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsAssociatedPlayerConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsAssociatedPlayerConnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsAssociatedPlayerConnected");

	Params::RBPlayer_IsAssociatedPlayerConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsBleeding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsBleeding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsBleeding");

	Params::RBPlayer_IsBleeding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsConsideredKnockedDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bConsiderDelay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsConsideredKnockedDown(bool bConsiderDelay) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsConsideredKnockedDown");

	Params::RBPlayer_IsConsideredKnockedDown Parms{};

	Parms.bConsiderDelay = bConsiderDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsConsideredMakingKnockedDownBloodTrail
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsConsideredMakingKnockedDownBloodTrail() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsConsideredMakingKnockedDownBloodTrail");

	Params::RBPlayer_IsConsideredMakingKnockedDownBloodTrail Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsConsideredPeeking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreNetworkFlag                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsConsideredPeeking(bool bIgnoreNetworkFlag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsConsideredPeeking");

	Params::RBPlayer_IsConsideredPeeking Parms{};

	Parms.bIgnoreNetworkFlag = bIgnoreNetworkFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsConsideredUsingSpectraActiveSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsConsideredUsingSpectraActiveSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsConsideredUsingSpectraActiveSkill");

	Params::RBPlayer_IsConsideredUsingSpectraActiveSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsControllerInMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsControllerInMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsControllerInMenu");

	Params::RBPlayer_IsControllerInMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsEyeLocationUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsEyeLocationUnderwater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsEyeLocationUnderwater");

	Params::RBPlayer_IsEyeLocationUnderwater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsFocusOnSwappingItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPickup*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsFocusOnSwappingItem(const class ARBPickup* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsFocusOnSwappingItem");

	Params::RBPlayer_IsFocusOnSwappingItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsFollower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsFollower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsFollower");

	Params::RBPlayer_IsFollower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsInPsychosis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsInPsychosis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsInPsychosis");

	Params::RBPlayer_IsInPsychosis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsInSAS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsInSAS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsInSAS");

	Params::RBPlayer_IsInSAS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsLocallyControlledOrSpectated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsLocallyControlledOrSpectated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsLocallyControlledOrSpectated");

	Params::RBPlayer_IsLocallyControlledOrSpectated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsLocallySpectated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsLocallySpectated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsLocallySpectated");

	Params::RBPlayer_IsLocallySpectated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsOfTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeam                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsOfTeam(ETeam Team) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsOfTeam");

	Params::RBPlayer_IsOfTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayer.IsReadyToWatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayer::IsReadyToWatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayer", "IsReadyToWatch");

	Params::RBPlayer_IsReadyToWatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCellCustomizationConfig.RefreshItems
// (Final, Native, Public)

void URBPlayerCellCustomizationConfig::RefreshItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellCustomizationConfig", "RefreshItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCellCustomizationConfig.GetDefaultPlayerCellItemForSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECustomizationMenuCategory              Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCellItemDefinition*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCellItemDefinition* URBPlayerCellCustomizationConfig::GetDefaultPlayerCellItemForSlot(ECustomizationMenuCategory Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellCustomizationConfig", "GetDefaultPlayerCellItemForSlot");

	Params::RBPlayerCellCustomizationConfig_GetDefaultPlayerCellItemForSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCellCustomizationConfig.GetPlayerCellItemDefinition
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCellItemDefinition*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCellItemDefinition* URBPlayerCellCustomizationConfig::GetPlayerCellItemDefinition(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellCustomizationConfig", "GetPlayerCellItemDefinition");

	Params::RBPlayerCellCustomizationConfig_GetPlayerCellItemDefinition Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCellItem.Event_AssignItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBPlayerCellItemDefinition*      ItemDefinition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPreview                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerCellItem::Event_AssignItem(class URBPlayerCellItemDefinition* ItemDefinition, bool bIsPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellItem", "Event_AssignItem");

	Params::RBPlayerCellItem_Event_AssignItem Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.bIsPreview = bIsPreview;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerCellItem.Event_AssignToPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerCellItem::Event_AssignToPlayer(class ARBLobbyPlayerState* RBLobbyPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellItem", "Event_AssignToPlayer");

	Params::RBPlayerCellItem_Event_AssignToPlayer Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerCellItem.Event_ClearItem
// (Event, Public, BlueprintEvent)

void ARBPlayerCellItem::Event_ClearItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellItem", "Event_ClearItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayerCellItem.Event_UnassignedFromPlayer
// (Event, Public, BlueprintEvent)

void ARBPlayerCellItem::Event_UnassignedFromPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCellItem", "Event_UnassignedFromPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTaskTrackingEntry.OnGamePhaseUpdated
// (Final, Native, Private)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskTrackingEntry::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskTrackingEntry", "OnGamePhaseUpdated");

	Params::RBTaskTrackingEntry_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskTrackingEntry.OnItemAcquired
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskTrackingEntry::OnItemAcquired(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskTrackingEntry", "OnItemAcquired");

	Params::RBTaskTrackingEntry_OnItemAcquired Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskTrackingEntry.OnPlayerEvent
// (Final, Native, Private)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskTrackingEntry::OnPlayerEvent(EPlayerEvent EventType, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskTrackingEntry", "OnPlayerEvent");

	Params::RBTaskTrackingEntry_OnPlayerEvent Parms{};

	Parms.EventType = EventType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTaskTrackingEntry.OnTaskCompleted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             TaskId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskTrackingEntry::OnTaskCompleted(const class FName& TaskId, int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskTrackingEntry", "OnTaskCompleted");

	Params::RBTaskTrackingEntry_OnTaskCompleted Parms{};

	Parms.TaskId = TaskId;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableWeapon.BP_OnGroundAndPoundCounter
// (Event, Public, BlueprintEvent)

void ARBThrowableWeapon::BP_OnGroundAndPoundCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "BP_OnGroundAndPoundCounter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBThrowableWeapon.BP_OnHitDestroy
// (Event, Public, BlueprintEvent)

void ARBThrowableWeapon::BP_OnHitDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "BP_OnHitDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBThrowableWeapon.BP_OnThrownHit
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitReflectionNormal                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ImpactMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBThrowableWeapon::BP_OnThrownHit(const struct FVector& HitNormal, const struct FVector& HitReflectionNormal, class UPhysicalMaterial* ImpactMaterial, class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "BP_OnThrownHit");

	Params::RBThrowableWeapon_BP_OnThrownHit Parms{};

	Parms.HitNormal = std::move(HitNormal);
	Parms.HitReflectionNormal = std::move(HitReflectionNormal);
	Parms.ImpactMaterial = ImpactMaterial;
	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBThrowableWeapon.Multicast_BouncedDestroy
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          HitLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ImpactMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBThrowableWeapon::Multicast_BouncedDestroy(const struct FVector& HitLocation, const struct FVector& HitNormal, class UPhysicalMaterial* ImpactMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "Multicast_BouncedDestroy");

	Params::RBThrowableWeapon_Multicast_BouncedDestroy Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.ImpactMaterial = ImpactMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableWeapon.Multicast_Throw
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          ThrowOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ThrowStartLocation                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ThrowOnCurveLocationaimAssistTargetComp                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBAimAssistComponent*            AimAssistTargetComp                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBThrowableWeapon::Multicast_Throw(class ARBPawn* ThrowOwner, const struct FVector& ThrowStartLocation, const struct FVector& ThrowOnCurveLocationaimAssistTargetComp, class URBAimAssistComponent* AimAssistTargetComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "Multicast_Throw");

	Params::RBThrowableWeapon_Multicast_Throw Parms{};

	Parms.ThrowOwner = ThrowOwner;
	Parms.ThrowStartLocation = std::move(ThrowStartLocation);
	Parms.ThrowOnCurveLocationaimAssistTargetComp = std::move(ThrowOnCurveLocationaimAssistTargetComp);
	Parms.AimAssistTargetComp = AimAssistTargetComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableWeapon.Multicast_ThrownHit
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          HitLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReflectedDir                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ImpactMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceBreak                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBThrowableWeapon::Multicast_ThrownHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& ReflectedDir, class UPhysicalMaterial* ImpactMaterial, class AActor* HitActor, bool ForceBreak)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "Multicast_ThrownHit");

	Params::RBThrowableWeapon_Multicast_ThrownHit Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.ReflectedDir = std::move(ReflectedDir);
	Parms.ImpactMaterial = ImpactMaterial;
	Parms.HitActor = HitActor;
	Parms.ForceBreak = ForceBreak;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableWeapon.OnRep_ThrowDamageHitCount
// (Final, Native, Private)

void ARBThrowableWeapon::OnRep_ThrowDamageHitCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "OnRep_ThrowDamageHitCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableWeapon.RefreshThrowableVisualAfterThrowHit
// (Event, Protected, BlueprintEvent)

void ARBThrowableWeapon::RefreshThrowableVisualAfterThrowHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableWeapon", "RefreshThrowableVisualAfterThrowHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBThrowableSkillItem.BP_BeginActivationSequence
// (Final, Native, Public, BlueprintCallable)

void ARBThrowableSkillItem::BP_BeginActivationSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "BP_BeginActivationSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableSkillItem.BP_EndActivationSequence
// (Final, Native, Public, BlueprintCallable)

void ARBThrowableSkillItem::BP_EndActivationSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "BP_EndActivationSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableSkillItem.BP_MakePermanentlyDestroyed
// (Final, Native, Public, BlueprintCallable)

void ARBThrowableSkillItem::BP_MakePermanentlyDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "BP_MakePermanentlyDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableSkillItem.DelayedDestroy
// (Native, Public)

void ARBThrowableSkillItem::DelayedDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "DelayedDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableSkillItem.Event_OnActivate
// (Event, Public, BlueprintEvent)

void ARBThrowableSkillItem::Event_OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "Event_OnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBThrowableSkillItem.Event_OnDeployed
// (Event, Public, BlueprintEvent)

void ARBThrowableSkillItem::Event_OnDeployed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "Event_OnDeployed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBThrowableSkillItem.OnRep_State
// (Final, Native, Protected)

void ARBThrowableSkillItem::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBThrowableSkillItem.GetImpactRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBThrowableSkillItem::GetImpactRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBThrowableSkillItem", "GetImpactRadius");

	Params::RBThrowableSkillItem_GetImpactRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBToggleable.PostToggled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bToggleEnabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBToggleable::PostToggled(bool bToggleEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToggleable", "PostToggled");

	Params::RBToggleable_PostToggled Parms{};

	Parms.bToggleEnabled = bToggleEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToggleable.IsTogglingStaticShadowComponentAllowed
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBToggleable::IsTogglingStaticShadowComponentAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToggleable", "IsTogglingStaticShadowComponentAllowed");

	Params::RBToggleable_IsTogglingStaticShadowComponentAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.BP_GetAllResourcesToLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsFemale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> URBPlayerCustomizationOption::BP_GetAllResourcesToLoad(bool IsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "BP_GetAllResourcesToLoad");

	Params::RBPlayerCustomizationOption_BP_GetAllResourcesToLoad Parms{};

	Parms.IsFemale = IsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.BP_GetMaterialOverrideInstancesMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class UMaterialInstanceConstant*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class UMaterialInstanceConstant*> URBPlayerCustomizationOption::BP_GetMaterialOverrideInstancesMap(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "BP_GetMaterialOverrideInstancesMap");

	Params::RBPlayerCustomizationOption_BP_GetMaterialOverrideInstancesMap Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.GetExtraSkeletalMeshes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSoftObjectPtr<class USkeletalMesh>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftObjectPtr<class USkeletalMesh>> URBPlayerCustomizationOption::GetExtraSkeletalMeshes(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "GetExtraSkeletalMeshes");

	Params::RBPlayerCustomizationOption_GetExtraSkeletalMeshes Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.GetMaterialOverrides
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRBPlayerCustomizationMaterialOverride>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBPlayerCustomizationMaterialOverride> URBPlayerCustomizationOption::GetMaterialOverrides(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "GetMaterialOverrides");

	Params::RBPlayerCustomizationOption_GetMaterialOverrides Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USkeletalMesh>     ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class USkeletalMesh> URBPlayerCustomizationOption::GetSkeletalMesh(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "GetSkeletalMesh");

	Params::RBPlayerCustomizationOption_GetSkeletalMesh Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOption.GetStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UStaticMesh>       ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UStaticMesh> URBPlayerCustomizationOption::GetStaticMesh(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOption", "GetStaticMesh");

	Params::RBPlayerCustomizationOption_GetStaticMesh Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnInteractibleAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBToyMachineLargeObjectCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnInteractibleAddedToWorld");

	Params::RBToyMachineLargeObjectCoordinator_OnInteractibleAddedToWorld Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnLargeObjectInteractionDoAction
// (Native, Protected)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*LargeObjectPanel                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBToyMachineLargeObjectCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* LargeObjectPanel, class ARBLargePickup* LargePickup, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnLargeObjectInteractionDoAction");

	Params::RBToyMachineLargeObjectCoordinator_OnLargeObjectInteractionDoAction Parms{};

	Parms.LargeObjectPanel = LargeObjectPanel;
	Parms.LargePickup = LargePickup;
	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnLargePickupUsed_Server
// (Final, Native, Protected)
// Parameters:
// class ARBLargePickup*                   Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBToyMachineLargeObjectCoordinator::OnLargePickupUsed_Server(class ARBLargePickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnLargePickupUsed_Server");

	Params::RBToyMachineLargeObjectCoordinator_OnLargePickupUsed_Server Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnLargePickupUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBToyMachineLargeObjectCoordinator::OnLargePickupUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnLargePickupUsedOnObject");

	Params::RBToyMachineLargeObjectCoordinator_OnLargePickupUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBToyMachineLargeObjectCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnPickupHolderChanged");

	Params::RBToyMachineLargeObjectCoordinator_OnPickupHolderChanged Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBToyMachineLargeObjectCoordinator.OnRep_AvailableLargePickups
// (Final, Native, Protected)

void ARBToyMachineLargeObjectCoordinator::OnRep_AvailableLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBToyMachineLargeObjectCoordinator", "OnRep_AvailableLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomizationOutfit.Editor_RefreshHiddenSlots
// (Final, Native, Public)

void URBCustomizationOutfit::Editor_RefreshHiddenSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "Editor_RefreshHiddenSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBCustomizationOutfit.GetUnlockLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBCustomizationOutfit::GetUnlockLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "GetUnlockLevel");

	Params::RBCustomizationOutfit_GetUnlockLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOutfit.BP_GetAllResourcesToLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsFemale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> URBCustomizationOutfit::BP_GetAllResourcesToLoad(bool IsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "BP_GetAllResourcesToLoad");

	Params::RBCustomizationOutfit_BP_GetAllResourcesToLoad Parms{};

	Parms.IsFemale = IsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOutfit.CanEquipSinglePieces
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOutfit::CanEquipSinglePieces() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "CanEquipSinglePieces");

	Params::RBCustomizationOutfit_CanEquipSinglePieces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOutfit.GetNonAcquiredOptions
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URBPlayerCustomizationOption*>OutOptions                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBCustomizationOutfit::GetNonAcquiredOptions(const class ARBPlayerState* RBPlayerState, TArray<class URBPlayerCustomizationOption*>* OutOptions) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "GetNonAcquiredOptions");

	Params::RBCustomizationOutfit_GetNonAcquiredOptions Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOptions != nullptr)
		*OutOptions = std::move(Parms.OutOptions);
}


// Function OPP.RBCustomizationOutfit.GetOutfitCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* URBCustomizationOutfit::GetOutfitCustomizationOption(EPlayerCustomizationSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "GetOutfitCustomizationOption");

	Params::RBCustomizationOutfit_GetOutfitCustomizationOption Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBCustomizationOutfit.IsSlotPartOfOutfit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBCustomizationOutfit::IsSlotPartOfOutfit(EPlayerCustomizationSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBCustomizationOutfit", "IsSlotPartOfOutfit");

	Params::RBCustomizationOutfit_IsSlotPartOfOutfit Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.Editor_BuildOnlineIds
// (Final, Native, Public)

void URBPlayerCustomizationConfig::Editor_BuildOnlineIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "Editor_BuildOnlineIds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationConfig.Editor_DumpMismatchedItemProgressionData
// (Final, Native, Public)

void URBPlayerCustomizationConfig::Editor_DumpMismatchedItemProgressionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "Editor_DumpMismatchedItemProgressionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnmappedItemProgressionData
// (Final, Native, Public)

void URBPlayerCustomizationConfig::Editor_DumpUnmappedItemProgressionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "Editor_DumpUnmappedItemProgressionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnusedInventoryItems
// (Final, Native, Public)

void URBPlayerCustomizationConfig::Editor_DumpUnusedInventoryItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "Editor_DumpUnusedInventoryItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationConfig.Editor_RebuildAutoGeneratedData
// (Final, Native, Public)

void URBPlayerCustomizationConfig::Editor_RebuildAutoGeneratedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "Editor_RebuildAutoGeneratedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationConfig.GetAllCustomizationOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationSexQueryType        SexQueryType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeLegendaries                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URBPlayerCustomizationOption*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URBPlayerCustomizationOption*> URBPlayerCustomizationConfig::GetAllCustomizationOptions(EPlayerCustomizationSlot Slot, EPlayerCustomizationSexQueryType SexQueryType, bool bIncludeLegendaries) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetAllCustomizationOptions");

	Params::RBPlayerCustomizationConfig_GetAllCustomizationOptions Parms{};

	Parms.Slot = Slot;
	Parms.SexQueryType = SexQueryType;
	Parms.bIncludeLegendaries = bIncludeLegendaries;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetCustomizationOptionByOnlineUnlockId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOption*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCustomizationOption* URBPlayerCustomizationConfig::GetCustomizationOptionByOnlineUnlockId(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetCustomizationOptionByOnlineUnlockId");

	Params::RBPlayerCustomizationConfig_GetCustomizationOptionByOnlineUnlockId Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetCustomizationOutfit
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBCustomizationOutfit*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBCustomizationOutfit* URBPlayerCustomizationConfig::GetCustomizationOutfit(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetCustomizationOutfit");

	Params::RBPlayerCustomizationConfig_GetCustomizationOutfit Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetDefaultCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetDefaultCustomizationOption(EPlayerCustomizationSlot Slot, bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetDefaultCustomizationOption");

	Params::RBPlayerCustomizationConfig_GetDefaultCustomizationOption Parms{};

	Parms.Slot = Slot;
	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetDefaultPlayerCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetDefaultPlayerCustomizationInfo(bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetDefaultPlayerCustomizationInfo");

	Params::RBPlayerCustomizationConfig_GetDefaultPlayerCustomizationInfo Parms{};

	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetHairColorOption
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBHairColorOption               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRBHairColorOption URBPlayerCustomizationConfig::GetHairColorOption(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetHairColorOption");

	Params::RBPlayerCustomizationConfig_GetHairColorOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetPlayerCustomizationOption
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetPlayerCustomizationOption(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetPlayerCustomizationOption");

	Params::RBPlayerCustomizationConfig_GetPlayerCustomizationOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetPlayerIconOption
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerIconCustomizationOption* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerIconCustomizationOption* URBPlayerCustomizationConfig::GetPlayerIconOption(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetPlayerIconOption");

	Params::RBPlayerCustomizationConfig_GetPlayerIconOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysAcquiredOnly                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomAcquiredCustomizationInfo(class ARBPlayerState* RBPlayerState, bool bAlwaysAcquiredOnly) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetRandomAcquiredCustomizationInfo");

	Params::RBPlayerCustomizationConfig_GetRandomAcquiredCustomizationInfo Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.bAlwaysAcquiredOnly = bAlwaysAcquiredOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysAcquiredOnly                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerCustomizationOption*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetRandomAcquiredCustomizationOption(class ARBPlayerState* RBPlayerState, EPlayerCustomizationSlot Slot, bool bIsFemale, bool bAlwaysAcquiredOnly) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetRandomAcquiredCustomizationOption");

	Params::RBPlayerCustomizationConfig_GetRandomAcquiredCustomizationOption Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.Slot = Slot;
	Parms.bIsFemale = bIsFemale;
	Parms.bAlwaysAcquiredOnly = bAlwaysAcquiredOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredPlayerIconCustomizationOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPlayerIconCustomizationOption* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPlayerIconCustomizationOption* URBPlayerCustomizationConfig::GetRandomAcquiredPlayerIconCustomizationOption(class ARBPlayerState* RBPlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetRandomAcquiredPlayerIconCustomizationOption");

	Params::RBPlayerCustomizationConfig_GetRandomAcquiredPlayerIconCustomizationOption Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetRandomCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationRarity              MaxRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandomSex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomCustomizationInfo(int32 RandomSeed, EPlayerCustomizationRarity MaxRarity, bool bRandomSex, bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetRandomCustomizationInfo");

	Params::RBPlayerCustomizationConfig_GetRandomCustomizationInfo Parms{};

	Parms.RandomSeed = RandomSeed;
	Parms.MaxRarity = MaxRarity;
	Parms.bRandomSex = bRandomSex;
	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetRandomDeadBodyCustomizationInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandomSex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFemale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomDeadBodyCustomizationInfo(int32 RandomSeed, bool bRandomSex, bool bIsFemale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetRandomDeadBodyCustomizationInfo");

	Params::RBPlayerCustomizationConfig_GetRandomDeadBodyCustomizationInfo Parms{};

	Parms.RandomSeed = RandomSeed;
	Parms.bRandomSex = bRandomSex;
	Parms.bIsFemale = bIsFemale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationConfig.GetVoiceOption
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBVoiceCustomizationOption*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBVoiceCustomizationOption* URBPlayerCustomizationConfig::GetVoiceOption(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationConfig", "GetVoiceOption");

	Params::RBPlayerCustomizationConfig_GetVoiceOption Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOwner.OnExtraCustomizationMeshesAddedForSlot
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USkeletalMeshComponent*>   AddedExtraMeshes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBPlayerCustomizationOwner::OnExtraCustomizationMeshesAddedForSlot(const TArray<class USkeletalMeshComponent*>& AddedExtraMeshes, EPlayerCustomizationSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOwner", "OnExtraCustomizationMeshesAddedForSlot");

	Params::RBPlayerCustomizationOwner_OnExtraCustomizationMeshesAddedForSlot Parms{};

	Parms.AddedExtraMeshes = std::move(AddedExtraMeshes);
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerCustomizationOwner.GetMainParentSkeletalMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* IRBPlayerCustomizationOwner::GetMainParentSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOwner", "GetMainParentSkeletalMesh");

	Params::RBPlayerCustomizationOwner_GetMainParentSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOwner.GetPlayerCustomizationInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FRBPlayerCustomizationInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerCustomizationInfo IRBPlayerCustomizationOwner::GetPlayerCustomizationInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOwner", "GetPlayerCustomizationInfo");

	Params::RBPlayerCustomizationOwner_GetPlayerCustomizationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOwner.GetSkeletalMeshComponentForSlot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EPlayerCustomizationSlot                Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* IRBPlayerCustomizationOwner::GetSkeletalMeshComponentForSlot(EPlayerCustomizationSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOwner", "GetSkeletalMeshComponentForSlot");

	Params::RBPlayerCustomizationOwner_GetSkeletalMeshComponentForSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerCustomizationOwner.GetWatchComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* IRBPlayerCustomizationOwner::GetWatchComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerCustomizationOwner", "GetWatchComponent");

	Params::RBPlayerCustomizationOwner_GetWatchComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerDetectionComponent.BP_SetCurrentState_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerComponentDetectionState          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerDetectionComponent::BP_SetCurrentState_Server(EPlayerComponentDetectionState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerDetectionComponent", "BP_SetCurrentState_Server");

	Params::RBPlayerDetectionComponent_BP_SetCurrentState_Server Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerDetectionComponent.Event_OnDetectionStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EPlayerComponentDetectionState          OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerComponentDetectionState          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerDetectionComponent::Event_OnDetectionStateChanged(EPlayerComponentDetectionState OldState, EPlayerComponentDetectionState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerDetectionComponent", "Event_OnDetectionStateChanged");

	Params::RBPlayerDetectionComponent_Event_OnDetectionStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerDetectionComponent.OnRep_CurrentState
// (Final, Native, Protected)
// Parameters:
// EPlayerComponentDetectionState          OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerDetectionComponent::OnRep_CurrentState(EPlayerComponentDetectionState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerDetectionComponent", "OnRep_CurrentState");

	Params::RBPlayerDetectionComponent_OnRep_CurrentState Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPlayerDetectionComponent::GetCurrentDetectionAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerDetectionComponent", "GetCurrentDetectionAngle");

	Params::RBPlayerDetectionComponent_GetCurrentDetectionAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPlayerDetectionComponent::GetCurrentDetectionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerDetectionComponent", "GetCurrentDetectionDistance");

	Params::RBPlayerDetectionComponent_GetCurrentDetectionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerGameSessionManager.OnPartyMemberPlayerSlotsReservationProcessed
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FProfileId>               Members                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAccepted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerGameSessionManager::OnPartyMemberPlayerSlotsReservationProcessed(const TArray<struct FProfileId>& Members, bool bAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionManager", "OnPartyMemberPlayerSlotsReservationProcessed");

	Params::RBPlayerGameSessionManager_OnPartyMemberPlayerSlotsReservationProcessed Parms{};

	Parms.Members = std::move(Members);
	Parms.bAccepted = bAccepted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerGameSessionManager.GetTransitionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerGameSessionTransitionType        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerGameSessionTransitionType URBPlayerGameSessionManager::GetTransitionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionManager", "GetTransitionType");

	Params::RBPlayerGameSessionManager_GetTransitionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerGameSessionManager.IsBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerGameSessionManager::IsBusy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionManager", "IsBusy");

	Params::RBPlayerGameSessionManager_IsBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerGameSessionTransitionWidget.Event_Hide
// (Event, Public, BlueprintEvent)

void URBPlayerGameSessionTransitionWidget::Event_Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionTransitionWidget", "Event_Hide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayerGameSessionTransitionWidget.Event_Show
// (Event, Public, BlueprintEvent)

void URBPlayerGameSessionTransitionWidget::Event_Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionTransitionWidget", "Event_Show");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayerGameSessionTransitionWidget.OnOutroCompleted
// (Final, Native, Public, BlueprintCallable)

void URBPlayerGameSessionTransitionWidget::OnOutroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerGameSessionTransitionWidget", "OnOutroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActiveSkillCommonParams   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FActiveSkillCommonParams URBPlayerLoadoutConfig::GetActiveSkillCommonParams(EActiveSkillType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerLoadoutConfig", "GetActiveSkillCommonParams");

	Params::RBPlayerLoadoutConfig_GetActiveSkillCommonParams Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParamsById
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActiveSkillCommonParams   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FActiveSkillCommonParams URBPlayerLoadoutConfig::GetActiveSkillCommonParamsById(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerLoadoutConfig", "GetActiveSkillCommonParamsById");

	Params::RBPlayerLoadoutConfig_GetActiveSkillCommonParamsById Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutManager.OnPlayerProgressionReceived
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerLoadoutManager::OnPlayerProgressionReceived(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerLoadoutManager", "OnPlayerProgressionReceived");

	Params::RBPlayerLoadoutManager_OnPlayerProgressionReceived Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerLoadoutManager.UpdatePlayerLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBController*                    RBController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerLoadout                 Loadout                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBPlayerLoadoutManager::UpdatePlayerLoadout(class ARBController* RBController, const struct FRBPlayerLoadout& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerLoadoutManager", "UpdatePlayerLoadout");

	Params::RBPlayerLoadoutManager_UpdatePlayerLoadout Parms{};

	Parms.RBController = RBController;
	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerLoadoutManager.IsValidLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBPlayerLoadout                 Loadout                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerLoadoutManager::IsValidLoadout(class ARBPlayerState* RBPlayerState, const struct FRBPlayerLoadout& Loadout) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerLoadoutManager", "IsValidLoadout");

	Params::RBPlayerLoadoutManager_IsValidLoadout Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.CanEquipPerkInMenuLoadout
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemIdToEquip                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerLoadoutUIBlueprintLibrary::CanEquipPerkInMenuLoadout(const class FName& ItemIdToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "CanEquipPerkInMenuLoadout");

	Params::RBPlayerLoadoutUIBlueprintLibrary_CanEquipPerkInMenuLoadout Parms{};

	Parms.ItemIdToEquip = ItemIdToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetActiveSkillUpgradeItemInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EActiveSkillType                        ActiveSkillType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMenuUpgradeItemInfo             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetActiveSkillUpgradeItemInfo(EActiveSkillType ActiveSkillType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "GetActiveSkillUpgradeItemInfo");

	Params::RBPlayerLoadoutUIBlueprintLibrary_GetActiveSkillUpgradeItemInfo Parms{};

	Parms.ActiveSkillType = ActiveSkillType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetMenuLoadout
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FRBPlayerLoadout                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRBPlayerLoadout URBPlayerLoadoutUIBlueprintLibrary::GetMenuLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "GetMenuLoadout");

	Params::RBPlayerLoadoutUIBlueprintLibrary_GetMenuLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMenuUpgradeItemInfo             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetUpgradeItemInfo(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "GetUpgradeItemInfo");

	Params::RBPlayerLoadoutUIBlueprintLibrary_GetUpgradeItemInfo Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfoForPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMenuUpgradeItemInfo             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetUpgradeItemInfoForPlayer(const class FName& ItemId, const class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "GetUpgradeItemInfoForPlayer");

	Params::RBPlayerLoadoutUIBlueprintLibrary_GetUpgradeItemInfoForPlayer Parms{};

	Parms.ItemId = ItemId;
	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.HasAcquiredRig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerLoadoutUIBlueprintLibrary::HasAcquiredRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "HasAcquiredRig");

	Params::RBPlayerLoadoutUIBlueprintLibrary_HasAcquiredRig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.InitMenuLoadout
// (Final, Native, Static, Public, BlueprintCallable)

void URBPlayerLoadoutUIBlueprintLibrary::InitMenuLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "InitMenuLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.ToggleActiveSkillInMenuloadout
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EActiveSkillType                        ActiveSkillType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerLoadoutUIBlueprintLibrary::ToggleActiveSkillInMenuloadout(EActiveSkillType ActiveSkillType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "ToggleActiveSkillInMenuloadout");

	Params::RBPlayerLoadoutUIBlueprintLibrary_ToggleActiveSkillInMenuloadout Parms{};

	Parms.ActiveSkillType = ActiveSkillType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerLoadoutUIBlueprintLibrary.TogglePerkInMenuLoadout
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemIdToEquip                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerLoadoutUIBlueprintLibrary::TogglePerkInMenuLoadout(const class FName& ItemIdToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerLoadoutUIBlueprintLibrary", "TogglePerkInMenuLoadout");

	Params::RBPlayerLoadoutUIBlueprintLibrary_TogglePerkInMenuLoadout Parms{};

	Parms.ItemIdToEquip = ItemIdToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardUIDataFromGeneratedRewards
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBGeneratedRewardData           RewardData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRewardUIData>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromGeneratedRewards(const class ARBPlayerState* RBPlayerState, const struct FRBGeneratedRewardData& RewardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerProgressionData", "GetRewardUIDataFromGeneratedRewards");

	Params::RBPlayerProgressionData_GetRewardUIDataFromGeneratedRewards Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.RewardData = std::move(RewardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardUIDataFromLevelData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerProgressionLevelData      LevelData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRewardUIData>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromLevelData(const class ARBPlayerState* RBPlayerState, const struct FPlayerProgressionLevelData& LevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerProgressionData", "GetRewardUIDataFromLevelData");

	Params::RBPlayerProgressionData_GetRewardUIDataFromLevelData Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.LevelData = std::move(LevelData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardUIDataFromRewards
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBRewardData                    RewardData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSortByImportance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRewardUIData>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromRewards(const class ARBPlayerState* RBPlayerState, const struct FRBRewardData& RewardData, bool bSortByImportance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPlayerProgressionData", "GetRewardUIDataFromRewards");

	Params::RBPlayerProgressionData_GetRewardUIDataFromRewards Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.RewardData = std::move(RewardData);
	Parms.bSortByImportance = bSortByImportance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.FilterItemProgressionData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemProgressionCategory                Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActiveSkillType                        AssociatedActiveSkillType                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfileUpgradeCategory                 ProfileUpgradeCategory                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPerkCategory                           PerkCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFilterAvailable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRBItemProgressionData>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBItemProgressionData> URBPlayerProgressionData::FilterItemProgressionData(EItemProgressionCategory Category, EActiveSkillType AssociatedActiveSkillType, EProfileUpgradeCategory ProfileUpgradeCategory, EPerkCategory PerkCategory, int32 Rank, bool bFilterAvailable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "FilterItemProgressionData");

	Params::RBPlayerProgressionData_FilterItemProgressionData Parms{};

	Parms.Category = Category;
	Parms.AssociatedActiveSkillType = AssociatedActiveSkillType;
	Parms.ProfileUpgradeCategory = ProfileUpgradeCategory;
	Parms.PerkCategory = PerkCategory;
	Parms.Rank = Rank;
	Parms.bFilterAvailable = bFilterAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.FilterItemProgressionDataIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemProgressionCategory                Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActiveSkillType                        AssociatedActiveSkillType                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfileUpgradeCategory                 ProfileUpgradeCategory                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPerkCategory                           PerkCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFilterAvailable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> URBPlayerProgressionData::FilterItemProgressionDataIds(EItemProgressionCategory Category, EActiveSkillType AssociatedActiveSkillType, EProfileUpgradeCategory ProfileUpgradeCategory, EPerkCategory PerkCategory, int32 Rank, bool bFilterAvailable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "FilterItemProgressionDataIds");

	Params::RBPlayerProgressionData_FilterItemProgressionDataIds Parms{};

	Parms.Category = Category;
	Parms.AssociatedActiveSkillType = AssociatedActiveSkillType;
	Parms.ProfileUpgradeCategory = ProfileUpgradeCategory;
	Parms.PerkCategory = PerkCategory;
	Parms.Rank = Rank;
	Parms.bFilterAvailable = bFilterAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetActiveSkillSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        ActiveSkillType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBActiveSkillSettings     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FRBActiveSkillSettings URBPlayerProgressionData::GetActiveSkillSettings(EActiveSkillType ActiveSkillType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetActiveSkillSettings");

	Params::RBPlayerProgressionData_GetActiveSkillSettings Parms{};

	Parms.ActiveSkillType = ActiveSkillType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetBadge
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BadgeId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBPlayerBadgeRow          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerBadgeRow URBPlayerProgressionData::GetBadge(const class FName& BadgeId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetBadge");

	Params::RBPlayerProgressionData_GetBadge Parms{};

	Parms.BadgeId = BadgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetBadges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRBPlayerBadgeRow>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRBPlayerBadgeRow> URBPlayerProgressionData::GetBadges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetBadges");

	Params::RBPlayerProgressionData_GetBadges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetBattlePasses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBBattlePassData>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBBattlePassData> URBPlayerProgressionData::GetBattlePasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetBattlePasses");

	Params::RBPlayerProgressionData_GetBattlePasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetItemProgressionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValidateFeatureSwitch                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBItemProgressionData     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBItemProgressionData URBPlayerProgressionData::GetItemProgressionData(const class FName& ItemId, bool bValidateFeatureSwitch) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetItemProgressionData");

	Params::RBPlayerProgressionData_GetItemProgressionData Parms{};

	Parms.ItemId = ItemId;
	Parms.bValidateFeatureSwitch = bValidateFeatureSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetLevelingData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerProgressionLevelingDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPlayerProgressionLevelingData URBPlayerProgressionData::GetLevelingData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetLevelingData");

	Params::RBPlayerProgressionData_GetLevelingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetMaxPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPlayerProgressionData::GetMaxPlayerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetMaxPlayerLevel");

	Params::RBPlayerProgressionData_GetMaxPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetPerkSlotRequiredLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PerkSlotIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPerkCategory                           PerkCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPlayerProgressionData::GetPerkSlotRequiredLevel(int32 PerkSlotIndex, EPerkCategory PerkCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetPerkSlotRequiredLevel");

	Params::RBPlayerProgressionData_GetPerkSlotRequiredLevel Parms{};

	Parms.PerkSlotIndex = PerkSlotIndex;
	Parms.PerkCategory = PerkCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetPlayerLevelRequiredXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPlayerProgressionData::GetPlayerLevelRequiredXP(int32 Level) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetPlayerLevelRequiredXP");

	Params::RBPlayerProgressionData_GetPlayerLevelRequiredXP Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EffectId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBPlayerUpgradeEffectData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBPlayerUpgradeEffectData URBPlayerProgressionData::GetPlayerUpgradeEffectData(const class FName& EffectId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetPlayerUpgradeEffectData");

	Params::RBPlayerProgressionData_GetPlayerUpgradeEffectData Parms{};

	Parms.EffectId = EffectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EffectId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SettingId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPlayerProgressionData::GetPlayerUpgradeEffectSetting(const class FName& EffectId, const class FName& SettingId, float DefaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetPlayerUpgradeEffectSetting");

	Params::RBPlayerProgressionData_GetPlayerUpgradeEffectSetting Parms{};

	Parms.EffectId = EffectId;
	Parms.SettingId = SettingId;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RewardDataId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBRewardData              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBRewardData URBPlayerProgressionData::GetRewardData(const class FName& RewardDataId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetRewardData");

	Params::RBPlayerProgressionData_GetRewardData Parms{};

	Parms.RewardDataId = RewardDataId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardPool
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RewardPoolId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBRandomRewardPool        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBRandomRewardPool URBPlayerProgressionData::GetRewardPool(const class FName& RewardPoolId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetRewardPool");

	Params::RBPlayerProgressionData_GetRewardPool Parms{};

	Parms.RewardPoolId = RewardPoolId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetRewardsForPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBRewardData              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBRewardData URBPlayerProgressionData::GetRewardsForPlayerLevel(int32 Level) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetRewardsForPlayerLevel");

	Params::RBPlayerProgressionData_GetRewardsForPlayerLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionData.GetUnlockInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemUnlockInfo            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemUnlockInfo URBPlayerProgressionData::GetUnlockInfo(const class ARBPlayerState* RBPlayerState, const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionData", "GetUnlockInfo");

	Params::RBPlayerProgressionData_GetUnlockInfo Parms{};

	Parms.RBPlayerState = RBPlayerState;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerProgressionManager.CanReleaseCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBController*                    RBController                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerProgressionManager::CanReleaseCharacter(const class ARBController* RBController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerProgressionManager", "CanReleaseCharacter");

	Params::RBPlayerProgressionManager_CanReleaseCharacter Parms{};

	Parms.RBController = RBController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerRespawner.BP_OnDoorClosed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayerRespawner::BP_OnDoorClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "BP_OnDoorClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerRespawner.BP_OnDoorOpened
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPlayerRespawner::BP_OnDoorOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "BP_OnDoorOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerRespawner.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerRespawner::BP_SetEnabled(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "BP_SetEnabled");

	Params::RBPlayerRespawner_BP_SetEnabled Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerRespawner.Event_OnStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ERespawnerState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerRespawner::Event_OnStateChanged(ERespawnerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "Event_OnStateChanged");

	Params::RBPlayerRespawner_Event_OnStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPlayerRespawner.OnRep_OnStateChanged
// (Final, Native, Protected)

void ARBPlayerRespawner::OnRep_OnStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "OnRep_OnStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerRespawner.OnRespawnTransitionFinished
// (Final, Native, Protected)

void ARBPlayerRespawner::OnRespawnTransitionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "OnRespawnTransitionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerRespawner.IsInUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBPlayerRespawner::IsInUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerRespawner", "IsInUse");

	Params::RBPlayerRespawner_IsInUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerSeparatorVolume.OnBeginActorOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerSeparatorVolume::OnBeginActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSeparatorVolume", "OnBeginActorOverlap");

	Params::RBPlayerSeparatorVolume_OnBeginActorOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSeparatorVolume.OnEndActorOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerSeparatorVolume::OnEndActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSeparatorVolume", "OnEndActorOverlap");

	Params::RBPlayerSeparatorVolume_OnEndActorOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSeparatorVolume.OnRep_PlayerInside
// (Final, Native, Private)
// Parameters:
// class ARBPlayer*                        OldPlayerInside                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPlayerSeparatorVolume::OnRep_PlayerInside(class ARBPlayer* OldPlayerInside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSeparatorVolume", "OnRep_PlayerInside");

	Params::RBPlayerSeparatorVolume_OnRep_PlayerInside Parms{};

	Parms.OldPlayerInside = OldPlayerInside;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentDetectionMeter
// (Final, Native, Public)

void URBPlayerSoundDetectionComponent::OnRep_CurrentDetectionMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSoundDetectionComponent", "OnRep_CurrentDetectionMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentState
// (Final, Native, Public)
// Parameters:
// EPlayerSoundDetectionState              OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerSoundDetectionComponent::OnRep_CurrentState(EPlayerSoundDetectionState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSoundDetectionComponent", "OnRep_CurrentState");

	Params::RBPlayerSoundDetectionComponent_OnRep_CurrentState Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSoundDetectionComponent.SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerSoundDetectionComponent::SetEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSoundDetectionComponent", "SetEnabled");

	Params::RBPlayerSoundDetectionComponent_SetEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerSpawnPoint.GetSpawnPointTransform
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IRBPlayerSpawnPoint::GetSpawnPointTransform(struct FVector* OutPosition, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSpawnPoint", "GetSpawnPointTransform");

	Params::RBPlayerSpawnPoint_GetSpawnPointTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function OPP.RBPlayerSpawnPoint.ShouldActivateNV
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBPlayerSpawnPoint::ShouldActivateNV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerSpawnPoint", "ShouldActivateNV");

	Params::RBPlayerSpawnPoint_ShouldActivateNV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerStatsTabWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBPlayerStatsTabWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPlayerStatsTabWidget.OnPlayerStatsDataAvailable
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FRBStatContext>           Stats                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRBUIReleasedCharacterDetails>ReleasedCharacterDetailsList                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBPlayerStatsTabWidget::OnPlayerStatsDataAvailable(const TArray<struct FRBStatContext>& Stats, const TArray<struct FRBUIReleasedCharacterDetails>& ReleasedCharacterDetailsList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "OnPlayerStatsDataAvailable");

	Params::RBPlayerStatsTabWidget_OnPlayerStatsDataAvailable Parms{};

	Parms.Stats = std::move(Stats);
	Parms.ReleasedCharacterDetailsList = std::move(ReleasedCharacterDetailsList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerStatsTabWidget.GetGlobalStatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerStat                             PlayerStat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPlayerStatsTabWidget::GetGlobalStatValue(EPlayerStat PlayerStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "GetGlobalStatValue");

	Params::RBPlayerStatsTabWidget_GetGlobalStatValue Parms{};

	Parms.PlayerStat = PlayerStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerStatsTabWidget.GetReleasedCharacterDetailsList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBUIReleasedCharacterDetails>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBUIReleasedCharacterDetails> URBPlayerStatsTabWidget::GetReleasedCharacterDetailsList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "GetReleasedCharacterDetailsList");

	Params::RBPlayerStatsTabWidget_GetReleasedCharacterDetailsList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerStatsTabWidget.GetStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBStatContext>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBStatContext> URBPlayerStatsTabWidget::GetStats() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "GetStats");

	Params::RBPlayerStatsTabWidget_GetStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerStatsTabWidget.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerStatsTabWidget::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerStatsTabWidget", "IsDataPending");

	Params::RBPlayerStatsTabWidget_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPlayerTriggerComponent.OnActorLeft
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnActorLeft(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnActorLeft");

	Params::RBPlayerTriggerComponent_OnActorLeft Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnActorOverlapped
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnActorOverlapped(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnActorOverlapped");

	Params::RBPlayerTriggerComponent_OnActorOverlapped Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnComponentBeginOverlap");

	Params::RBPlayerTriggerComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnComponentEndOverlap");

	Params::RBPlayerTriggerComponent_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnPawnKilled
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnPawnKilled(class ARBPawn* InstigatorActor, class ARBPawn* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnPawnKilled");

	Params::RBPlayerTriggerComponent_OnPawnKilled Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnPawnRespawned
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnPawnRespawned(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnPawnRespawned");

	Params::RBPlayerTriggerComponent_OnPawnRespawned Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.OnPlayerRevived
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        InstigatorActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPlayer*                        SubjectActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPlayerTriggerComponent::OnPlayerRevived(class ARBPlayer* InstigatorActor, class ARBPlayer* SubjectActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "OnPlayerRevived");

	Params::RBPlayerTriggerComponent_OnPlayerRevived Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.SubjectActor = SubjectActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPlayerTriggerComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPlayerTriggerComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPlayerTriggerComponent", "IsEnabled");

	Params::RBPlayerTriggerComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPopUpConfirmCancelWidget.BP_Cancel
// (Final, Native, Public, BlueprintCallable)

void URBPopUpConfirmCancelWidget::BP_Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpConfirmCancelWidget", "BP_Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpConfirmCancelWidget.BP_Confirm
// (Final, Native, Public, BlueprintCallable)

void URBPopUpConfirmCancelWidget::BP_Confirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpConfirmCancelWidget", "BP_Confirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpConfirmCancelWidget.Event_InitializePopup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TitleText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ConfirmText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             CancelText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPopUpConfirmCancelWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText, const class FText& CancelText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpConfirmCancelWidget", "Event_InitializePopup");

	Params::RBPopUpConfirmCancelWidget_Event_InitializePopup Parms{};

	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);
	Parms.ConfirmText = std::move(ConfirmText);
	Parms.CancelText = std::move(CancelText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPopUpWaitWidget.BP_EndWait
// (Final, Native, Public, BlueprintCallable)

void URBPopUpWaitWidget::BP_EndWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpWaitWidget", "BP_EndWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpWaitWidget.Event_InitializePopup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TitleText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBPopUpWaitWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpWaitWidget", "Event_InitializePopup");

	Params::RBPopUpWaitWidget_Event_InitializePopup Parms{};

	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBPopUpInputTextWidget.BP_OnTextEntered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPopUpInputTextWidget::BP_OnTextEntered(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpInputTextWidget", "BP_OnTextEntered");

	Params::RBPopUpInputTextWidget_BP_OnTextEntered Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPopUpInputTextWidget.Event_InitializePopup
// (Event, Public, BlueprintEvent)

void URBPopUpInputTextWidget::Event_InitializePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPopUpInputTextWidget", "Event_InitializePopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URBPopUpConfirmWidget>WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TitleText                                              (Parm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (Parm, NativeAccessSpecifierPublic)
// class FText                             ConfirmText                                            (Parm, NativeAccessSpecifierPublic)
// class URBPopUpConfirmWidget*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPopUpConfirmWidget* URBPopUpBlueprintLibrary::CreatePopUpConfirm(class UObject* WorldContextObject, TSubclassOf<class URBPopUpConfirmWidget> WidgetType, const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPopUpBlueprintLibrary", "CreatePopUpConfirm");

	Params::RBPopUpBlueprintLibrary_CreatePopUpConfirm Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetType = WidgetType;
	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);
	Parms.ConfirmText = std::move(ConfirmText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirmCancel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URBPopUpConfirmCancelWidget>WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TitleText                                              (Parm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (Parm, NativeAccessSpecifierPublic)
// class FText                             ConfirmText                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             CancelText                                             (Parm, NativeAccessSpecifierPublic)
// class URBPopUpConfirmCancelWidget*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPopUpConfirmCancelWidget* URBPopUpBlueprintLibrary::CreatePopUpConfirmCancel(class UObject* WorldContextObject, TSubclassOf<class URBPopUpConfirmCancelWidget> WidgetType, const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText, const class FText& CancelText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPopUpBlueprintLibrary", "CreatePopUpConfirmCancel");

	Params::RBPopUpBlueprintLibrary_CreatePopUpConfirmCancel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetType = WidgetType;
	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);
	Parms.ConfirmText = std::move(ConfirmText);
	Parms.CancelText = std::move(CancelText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPopUpBlueprintLibrary.CreatePopUpInputText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URBPopUpInputTextWidget>WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBPopUpInputTextWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPopUpInputTextWidget* URBPopUpBlueprintLibrary::CreatePopUpInputText(class UObject* WorldContextObject, TSubclassOf<class URBPopUpInputTextWidget> WidgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPopUpBlueprintLibrary", "CreatePopUpInputText");

	Params::RBPopUpBlueprintLibrary_CreatePopUpInputText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetType = WidgetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPopUpBlueprintLibrary.CreatePopUpWait
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URBPopUpWaitWidget>   WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TitleText                                              (Parm, NativeAccessSpecifierPublic)
// class FText                             MainText                                               (Parm, NativeAccessSpecifierPublic)
// class URBPopUpWaitWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBPopUpWaitWidget* URBPopUpBlueprintLibrary::CreatePopUpWait(class UObject* WorldContextObject, TSubclassOf<class URBPopUpWaitWidget> WidgetType, const class FText& TitleText, const class FText& MainText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RBPopUpBlueprintLibrary", "CreatePopUpWait");

	Params::RBPopUpBlueprintLibrary_CreatePopUpWait Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetType = WidgetType;
	Parms.TitleText = std::move(TitleText);
	Parms.MainText = std::move(MainText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPostProcessUpdateManager.OnEnterNightVision
// (Event, Public, BlueprintEvent)

void ARBPostProcessUpdateManager::OnEnterNightVision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPostProcessUpdateManager", "OnEnterNightVision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPostProcessUpdateManager.OnExitNightVision
// (Event, Public, BlueprintEvent)

void ARBPostProcessUpdateManager::OnExitNightVision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPostProcessUpdateManager", "OnExitNightVision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPressurePanelComponent.CurrentInputRatioChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::CurrentInputRatioChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "CurrentInputRatioChangedCallback");

	Params::RBPressurePanelComponent_CurrentInputRatioChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.InputHeldChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::InputHeldChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "InputHeldChangedCallback");

	Params::RBPressurePanelComponent_InputHeldChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.InputRatioInZoneChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::InputRatioInZoneChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "InputRatioInZoneChangedCallback");

	Params::RBPressurePanelComponent_InputRatioInZoneChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.LastInputHeldStartedPawnTimeChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::LastInputHeldStartedPawnTimeChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "LastInputHeldStartedPawnTimeChangedCallback");

	Params::RBPressurePanelComponent_LastInputHeldStartedPawnTimeChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.Multicast_OnPanelSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "Multicast_OnPanelSucceeded");

	Params::RBPressurePanelComponent_Multicast_OnPanelSucceeded Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_CurrentInputRatio
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_CurrentInputRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_CurrentInputRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_CurrentMeter
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_CurrentMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_CurrentMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_InputHeld
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_InputHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_InputHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_InputRatioInZone
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_InputRatioInZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_InputRatioInZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_InputRatioTarget
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_InputRatioTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_InputRatioTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_LastInputHeldStartedPawnTime
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_LastInputHeldStartedPawnTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_LastInputHeldStartedPawnTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_Locked
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_Locked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_Locked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnRep_ValveType
// (Final, Native, Protected)

void URBPressurePanelComponent::OnRep_ValveType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnRep_ValveType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.OnUnlockingButtonStateChanged_Server
// (Final, Native, Public)
// Parameters:
// class URBCoopOperatableComponent*       Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPressurePanelComponent::OnUnlockingButtonStateChanged_Server(class URBCoopOperatableComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "OnUnlockingButtonStateChanged_Server");

	Params::RBPressurePanelComponent_OnUnlockingButtonStateChanged_Server Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPressurePanelComponent.GetCurrentMeterRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPressurePanelComponent::GetCurrentMeterRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "GetCurrentMeterRatio");

	Params::RBPressurePanelComponent_GetCurrentMeterRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPressurePanelComponent.GetUnlockedTimeLeftRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPressurePanelComponent::GetUnlockedTimeLeftRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "GetUnlockedTimeLeftRatio");

	Params::RBPressurePanelComponent_GetUnlockedTimeLeftRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPressurePanelComponent.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBPressurePanelComponent::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPressurePanelComponent", "IsCompleted");

	Params::RBPressurePanelComponent_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProjectionCodeCoordinator.OnInteractibleAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProjectionCodeCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnInteractibleAddedToWorld");

	Params::RBProjectionCodeCoordinator_OnInteractibleAddedToWorld Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectionCodeCoordinator.OnLargeObjectInteractionDoAction
// (Native, Protected)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*LargeObjectPanel                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProjectionCodeCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* LargeObjectPanel, class ARBLargePickup* LargePickup, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnLargeObjectInteractionDoAction");

	Params::RBProjectionCodeCoordinator_OnLargeObjectInteractionDoAction Parms{};

	Parms.LargeObjectPanel = LargeObjectPanel;
	Parms.LargePickup = LargePickup;
	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectionCodeCoordinator.OnLargePickupUsed_Server
// (Final, Native, Protected)
// Parameters:
// class ARBLargePickup*                   Pickup                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProjectionCodeCoordinator::OnLargePickupUsed_Server(class ARBLargePickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnLargePickupUsed_Server");

	Params::RBProjectionCodeCoordinator_OnLargePickupUsed_Server Parms{};

	Parms.Pickup = Pickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectionCodeCoordinator.OnLargePickupUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProjectionCodeCoordinator::OnLargePickupUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnLargePickupUsedOnObject");

	Params::RBProjectionCodeCoordinator_OnLargePickupUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectionCodeCoordinator.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProjectionCodeCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnPickupHolderChanged");

	Params::RBProjectionCodeCoordinator_OnPickupHolderChanged Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProjectionCodeCoordinator.OnRep_AvailableLargePickups
// (Final, Native, Protected)

void ARBProjectionCodeCoordinator::OnRep_AvailableLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProjectionCodeCoordinator", "OnRep_AvailableLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.ApplyCurrentOptims
// (Final, Native, Public, BlueprintCallable)

void URBPropOptimizerComponent::ApplyCurrentOptims()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "ApplyCurrentOptims");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.RecomputeControlledComponents
// (Final, Native, Public, BlueprintCallable)

void URBPropOptimizerComponent::RecomputeControlledComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "RecomputeControlledComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.SetCustomControlledMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      ControlledMeshes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPropOptimizerComponent::SetCustomControlledMeshes(const TArray<class UPrimitiveComponent*>& ControlledMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "SetCustomControlledMeshes");

	Params::RBPropOptimizerComponent_SetCustomControlledMeshes Parms{};

	Parms.ControlledMeshes = std::move(ControlledMeshes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.SetCustomControlledTimelines
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UTimelineComponent*>       ControlledTimelines                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPropOptimizerComponent::SetCustomControlledTimelines(const TArray<class UTimelineComponent*>& ControlledTimelines)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "SetCustomControlledTimelines");

	Params::RBPropOptimizerComponent_SetCustomControlledTimelines Parms{};

	Parms.ControlledTimelines = std::move(ControlledTimelines);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.SetForceUpdateAnims
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPropOptimizerComponent::SetForceUpdateAnims(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "SetForceUpdateAnims");

	Params::RBPropOptimizerComponent_SetForceUpdateAnims Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.SetOptimEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPropOptimizerComponent::SetOptimEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "SetOptimEnabled");

	Params::RBPropOptimizerComponent_SetOptimEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPropOptimizerComponent.SetTickEnabledOnProps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPropOptimizerComponent::SetTickEnabledOnProps(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPropOptimizerComponent", "SetTickEnabledOnProps");

	Params::RBPropOptimizerComponent_SetTickEnabledOnProps Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.BP_SetActive
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBProximityDetectableComponent::BP_SetActive(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "BP_SetActive");

	Params::RBProximityDetectableComponent_BP_SetActive Parms{};

	Parms.bNewActive = bNewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.BP_SetIsProgressLocked
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBProximityDetectableComponent::BP_SetIsProgressLocked(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "BP_SetIsProgressLocked");

	Params::RBProximityDetectableComponent_BP_SetIsProgressLocked Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnProgressLockedChanged
// (Event, Public, BlueprintEvent)

void URBProximityDetectableComponent::OnProgressLockedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnProgressLockedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectableComponent.OnRefreshLight
// (Event, Public, BlueprintEvent)

void URBProximityDetectableComponent::OnRefreshLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRefreshLight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectableComponent.OnRep_Active
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_Active()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_Active");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnRep_Detectors
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_Detectors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_Detectors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnRep_IsProgressLocked
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_IsProgressLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_IsProgressLocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnRep_ProgressActive
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_ProgressActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_ProgressActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnRep_ProgressCompleted
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_ProgressCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_ProgressCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.OnRep_ProgressLevel
// (Final, Native, Public)

void URBProximityDetectableComponent::OnRep_ProgressLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "OnRep_ProgressLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectableComponent.BP_ShouldTick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBProximityDetectableComponent::BP_ShouldTick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "BP_ShouldTick");

	Params::RBProximityDetectableComponent_BP_ShouldTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectableComponent.GetProgressRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBProximityDetectableComponent::GetProgressRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "GetProgressRatio");

	Params::RBProximityDetectableComponent_GetProgressRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectableComponent.IsProgressLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBProximityDetectableComponent::IsProgressLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectableComponent", "IsProgressLocked");

	Params::RBProximityDetectableComponent_IsProgressLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectionObjectiveCoordinator.OnProximityProgressCompleted
// (Final, Native, Protected)
// Parameters:
// class URBProximityDetectableComponent*  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectionObjectiveCoordinator::OnProximityProgressCompleted(class URBProximityDetectableComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectionObjectiveCoordinator", "OnProximityProgressCompleted");

	Params::RBProximityDetectionObjectiveCoordinator_OnProximityProgressCompleted Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityDetectorIcons
// (Final, Native, Private)

void ARBProximityDetectionObjectiveCoordinator::OnRep_ShowProximityDetectorIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectionObjectiveCoordinator", "OnRep_ShowProximityDetectorIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityTriggerIcons
// (Final, Native, Private)

void ARBProximityDetectionObjectiveCoordinator::OnRep_ShowProximityTriggerIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectionObjectiveCoordinator", "OnRep_ShowProximityTriggerIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectionObjectiveCoordinator::SetShowProximityDetectorIconsVisible_Server(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectionObjectiveCoordinator", "SetShowProximityDetectorIconsVisible_Server");

	Params::RBProximityDetectionObjectiveCoordinator_SetShowProximityDetectorIconsVisible_Server Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectionObjectiveCoordinator::SetShowProximityTriggerIconsVisible_Server(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectionObjectiveCoordinator", "SetShowProximityTriggerIconsVisible_Server");

	Params::RBProximityDetectionObjectiveCoordinator_SetShowProximityTriggerIconsVisible_Server Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.BP_OnCompletedLevel
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnCompletedLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnCompletedLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnDeviceStateChanged
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnDeviceStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnDeviceStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnEquipped
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnEquipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnHoldStateChanged
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnHoldStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnHoldStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnProgressChanged
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnProgressChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnProgressChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnProximityLevelChanged
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnProximityLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnProximityLevelChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnProximityStateChanged
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnProximityStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnProximityStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.BP_OnUnequipped
// (Event, Protected, BlueprintEvent)

void ARBProximityDetectorItem::BP_OnUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_OnUnequipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBProximityDetectorItem.Multicast_OnCompletedLevel
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARBProximityDetectorItem::Multicast_OnCompletedLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "Multicast_OnCompletedLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnButtonHeldChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectorItem::OnButtonHeldChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnButtonHeldChangedCallback");

	Params::RBProximityDetectorItem_OnButtonHeldChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnDetectorStateChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectorItem::OnDetectorStateChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnDetectorStateChangedCallback");

	Params::RBProximityDetectorItem_OnDetectorStateChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnProximityComponentDetectedChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBProximityDetectorItem::OnProximityComponentDetectedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnProximityComponentDetectedChangedCallback");

	Params::RBProximityDetectorItem_OnProximityComponentDetectedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnRep_ButtonHeld
// (Final, Native, Private)

void ARBProximityDetectorItem::OnRep_ButtonHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnRep_ButtonHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnRep_DetectorState
// (Final, Native, Private)

void ARBProximityDetectorItem::OnRep_DetectorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnRep_DetectorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnRep_ProximityComponentDetected
// (Final, Native, Private)

void ARBProximityDetectorItem::OnRep_ProximityComponentDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnRep_ProximityComponentDetected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnRep_ProximityLevel
// (Final, Native, Private)

void ARBProximityDetectorItem::OnRep_ProximityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnRep_ProximityLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.OnRep_ProximityZLevelState
// (Final, Native, Private)

void ARBProximityDetectorItem::OnRep_ProximityZLevelState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "OnRep_ProximityZLevelState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBProximityDetectorItem.BP_GetProgress
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBProximityDetectorItem::BP_GetProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_GetProgress");

	Params::RBProximityDetectorItem_BP_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.BP_IsHolding
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBProximityDetectorItem::BP_IsHolding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "BP_IsHolding");

	Params::RBProximityDetectorItem_BP_IsHolding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.GetDeviceType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProximityDetectorDeviceType            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProximityDetectorDeviceType ARBProximityDetectorItem::GetDeviceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "GetDeviceType");

	Params::RBProximityDetectorItem_GetDeviceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.GetProximityComponentDetected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBProximityDetectableComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBProximityDetectableComponent* ARBProximityDetectorItem::GetProximityComponentDetected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "GetProximityComponentDetected");

	Params::RBProximityDetectorItem_GetProximityComponentDetected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.GetProximityLevel
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARBProximityDetectorItem::GetProximityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "GetProximityLevel");

	Params::RBProximityDetectorItem_GetProximityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.GetProximityZLevelState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProximityDetectorZLevelState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProximityDetectorZLevelState ARBProximityDetectorItem::GetProximityZLevelState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "GetProximityZLevelState");

	Params::RBProximityDetectorItem_GetProximityZLevelState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBProximityDetectorItem.IsHoldingButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBProximityDetectorItem::IsHoldingButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBProximityDetectorItem", "IsHoldingButton");

	Params::RBProximityDetectorItem_IsHoldingButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPsychosisMine.DeinitPlacedInLevel_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPsychosisMine::DeinitPlacedInLevel_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "DeinitPlacedInLevel_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPsychosisMine.Event_EffectFinished
// (Event, Public, BlueprintEvent)

void ARBPsychosisMine::Event_EffectFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Event_EffectFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPsychosisMine.Event_OnActivate
// (Event, Public, BlueprintEvent)

void ARBPsychosisMine::Event_OnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Event_OnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPsychosisMine.Event_OnBreak
// (Event, Public, BlueprintEvent)

void ARBPsychosisMine::Event_OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Event_OnBreak");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPsychosisMine.Event_OnDeployed
// (Event, Public, BlueprintEvent)

void ARBPsychosisMine::Event_OnDeployed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Event_OnDeployed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPsychosisMine.Event_OnExpiredUnactivated
// (Event, Public, BlueprintEvent)

void ARBPsychosisMine::Event_OnExpiredUnactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Event_OnExpiredUnactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPsychosisMine.InitPlacedInLevel_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBPsychosisMine::InitPlacedInLevel_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "InitPlacedInLevel_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPsychosisMine.Multicast_OnDeploy
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class ARBPawn*                          Deployer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBPsychosisMine::Multicast_OnDeploy(class ARBPawn* Deployer, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "Multicast_OnDeploy");

	Params::RBPsychosisMine_Multicast_OnDeploy Parms{};

	Parms.Deployer = Deployer;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPsychosisMine.OnRep_State
// (Final, Native, Protected)

void ARBPsychosisMine::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPsychosisMine.GetPsychosisMineTriggerRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBPsychosisMine::GetPsychosisMineTriggerRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPsychosisMine", "GetPsychosisMineTriggerRadius");

	Params::RBPsychosisMine_GetPsychosisMineTriggerRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.AnimationDone
// (Final, Native, Public, BlueprintCallable)

void URBZoneTimingPanelComponent::AnimationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "AnimationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.CompleteGameplay_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBZoneTimingPanelComponent::CompleteGameplay_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "CompleteGameplay_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.Event_OnInputEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimingInputResultType                  Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneTimingPanelComponent::Event_OnInputEvent(class ARBPlayer* Player, int32 TargetIndex, float Timestamp, ETimingInputResultType Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Event_OnInputEvent");

	Params::RBZoneTimingPanelComponent_Event_OnInputEvent Parms{};

	Parms.Player = Player;
	Parms.TargetIndex = TargetIndex;
	Parms.Timestamp = Timestamp;
	Parms.Result = Result;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBZoneTimingPanelComponent.Event_OnInteractionAnimationDone
// (Event, Public, BlueprintEvent)

void URBZoneTimingPanelComponent::Event_OnInteractionAnimationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Event_OnInteractionAnimationDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBZoneTimingPanelComponent.Event_OnTargetInfoChanged
// (Event, Public, BlueprintEvent)

void URBZoneTimingPanelComponent::Event_OnTargetInfoChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Event_OnTargetInfoChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBZoneTimingPanelComponent.Event_OnThresholdReachedStateChanged
// (Event, Public, BlueprintEvent)

void URBZoneTimingPanelComponent::Event_OnThresholdReachedStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Event_OnThresholdReachedStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelInput
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NeedleRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PawnTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimingInputResultType                  Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneTimingPanelComponent::Multicast_OnPanelInput(class ARBPlayer* Player, float NeedleRatio, float PawnTimestamp, ETimingInputResultType Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Multicast_OnPanelInput");

	Params::RBZoneTimingPanelComponent_Multicast_OnPanelInput Parms{};

	Parms.Player = Player;
	Parms.NeedleRatio = NeedleRatio;
	Parms.PawnTimestamp = PawnTimestamp;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneTimingPanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "Multicast_OnPanelSucceeded");

	Params::RBZoneTimingPanelComponent_Multicast_OnPanelSucceeded Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnNeedleResetInitialRatioChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneTimingPanelComponent::OnNeedleResetInitialRatioChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnNeedleResetInitialRatioChangedCallback");

	Params::RBZoneTimingPanelComponent_OnNeedleResetInitialRatioChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnNeedleResetTimeStampChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneTimingPanelComponent::OnNeedleResetTimeStampChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnNeedleResetTimeStampChangedCallback");

	Params::RBZoneTimingPanelComponent_OnNeedleResetTimeStampChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetInitialRatio
// (Final, Native, Private)

void URBZoneTimingPanelComponent::OnRep_NeedleResetInitialRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnRep_NeedleResetInitialRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetTimeStamp
// (Final, Native, Private)

void URBZoneTimingPanelComponent::OnRep_NeedleResetTimeStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnRep_NeedleResetTimeStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnRep_TargetInfo
// (Final, Native, Private)

void URBZoneTimingPanelComponent::OnRep_TargetInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnRep_TargetInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.OnRep_ThresholdReached
// (Final, Native, Private)

void URBZoneTimingPanelComponent::OnRep_ThresholdReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "OnRep_ThresholdReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneTimingPanelComponent.BP_GetTimingInputResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETimingInputResultType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETimingInputResultType URBZoneTimingPanelComponent::BP_GetTimingInputResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "BP_GetTimingInputResult");

	Params::RBZoneTimingPanelComponent_BP_GetTimingInputResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetCurrentNeedlePosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBZoneTimingPanelComponent::GetCurrentNeedlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetCurrentNeedlePosition");

	Params::RBZoneTimingPanelComponent_GetCurrentNeedlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetMeterRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBZoneTimingPanelComponent::GetMeterRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetMeterRatio");

	Params::RBZoneTimingPanelComponent_GetMeterRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetNeedlePosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBZoneTimingPanelComponent::GetNeedlePosition(float Timestamp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetNeedlePosition");

	Params::RBZoneTimingPanelComponent_GetNeedlePosition Parms{};

	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetNeedleSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBZoneTimingPanelComponent::GetNeedleSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetNeedleSpeed");

	Params::RBZoneTimingPanelComponent_GetNeedleSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetResultIndexAtPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBZoneTimingPanelComponent::GetResultIndexAtPosition(float Ratio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetResultIndexAtPosition");

	Params::RBZoneTimingPanelComponent_GetResultIndexAtPosition Parms{};

	Parms.Ratio = Ratio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneTimingPanelComponent.GetZoneTimingCustomInteractionText
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Out_CustomInteractionText                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    Out_bInteractionFail                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBZoneTimingPanelComponent::GetZoneTimingCustomInteractionText(const class ARBPlayer* Player, class FText* Out_CustomInteractionText, bool* Out_bInteractionFail) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneTimingPanelComponent", "GetZoneTimingCustomInteractionText");

	Params::RBZoneTimingPanelComponent_GetZoneTimingCustomInteractionText Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out_CustomInteractionText != nullptr)
		*Out_CustomInteractionText = std::move(Parms.Out_CustomInteractionText);

	if (Out_bInteractionFail != nullptr)
		*Out_bInteractionFail = Parms.Out_bInteractionFail;

	return Parms.ReturnValue;
}


// Function OPP.RBVariatorManager.Multicast_Reset
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ARBVariatorManager::Multicast_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorManager", "Multicast_Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBVariatorManager.OnRep_ReplicatedVariatorInfos
// (Final, Native, Private)

void ARBVariatorManager::OnRep_ReplicatedVariatorInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorManager", "OnRep_ReplicatedVariatorInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBVariatorManager.GetCurrentVariatorConfigs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class URBVariatorInfo*>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class URBVariatorInfo*> ARBVariatorManager::GetCurrentVariatorConfigs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorManager", "GetCurrentVariatorConfigs");

	Params::RBVariatorManager_GetCurrentVariatorConfigs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBVariatorManager.GetFixedRollingGateVariatorType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERollingGateVariatorType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERollingGateVariatorType ARBVariatorManager::GetFixedRollingGateVariatorType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorManager", "GetFixedRollingGateVariatorType");

	Params::RBVariatorManager_GetFixedRollingGateVariatorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBVariatorManager.IsVariatorUniqueTypeActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUniqueVariatorType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBVariatorManager::IsVariatorUniqueTypeActive(EUniqueVariatorType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBVariatorManager", "IsVariatorUniqueTypeActive");

	Params::RBVariatorManager_IsVariatorUniqueTypeActive Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPumpZoneTimingComponent.Event_OnPumpIsFueledStateChanged
// (Event, Public, BlueprintEvent)

void URBPumpZoneTimingComponent::Event_OnPumpIsFueledStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "Event_OnPumpIsFueledStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBPumpZoneTimingComponent.OnRep_LinkedValves
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class URBValvePanelComponent*>   OldLinkedValves                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPumpZoneTimingComponent::OnRep_LinkedValves(const TArray<class URBValvePanelComponent*>& OldLinkedValves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "OnRep_LinkedValves");

	Params::RBPumpZoneTimingComponent_OnRep_LinkedValves Parms{};

	Parms.OldLinkedValves = std::move(OldLinkedValves);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPumpZoneTimingComponent.OnRep_PumpIsFueled
// (Final, Native, Private)

void URBPumpZoneTimingComponent::OnRep_PumpIsFueled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "OnRep_PumpIsFueled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPumpZoneTimingComponent.OnValveGameplayRatioChanged
// (Final, Native, Private)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPumpZoneTimingComponent::OnValveGameplayRatioChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "OnValveGameplayRatioChanged");

	Params::RBPumpZoneTimingComponent_OnValveGameplayRatioChanged Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPumpZoneTimingComponent.GetFuelRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBPumpZoneTimingComponent::GetFuelRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "GetFuelRatio");

	Params::RBPumpZoneTimingComponent_GetFuelRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPumpZoneTimingComponent.GetLinkedValves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class URBValvePanelComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class URBValvePanelComponent*> URBPumpZoneTimingComponent::GetLinkedValves() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPumpZoneTimingComponent", "GetLinkedValves");

	Params::RBPumpZoneTimingComponent_GetLinkedValves Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPushableComponent.OnPawnPushingChangedCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPushableComponent::OnPawnPushingChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushableComponent", "OnPawnPushingChangedCallback");

	Params::RBPushableComponent_OnPawnPushingChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushableComponent.OnRep_PawnPushing
// (Final, Native, Private)

void URBPushableComponent::OnRep_PawnPushing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushableComponent", "OnRep_PawnPushing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushableComponent.GetPawnPushing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPawn*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBPawn* URBPushableComponent::GetPawnPushing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushableComponent", "GetPawnPushing");

	Params::RBPushableComponent_GetPawnPushing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPushCartGoalManager.OnRep_Active
// (Final, Native, Public)

void ARBPushCartGoalManager::OnRep_Active()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartGoalManager", "OnRep_Active");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartGoalManager.OnRep_CartGoalReached
// (Final, Native, Public)

void ARBPushCartGoalManager::OnRep_CartGoalReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartGoalManager", "OnRep_CartGoalReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartGoalManager.OnRep_LinkedObjectiveCoordinator
// (Final, Native, Public)

void ARBPushCartGoalManager::OnRep_LinkedObjectiveCoordinator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartGoalManager", "OnRep_LinkedObjectiveCoordinator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartObjectiveCoordinator.OnRep_PushCartInfos
// (Final, Native, Protected)

void ARBPushCartObjectiveCoordinator::OnRep_PushCartInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartObjectiveCoordinator", "OnRep_PushCartInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartObjectiveCoordinator.OnTargetTriggerBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBPushCartObjectiveCoordinator::OnTargetTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartObjectiveCoordinator", "OnTargetTriggerBeginOverlap");

	Params::RBPushCartObjectiveCoordinator_OnTargetTriggerBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartRailBlocker.OnLinkedTriggered
// (Final, Native, Public)
// Parameters:
// bool                                    bIsOn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPushCartRailBlocker::OnLinkedTriggered(bool bIsOn, class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartRailBlocker", "OnLinkedTriggered");

	Params::RBPushCartRailBlocker_OnLinkedTriggered Parms{};

	Parms.bIsOn = bIsOn;
	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartSpawnerTrigger.GetGoalIconActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* IRBPushCartSpawnerTrigger::GetGoalIconActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartSpawnerTrigger", "GetGoalIconActor");

	Params::RBPushCartSpawnerTrigger_GetGoalIconActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPushCartSpawnerTrigger.GetGoalTrigger
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* IRBPushCartSpawnerTrigger::GetGoalTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartSpawnerTrigger", "GetGoalTrigger");

	Params::RBPushCartSpawnerTrigger_GetGoalTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPushCartSpawner.OnRep_Pushable
// (Final, Native, Public)

void ARBPushCartSpawner::OnRep_Pushable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartSpawner", "OnRep_Pushable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPushCartSpawner.OnRep_ScheduledForSpawn
// (Final, Native, Public)

void ARBPushCartSpawner::OnRep_ScheduledForSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPushCartSpawner", "OnRep_ScheduledForSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.OnPawnEnterRoom
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::OnPawnEnterRoom(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "OnPawnEnterRoom");

	Params::RBPuzzleRoomComponent_OnPawnEnterRoom Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.OnRep_Active
// (Final, Native, Public)

void URBPuzzleRoomComponent::OnRep_Active()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "OnRep_Active");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.OnRep_CountdownElapsed
// (Final, Native, Private)

void URBPuzzleRoomComponent::OnRep_CountdownElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "OnRep_CountdownElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.OnRep_Scheduled
// (Final, Native, Public)

void URBPuzzleRoomComponent::OnRep_Scheduled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "OnRep_Scheduled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.OnWorldPopulateFinished_Implementation
// (Native, Public)

void URBPuzzleRoomComponent::OnWorldPopulateFinished_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "OnWorldPopulateFinished_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.TryActivatePuzzleRoom_Server
// (Final, Native, Public)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::TryActivatePuzzleRoom_Server(class ARBPawn* Interactor, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "TryActivatePuzzleRoom_Server");

	Params::RBPuzzleRoomComponent_TryActivatePuzzleRoom_Server Parms{};

	Parms.Interactor = Interactor;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomComponent.GetAllLinkedBlacklights
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBBlacklight*>            OutBlacklights                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::GetAllLinkedBlacklights(TArray<class ARBBlacklight*>* OutBlacklights) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetAllLinkedBlacklights");

	Params::RBPuzzleRoomComponent_GetAllLinkedBlacklights Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBlacklights != nullptr)
		*OutBlacklights = std::move(Parms.OutBlacklights);
}


// Function OPP.RBPuzzleRoomComponent.GetAllLinkedLights
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBLight*>                 OutLights                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::GetAllLinkedLights(TArray<class ARBLight*>* OutLights) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetAllLinkedLights");

	Params::RBPuzzleRoomComponent_GetAllLinkedLights Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLights != nullptr)
		*OutLights = std::move(Parms.OutLights);
}


// Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodeDecals
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARBPasscodeNumberDecalActor*>OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::GetAllLinkedPasscodeDecals(TArray<class ARBPasscodeNumberDecalActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetAllLinkedPasscodeDecals");

	Params::RBPuzzleRoomComponent_GetAllLinkedPasscodeDecals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodePads
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class URBPasscodePadComponent*>  OutPads                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBPuzzleRoomComponent::GetAllLinkedPasscodePads(TArray<class URBPasscodePadComponent*>* OutPads) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetAllLinkedPasscodePads");

	Params::RBPuzzleRoomComponent_GetAllLinkedPasscodePads Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPads != nullptr)
		*OutPads = std::move(Parms.OutPads);
}


// Function OPP.RBPuzzleRoomComponent.GetLinkedTimerButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBSimpleInteractionComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSimpleInteractionComponent* URBPuzzleRoomComponent::GetLinkedTimerButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetLinkedTimerButton");

	Params::RBPuzzleRoomComponent_GetLinkedTimerButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPuzzleRoomComponent.GetNumberOfDigitsToUnlock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBPuzzleRoomComponent::GetNumberOfDigitsToUnlock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomComponent", "GetNumberOfDigitsToUnlock");

	Params::RBPuzzleRoomComponent_GetNumberOfDigitsToUnlock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomLargeInteractObjectiveCoordinator", "OnInteractibleAddedToWorld");

	Params::RBPuzzleRoomLargeInteractObjectiveCoordinator_OnInteractibleAddedToWorld Parms{};

	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction
// (Native, Protected)
// Parameters:
// class URBLargeObjectInteractionPanelComponent*LargeObjectPanel                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* LargeObjectPanel, class ARBLargePickup* LargePickup, class ARBPawn* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomLargeInteractObjectiveCoordinator", "OnLargeObjectInteractionDoAction");

	Params::RBPuzzleRoomLargeInteractObjectiveCoordinator_OnLargeObjectInteractionDoAction Parms{};

	Parms.LargeObjectPanel = LargeObjectPanel;
	Parms.LargePickup = LargePickup;
	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Interactible                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnLargePickupUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomLargeInteractObjectiveCoordinator", "OnLargePickupUsedOnObject");

	Params::RBPuzzleRoomLargeInteractObjectiveCoordinator_OnLargePickupUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnPickupHolderChanged
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomLargeInteractObjectiveCoordinator", "OnPickupHolderChanged");

	Params::RBPuzzleRoomLargeInteractObjectiveCoordinator_OnPickupHolderChanged Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups
// (Final, Native, Protected)

void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnRep_AvailableLargePickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBPuzzleRoomLargeInteractObjectiveCoordinator", "OnRep_AvailableLargePickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrapGroup.GenerateScenarioForEachTrap
// (Final, Native, Public)

void ARBTrapGroup::GenerateScenarioForEachTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapGroup", "GenerateScenarioForEachTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuitMenu.Cancel
// (Final, Native, Public, BlueprintCallable)

void URBQuitMenu::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuitMenu", "Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuitMenu.Event_Exiting
// (Event, Public, BlueprintEvent)

void URBQuitMenu::Event_Exiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuitMenu", "Event_Exiting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBQuitMenu.ExitGame
// (Final, Native, Public, BlueprintCallable)

void URBQuitMenu::ExitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuitMenu", "ExitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBQuitMenu.ExitToMainMenu
// (Final, Native, Public, BlueprintCallable)

void URBQuitMenu::ExitToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBQuitMenu", "ExitToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRadioDistraction.Event_Break
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBPawn*                          breakingPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRadioDistraction::Event_Break(class ARBPawn* breakingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRadioDistraction", "Event_Break");

	Params::RBRadioDistraction_Event_Break Parms{};

	Parms.breakingPawn = breakingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBRadioDistraction.Multicast_Break
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          breakingPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRadioDistraction::Multicast_Break(class ARBPawn* breakingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRadioDistraction", "Multicast_Break");

	Params::RBRadioDistraction_Multicast_Break Parms{};

	Parms.breakingPawn = breakingPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.CancelFindParty
// (Final, Native, Public, BlueprintCallable)

void URBTrialBoardMenuTabWidget::CancelFindParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CancelFindParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.CancelMatchCountdown
// (Final, Native, Public, BlueprintCallable)

void URBTrialBoardMenuTabWidget::CancelMatchCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CancelMatchCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_AddEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_AddEntry(class URBSocialMenuEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_AddEntry");

	Params::RBTrialBoardMenuTabWidget_Event_AddEntry Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_ChangeActiveSkill
// (Event, Public, BlueprintEvent)

void URBTrialBoardMenuTabWidget::Event_ChangeActiveSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_ChangeActiveSkill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_OnFilterChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ERBSocialMenuEntryFilter                Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_OnFilterChanged(ERBSocialMenuEntryFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_OnFilterChanged");

	Params::RBTrialBoardMenuTabWidget_Event_OnFilterChanged Parms{};

	Parms.Filter = Filter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBTrialBoardMenuTabWidget::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_RemoveEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_RemoveEntry(class URBSocialMenuEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_RemoveEntry");

	Params::RBTrialBoardMenuTabWidget_Event_RemoveEntry Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_RestoreEntryFocus
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_RestoreEntryFocus(class URBSocialMenuEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_RestoreEntryFocus");

	Params::RBTrialBoardMenuTabWidget_Event_RestoreEntryFocus Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_SetEntryPosition
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_SetEntryPosition(class URBSocialMenuEntry* Entry, const struct FVector2D& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_SetEntryPosition");

	Params::RBTrialBoardMenuTabWidget_Event_SetEntryPosition Parms{};

	Parms.Entry = Entry;
	Parms.Position = std::move(Position);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_ShowOptions
// (Event, Public, BlueprintEvent)

void URBTrialBoardMenuTabWidget::Event_ShowOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_ShowOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTrialBoardMenuTabWidget.Event_UpdatePartyInviteWidgetVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldBeVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::Event_UpdatePartyInviteWidgetVisibility(bool bShouldBeVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "Event_UpdatePartyInviteWidgetVisibility");

	Params::RBTrialBoardMenuTabWidget_Event_UpdatePartyInviteWidgetVisibility Parms{};

	Parms.bShouldBeVisible = bShouldBeVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrialBoardMenuTabWidget.FindParty
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::FindParty(const class FName& ProgramId, const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "FindParty");

	Params::RBTrialBoardMenuTabWidget_FindParty Parms{};

	Parms.ProgramId = ProgramId;
	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetSceneActor
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ARBSocialMenuSceneActor*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBSocialMenuSceneActor* URBTrialBoardMenuTabWidget::GetSceneActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetSceneActor");

	Params::RBTrialBoardMenuTabWidget_GetSceneActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetSocialMenuManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URBSocialMenuManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSocialMenuManager* URBTrialBoardMenuTabWidget::GetSocialMenuManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetSocialMenuManager");

	Params::RBTrialBoardMenuTabWidget_GetSocialMenuManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnDrawHud
// (Final, Native, Private)

void URBTrialBoardMenuTabWidget::OnDrawHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnDrawHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnEntryActionRequested
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnEntryActionRequested");

	Params::RBTrialBoardMenuTabWidget_OnEntryActionRequested Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnFilterChanged
// (Final, Native, Private)
// Parameters:
// ERBSocialMenuEntryFilter                Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnFilterChanged(ERBSocialMenuEntryFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnFilterChanged");

	Params::RBTrialBoardMenuTabWidget_OnFilterChanged Parms{};

	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnFindPartyStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindPartyState                  FindPartyState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnFindPartyStateUpdated");

	Params::RBTrialBoardMenuTabWidget_OnFindPartyStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.FindPartyState = std::move(FindPartyState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnGameStageInfoUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBGameStageInfo                 GameStageInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnGameStageInfoUpdated(const struct FRBGameStageInfo& GameStageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnGameStageInfoUpdated");

	Params::RBTrialBoardMenuTabWidget_OnGameStageInfoUpdated Parms{};

	Parms.GameStageInfo = std::move(GameStageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnMatchSettingsUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnMatchSettingsUpdated");

	Params::RBTrialBoardMenuTabWidget_OnMatchSettingsUpdated Parms{};

	Parms.MatchSettings = std::move(MatchSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnMatchStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchState                      MatchState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnMatchStateUpdated");

	Params::RBTrialBoardMenuTabWidget_OnMatchStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchState = std::move(MatchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnPartyOwnerMatchSettingsUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchSettings                   MatchSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnPartyOwnerMatchSettingsUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& MatchSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnPartyOwnerMatchSettingsUpdated");

	Params::RBTrialBoardMenuTabWidget_OnPartyOwnerMatchSettingsUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchSettings = std::move(MatchSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnPlayerJoinedGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnPlayerJoinedGame");

	Params::RBTrialBoardMenuTabWidget_OnPlayerJoinedGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeaving
// (Final, Native, Private)
// Parameters:
// EPlayerLeaveTarget                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnPlayerLeaving(EPlayerLeaveTarget Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnPlayerLeaving");

	Params::RBTrialBoardMenuTabWidget_OnPlayerLeaving Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeftGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnPlayerLeftGame");

	Params::RBTrialBoardMenuTabWidget_OnPlayerLeftGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnPlayerStatsDataAvailable
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FRBStatContext>           Stats                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRBUIReleasedCharacterDetails>ReleasedCharacterDetailsList                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnPlayerStatsDataAvailable(const TArray<struct FRBStatContext>& Stats, const TArray<struct FRBUIReleasedCharacterDetails>& ReleasedCharacterDetailsList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnPlayerStatsDataAvailable");

	Params::RBTrialBoardMenuTabWidget_OnPlayerStatsDataAvailable Parms{};

	Parms.Stats = std::move(Stats);
	Parms.ReleasedCharacterDetailsList = std::move(ReleasedCharacterDetailsList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.OnSocialMenuEntryCustomizationUpdated
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::OnSocialMenuEntryCustomizationUpdated(class URBSocialMenuEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "OnSocialMenuEntryCustomizationUpdated");

	Params::RBTrialBoardMenuTabWidget_OnSocialMenuEntryCustomizationUpdated Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SaveMatchSettings
// (Final, Native, Public, BlueprintCallable)

void URBTrialBoardMenuTabWidget::SaveMatchSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SaveMatchSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SetEnableCharacterOverlayWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnableCharacterOverlayWidgets                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::SetEnableCharacterOverlayWidgets(bool bInEnableCharacterOverlayWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SetEnableCharacterOverlayWidgets");

	Params::RBTrialBoardMenuTabWidget_SetEnableCharacterOverlayWidgets Parms{};

	Parms.bInEnableCharacterOverlayWidgets = bInEnableCharacterOverlayWidgets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SetFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERBSocialMenuEntryFilter                Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::SetFilter(ERBSocialMenuEntryFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SetFilter");

	Params::RBTrialBoardMenuTabWidget_SetFilter Parms{};

	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SetShowOtherPlayerOverlayWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShowOtherPlayerOverlayWidgets                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::SetShowOtherPlayerOverlayWidgets(bool bInShowOtherPlayerOverlayWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SetShowOtherPlayerOverlayWidgets");

	Params::RBTrialBoardMenuTabWidget_SetShowOtherPlayerOverlayWidgets Parms{};

	Parms.bInShowOtherPlayerOverlayWidgets = bInShowOtherPlayerOverlayWidgets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SetTrialChainId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TrialChainId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::SetTrialChainId(const class FName& TrialChainId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SetTrialChainId");

	Params::RBTrialBoardMenuTabWidget_SetTrialChainId Parms{};

	Parms.TrialChainId = TrialChainId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.SetTrialId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTrialBoardMenuTabWidget::SetTrialId(const class FName& TrialId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "SetTrialId");

	Params::RBTrialBoardMenuTabWidget_SetTrialId Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.StartMatchCountdown
// (Final, Native, Public, BlueprintCallable)

void URBTrialBoardMenuTabWidget::StartMatchCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "StartMatchCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTrialBoardMenuTabWidget.AreTrialsFromSameProgram
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             FirstTrialId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SecondTrialId                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::AreTrialsFromSameProgram(const class FName& FirstTrialId, const class FName& SecondTrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "AreTrialsFromSameProgram");

	Params::RBTrialBoardMenuTabWidget_AreTrialsFromSameProgram Parms{};

	Parms.FirstTrialId = FirstTrialId;
	Parms.SecondTrialId = SecondTrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanAddFriend
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanAddFriend() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanAddFriend");

	Params::RBTrialBoardMenuTabWidget_CanAddFriend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanCancelFindParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanCancelFindParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanCancelFindParty");

	Params::RBTrialBoardMenuTabWidget_CanCancelFindParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanCancelMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanCancelMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanCancelMatch");

	Params::RBTrialBoardMenuTabWidget_CanCancelMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanFindParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanFindParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanFindParty");

	Params::RBTrialBoardMenuTabWidget_CanFindParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanSelectTrial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanSelectTrial(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanSelectTrial");

	Params::RBTrialBoardMenuTabWidget_CanSelectTrial Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanSendPartyInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanSendPartyInvite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanSendPartyInvite");

	Params::RBTrialBoardMenuTabWidget_CanSendPartyInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.CanStartMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::CanStartMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "CanStartMatch");

	Params::RBTrialBoardMenuTabWidget_CanStartMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetBestTrialPersonalTQ
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBTrialBoardMenuTabWidget::GetBestTrialPersonalTQ(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetBestTrialPersonalTQ");

	Params::RBTrialBoardMenuTabWidget_GetBestTrialPersonalTQ Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBSocialMenuEntryFilter                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERBSocialMenuEntryFilter URBTrialBoardMenuTabWidget::GetFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetFilter");

	Params::RBTrialBoardMenuTabWidget_GetFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetMatchCurrentPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBTrialBoardMenuTabWidget::GetMatchCurrentPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetMatchCurrentPlayerCount");

	Params::RBTrialBoardMenuTabWidget_GetMatchCurrentPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetMatchSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMatchSettings             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMatchSettings URBTrialBoardMenuTabWidget::GetMatchSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetMatchSettings");

	Params::RBTrialBoardMenuTabWidget_GetMatchSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfilePlatform                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfilePlatform URBTrialBoardMenuTabWidget::GetPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetPlatform");

	Params::RBTrialBoardMenuTabWidget_GetPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetProgramId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName URBTrialBoardMenuTabWidget::GetProgramId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetProgramId");

	Params::RBTrialBoardMenuTabWidget_GetProgramId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.GetProgramTQ
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBTrialBoardMenuTabWidget::GetProgramTQ(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "GetProgramTQ");

	Params::RBTrialBoardMenuTabWidget_GetProgramTQ Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.HasAttemptedTrial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::HasAttemptedTrial(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "HasAttemptedTrial");

	Params::RBTrialBoardMenuTabWidget_HasAttemptedTrial Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.HasCompletedProgram
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::HasCompletedProgram(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "HasCompletedProgram");

	Params::RBTrialBoardMenuTabWidget_HasCompletedProgram Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsDataPending");

	Params::RBTrialBoardMenuTabWidget_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsMatchOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsMatchOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsMatchOwner");

	Params::RBTrialBoardMenuTabWidget_IsMatchOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsOperationPending");

	Params::RBTrialBoardMenuTabWidget_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsProgramUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsProgramUnlocked(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsProgramUnlocked");

	Params::RBTrialBoardMenuTabWidget_IsProgramUnlocked Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsProgramVisible
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ProgramId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsProgramVisible(const class FName& ProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsProgramVisible");

	Params::RBTrialBoardMenuTabWidget_IsProgramVisible Parms{};

	Parms.ProgramId = ProgramId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsSolo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsSolo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsSolo");

	Params::RBTrialBoardMenuTabWidget_IsSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsTrialCompleted
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPerfect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsTrialCompleted(const class FName& TrialId, bool bPerfect) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsTrialCompleted");

	Params::RBTrialBoardMenuTabWidget_IsTrialCompleted Parms{};

	Parms.TrialId = TrialId;
	Parms.bPerfect = bPerfect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsTrialEnabled
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsTrialEnabled(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsTrialEnabled");

	Params::RBTrialBoardMenuTabWidget_IsTrialEnabled Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.IsTrialUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::IsTrialUnlocked(const class FName& TrialId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "IsTrialUnlocked");

	Params::RBTrialBoardMenuTabWidget_IsTrialUnlocked Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.ShowFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::ShowFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "ShowFilter");

	Params::RBTrialBoardMenuTabWidget_ShowFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrialBoardMenuTabWidget.WouldTrialCompletionUnlockProgram
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrialId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutProgramId                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTrialBoardMenuTabWidget::WouldTrialCompletionUnlockProgram(const class FName& TrialId, class FName* OutProgramId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrialBoardMenuTabWidget", "WouldTrialCompletionUnlockProgram");

	Params::RBTrialBoardMenuTabWidget_WouldTrialCompletionUnlockProgram Parms{};

	Parms.TrialId = TrialId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProgramId != nullptr)
		*OutProgramId = Parms.OutProgramId;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomGroup.AddSelectedActors
// (Final, Native, Public)

void ARBRandomGroup::AddSelectedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomGroup", "AddSelectedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomGroup.CenterOnLinkedActors
// (Final, Native, Public)

void ARBRandomGroup::CenterOnLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomGroup", "CenterOnLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomGroup.SelectLinkedActors
// (Final, Native, Public)

void ARBRandomGroup::SelectLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomGroup", "SelectLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomGroup.GetRandomActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBRandomGroup::GetRandomActors(TArray<class AActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomGroup", "GetRandomActors");

	Params::RBRandomGroup_GetRandomActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function OPP.RBTriggerableGate.BP_ForceVariatorType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ERollingGateVariatorType                VariatorType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableGate::BP_ForceVariatorType(ERollingGateVariatorType VariatorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "BP_ForceVariatorType");

	Params::RBTriggerableGate_BP_ForceVariatorType Parms{};

	Parms.VariatorType = VariatorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableGate.Event_OnBlockableStateChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableGate::Event_OnBlockableStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "Event_OnBlockableStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableGate.Event_OnCurrentVariatorTypeChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableGate::Event_OnCurrentVariatorTypeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "Event_OnCurrentVariatorTypeChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableGate.Event_OnVariatorLogicEnabledChanged
// (Event, Public, BlueprintEvent)

void ARBTriggerableGate::Event_OnVariatorLogicEnabledChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "Event_OnVariatorLogicEnabledChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBTriggerableGate.OnRep_BlockableState
// (Final, Native, Private)

void ARBTriggerableGate::OnRep_BlockableState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "OnRep_BlockableState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableGate.OnRep_CurrentVariatorType
// (Final, Native, Private)

void ARBTriggerableGate::OnRep_CurrentVariatorType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "OnRep_CurrentVariatorType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableGate.OnRep_VariatorLogicEnabled
// (Final, Native, Private)

void ARBTriggerableGate::OnRep_VariatorLogicEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "OnRep_VariatorLogicEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableGate.SetVariatorActorsEnabled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTriggerableGate::SetVariatorActorsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "SetVariatorActorsEnabled");

	Params::RBTriggerableGate_SetVariatorActorsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableGate.GetBlockableState
// (Native, Public, Const)
// Parameters:
// EBlockableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlockableState ARBTriggerableGate::GetBlockableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "GetBlockableState");

	Params::RBTriggerableGate_GetBlockableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTriggerableGate.GetCurrentVariatorType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERollingGateVariatorType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERollingGateVariatorType ARBTriggerableGate::GetCurrentVariatorType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableGate", "GetCurrentVariatorType");

	Params::RBTriggerableGate_GetCurrentVariatorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizable.GetStateName
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FString                           StateA                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StateB                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBRandomizable::GetStateName(class FString* StateA, class FString* StateB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "GetStateName");

	Params::RBRandomizable_GetStateName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StateA != nullptr)
		*StateA = std::move(Parms.StateA);

	if (StateB != nullptr)
		*StateB = std::move(Parms.StateB);

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizable.PrepareState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           RandomOwner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRandomizable::PrepareState(bool bStateA, class AActor* RandomOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "PrepareState");

	Params::RBRandomizable_PrepareState Parms{};

	Parms.bStateA = bStateA;
	Parms.RandomOwner = RandomOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizable.SetShouldBeIgnoredForLots
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRandomizable::SetShouldBeIgnoredForLots(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "SetShouldBeIgnoredForLots");

	Params::RBRandomizable_SetShouldBeIgnoredForLots Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizable.SetState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStateA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRandomizable::SetState(bool bStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "SetState");

	Params::RBRandomizable_SetState Parms{};

	Parms.bStateA = bStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizable.IsStateA
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBRandomizable::IsStateA() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "IsStateA");

	Params::RBRandomizable_IsStateA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizable.ShouldBeIgnoredForLots
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBRandomizable::ShouldBeIgnoredForLots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizable", "ShouldBeIgnoredForLots");

	Params::RBRandomizable_ShouldBeIgnoredForLots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizableDeferredDecal.OnRep_Enabled
// (Final, Native, Public)

void ARBRandomizableDeferredDecal::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableDeferredDecal", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.BP_PrepareIsStateA
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsStateA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRandomizableHelperComponent::BP_PrepareIsStateA(bool bIsStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_PrepareIsStateA");

	Params::RBRandomizableHelperComponent_BP_PrepareIsStateA Parms{};

	Parms.bIsStateA = bIsStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.BP_SetIsStateA
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsStateA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRandomizableHelperComponent::BP_SetIsStateA(bool bIsStateA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_SetIsStateA");

	Params::RBRandomizableHelperComponent_BP_SetIsStateA Parms{};

	Parms.bIsStateA = bIsStateA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.BP_SetRandomState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ERandomState                            NewRandomState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRandomizableHelperComponent::BP_SetRandomState(ERandomState NewRandomState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_SetRandomState");

	Params::RBRandomizableHelperComponent_BP_SetRandomState Parms{};

	Parms.NewRandomState = NewRandomState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.BP_SetShouldBeIgnoredForLots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRandomizableHelperComponent::BP_SetShouldBeIgnoredForLots(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_SetShouldBeIgnoredForLots");

	Params::RBRandomizableHelperComponent_BP_SetShouldBeIgnoredForLots Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.Editor_TransferSharedActorToMatchActor
// (Final, Native, Public)

void URBRandomizableHelperComponent::Editor_TransferSharedActorToMatchActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "Editor_TransferSharedActorToMatchActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.IsolateSharedActorsToMatchState
// (Final, Native, Public, BlueprintCallable)

void URBRandomizableHelperComponent::IsolateSharedActorsToMatchState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "IsolateSharedActorsToMatchState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.OnRep_RandomState
// (Final, Native, Public)

void URBRandomizableHelperComponent::OnRep_RandomState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "OnRep_RandomState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.SelectLinkedActors
// (Final, Native, Public, BlueprintCallable)

void URBRandomizableHelperComponent::SelectLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "SelectLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.SelectSharedActors
// (Final, Native, Public, BlueprintCallable)

void URBRandomizableHelperComponent::SelectSharedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "SelectSharedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.SnapToState
// (Final, Native, Public, BlueprintCallable)

void URBRandomizableHelperComponent::SnapToState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "SnapToState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRandomizableHelperComponent.BP_IsStateA
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBRandomizableHelperComponent::BP_IsStateA() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_IsStateA");

	Params::RBRandomizableHelperComponent_BP_IsStateA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizableHelperComponent.BP_IsStateSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBRandomizableHelperComponent::BP_IsStateSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_IsStateSet");

	Params::RBRandomizableHelperComponent_BP_IsStateSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRandomizableHelperComponent.BP_ShouldBeIgnoredForLots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBRandomizableHelperComponent::BP_ShouldBeIgnoredForLots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRandomizableHelperComponent", "BP_ShouldBeIgnoredForLots");

	Params::RBRandomizableHelperComponent_BP_ShouldBeIgnoredForLots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.CoordinatorTutorialInfo.OnCompletionInProgressChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsProgressionInProgress                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCompletedByLocalPlayer                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoordinatorTutorialInfo::OnCompletionInProgressChanged(class ARBBaseObjectiveCoordinator* Coordinator, bool IsProgressionInProgress, bool IsCompletedByLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoordinatorTutorialInfo", "OnCompletionInProgressChanged");

	Params::CoordinatorTutorialInfo_OnCompletionInProgressChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.IsProgressionInProgress = IsProgressionInProgress;
	Parms.IsCompletedByLocalPlayer = IsCompletedByLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRechargeStationPanelComponent.OnRep_CurrentEnergy
// (Final, Native, Private)

void URBRechargeStationPanelComponent::OnRep_CurrentEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRechargeStationPanelComponent", "OnRep_CurrentEnergy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRechargeStationPanelComponent.OnRep_IsInCooldown
// (Final, Native, Private)

void URBRechargeStationPanelComponent::OnRep_IsInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRechargeStationPanelComponent", "OnRep_IsInCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRechargeStationPanelComponent.OnRep_IsRecharging
// (Final, Native, Private)

void URBRechargeStationPanelComponent::OnRep_IsRecharging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRechargeStationPanelComponent", "OnRep_IsRecharging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.AddLocalForcedLoadedLevels
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     LevelNames                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBStreaming::AddLocalForcedLoadedLevels(const TArray<class FName>& LevelNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "AddLocalForcedLoadedLevels");

	Params::RBStreaming_AddLocalForcedLoadedLevels Parms{};

	Parms.LevelNames = std::move(LevelNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.CancelPendingMapChange
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBStreaming::CancelPendingMapChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "CancelPendingMapChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.Multicast_ForceUnloadLevels
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<class FName>                     LevelsToUnload                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bResetWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStreaming::Multicast_ForceUnloadLevels(const TArray<class FName>& LevelsToUnload, bool bResetWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "Multicast_ForceUnloadLevels");

	Params::RBStreaming_Multicast_ForceUnloadLevels Parms{};

	Parms.LevelsToUnload = std::move(LevelsToUnload);
	Parms.bResetWorld = bResetWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.OnLevelsToExcludeChanged
// (Final, Native, Private)

void ARBStreaming::OnLevelsToExcludeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "OnLevelsToExcludeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.OnTargetStreamingStateUpdated
// (Final, Native, Private)

void ARBStreaming::OnTargetStreamingStateUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "OnTargetStreamingStateUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.PrepareMapChange
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     LevelNames                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ForcedLevelNames                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBStreaming::PrepareMapChange(const TArray<class FName>& LevelNames, const TArray<class FName>& ForcedLevelNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "PrepareMapChange");

	Params::RBStreaming_PrepareMapChange Parms{};

	Parms.LevelNames = std::move(LevelNames);
	Parms.ForcedLevelNames = std::move(ForcedLevelNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.StartMapTransition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBStreaming::StartMapTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "StartMapTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.UnloadLevels
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     LevelNames                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARBStreaming::UnloadLevels(const TArray<class FName>& LevelNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "UnloadLevels");

	Params::RBStreaming_UnloadLevels Parms{};

	Parms.LevelNames = std::move(LevelNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStreaming.IsTargetStateReachedAndStreamingStable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStreaming::IsTargetStateReachedAndStreamingStable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStreaming", "IsTargetStateReachedAndStreamingStable");

	Params::RBStreaming_IsTargetStateReachedAndStreamingStable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRegroupObjectiveActor.OnNumberOfPlayerInZoneChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NumberOfPlayers                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRegroupObjectiveActor::OnNumberOfPlayerInZoneChanged(int32 NumberOfPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnNumberOfPlayerInZoneChanged");

	Params::RBRegroupObjectiveActor_OnNumberOfPlayerInZoneChanged Parms{};

	Parms.NumberOfPlayers = NumberOfPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveActor.OnObjectiveEnded
// (Native, Event, Public, BlueprintEvent)

void IRBRegroupObjectiveActor::OnObjectiveEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnObjectiveEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveActor.OnObjectiveStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBRegroupObjectiveCoordinator*   Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRegroupObjectiveActor::OnObjectiveStarted(class ARBRegroupObjectiveCoordinator* Coordinator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnObjectiveStarted");

	Params::RBRegroupObjectiveActor_OnObjectiveStarted Parms{};

	Parms.Coordinator = Coordinator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveActor.OnRegroupActionFailed
// (Native, Event, Public, BlueprintEvent)

void IRBRegroupObjectiveActor::OnRegroupActionFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnRegroupActionFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveActor.OnRegroupObjectiveStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ERegroupObjectiveState                  NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRegroupObjectiveActor::OnRegroupObjectiveStateChanged(ERegroupObjectiveState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnRegroupObjectiveStateChanged");

	Params::RBRegroupObjectiveActor_OnRegroupObjectiveStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveActor.OnTotalNumberOfPlayersChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NumberOfPlayers                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRegroupObjectiveActor::OnTotalNumberOfPlayersChanged(int32 NumberOfPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveActor", "OnTotalNumberOfPlayersChanged");

	Params::RBRegroupObjectiveActor_OnTotalNumberOfPlayersChanged Parms{};

	Parms.NumberOfPlayers = NumberOfPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.BP_SetWaitingForBP
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRegroupObjectiveCoordinator::BP_SetWaitingForBP(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "BP_SetWaitingForBP");

	Params::RBRegroupObjectiveCoordinator_BP_SetWaitingForBP Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnOperatingFinished
// (Final, Native, Protected)
// Parameters:
// class URBOperatableComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRegroupObjectiveCoordinator::OnOperatingFinished(class URBOperatableComponent* Component, class ARBPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnOperatingFinished");

	Params::RBRegroupObjectiveCoordinator_OnOperatingFinished Parms{};

	Parms.Component = Component;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnPlayerDoAction
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRegroupObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnPlayerDoAction");

	Params::RBRegroupObjectiveCoordinator_OnPlayerDoAction Parms{};

	Parms.Player = Player;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnPlayerSimpleDoAction
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRegroupObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnPlayerSimpleDoAction");

	Params::RBRegroupObjectiveCoordinator_OnPlayerSimpleDoAction Parms{};

	Parms.Player = Player;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnRep_NumberOfPlayerInZone
// (Final, Native, Protected)

void ARBRegroupObjectiveCoordinator::OnRep_NumberOfPlayerInZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnRep_NumberOfPlayerInZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnRep_RegroupState
// (Final, Native, Protected)

void ARBRegroupObjectiveCoordinator::OnRep_RegroupState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnRep_RegroupState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRegroupObjectiveCoordinator.OnRep_TotalNumberOfPlayers
// (Final, Native, Protected)

void ARBRegroupObjectiveCoordinator::OnRep_TotalNumberOfPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRegroupObjectiveCoordinator", "OnRep_TotalNumberOfPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReleaseMenu.Event_CharacterReleased
// (Event, Protected, BlueprintEvent)

void URBReleaseMenu::Event_CharacterReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseMenu", "Event_CharacterReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBReleaseMenu.OnPlayerReleaseStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPlayerReleaseState              PlayerReleaseState                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBReleaseMenu::OnPlayerReleaseStateUpdated(const struct FPlayerReleaseState& PlayerReleaseState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseMenu", "OnPlayerReleaseStateUpdated");

	Params::RBReleaseMenu_OnPlayerReleaseStateUpdated Parms{};

	Parms.PlayerReleaseState = std::move(PlayerReleaseState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReleaseMenu.OnReleaseButtonDown
// (Final, Native, Protected, BlueprintCallable)

void URBReleaseMenu::OnReleaseButtonDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseMenu", "OnReleaseButtonDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReleaseMenu.OnReleaseButtonUp
// (Final, Native, Protected, BlueprintCallable)

void URBReleaseMenu::OnReleaseButtonUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseMenu", "OnReleaseButtonUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReleaseMenu.ReleaseCharacter
// (Final, Native, Protected, BlueprintCallable)

void URBReleaseMenu::ReleaseCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReleaseMenu", "ReleaseCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_SetAIConfigInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FAIConfigData                    AddedOverrides                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class URBPartialAIConfig*>       AdditionalConfigs                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_SetAIConfigInfo(const struct FAIConfigData& AddedOverrides, const TArray<class URBPartialAIConfig*>& AdditionalConfigs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_SetAIConfigInfo");

	Params::RBRemoteDebuggingComponent_Client_SetAIConfigInfo Parms{};

	Parms.AddedOverrides = std::move(AddedOverrides);
	Parms.AdditionalConfigs = std::move(AdditionalConfigs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_SetRecentAnalyticsEvents
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<class FString>                   RecentEvents                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_SetRecentAnalyticsEvents(const TArray<class FString>& RecentEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_SetRecentAnalyticsEvents");

	Params::RBRemoteDebuggingComponent_Client_SetRecentAnalyticsEvents Parms{};

	Parms.RecentEvents = std::move(RecentEvents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateBotDebugInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FBotDebugInfo                    DebugInfo                                              (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateBotDebugInfo(const struct FBotDebugInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateBotDebugInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateBotDebugInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateGameplayRandomizationDebugInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FGameplayRandomizationDebugInfo  DebugInfo                                              (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateGameplayRandomizationDebugInfo(const struct FGameplayRandomizationDebugInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateGameplayRandomizationDebugInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateGameplayRandomizationDebugInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateMusicDebugInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FMusicDebugInfo                  DebugInfo                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateMusicDebugInfo(const struct FMusicDebugInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateMusicDebugInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateMusicDebugInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateOverseerInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FOverseerInfo                    OverseerInfo                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateOverseerInfo(const struct FOverseerInfo& OverseerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateOverseerInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateOverseerInfo Parms{};

	Parms.OverseerInfo = std::move(OverseerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdatePlayerDebugInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FPlayerDebugInfo                 DebugInfo                                              (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdatePlayerDebugInfo(const struct FPlayerDebugInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdatePlayerDebugInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdatePlayerDebugInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateScoringDebugInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FScoringDebugInfo                DebugInfo                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateScoringDebugInfo(const struct FScoringDebugInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateScoringDebugInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateScoringDebugInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Client_UpdateServerStreamingInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FLevelStreamingInfo              DebugInfo                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Client_UpdateServerStreamingInfo(const struct FLevelStreamingInfo& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Client_UpdateServerStreamingInfo");

	Params::RBRemoteDebuggingComponent_Client_UpdateServerStreamingInfo Parms{};

	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRemoteDebuggingComponent.Server_SetDebuggingState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FRemoteDebuggingState            Param_DebuggingState                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URBRemoteDebuggingComponent::Server_SetDebuggingState(const struct FRemoteDebuggingState& Param_DebuggingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRemoteDebuggingComponent", "Server_SetDebuggingState");

	Params::RBRemoteDebuggingComponent_Server_SetDebuggingState Parms{};

	Parms.Param_DebuggingState = std::move(Param_DebuggingState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReplayTutorialMenu.Cancel
// (Final, Native, Public, BlueprintCallable)

void URBReplayTutorialMenu::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReplayTutorialMenu", "Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReplayTutorialMenu.Event_Exiting
// (Event, Public, BlueprintEvent)

void URBReplayTutorialMenu::Event_Exiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReplayTutorialMenu", "Event_Exiting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBReplayTutorialMenu.FindTutorialServer
// (Final, Native, Public, BlueprintCallable)

void URBReplayTutorialMenu::FindTutorialServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReplayTutorialMenu", "FindTutorialServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReplayTutorialMenu.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBReplayTutorialMenu::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReplayTutorialMenu", "IsOperationPending");

	Params::RBReplayTutorialMenu_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBReportPlayerMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBReportPlayerMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBReportPlayerMenu.FilterDetailsText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBReportPlayerMenu::FilterDetailsText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "FilterDetailsText");

	Params::RBReportPlayerMenu_FilterDetailsText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBReportPlayerMenu.Send
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerReportReason                     Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReasonText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBReportPlayerMenu::Send(EPlayerReportReason Reason, const class FString& ReasonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "Send");

	Params::RBReportPlayerMenu_Send Parms{};

	Parms.Reason = Reason;
	Parms.ReasonText = std::move(ReasonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBReportPlayerMenu.GetPlayerDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBReportPlayerMenu::GetPlayerDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "GetPlayerDisplayName");

	Params::RBReportPlayerMenu_GetPlayerDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBReportPlayerMenu.GetPlayerPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfilePlatform                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfilePlatform URBReportPlayerMenu::GetPlayerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "GetPlayerPlatform");

	Params::RBReportPlayerMenu_GetPlayerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBReportPlayerMenu.GetPlayerReportReasonText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerReportReason                     Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText URBReportPlayerMenu::GetPlayerReportReasonText(EPlayerReportReason Reason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBReportPlayerMenu", "GetPlayerReportReasonText");

	Params::RBReportPlayerMenu_GetPlayerReportReasonText Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRepulsionComponent.ActivateScheduledState
// (Final, Native, Public)

void URBRepulsionComponent::ActivateScheduledState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "ActivateScheduledState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.AddPawnException
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRepulsionComponent::AddPawnException(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "AddPawnException");

	Params::RBRepulsionComponent_AddPawnException Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.AddRepulsionRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERepulsionRuleType                      RuleType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RepulsionDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseVelocityOverLocation                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRepulsionRule                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRepulsionRule URBRepulsionComponent::AddRepulsionRule(ERepulsionRuleType RuleType, int32 RepulsionDirection, bool bUseVelocityOverLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "AddRepulsionRule");

	Params::RBRepulsionComponent_AddRepulsionRule Parms{};

	Parms.RuleType = RuleType;
	Parms.RepulsionDirection = RepulsionDirection;
	Parms.bUseVelocityOverLocation = bUseVelocityOverLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRepulsionComponent.BP_SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRepulsionComponent::BP_SetEnabled(bool bNewValue, float Delay, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "BP_SetEnabled");

	Params::RBRepulsionComponent_BP_SetEnabled Parms{};

	Parms.bNewValue = bNewValue;
	Parms.Delay = Delay;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.OnRep_RepulsionRules
// (Final, Native, Public)

void URBRepulsionComponent::OnRep_RepulsionRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "OnRep_RepulsionRules");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.OnRep_ScheduledState
// (Final, Native, Public)

void URBRepulsionComponent::OnRep_ScheduledState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "OnRep_ScheduledState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.OnRep_ScheduledTime
// (Final, Native, Public)

void URBRepulsionComponent::OnRep_ScheduledTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "OnRep_ScheduledTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRepulsionComponent.SetOriginalSizeToCurrentSize
// (Final, Native, Public, BlueprintCallable)

void URBRepulsionComponent::SetOriginalSizeToCurrentSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRepulsionComponent", "SetOriginalSizeToCurrentSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.BP_OnAddInputHorizontal
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanelPart::BP_OnAddInputHorizontal(float Val, bool bIsGamepad, float DeltaValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_OnAddInputHorizontal");

	Params::RBSwitchPanelPart_BP_OnAddInputHorizontal Parms{};

	Parms.Val = Val;
	Parms.bIsGamepad = bIsGamepad;
	Parms.DeltaValue = DeltaValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchPanelPart.BP_OnAddInputVertical
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanelPart::BP_OnAddInputVertical(float Val, bool bIsGamepad, float DeltaValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_OnAddInputVertical");

	Params::RBSwitchPanelPart_BP_OnAddInputVertical Parms{};

	Parms.Val = Val;
	Parms.bIsGamepad = bIsGamepad;
	Parms.DeltaValue = DeltaValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchPanelPart.BP_OnStartInteract
// (Event, Public, BlueprintEvent)

void ARBSwitchPanelPart::BP_OnStartInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_OnStartInteract");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanelPart.BP_OnStopInteract
// (Event, Public, BlueprintEvent)

void ARBSwitchPanelPart::BP_OnStopInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_OnStopInteract");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanelPart.BP_OnSwitchStatusChanged
// (Event, Public, BlueprintEvent)

void ARBSwitchPanelPart::BP_OnSwitchStatusChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_OnSwitchStatusChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchPanelPart.BP_ResetValues
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bKeepCurrentValues                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanelPart::BP_ResetValues(bool bKeepCurrentValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_ResetValues");

	Params::RBSwitchPanelPart_BP_ResetValues Parms{};

	Parms.bKeepCurrentValues = bKeepCurrentValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.BP_SetSwitchStatus
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanelPart::BP_SetSwitchStatus(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_SetSwitchStatus");

	Params::RBSwitchPanelPart_BP_SetSwitchStatus Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.Multicast_ResetValues
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DesiredSwitchStatusValue                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSwitchPanelPart::Multicast_ResetValues(float DesiredSwitchStatusValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "Multicast_ResetValues");

	Params::RBSwitchPanelPart_Multicast_ResetValues Parms{};

	Parms.DesiredSwitchStatusValue = DesiredSwitchStatusValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.OnRep_ActiveSwitchValue
// (Final, Native, Public)

void ARBSwitchPanelPart::OnRep_ActiveSwitchValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "OnRep_ActiveSwitchValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork
// (Final, Native, Public)

void ARBSwitchPanelPart::OnRep_DesiredSwitchStatusNetwork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "OnRep_DesiredSwitchStatusNetwork");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork_Callback
// (Final, Native, Public)

void ARBSwitchPanelPart::OnRep_DesiredSwitchStatusNetwork_Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "OnRep_DesiredSwitchStatusNetwork_Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchPanelPart.BP_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSwitchPanelPart::BP_IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_IsActive");

	Params::RBSwitchPanelPart_BP_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSwitchPanelPart.BP_IsCloseToActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSwitchPanelPart::BP_IsCloseToActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_IsCloseToActive");

	Params::RBSwitchPanelPart_BP_IsCloseToActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSwitchPanelPart.BP_IsPanelEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSwitchPanelPart::BP_IsPanelEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchPanelPart", "BP_IsPanelEnabled");

	Params::RBSwitchPanelPart_BP_IsPanelEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRespawnLimiterZone.SetEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRespawnLimiterZone::SetEnabled(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRespawnLimiterZone", "SetEnabled");

	Params::RBRespawnLimiterZone_SetEnabled Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRespawnLimiterZone.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBRespawnLimiterZone::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRespawnLimiterZone", "IsEnabled");

	Params::RBRespawnLimiterZone_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRewardMenu.GetRewardSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERewardSource                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERewardSource URBRewardMenu::GetRewardSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRewardMenu", "GetRewardSource");

	Params::RBRewardMenu_GetRewardSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRewardMenu.GetUIXPGainInfoList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRBUIXPGainInfo>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FRBUIXPGainInfo> URBRewardMenu::GetUIXPGainInfoList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRewardMenu", "GetUIXPGainInfoList");

	Params::RBRewardMenu_GetUIXPGainInfoList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRewardRoomComponent.OnLinkedDoorUnlocked
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBRewardRoomComponent::OnLinkedDoorUnlocked(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRewardRoomComponent", "OnLinkedDoorUnlocked");

	Params::RBRewardRoomComponent_OnLinkedDoorUnlocked Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRewardRoomComponent.OnRep_LinkedRewardDoor
// (Final, Native, Public)

void URBRewardRoomComponent::OnRep_LinkedRewardDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRewardRoomComponent", "OnRep_LinkedRewardDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRewardRoomComponent.OnRep_Scheduled
// (Final, Native, Public)

void URBRewardRoomComponent::OnRep_Scheduled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRewardRoomComponent", "OnRep_Scheduled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRollingGateVariatorActor.SetVariatorEnabled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBRollingGateVariatorActor::SetVariatorEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRollingGateVariatorActor", "SetVariatorEnabled");

	Params::RBRollingGateVariatorActor_SetVariatorEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.BP_GetActiveObjectivesInside
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutObjectiveActors                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBRoom::BP_GetActiveObjectivesInside(TArray<class AActor*>* OutObjectiveActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "BP_GetActiveObjectivesInside");

	Params::RBRoom_BP_GetActiveObjectivesInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjectiveActors != nullptr)
		*OutObjectiveActors = std::move(Parms.OutObjectiveActors);
}


// Function OPP.RBRoom.BP_GetPossibleObjectivesInside
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutObjectiveActors                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBRoom::BP_GetPossibleObjectivesInside(TArray<class AActor*>* OutObjectiveActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "BP_GetPossibleObjectivesInside");

	Params::RBRoom_BP_GetPossibleObjectivesInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjectiveActors != nullptr)
		*OutObjectiveActors = std::move(Parms.OutObjectiveActors);
}


// Function OPP.RBRoom.Editor_ClearFromRoomGroups
// (Final, Native, Public)

void ARBRoom::Editor_ClearFromRoomGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_ClearFromRoomGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_ClearRoomLink
// (Final, Native, Public)

void ARBRoom::Editor_ClearRoomLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_ClearRoomLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_LinkAllSelectedRooms
// (Final, Native, Public)

void ARBRoom::Editor_LinkAllSelectedRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_LinkAllSelectedRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_PreviewActivated
// (Final, Native, Public)

void ARBRoom::Editor_PreviewActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_PreviewActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_PreviewCompleted
// (Final, Native, Public)

void ARBRoom::Editor_PreviewCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_PreviewCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_PreviewDeactivated
// (Final, Native, Public)

void ARBRoom::Editor_PreviewDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_PreviewDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_PreviewPrizeAvailable
// (Final, Native, Public)

void ARBRoom::Editor_PreviewPrizeAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_PreviewPrizeAvailable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_SelectAllConnectors
// (Final, Native, Public)

void ARBRoom::Editor_SelectAllConnectors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_SelectAllConnectors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_SelectAllLinkedRooms
// (Final, Native, Public)

void ARBRoom::Editor_SelectAllLinkedRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_SelectAllLinkedRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_SelectCurrentRoomGroups
// (Final, Native, Public)

void ARBRoom::Editor_SelectCurrentRoomGroups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_SelectCurrentRoomGroups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.Editor_SetAsRoomLinkMaster
// (Final, Native, Public)

void ARBRoom::Editor_SetAsRoomLinkMaster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "Editor_SetAsRoomLinkMaster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.OnActorEnterRoom
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRoom::OnActorEnterRoom(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "OnActorEnterRoom");

	Params::RBRoom_OnActorEnterRoom Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.OnActorExitRoom
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRoom::OnActorExitRoom(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "OnActorExitRoom");

	Params::RBRoom_OnActorExitRoom Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoom.GetAllOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSet<class AActor*>                     OutActors                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void ARBRoom::GetAllOverlappingActors(TSet<class AActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "GetAllOverlappingActors");

	Params::RBRoom_GetAllOverlappingActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function OPP.RBRoom.GetLinkedMissionRoomGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBRoomGroup*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBRoomGroup* ARBRoom::GetLinkedMissionRoomGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "GetLinkedMissionRoomGroup");

	Params::RBRoom_GetLinkedMissionRoomGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoom.IsSlaveRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBRoom::IsSlaveRoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoom", "IsSlaveRoom");

	Params::RBRoom_IsSlaveRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoomGroup.BP_GetActiveObjectivesInside
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutObjectiveActors                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBRoomGroup::BP_GetActiveObjectivesInside(TArray<class AActor*>* OutObjectiveActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "BP_GetActiveObjectivesInside");

	Params::RBRoomGroup_BP_GetActiveObjectivesInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjectiveActors != nullptr)
		*OutObjectiveActors = std::move(Parms.OutObjectiveActors);
}


// Function OPP.RBRoomGroup.BP_GetPossibleObjectivesInside
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutObjectiveActors                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARBRoomGroup::BP_GetPossibleObjectivesInside(TArray<class AActor*>* OutObjectiveActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "BP_GetPossibleObjectivesInside");

	Params::RBRoomGroup_BP_GetPossibleObjectivesInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjectiveActors != nullptr)
		*OutObjectiveActors = std::move(Parms.OutObjectiveActors);
}


// Function OPP.RBRoomGroup.BP_SetSectionClosedOff
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClosedOff                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnapToState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBRoomGroup::BP_SetSectionClosedOff(bool bClosedOff, bool bSnapToState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "BP_SetSectionClosedOff");

	Params::RBRoomGroup_BP_SetSectionClosedOff Parms{};

	Parms.bClosedOff = bClosedOff;
	Parms.bSnapToState = bSnapToState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.Editor_ClearInvalidRooms
// (Final, Native, Public)

void ARBRoomGroup::Editor_ClearInvalidRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "Editor_ClearInvalidRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.Editor_LinkAllSelectedRooms
// (Final, Native, Public)

void ARBRoomGroup::Editor_LinkAllSelectedRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "Editor_LinkAllSelectedRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.Editor_SelectedAllLinkedRooms
// (Final, Native, Public)

void ARBRoomGroup::Editor_SelectedAllLinkedRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "Editor_SelectedAllLinkedRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.Editor_UnlinkAllSelectedRooms
// (Final, Native, Public)

void ARBRoomGroup::Editor_UnlinkAllSelectedRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "Editor_UnlinkAllSelectedRooms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.OnRep_IsMissionRoomGroup
// (Final, Native, Public)

void ARBRoomGroup::OnRep_IsMissionRoomGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "OnRep_IsMissionRoomGroup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBRoomGroup.BP_GetVolumeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AVolume*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVolume*> ARBRoomGroup::BP_GetVolumeList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomGroup", "BP_GetVolumeList");

	Params::RBRoomGroup_BP_GetVolumeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBRoomPostProcessComponent.OnWorldPopulateFinished_Implementation
// (Native, Public)

void URBRoomPostProcessComponent::OnWorldPopulateFinished_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBRoomPostProcessComponent", "OnWorldPopulateFinished_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.BP_Cheat_ForceSASState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ESASState                               State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::BP_Cheat_ForceSASState(ESASState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_Cheat_ForceSASState");

	Params::RBSAS_BP_Cheat_ForceSASState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.BP_OnStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ESASState                               State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::BP_OnStateChanged(ESASState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_OnStateChanged");

	Params::RBSAS_BP_OnStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSAS.Event_OnCleanSAS
// (Event, Public, BlueprintEvent)

void ARBSAS::Event_OnCleanSAS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "Event_OnCleanSAS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSAS.OnGamePhaseUpdated
// (Final, Native, Protected)
// Parameters:
// EGamePhase                              GamePhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::OnGamePhaseUpdated(EGamePhase GamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnGamePhaseUpdated");

	Params::RBSAS_OnGamePhaseUpdated Parms{};

	Parms.GamePhase = GamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnPawnRespawned
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::OnPawnRespawned(class ARBPawn* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnPawnRespawned");

	Params::RBSAS_OnPawnRespawned Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnPlayerEnteredEvent
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::OnPlayerEnteredEvent(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnPlayerEnteredEvent");

	Params::RBSAS_OnPlayerEnteredEvent Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnPlayerExitedEvent
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::OnPlayerExitedEvent(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnPlayerExitedEvent");

	Params::RBSAS_OnPlayerExitedEvent Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnRep_CurrentState
// (Final, Native, Protected)

void ARBSAS::OnRep_CurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnRep_CurrentState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnStageEnded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IsRestarting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSAS::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool IsRestarting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnStageEnded");

	Params::RBSAS_OnStageEnded Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);
	Parms.IsRestarting = IsRestarting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.OnStageReady
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FRBStageID                       StageID                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRBMissionID                     MissionID                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARBSAS::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "OnStageReady");

	Params::RBSAS_OnStageReady Parms{};

	Parms.StageID = std::move(StageID);
	Parms.MissionID = std::move(MissionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSAS.BP_GetCurrentlyLoadedTrialStageName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBSAS::BP_GetCurrentlyLoadedTrialStageName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_GetCurrentlyLoadedTrialStageName");

	Params::RBSAS_BP_GetCurrentlyLoadedTrialStageName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSAS.BP_GetNextTrialStageName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBSAS::BP_GetNextTrialStageName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_GetNextTrialStageName");

	Params::RBSAS_BP_GetNextTrialStageName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSAS.BP_GetPreviousTrialStageName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBSAS::BP_GetPreviousTrialStageName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_GetPreviousTrialStageName");

	Params::RBSAS_BP_GetPreviousTrialStageName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSAS.BP_GetTrialNameFromChainIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ChainIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ARBSAS::BP_GetTrialNameFromChainIndex(int32 ChainIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSAS", "BP_GetTrialNameFromChainIndex");

	Params::RBSAS_BP_GetTrialNameFromChainIndex Parms{};

	Parms.ChainIndex = ChainIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASTube.BP_ForceAutoDoorState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EAutoDoorState                          InDoorState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSASTube::BP_ForceAutoDoorState(EAutoDoorState InDoorState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_ForceAutoDoorState");

	Params::RBSASTube_BP_ForceAutoDoorState Parms{};

	Parms.InDoorState = InDoorState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.BP_OnClose
// (Event, Public, BlueprintEvent)

void ARBSASTube::BP_OnClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_OnClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.BP_OnDoorAnimationFinished
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBSASTube::BP_OnDoorAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_OnDoorAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.BP_OnOpen
// (Event, Public, BlueprintEvent)

void ARBSASTube::BP_OnOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_OnOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.BP_OnPlayersInsideChanged
// (Event, Public, BlueprintEvent)

void ARBSASTube::BP_OnPlayersInsideChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_OnPlayersInsideChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.BP_OnPreBeginPlay
// (Event, Public, BlueprintEvent)

void ARBSASTube::BP_OnPreBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "BP_OnPreBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.Event_OnDoorStateChanged
// (Event, Public, BlueprintEvent)

void ARBSASTube::Event_OnDoorStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "Event_OnDoorStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.Event_OnTubeFacingForwardChanged
// (Event, Public, BlueprintEvent)

void ARBSASTube::Event_OnTubeFacingForwardChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "Event_OnTubeFacingForwardChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTube.OnComponentBoxBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSASTube::OnComponentBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnComponentBoxBeginOverlap");

	Params::RBSASTube_OnComponentBoxBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnComponentCapsuleBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSASTube::OnComponentCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnComponentCapsuleBeginOverlap");

	Params::RBSASTube_OnComponentCapsuleBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnComponentCapsuleEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSASTube::OnComponentCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnComponentCapsuleEndOverlap");

	Params::RBSASTube_OnComponentCapsuleEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnRep_DoorState
// (Final, Native, Private)

void ARBSASTube::OnRep_DoorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnRep_DoorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnRep_IsOpened
// (Final, Native, Private)

void ARBSASTube::OnRep_IsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnRep_IsOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnRep_PlayersInside
// (Final, Native, Private)

void ARBSASTube::OnRep_PlayersInside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnRep_PlayersInside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.OnRep_TubeFacingForward
// (Final, Native, Private)

void ARBSASTube::OnRep_TubeFacingForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "OnRep_TubeFacingForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTube.GetDoorState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAutoDoorState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAutoDoorState ARBSASTube::GetDoorState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTube", "GetDoorState");

	Params::RBSASTube_GetDoorState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSASTubesDoor.BP_ForceAlwaysOpen
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBSASTubesDoor::BP_ForceAlwaysOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTubesDoor", "BP_ForceAlwaysOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSASTubesDoor.Event_OnTubesChanged
// (Event, Public, BlueprintEvent)

void ARBSASTubesDoor::Event_OnTubesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTubesDoor", "Event_OnTubesChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSASTubesDoor.OnRep_Tubes
// (Final, Native, Protected)

void ARBSASTubesDoor::OnRep_Tubes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSASTubesDoor", "OnRep_Tubes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSaveGameManager.AsyncLoadGameUserPreferencesDone
// (Final, Native, Private)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSaveGameManager::AsyncLoadGameUserPreferencesDone(const class FString& SlotName, const int32 UserIndex, class USaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSaveGameManager", "AsyncLoadGameUserPreferencesDone");

	Params::RBSaveGameManager_AsyncLoadGameUserPreferencesDone Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSaveGameManager.AsyncLoadProfileDone
// (Final, Native, Private)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSaveGameManager::AsyncLoadProfileDone(const class FString& SlotName, const int32 UserIndex, class USaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSaveGameManager", "AsyncLoadProfileDone");

	Params::RBSaveGameManager_AsyncLoadProfileDone Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSaveGameManager.AsyncWriteGameUserPreferencesDone
// (Final, Native, Private)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSaveGameManager::AsyncWriteGameUserPreferencesDone(const class FString& SlotName, const int32 UserIndex, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSaveGameManager", "AsyncWriteGameUserPreferencesDone");

	Params::RBSaveGameManager_AsyncWriteGameUserPreferencesDone Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSaveGameManager.AsyncWriteProfileDone
// (Final, Native, Private)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSaveGameManager::AsyncWriteProfileDone(const class FString& SlotName, const int32 UserIndex, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSaveGameManager", "AsyncWriteProfileDone");

	Params::RBSaveGameManager_AsyncWriteProfileDone Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSawPanelComponent.OnSlavePanelPawnInteractingChanged
// (Final, Native, Public)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSawPanelComponent::OnSlavePanelPawnInteractingChanged(class URBInteractiblePanelComponent* Panel, class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "OnSlavePanelPawnInteractingChanged");

	Params::RBSawPanelComponent_OnSlavePanelPawnInteractingChanged Parms{};

	Parms.Panel = Panel;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSawPanelComponent.BP_GetPawnPushingIntentRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetPawnPushingIntentRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetPawnPushingIntentRatio");

	Params::RBSawPanelComponent_BP_GetPawnPushingIntentRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_GetSawAccumulatedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetSawAccumulatedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetSawAccumulatedDistance");

	Params::RBSawPanelComponent_BP_GetSawAccumulatedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_GetSawCurrentOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetSawCurrentOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetSawCurrentOffset");

	Params::RBSawPanelComponent_BP_GetSawCurrentOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_GetSawMovingSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetSawMovingSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetSawMovingSpeed");

	Params::RBSawPanelComponent_BP_GetSawMovingSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_GetSawOffsetRatioForSide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetSawOffsetRatioForSide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetSawOffsetRatioForSide");

	Params::RBSawPanelComponent_BP_GetSawOffsetRatioForSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_GetSawPushDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSawPanelComponent::BP_GetSawPushDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_GetSawPushDelta");

	Params::RBSawPanelComponent_BP_GetSawPushDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.BP_IsSawConsideredMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSawPanelComponent::BP_IsSawConsideredMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "BP_IsSawConsideredMoving");

	Params::RBSawPanelComponent_BP_IsSawConsideredMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSawPanelComponent.IsMaster
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSawPanelComponent::IsMaster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSawPanelComponent", "IsMaster");

	Params::RBSawPanelComponent_IsMaster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScoringConfig.FilterScoringEvents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FRecordedScoringEvent>    ScoringEvents                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   MaxEvents                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRecordedScoringEvent>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRecordedScoringEvent> URBScoringConfig::FilterScoringEvents(const TArray<struct FRecordedScoringEvent>& ScoringEvents, int32 MaxEvents) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScoringConfig", "FilterScoringEvents");

	Params::RBScoringConfig_FilterScoringEvents Parms{};

	Parms.ScoringEvents = std::move(ScoringEvents);
	Parms.MaxEvents = MaxEvents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScoringConfig.GetScoringRule
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RuleId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBScoringRuleRow          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBScoringRuleRow URBScoringConfig::GetScoringRule(const class FName& RuleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScoringConfig", "GetScoringRule");

	Params::RBScoringConfig_GetScoringRule Parms{};

	Parms.RuleId = RuleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScoringConfig.GetTextValue
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRecordedScoringEvent            ScoringEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   TrialSeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScoringEventIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBScoringConfig::GetTextValue(const struct FRecordedScoringEvent& ScoringEvent, int32 TrialSeed, int32 ScoringEventIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScoringConfig", "GetTextValue");

	Params::RBScoringConfig_GetTextValue Parms{};

	Parms.ScoringEvent = std::move(ScoringEvent);
	Parms.TrialSeed = TrialSeed;
	Parms.ScoringEventIndex = ScoringEventIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBScriptedAnimStation.BP_OnScriptedAnimStationNotifyEvent
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBScriptedAnimStation::BP_OnScriptedAnimStationNotifyEvent(const class FName& EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "BP_OnScriptedAnimStationNotifyEvent");

	Params::RBScriptedAnimStation_BP_OnScriptedAnimStationNotifyEvent Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBScriptedAnimStation.BP_SetStationHidden
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBScriptedAnimStation::BP_SetStationHidden(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "BP_SetStationHidden");

	Params::RBScriptedAnimStation_BP_SetStationHidden Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.BP_StartScriptedSequence
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBScriptedAnimStation::BP_StartScriptedSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "BP_StartScriptedSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.BP_StopScriptedSequence
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBScriptedAnimStation::BP_StopScriptedSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "BP_StopScriptedSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.Event_StartedScriptedAnim
// (Event, Public, BlueprintEvent)

void ARBScriptedAnimStation::Event_StartedScriptedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "Event_StartedScriptedAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBScriptedAnimStation.Event_StoppedScriptedAnim
// (Event, Public, BlueprintEvent)

void ARBScriptedAnimStation::Event_StoppedScriptedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "Event_StoppedScriptedAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBScriptedAnimStation.GetFacePoseAsset
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPoseAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPoseAsset* ARBScriptedAnimStation::GetFacePoseAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "GetFacePoseAsset");

	Params::RBScriptedAnimStation_GetFacePoseAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBScriptedAnimStation.OnRep_ShouldBePlaying
// (Final, Native, Public)

void ARBScriptedAnimStation::OnRep_ShouldBePlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "OnRep_ShouldBePlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.OnRep_StationHidden
// (Final, Native, Public)

void ARBScriptedAnimStation::OnRep_StationHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "OnRep_StationHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.SetForceClientMeshUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBScriptedAnimStation::SetForceClientMeshUpdate(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "SetForceClientMeshUpdate");

	Params::RBScriptedAnimStation_SetForceClientMeshUpdate Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBScriptedAnimStation.BP_WillSkeletalMeshTick
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBScriptedAnimStation::BP_WillSkeletalMeshTick(class USkeletalMeshComponent* Mesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBScriptedAnimStation", "BP_WillSkeletalMeshTick");

	Params::RBScriptedAnimStation_BP_WillSkeletalMeshTick Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSettings_Gameplay.GetIngameItemConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemType                               ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FIngameItemConfig          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FIngameItemConfig URBSettings_Gameplay::GetIngameItemConfig(EItemType ItemType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSettings_Gameplay", "GetIngameItemConfig");

	Params::RBSettings_Gameplay_GetIngameItemConfig Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWaterValveObjectiveCoordinator.BP_StopWater
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)

void ARBWaterValveObjectiveCoordinator::BP_StopWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "BP_StopWater");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterValveObjectiveCoordinator.OnPanelActiveChangedEvent_Server
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWaterValveObjectiveCoordinator::OnPanelActiveChangedEvent_Server(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "OnPanelActiveChangedEvent_Server");

	Params::RBWaterValveObjectiveCoordinator_OnPanelActiveChangedEvent_Server Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterValveObjectiveCoordinator.OnPumpInteractionEvent_Server
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWaterValveObjectiveCoordinator::OnPumpInteractionEvent_Server(class ARBPawn* Interactor, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "OnPumpInteractionEvent_Server");

	Params::RBWaterValveObjectiveCoordinator_OnPumpInteractionEvent_Server Parms{};

	Parms.Interactor = Interactor;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterValveObjectiveCoordinator.OnRep_WaterValveSectionData
// (Final, Native, Private)

void ARBWaterValveObjectiveCoordinator::OnRep_WaterValveSectionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "OnRep_WaterValveSectionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterValveObjectiveCoordinator.OnValveInitialInteraction_Server
// (Final, Native, Protected)
// Parameters:
// class URBInteractiblePanelComponent*    Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          PawnInteracting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWaterValveObjectiveCoordinator::OnValveInitialInteraction_Server(class URBInteractiblePanelComponent* Panel, class ARBPawn* PawnInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "OnValveInitialInteraction_Server");

	Params::RBWaterValveObjectiveCoordinator_OnValveInitialInteraction_Server Parms{};

	Parms.Panel = Panel;
	Parms.PawnInteracting = PawnInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterValveObjectiveCoordinator.SelectAllLinkedActors
// (Final, Native, Protected)

void ARBWaterValveObjectiveCoordinator::SelectAllLinkedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterValveObjectiveCoordinator", "SelectAllLinkedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.Multicast_OnSimpleDoActionCompleted
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::Multicast_OnSimpleDoActionCompleted(class ARBPawn* Player, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "Multicast_OnSimpleDoActionCompleted");

	Params::RBSimpleObjectiveCoordinator_Multicast_OnSimpleDoActionCompleted Parms{};

	Parms.Player = Player;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.Multicast_ShowSimpleObjectiveTutorial
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBSimpleInteractionComponent*    SimpleComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::Multicast_ShowSimpleObjectiveTutorial(class ARBPawn* Player, class URBSimpleInteractionComponent* SimpleComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "Multicast_ShowSimpleObjectiveTutorial");

	Params::RBSimpleObjectiveCoordinator_Multicast_ShowSimpleObjectiveTutorial Parms{};

	Parms.Player = Player;
	Parms.SimpleComponent = SimpleComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnPlayerCompletedOperatable
// (Final, Native, Protected)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBOperatable*                    Operatable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnPlayerCompletedOperatable(bool IsOn, class ARBOperatable* Operatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnPlayerCompletedOperatable");

	Params::RBSimpleObjectiveCoordinator_OnPlayerCompletedOperatable Parms{};

	Parms.IsOn = IsOn;
	Parms.Operatable = Operatable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnPlayerDoAction
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBInteractible*                  Interactible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class ARBInteractible* Interactible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnPlayerDoAction");

	Params::RBSimpleObjectiveCoordinator_OnPlayerDoAction Parms{};

	Parms.Player = Player;
	Parms.Interactible = Interactible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnPlayerSimpleDoAction
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBInteractibleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnPlayerSimpleDoAction");

	Params::RBSimpleObjectiveCoordinator_OnPlayerSimpleDoAction Parms{};

	Parms.Player = Player;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnTargetTriggerBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnTargetTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnTargetTriggerBeginOverlap");

	Params::RBSimpleObjectiveCoordinator_OnTargetTriggerBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnTriggered
// (Final, Native, Protected)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBTriggerable*                   Triggerable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnTriggered(bool IsOn, class ARBTriggerable* Triggerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnTriggered");

	Params::RBSimpleObjectiveCoordinator_OnTriggered Parms{};

	Parms.IsOn = IsOn;
	Parms.Triggerable = Triggerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnTriggeredVolumeEvent
// (Final, Native, Protected)
// Parameters:
// class URBPlayerTriggerComponent*        Trigger                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnTriggeredVolumeEvent(class URBPlayerTriggerComponent* Trigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnTriggeredVolumeEvent");

	Params::RBSimpleObjectiveCoordinator_OnTriggeredVolumeEvent Parms{};

	Parms.Trigger = Trigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimpleObjectiveCoordinator.OnUsedOnObject
// (Final, Native, Protected)
// Parameters:
// class ARBPawn*                          Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URBLargeObjectInteractionPanelComponent*Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSimpleObjectiveCoordinator::OnUsedOnObject(class ARBPawn* Interactor, class ARBLargePickup* LargePickup, class URBLargeObjectInteractionPanelComponent* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimpleObjectiveCoordinator", "OnUsedOnObject");

	Params::RBSimpleObjectiveCoordinator_OnUsedOnObject Parms{};

	Parms.Interactor = Interactor;
	Parms.LargePickup = LargePickup;
	Parms.Panel = Panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodeButtonComponent.OnRep_IsOn
// (Final, Native, Public)

void URBSimplePasscodeButtonComponent::OnRep_IsOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodeButtonComponent", "OnRep_IsOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodeButtonComponent.OnRep_Pressed
// (Final, Native, Public)

void URBSimplePasscodeButtonComponent::OnRep_Pressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodeButtonComponent", "OnRep_Pressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodeButtonComponent.BP_IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSimplePasscodeButtonComponent::BP_IsPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodeButtonComponent", "BP_IsPressed");

	Params::RBSimplePasscodeButtonComponent_BP_IsPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSimplePasscodePadComponent.BP_SetOnStateOnAllButtons
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSimplePasscodePadComponent::BP_SetOnStateOnAllButtons(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "BP_SetOnStateOnAllButtons");

	Params::RBSimplePasscodePadComponent_BP_SetOnStateOnAllButtons Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodePadComponent.Multicast_OnPasscodePadValidation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bValid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSimplePasscodePadComponent::Multicast_OnPasscodePadValidation(bool bValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "Multicast_OnPasscodePadValidation");

	Params::RBSimplePasscodePadComponent_Multicast_OnPasscodePadValidation Parms{};

	Parms.bValid = bValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodePadComponent.OnRep_ButtonsPressed
// (Final, Native, Private)

void URBSimplePasscodePadComponent::OnRep_ButtonsPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "OnRep_ButtonsPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodePadComponent.ReleaseAllButtons
// (Final, Native, Public)

void URBSimplePasscodePadComponent::ReleaseAllButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "ReleaseAllButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodePadComponent.ValidatePad_Server
// (Final, Native, Public)

void URBSimplePasscodePadComponent::ValidatePad_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "ValidatePad_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSimplePasscodePadComponent.IsSolved_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSimplePasscodePadComponent::IsSolved_Server() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSimplePasscodePadComponent", "IsSolved_Server");

	Params::RBSimplePasscodePadComponent_IsSolved_Server Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSlideDownVolume.OnBrushComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSlideDownVolume::OnBrushComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlideDownVolume", "OnBrushComponentBeginOverlap");

	Params::RBSlideDownVolume_OnBrushComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSlideDownVolume.OnPlayerEntered
// (Final, Native, Public)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSlideDownVolume::OnPlayerEntered(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlideDownVolume", "OnPlayerEntered");

	Params::RBSlideDownVolume_OnPlayerEntered Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSlidingLock.BP_ApplyAnimatedTransform
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBPawn*                          InteractorPawn                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSlidingLock::BP_ApplyAnimatedTransform(float CurveValue, const class ARBPawn* InteractorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_ApplyAnimatedTransform");

	Params::RBSlidingLock_BP_ApplyAnimatedTransform Parms{};

	Parms.CurveValue = CurveValue;
	Parms.InteractorPawn = InteractorPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSlidingLock.BP_OnDoorDestroyed
// (Event, Public, BlueprintEvent)

void ARBSlidingLock::BP_OnDoorDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_OnDoorDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSlidingLock.BP_OnDoorOwnerChanged
// (Event, Public, BlueprintEvent)

void ARBSlidingLock::BP_OnDoorOwnerChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_OnDoorOwnerChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSlidingLock.BP_OnLock
// (Event, Public, BlueprintEvent)

void ARBSlidingLock::BP_OnLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_OnLock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSlidingLock.BP_OnUnlock
// (Event, Public, BlueprintEvent)

void ARBSlidingLock::BP_OnUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_OnUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSlidingLock.BP_OverrideEditorCompTranform
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             CompName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ARBSlidingLock::BP_OverrideEditorCompTranform(class FName CompName, bool bLocked, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_OverrideEditorCompTranform");

	Params::RBSlidingLock_BP_OverrideEditorCompTranform Parms{};

	Parms.CompName = CompName;
	Parms.bLocked = bLocked;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBSlidingLock.BP_PostDoorInitialization
// (Event, Public, BlueprintEvent)

void ARBSlidingLock::BP_PostDoorInitialization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_PostDoorInitialization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSlidingLock.BP_SetLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSlidingLock::BP_SetLocked(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_SetLocked");

	Params::RBSlidingLock_BP_SetLocked Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSlidingLock.IsLockedChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSlidingLock::IsLockedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "IsLockedChangedCallback");

	Params::RBSlidingLock_IsLockedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSlidingLock.OnRep_Islocked
// (Final, Native, Protected)

void ARBSlidingLock::OnRep_Islocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "OnRep_Islocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSlidingLock.BP_IsInFront
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSlidingLock::BP_IsInFront() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_IsInFront");

	Params::RBSlidingLock_BP_IsInFront Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSlidingLock.BP_IsLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSlidingLock::BP_IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSlidingLock", "BP_IsLocked");

	Params::RBSlidingLock_BP_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.BP_GetRBPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ARBPlayerState*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ARBPlayerState* URBSocialMenuEntry::BP_GetRBPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "BP_GetRBPlayerState");

	Params::RBSocialMenuEntry_BP_GetRBPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.Event_ActionRequested
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntry::Event_ActionRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "Event_ActionRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntry.Event_CloseContextualMenu
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntry::Event_CloseContextualMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "Event_CloseContextualMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntry.Event_OpenContextualMenu
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntry::Event_OpenContextualMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "Event_OpenContextualMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntry.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntry::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntry.HideCharacter
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntry::HideCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "HideCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnCurrentLoadoutChanged
// (Final, Native, Private)

void URBSocialMenuEntry::OnCurrentLoadoutChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnCurrentLoadoutChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnPlayerCustomizationUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FRBPlayerCustomizationInfo       CustomizationInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnPlayerCustomizationUpdated(const struct FRBPlayerCustomizationInfo& CustomizationInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnPlayerCustomizationUpdated");

	Params::RBSocialMenuEntry_OnPlayerCustomizationUpdated Parms{};

	Parms.CustomizationInfo = std::move(CustomizationInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnPlayerLeaving
// (Final, Native, Private)
// Parameters:
// EPlayerLeaveTarget                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnPlayerLeaving(EPlayerLeaveTarget Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnPlayerLeaving");

	Params::RBSocialMenuEntry_OnPlayerLeaving Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnPlayerLevelChanged
// (Final, Native, Private)

void URBSocialMenuEntry::OnPlayerLevelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnPlayerLevelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnPlayerPartyStateUpdated
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   Param_RBPlayerState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnPlayerPartyStateUpdated(class ARBPlayerState* Param_RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnPlayerPartyStateUpdated");

	Params::RBSocialMenuEntry_OnPlayerPartyStateUpdated Parms{};

	Parms.Param_RBPlayerState = Param_RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnPlayerStateMatchStateUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// class ARBLobbyPlayerState*              RBLobbyPlayerState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchState                      MatchState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnPlayerStateMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnPlayerStateMatchStateUpdated");

	Params::RBSocialMenuEntry_OnPlayerStateMatchStateUpdated Parms{};

	Parms.RBLobbyPlayerState = RBLobbyPlayerState;
	Parms.MatchState = std::move(MatchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionCompleted
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnSocialMenuEntryActionCompleted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnSocialMenuEntryActionCompleted");

	Params::RBSocialMenuEntry_OnSocialMenuEntryActionCompleted Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionStarted
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnSocialMenuEntryActionStarted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnSocialMenuEntryActionStarted");

	Params::RBSocialMenuEntry_OnSocialMenuEntryActionStarted Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.OnSocialMenuPartyInviteWidgetVisibilityUpdated
// (Final, Native, Private)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::OnSocialMenuPartyInviteWidgetVisibilityUpdated(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "OnSocialMenuPartyInviteWidgetVisibilityUpdated");

	Params::RBSocialMenuEntry_OnSocialMenuPartyInviteWidgetVisibilityUpdated Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.RequestAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::RequestAction(ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "RequestAction");

	Params::RBSocialMenuEntry_RequestAction Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.RequestOpenContextualMenu
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntry::RequestOpenContextualMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "RequestOpenContextualMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.Setup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URBSocialMenuManager*             Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRBSocialMenuEntryDetails        EntryDetails                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::Setup(class URBSocialMenuManager* Parent, const struct FRBSocialMenuEntryDetails& EntryDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "Setup");

	Params::RBSocialMenuEntry_Setup Parms{};

	Parms.Parent = Parent;
	Parms.EntryDetails = std::move(EntryDetails);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.SetVoiceChatOutputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::SetVoiceChatOutputVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "SetVoiceChatOutputVolume");

	Params::RBSocialMenuEntry_SetVoiceChatOutputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.SetVoiceChatVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntry::SetVoiceChatVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "SetVoiceChatVolume");

	Params::RBSocialMenuEntry_SetVoiceChatVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.ShowCharacter
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntry::ShowCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "ShowCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntry.CanOpenContextualMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::CanOpenContextualMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "CanOpenContextualMenu");

	Params::RBSocialMenuEntry_CanOpenContextualMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.CanSendPartyInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::CanSendPartyInvite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "CanSendPartyInvite");

	Params::RBSocialMenuEntry_CanSendPartyInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.CanUpdateVoiceChatVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::CanUpdateVoiceChatVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "CanUpdateVoiceChatVolume");

	Params::RBSocialMenuEntry_CanUpdateVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetAvailableActions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<ERBSocialMenuEntryAction>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<ERBSocialMenuEntryAction> URBSocialMenuEntry::GetAvailableActions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetAvailableActions");

	Params::RBSocialMenuEntry_GetAvailableActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuEntry::GetFlags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetFlags");

	Params::RBSocialMenuEntry_GetFlags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URBSocialMenuEntry::GetName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetName");

	Params::RBSocialMenuEntry_GetName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfilePlatform                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfilePlatform URBSocialMenuEntry::GetPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetPlatform");

	Params::RBSocialMenuEntry_GetPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetPlayerIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* URBSocialMenuEntry::GetPlayerIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetPlayerIcon");

	Params::RBSocialMenuEntry_GetPlayerIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuEntry::GetPlayerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetPlayerLevel");

	Params::RBSocialMenuEntry_GetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetPresenceText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URBSocialMenuEntry::GetPresenceText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetPresenceText");

	Params::RBSocialMenuEntry_GetPresenceText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetProfileId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FProfileId                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FProfileId URBSocialMenuEntry::GetProfileId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetProfileId");

	Params::RBSocialMenuEntry_GetProfileId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetReleaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuEntry::GetReleaseCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetReleaseCount");

	Params::RBSocialMenuEntry_GetReleaseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetSelectedActiveSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActiveSkillType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActiveSkillType URBSocialMenuEntry::GetSelectedActiveSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetSelectedActiveSkill");

	Params::RBSocialMenuEntry_GetSelectedActiveSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetSessionMaxMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuEntry::GetSessionMaxMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetSessionMaxMemberCount");

	Params::RBSocialMenuEntry_GetSessionMaxMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetSessionMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuEntry::GetSessionMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetSessionMemberCount");

	Params::RBSocialMenuEntry_GetSessionMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetSocialMenuEntryListType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBSocialMenuEntryListType              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERBSocialMenuEntryListType URBSocialMenuEntry::GetSocialMenuEntryListType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetSocialMenuEntryListType");

	Params::RBSocialMenuEntry_GetSocialMenuEntryListType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetVoiceChatOutputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSocialMenuEntry::GetVoiceChatOutputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetVoiceChatOutputVolume");

	Params::RBSocialMenuEntry_GetVoiceChatOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.GetVoiceChatVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBSocialMenuEntry::GetVoiceChatVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "GetVoiceChatVolume");

	Params::RBSocialMenuEntry_GetVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.HasFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBSocialMenuEntryFlag                  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::HasFlag(ERBSocialMenuEntryFlag Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "HasFlag");

	Params::RBSocialMenuEntry_HasFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.HasPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::HasPlayerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "HasPlayerLevel");

	Params::RBSocialMenuEntry_HasPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsBlocked");

	Params::RBSocialMenuEntry_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsCompatibleBuild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsCompatibleBuild() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsCompatibleBuild");

	Params::RBSocialMenuEntry_IsCompatibleBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsInGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsInGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsInGame");

	Params::RBSocialMenuEntry_IsInGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsInYourGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsInYourGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsInYourGame");

	Params::RBSocialMenuEntry_IsInYourGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsInYourParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsInYourParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsInYourParty");

	Params::RBSocialMenuEntry_IsInYourParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsJoinable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsJoinable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsJoinable");

	Params::RBSocialMenuEntry_IsJoinable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsOnline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsOnline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsOnline");

	Params::RBSocialMenuEntry_IsOnline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsOperationPending");

	Params::RBSocialMenuEntry_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsPartyInviteWidgetShown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsPartyInviteWidgetShown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsPartyInviteWidgetShown");

	Params::RBSocialMenuEntry_IsPartyInviteWidgetShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsPartyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsPartyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsPartyOwner");

	Params::RBSocialMenuEntry_IsPartyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.IsVoiceChatEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::IsVoiceChatEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "IsVoiceChatEnabled");

	Params::RBSocialMenuEntry_IsVoiceChatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.RequiresInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::RequiresInvite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "RequiresInvite");

	Params::RBSocialMenuEntry_RequiresInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntry.ShouldDisplayPresence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntry::ShouldDisplayPresence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntry", "ShouldDisplayPresence");

	Params::RBSocialMenuEntry_ShouldDisplayPresence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryContextualMenu.Event_Refresh
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntryContextualMenu::Event_Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryContextualMenu", "Event_Refresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntryContextualMenu.RequestAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryContextualMenu::RequestAction(ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryContextualMenu", "RequestAction");

	Params::RBSocialMenuEntryContextualMenu_RequestAction Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryContextualMenu.Setup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBSocialMenuEntry*               Param_AssociatedEntry                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryContextualMenu::Setup(class URBSocialMenuEntry* Param_AssociatedEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryContextualMenu", "Setup");

	Params::RBSocialMenuEntryContextualMenu_Setup Parms{};

	Parms.Param_AssociatedEntry = Param_AssociatedEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryContextualMenu.GetAssociatedEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBSocialMenuEntry*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBSocialMenuEntry* URBSocialMenuEntryContextualMenu::GetAssociatedEntry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryContextualMenu", "GetAssociatedEntry");

	Params::RBSocialMenuEntryContextualMenu_GetAssociatedEntry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryContextualMenu.GetAvailableActions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<ERBSocialMenuEntryAction>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<ERBSocialMenuEntryAction> URBSocialMenuEntryContextualMenu::GetAvailableActions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryContextualMenu", "GetAvailableActions");

	Params::RBSocialMenuEntryContextualMenu_GetAvailableActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.BP_RegisterActorToClean
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWorld::BP_RegisterActorToClean(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "BP_RegisterActorToClean");

	Params::RBWorld_BP_RegisterActorToClean Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWorld.EstimateFogDensity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBWorld::EstimateFogDensity(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "EstimateFogDensity");

	Params::RBWorld_EstimateFogDensity Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.OnPickupHolderChanged_Server
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBWorld::OnPickupHolderChanged_Server(class ARBPawn* Player, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "OnPickupHolderChanged_Server");

	Params::RBWorld_OnPickupHolderChanged_Server Parms{};

	Parms.Player = Player;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWorld.GetDoors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBDoor*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBDoor*> URBWorld::GetDoors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetDoors");

	Params::RBWorld_GetDoors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetItemSpawningManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBItemSpawningManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBItemSpawningManager* URBWorld::GetItemSpawningManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetItemSpawningManager");

	Params::RBWorld_GetItemSpawningManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetLoadProgressPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBWorld::GetLoadProgressPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetLoadProgressPercentage");

	Params::RBWorld_GetLoadProgressPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetMonsterClosets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBMonsterCloset*>   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBMonsterCloset*> URBWorld::GetMonsterClosets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetMonsterClosets");

	Params::RBWorld_GetMonsterClosets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetNPCs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBNPC*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBNPC*> URBWorld::GetNPCs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetNPCs");

	Params::RBWorld_GetNPCs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBBreakableObstacles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBBreakableObstacle*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBBreakableObstacle*> URBWorld::GetRBBreakableObstacles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBBreakableObstacles");

	Params::RBWorld_GetRBBreakableObstacles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBInteractibles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBInteractible*>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBInteractible*> URBWorld::GetRBInteractibles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBInteractibles");

	Params::RBWorld_GetRBInteractibles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBLargePickups
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBLargePickup*>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBLargePickup*> URBWorld::GetRBLargePickups() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBLargePickups");

	Params::RBWorld_GetRBLargePickups Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBPawns
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPawn*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPawn*> URBWorld::GetRBPawns() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBPawns");

	Params::RBWorld_GetRBPawns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBPickups
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPickup*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPickup*> URBWorld::GetRBPickups() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBPickups");

	Params::RBWorld_GetRBPickups Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPlayer*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPlayer*> URBWorld::GetRBPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBPlayers");

	Params::RBWorld_GetRBPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBRespawners
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARBPlayerRespawner*> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARBPlayerRespawner*> URBWorld::GetRBRespawners() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBRespawners");

	Params::RBWorld_GetRBRespawners Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorld.GetRBWaterSimulationComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URBWaterSimulationComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URBWaterSimulationComponent* URBWorld::GetRBWaterSimulationComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorld", "GetRBWaterSimulationComponent");

	Params::RBWorld_GetRBWaterSimulationComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryListWidget.Activate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBSocialMenuManager*             Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::Activate(class URBSocialMenuManager* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Activate");

	Params::RBSocialMenuEntryListWidget_Activate Parms{};

	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.Deactivate
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntryListWidget::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.Event_Clear
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntryListWidget::Event_Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_Clear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntryListWidget.Event_EntriesUpdated
// (Event, Public, BlueprintEvent)

void URBSocialMenuEntryListWidget::Event_EntriesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_EntriesUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuEntryListWidget.Event_OnDataPending
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsDataPending                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::Event_OnDataPending(bool bIsDataPending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_OnDataPending");

	Params::RBSocialMenuEntryListWidget_Event_OnDataPending Parms{};

	Parms.bIsDataPending = bIsDataPending;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuEntryListWidget.Event_OnEmptyStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsEmpty                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::Event_OnEmptyStateChanged(bool bIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_OnEmptyStateChanged");

	Params::RBSocialMenuEntryListWidget_Event_OnEmptyStateChanged Parms{};

	Parms.bIsEmpty = bIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuEntryListWidget.Event_RemoveEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBUserWidget*                    Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::Event_RemoveEntry(class URBUserWidget* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_RemoveEntry");

	Params::RBSocialMenuEntryListWidget_Event_RemoveEntry Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuEntryListWidget.Event_UpdateEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBUserWidget*                    Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Row                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::Event_UpdateEntry(class URBUserWidget* Entry, int32 Column, int32 Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "Event_UpdateEntry");

	Params::RBSocialMenuEntryListWidget_Event_UpdateEntry Parms{};

	Parms.Entry = Entry;
	Parms.Column = Column;
	Parms.Row = Row;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuEntryListWidget.NextPage
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntryListWidget::NextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "NextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.OnEntryActionRequested
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "OnEntryActionRequested");

	Params::RBSocialMenuEntryListWidget_OnEntryActionRequested Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.OnFilterChanged
// (Final, Native, Private)
// Parameters:
// ERBSocialMenuEntryFilter                Param_Filter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::OnFilterChanged(ERBSocialMenuEntryFilter Param_Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "OnFilterChanged");

	Params::RBSocialMenuEntryListWidget_OnFilterChanged Parms{};

	Parms.Param_Filter = Param_Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.OnPlayerJoinedGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "OnPlayerJoinedGame");

	Params::RBSocialMenuEntryListWidget_OnPlayerJoinedGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.OnPlayerLeftGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "OnPlayerLeftGame");

	Params::RBSocialMenuEntryListWidget_OnPlayerLeftGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.PreviousPage
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuEntryListWidget::PreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "PreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.SetFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERBSocialMenuEntryFilter                Param_Filter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuEntryListWidget::SetFilter(ERBSocialMenuEntryFilter Param_Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "SetFilter");

	Params::RBSocialMenuEntryListWidget_SetFilter Parms{};

	Parms.Param_Filter = Param_Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuEntryListWidget.GetFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBSocialMenuEntryFilter                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERBSocialMenuEntryFilter URBSocialMenuEntryListWidget::GetFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "GetFilter");

	Params::RBSocialMenuEntryListWidget_GetFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryListWidget.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntryListWidget::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "IsDataPending");

	Params::RBSocialMenuEntryListWidget_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryListWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntryListWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "IsEmpty");

	Params::RBSocialMenuEntryListWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuEntryListWidget.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuEntryListWidget::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuEntryListWidget", "IsOperationPending");

	Params::RBSocialMenuEntryListWidget_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.CloseContextualMenu
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuManager::CloseContextualMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "CloseContextualMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuManager.ClosePartyInviteWidget
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuManager::ClosePartyInviteWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "ClosePartyInviteWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OPP.RBSocialMenuManager.OnFilterChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// ERBSocialMenuEntryFilter                Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuManager::OnFilterChanged__DelegateSignature(ERBSocialMenuEntryFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "OnFilterChanged__DelegateSignature");

	Params::RBSocialMenuManager_OnFilterChanged__DelegateSignature Parms{};

	Parms.Filter = Filter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuManager.OpenPartyInviteWidget
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuManager::OpenPartyInviteWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "OpenPartyInviteWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuManager.SetFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERBSocialMenuEntryFilter                Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuManager::SetFilter(ERBSocialMenuEntryFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "SetFilter");

	Params::RBSocialMenuManager_SetFilter Parms{};

	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuManager.GetFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERBSocialMenuEntryFilter                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERBSocialMenuEntryFilter URBSocialMenuManager::GetFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "GetFilter");

	Params::RBSocialMenuManager_GetFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.HasContextualMenuOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::HasContextualMenuOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "HasContextualMenuOpen");

	Params::RBSocialMenuManager_HasContextualMenuOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.HasPendingFriendRequest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::HasPendingFriendRequest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "HasPendingFriendRequest");

	Params::RBSocialMenuManager_HasPendingFriendRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.IsCrossplayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::IsCrossplayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "IsCrossplayEnabled");

	Params::RBSocialMenuManager_IsCrossplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.IsPartyInviteWidgetShown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::IsPartyInviteWidgetShown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "IsPartyInviteWidgetShown");

	Params::RBSocialMenuManager_IsPartyInviteWidgetShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.ShouldEnableFindFriendMenuOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::ShouldEnableFindFriendMenuOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "ShouldEnableFindFriendMenuOption");

	Params::RBSocialMenuManager_ShouldEnableFindFriendMenuOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuManager.ShowFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuManager::ShowFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuManager", "ShowFilter");

	Params::RBSocialMenuManager_ShowFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.Activate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URBSocialMenuManager*             Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::Activate(class URBSocialMenuManager* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Activate");

	Params::RBSocialMenuPartyWidget_Activate Parms{};

	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.Deactivate
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuPartyWidget::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.Event_Clear
// (Event, Public, BlueprintEvent)

void URBSocialMenuPartyWidget::Event_Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_Clear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuPartyWidget.Event_EntriesUpdated
// (Event, Public, BlueprintEvent)

void URBSocialMenuPartyWidget::Event_EntriesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_EntriesUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuPartyWidget.Event_OnDataPending
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsDataPending                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::Event_OnDataPending(bool bIsDataPending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_OnDataPending");

	Params::RBSocialMenuPartyWidget_Event_OnDataPending Parms{};

	Parms.bIsDataPending = bIsDataPending;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuPartyWidget.Event_RefreshPartyOptions
// (Event, Public, BlueprintEvent)

void URBSocialMenuPartyWidget::Event_RefreshPartyOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_RefreshPartyOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuPartyWidget.Event_RemoveEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBUserWidget*                    Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::Event_RemoveEntry(class URBUserWidget* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_RemoveEntry");

	Params::RBSocialMenuPartyWidget_Event_RemoveEntry Parms{};

	Parms.Entry = Entry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuPartyWidget.Event_UpdateEntry
// (Event, Public, BlueprintEvent)
// Parameters:
// class URBUserWidget*                    Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Row                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::Event_UpdateEntry(class URBUserWidget* Entry, int32 Column, int32 Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "Event_UpdateEntry");

	Params::RBSocialMenuPartyWidget_Event_UpdateEntry Parms{};

	Parms.Entry = Entry;
	Parms.Column = Column;
	Parms.Row = Row;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuPartyWidget.LeaveParty
// (Final, Native, Public, BlueprintCallable)

void URBSocialMenuPartyWidget::LeaveParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "LeaveParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnEntryActionRequested
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnEntryActionRequested");

	Params::RBSocialMenuPartyWidget_OnEntryActionRequested Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnPlayerJoinedGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnPlayerJoinedGame");

	Params::RBSocialMenuPartyWidget_OnPlayerJoinedGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnPlayerLeaving
// (Final, Native, Private)
// Parameters:
// EPlayerLeaveTarget                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnPlayerLeaving(EPlayerLeaveTarget Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnPlayerLeaving");

	Params::RBSocialMenuPartyWidget_OnPlayerLeaving Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnPlayerLeftGame
// (Final, Native, Private)
// Parameters:
// class ARBPlayerState*                   RBPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnPlayerLeftGame");

	Params::RBSocialMenuPartyWidget_OnPlayerLeftGame Parms{};

	Parms.RBPlayerState = RBPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionCompleted
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnSocialMenuEntryActionCompleted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnSocialMenuEntryActionCompleted");

	Params::RBSocialMenuPartyWidget_OnSocialMenuEntryActionCompleted Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionStarted
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERBSocialMenuEntryAction                Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnSocialMenuEntryActionStarted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnSocialMenuEntryActionStarted");

	Params::RBSocialMenuPartyWidget_OnSocialMenuEntryActionStarted Parms{};

	Parms.Entry = Entry;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryCustomizationUpdated
// (Final, Native, Private)
// Parameters:
// class URBSocialMenuEntry*               Entry                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::OnSocialMenuEntryCustomizationUpdated(class URBSocialMenuEntry* Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "OnSocialMenuEntryCustomizationUpdated");

	Params::RBSocialMenuPartyWidget_OnSocialMenuEntryCustomizationUpdated Parms{};

	Parms.Entry = Entry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.SetAllowPartyMemberInvites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowPartyMemberInvites                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::SetAllowPartyMemberInvites(bool bAllowPartyMemberInvites)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "SetAllowPartyMemberInvites");

	Params::RBSocialMenuPartyWidget_SetAllowPartyMemberInvites Parms{};

	Parms.bAllowPartyMemberInvites = bAllowPartyMemberInvites;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.SetPartyInviteFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PartyInviteFilter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::SetPartyInviteFilter(int32 PartyInviteFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "SetPartyInviteFilter");

	Params::RBSocialMenuPartyWidget_SetPartyInviteFilter Parms{};

	Parms.PartyInviteFilter = PartyInviteFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.SetPartyPrivacy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPartyPrivacy                           Privacy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSocialMenuPartyWidget::SetPartyPrivacy(EPartyPrivacy Privacy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "SetPartyPrivacy");

	Params::RBSocialMenuPartyWidget_SetPartyPrivacy Parms{};

	Parms.Privacy = Privacy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSocialMenuPartyWidget.AllowPartyMemberInvites
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::AllowPartyMemberInvites() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "AllowPartyMemberInvites");

	Params::RBSocialMenuPartyWidget_AllowPartyMemberInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.CanLeaveParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::CanLeaveParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "CanLeaveParty");

	Params::RBSocialMenuPartyWidget_CanLeaveParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.GetPartyInviteFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URBSocialMenuPartyWidget::GetPartyInviteFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "GetPartyInviteFilter");

	Params::RBSocialMenuPartyWidget_GetPartyInviteFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.GetPartyPrivacy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPartyPrivacy                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPartyPrivacy URBSocialMenuPartyWidget::GetPartyPrivacy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "GetPartyPrivacy");

	Params::RBSocialMenuPartyWidget_GetPartyPrivacy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.IsCrossplayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::IsCrossplayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "IsCrossplayEnabled");

	Params::RBSocialMenuPartyWidget_IsCrossplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.IsDataPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::IsDataPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "IsDataPending");

	Params::RBSocialMenuPartyWidget_IsDataPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "IsEmpty");

	Params::RBSocialMenuPartyWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.IsOperationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::IsOperationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "IsOperationPending");

	Params::RBSocialMenuPartyWidget_IsOperationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.IsPartyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::IsPartyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "IsPartyOwner");

	Params::RBSocialMenuPartyWidget_IsPartyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.ShouldDisplayCrossplaySetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::ShouldDisplayCrossplaySetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "ShouldDisplayCrossplaySetting");

	Params::RBSocialMenuPartyWidget_ShouldDisplayCrossplaySetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.ShouldDisplayGroupInvitationRequests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::ShouldDisplayGroupInvitationRequests() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "ShouldDisplayGroupInvitationRequests");

	Params::RBSocialMenuPartyWidget_ShouldDisplayGroupInvitationRequests Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuPartyWidget.ShouldShowPartyOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSocialMenuPartyWidget::ShouldShowPartyOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuPartyWidget", "ShouldShowPartyOptions");

	Params::RBSocialMenuPartyWidget_ShouldShowPartyOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuSceneActor.Event_Activate
// (Event, Public, BlueprintEvent)

void ARBSocialMenuSceneActor::Event_Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "Event_Activate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuSceneActor.Event_Deactivate
// (Event, Public, BlueprintEvent)

void ARBSocialMenuSceneActor::Event_Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "Event_Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSocialMenuSceneActor.Event_UpdateNumDisplayedSlots
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSocialMenuSceneActor::Event_UpdateNumDisplayedSlots(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "Event_UpdateNumDisplayedSlots");

	Params::RBSocialMenuSceneActor_Event_UpdateNumDisplayedSlots Parms{};

	Parms.Num = Num;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSocialMenuSceneActor.IsFailureScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSocialMenuSceneActor::IsFailureScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "IsFailureScene");

	Params::RBSocialMenuSceneActor_IsFailureScene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuSceneActor.GetMenuCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESocialMenuSceneActorSlot               Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBMenuCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARBMenuCharacter* ARBSocialMenuSceneActor::GetMenuCharacter(ESocialMenuSceneActorSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "GetMenuCharacter");

	Params::RBSocialMenuSceneActor_GetMenuCharacter Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSocialMenuSceneActor.GetType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESocialMenuSceneActorType               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESocialMenuSceneActorType ARBSocialMenuSceneActor::GetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSocialMenuSceneActor", "GetType");

	Params::RBSocialMenuSceneActor_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSoundConnectorActor.Editor_RefreshConnection
// (Final, Native, Public)

void ARBSoundConnectorActor::Editor_RefreshConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorActor", "Editor_RefreshConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.BP_CloseConnector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBSoundConnectorComponent::BP_CloseConnector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "BP_CloseConnector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.BP_OpenConnector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void URBSoundConnectorComponent::BP_OpenConnector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "BP_OpenConnector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.Editor_RefreshConnection
// (Final, Native, Public)

void URBSoundConnectorComponent::Editor_RefreshConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "Editor_RefreshConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.IsOpenedChangedCallback
// (Final, Native, Public)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundConnectorComponent::IsOpenedChangedCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "IsOpenedChangedCallback");

	Params::RBSoundConnectorComponent_IsOpenedChangedCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.OnRep_Enabled
// (Final, Native, Public)

void URBSoundConnectorComponent::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.OnRep_IsOpened
// (Final, Native, Private)

void URBSoundConnectorComponent::OnRep_IsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "OnRep_IsOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundConnectorComponent::SetEnabled(bool bEnabledValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "SetEnabled");

	Params::RBSoundConnectorComponent_SetEnabled Parms{};

	Parms.bEnabledValue = bEnabledValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundConnectorComponent.SetOpen_Internal
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bOpenValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSoundConnectorComponent::SetOpen_Internal(bool bOpenValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundConnectorComponent", "SetOpen_Internal");

	Params::RBSoundConnectorComponent_SetOpen_Internal Parms{};

	Parms.bOpenValue = bOpenValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundTrap.BP_OnHitByThrowable
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBThrowableWeapon*               ThrowableWeapon                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSoundTrap::BP_OnHitByThrowable(const struct FVector& HitLocation, class ARBThrowableWeapon* ThrowableWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundTrap", "BP_OnHitByThrowable");

	Params::RBSoundTrap_BP_OnHitByThrowable Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.ThrowableWeapon = ThrowableWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSoundTrap.Multicast_OnTrapTriggered
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ARBPawn*                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSoundTrap::Multicast_OnTrapTriggered(class ARBPawn* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundTrap", "Multicast_OnTrapTriggered");

	Params::RBSoundTrap_Multicast_OnTrapTriggered Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundTrap.OnCapsuleBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSoundTrap::OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundTrap", "OnCapsuleBeginOverlap");

	Params::RBSoundTrap_OnCapsuleBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundTrap.BP_GetCollisionCapsule
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* ARBSoundTrap::BP_GetCollisionCapsule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundTrap", "BP_GetCollisionCapsule");

	Params::RBSoundTrap_BP_GetCollisionCapsule Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBSoundVolume.AddDynamicEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FSoundTriggerEvent               SoundTriggerEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBSoundVolume::AddDynamicEvent(const struct FSoundTriggerEvent& SoundTriggerEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundVolume", "AddDynamicEvent");

	Params::RBSoundVolume_AddDynamicEvent Parms{};

	Parms.SoundTriggerEvent = std::move(SoundTriggerEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundVolume.Editor_RefreshConnection
// (Final, Native, Public)

void ARBSoundVolume::Editor_RefreshConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundVolume", "Editor_RefreshConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSoundVolume.RemoveDynamicEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FSoundTriggerEvent               SoundTriggerEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBSoundVolume::RemoveDynamicEvent(const struct FSoundTriggerEvent& SoundTriggerEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSoundVolume", "RemoveDynamicEvent");

	Params::RBSoundVolume_RemoveDynamicEvent Parms{};

	Parms.SoundTriggerEvent = std::move(SoundTriggerEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.CurrentGameplayRatioChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::CurrentGameplayRatioChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "CurrentGameplayRatioChangedCallback");

	Params::RBValvePanelComponent_CurrentGameplayRatioChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.CurrentMeterChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::CurrentMeterChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "CurrentMeterChangedCallback");

	Params::RBValvePanelComponent_CurrentMeterChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.InputDirectionHeldSideChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::InputDirectionHeldSideChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "InputDirectionHeldSideChangedCallback");

	Params::RBValvePanelComponent_InputDirectionHeldSideChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.IsInFailureZoneChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::IsInFailureZoneChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "IsInFailureZoneChangedCallback");

	Params::RBValvePanelComponent_IsInFailureZoneChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.IsInSuccessZoneChangedCallback
// (Final, Native, Protected)
// Parameters:
// EScheduledPropertyValueChangedType      ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::IsInSuccessZoneChangedCallback(EScheduledPropertyValueChangedType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "IsInSuccessZoneChangedCallback");

	Params::RBValvePanelComponent_IsInSuccessZoneChangedCallback Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.Multicast_OnPanelSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "Multicast_OnPanelSucceeded");

	Params::RBValvePanelComponent_Multicast_OnPanelSucceeded Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_CurrentGameplayRatio
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_CurrentGameplayRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_CurrentGameplayRatio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_CurrentMeter
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_CurrentMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_CurrentMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_InputDirectionHeldSide
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_InputDirectionHeldSide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_InputDirectionHeldSide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_IsInFailureZone
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_IsInFailureZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_IsInFailureZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_IsInSuccessZone
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_IsInSuccessZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_IsInSuccessZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_Locked
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_Locked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_Locked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_SuccessRatioTarget
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_SuccessRatioTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_SuccessRatioTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnRep_ValveType
// (Final, Native, Protected)

void URBValvePanelComponent::OnRep_ValveType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnRep_ValveType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.OnUnlockingButtonStateChanged_Server
// (Final, Native, Public)
// Parameters:
// class URBCoopOperatableComponent*       Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBValvePanelComponent::OnUnlockingButtonStateChanged_Server(class URBCoopOperatableComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "OnUnlockingButtonStateChanged_Server");

	Params::RBValvePanelComponent_OnUnlockingButtonStateChanged_Server Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBValvePanelComponent.BP_GetCurrentPawnTurningIntent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBValvePanelComponent::BP_GetCurrentPawnTurningIntent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "BP_GetCurrentPawnTurningIntent");

	Params::RBValvePanelComponent_BP_GetCurrentPawnTurningIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBValvePanelComponent.BP_IsInFailureZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBValvePanelComponent::BP_IsInFailureZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "BP_IsInFailureZone");

	Params::RBValvePanelComponent_BP_IsInFailureZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBValvePanelComponent.BP_IsInSuccessZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBValvePanelComponent::BP_IsInSuccessZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "BP_IsInSuccessZone");

	Params::RBValvePanelComponent_BP_IsInSuccessZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBValvePanelComponent.GetCurrentMeterRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBValvePanelComponent::GetCurrentMeterRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "GetCurrentMeterRatio");

	Params::RBValvePanelComponent_GetCurrentMeterRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBValvePanelComponent.GetUnlockedTimeLeftRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBValvePanelComponent::GetUnlockedTimeLeftRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "GetUnlockedTimeLeftRatio");

	Params::RBValvePanelComponent_GetUnlockedTimeLeftRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBValvePanelComponent.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBValvePanelComponent::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBValvePanelComponent", "IsCompleted");

	Params::RBValvePanelComponent_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSpectatorMenu.Event_OnSpectatorChanged
// (Event, Public, BlueprintEvent)

void URBSpectatorMenu::Event_OnSpectatorChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectatorMenu", "Event_OnSpectatorChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSpectatorMenu.ToggleNextSpectator
// (Final, Native, Public, BlueprintCallable)

void URBSpectatorMenu::ToggleNextSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectatorMenu", "ToggleNextSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSpectatorMenu.TogglePreviousSpectator
// (Final, Native, Public, BlueprintCallable)

void URBSpectatorMenu::TogglePreviousSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectatorMenu", "TogglePreviousSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSpectatorMenu.CanCycleSpectators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSpectatorMenu::CanCycleSpectators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectatorMenu", "CanCycleSpectators");

	Params::RBSpectatorMenu_CanCycleSpectators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSpectatorPawn.Event_OnSetupFinished
// (Event, Public, BlueprintEvent)

void ARBSpectatorPawn::Event_OnSetupFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectatorPawn", "Event_OnSetupFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSpectraSkill.Event_OnVisionActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFullEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSpectraSkill::Event_OnVisionActiveChanged(bool IsActive, bool bFullEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectraSkill", "Event_OnVisionActiveChanged");

	Params::RBSpectraSkill_Event_OnVisionActiveChanged Parms{};

	Parms.IsActive = IsActive;
	Parms.bFullEffect = bFullEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSpectraSkill.Event_OnVisionActorAdded
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           VisionActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSpectraSkill::Event_OnVisionActorAdded(class AActor* VisionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectraSkill", "Event_OnVisionActorAdded");

	Params::RBSpectraSkill_Event_OnVisionActorAdded Parms{};

	Parms.VisionActor = VisionActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSpectraSkill.Event_OnVisionActorRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           VisionActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSpectraSkill::Event_OnVisionActorRemoved(class AActor* VisionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectraSkill", "Event_OnVisionActorRemoved");

	Params::RBSpectraSkill_Event_OnVisionActorRemoved Parms{};

	Parms.VisionActor = VisionActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSpectraSkill.Event_OnVisionFullEffectStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFullEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSpectraSkill::Event_OnVisionFullEffectStateChanged(bool bFullEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectraSkill", "Event_OnVisionFullEffectStateChanged");

	Params::RBSpectraSkill_Event_OnVisionFullEffectStateChanged Parms{};

	Parms.bFullEffect = bFullEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSpectraSkillTarget.CanBeActivedInSpectra
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARBSpectraSkill*                  SpectraOwner                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBSpectraSkillTarget::CanBeActivedInSpectra(const class ARBSpectraSkill* SpectraOwner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSpectraSkillTarget", "CanBeActivedInSpectra");

	Params::RBSpectraSkillTarget_CanBeActivedInSpectra Parms{};

	Parms.SpectraOwner = SpectraOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSplineFollowingStation.BP_SetStationEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::BP_SetStationEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "BP_SetStationEnabled");

	Params::RBSplineFollowingStation_BP_SetStationEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingStation.Event_OnSplineFollowingActorAnimationDone
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBSplineFollowingActor*          SplineFollowingActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::Event_OnSplineFollowingActorAnimationDone(class ARBSplineFollowingActor* SplineFollowingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "Event_OnSplineFollowingActorAnimationDone");

	Params::RBSplineFollowingStation_Event_OnSplineFollowingActorAnimationDone Parms{};

	Parms.SplineFollowingActor = SplineFollowingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSplineFollowingStation.Multicast_OnSplineFollowingActorReachedStation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBSplineFollowingActor*          SplineFollowingActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::Multicast_OnSplineFollowingActorReachedStation(class ARBSplineFollowingActor* SplineFollowingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "Multicast_OnSplineFollowingActorReachedStation");

	Params::RBSplineFollowingStation_Multicast_OnSplineFollowingActorReachedStation Parms{};

	Parms.SplineFollowingActor = SplineFollowingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingStation.OnActorEnterProximity
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::OnActorEnterProximity(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "OnActorEnterProximity");

	Params::RBSplineFollowingStation_OnActorEnterProximity Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingStation.OnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "OnComponentBeginOverlap");

	Params::RBSplineFollowingStation_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineFollowingStation.OnSplineFollowingActorReachedStation
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ARBSplineFollowingActor*          SplineFollowingActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineFollowingStation::OnSplineFollowingActorReachedStation(class ARBSplineFollowingActor* SplineFollowingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineFollowingStation", "OnSplineFollowingActorReachedStation");

	Params::RBSplineFollowingStation_OnSplineFollowingActorReachedStation Parms{};

	Parms.SplineFollowingActor = SplineFollowingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineHelperComponent.OnLargePickupDropped
// (Final, Native, Private)
// Parameters:
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSplineHelperComponent::OnLargePickupDropped(class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineHelperComponent", "OnLargePickupDropped");

	Params::RBSplineHelperComponent_OnLargePickupDropped Parms{};

	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineHelperComponent.OnLargePickupHoldingPlayerChanged
// (Final, Native, Private)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBLargePickup*                   LargePickup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSplineHelperComponent::OnLargePickupHoldingPlayerChanged(class ARBPawn* Pawn, class ARBLargePickup* LargePickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineHelperComponent", "OnLargePickupHoldingPlayerChanged");

	Params::RBSplineHelperComponent_OnLargePickupHoldingPlayerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.LargePickup = LargePickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshActor.BP_SetNextSpline
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBSplineMeshActor*               NextSplineMesh                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToFirstNode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineMeshActor::BP_SetNextSpline(class ARBSplineMeshActor* NextSplineMesh, bool bToFirstNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshActor", "BP_SetNextSpline");

	Params::RBSplineMeshActor_BP_SetNextSpline Parms{};

	Parms.NextSplineMesh = NextSplineMesh;
	Parms.bToFirstNode = bToFirstNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshActor.BP_SetPreviousSpline
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ARBSplineMeshActor*               PreviousSplineMesh                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToLastNode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplineMeshActor::BP_SetPreviousSpline(class ARBSplineMeshActor* PreviousSplineMesh, bool bToLastNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshActor", "BP_SetPreviousSpline");

	Params::RBSplineMeshActor_BP_SetPreviousSpline Parms{};

	Parms.PreviousSplineMesh = PreviousSplineMesh;
	Parms.bToLastNode = bToLastNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshActor.BP_UnlinkNextSpline
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBSplineMeshActor::BP_UnlinkNextSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshActor", "BP_UnlinkNextSpline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshActor.BP_UnlinkPreviousSpline
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBSplineMeshActor::BP_UnlinkPreviousSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshActor", "BP_UnlinkPreviousSpline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshActor.OnRep_Enabled
// (Final, Native, Public)

void ARBSplineMeshActor::OnRep_Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshActor", "OnRep_Enabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplineMeshLinkChooserComponent.OnRandomizationDone
// (Final, Native, Public)

void URBSplineMeshLinkChooserComponent::OnRandomizationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplineMeshLinkChooserComponent", "OnRandomizationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplinePushable.AutoMove
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoveForward                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBSplinePushable::AutoMove(float Distance, float Speed, bool bMoveForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "AutoMove");

	Params::RBSplinePushable_AutoMove Parms{};

	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.bMoveForward = bMoveForward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplinePushable.BP_DetachFromSpline
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARBSplinePushable::BP_DetachFromSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "BP_DetachFromSpline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplinePushable.BP_PostRotated
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FRotator                         FrontRotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         RearRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ARBSplinePushable::BP_PostRotated(const struct FRotator& FrontRotation, const struct FRotator& RearRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "BP_PostRotated");

	Params::RBSplinePushable_BP_PostRotated Parms{};

	Parms.FrontRotation = std::move(FrontRotation);
	Parms.RearRotation = std::move(RearRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSplinePushable.Event_OnAutoMoveStateChanged
// (Event, Public, BlueprintEvent)

void ARBSplinePushable::Event_OnAutoMoveStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "Event_OnAutoMoveStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSplinePushable.OnRep_AutoMove
// (Final, Native, Public)

void ARBSplinePushable::OnRep_AutoMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "OnRep_AutoMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSplinePushable.IsRollbacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBSplinePushable::IsRollbacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSplinePushable", "IsRollbacking");

	Params::RBSplinePushable_IsRollbacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.CastLocationOnStairs
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdjustToCenterOfStepDepth                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdjustToCenterOfStepHeight                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DropOffset                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBStairsMarker::CastLocationOnStairs(const struct FVector& Location, float Radius, bool bAdjustToCenterOfStepDepth, bool bAdjustToCenterOfStepHeight, const struct FVector& DropOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "CastLocationOnStairs");

	Params::RBStairsMarker_CastLocationOnStairs Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.bAdjustToCenterOfStepDepth = bAdjustToCenterOfStepDepth;
	Parms.bAdjustToCenterOfStepHeight = bAdjustToCenterOfStepHeight;
	Parms.DropOffset = std::move(DropOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.GetApproximateStairsDistanceSqr2D
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARBStairsMarker::GetApproximateStairsDistanceSqr2D(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "GetApproximateStairsDistanceSqr2D");

	Params::RBStairsMarker_GetApproximateStairsDistanceSqr2D Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.GetStairsDownDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBStairsMarker::GetStairsDownDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "GetStairsDownDirection");

	Params::RBStairsMarker_GetStairsDownDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.GetStairsKnockdownSlideVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARBStairsMarker::GetStairsKnockdownSlideVelocity(class ARBPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "GetStairsKnockdownSlideVelocity");

	Params::RBStairsMarker_GetStairsKnockdownSlideVelocity Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.IsLocationOnStairs
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsiderPhantomSteps                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStairsMarker::IsLocationOnStairs(const struct FVector& Location, float Radius, bool bConsiderPhantomSteps) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "IsLocationOnStairs");

	Params::RBStairsMarker_IsLocationOnStairs Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.bConsiderPhantomSteps = bConsiderPhantomSteps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.IsLocationValidInZ
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZBuffer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStairsMarker::IsLocationValidInZ(const struct FVector& Location, float ZBuffer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "IsLocationValidInZ");

	Params::RBStairsMarker_IsLocationValidInZ Parms{};

	Parms.Location = std::move(Location);
	Parms.ZBuffer = ZBuffer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStairsMarker.RotateObjectOnStairsSlope
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQuat                            ObjectRotationQuat                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat ARBStairsMarker::RotateObjectOnStairsSlope(const struct FQuat& ObjectRotationQuat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStairsMarker", "RotateObjectOnStairsSlope");

	Params::RBStairsMarker_RotateObjectOnStairsSlope Parms{};

	Parms.ObjectRotationQuat = std::move(ObjectRotationQuat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::Event_OnLocallyStalkingNPCBegin(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "Event_OnLocallyStalkingNPCBegin");

	Params::RBStalkerObjectiveCoordinator_Event_OnLocallyStalkingNPCBegin Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::Event_OnLocallyStalkingNPCEnd(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "Event_OnLocallyStalkingNPCEnd");

	Params::RBStalkerObjectiveCoordinator_Event_OnLocallyStalkingNPCEnd Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::Event_OnNPCStalkedBegin(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "Event_OnNPCStalkedBegin");

	Params::RBStalkerObjectiveCoordinator_Event_OnNPCStalkedBegin Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::Event_OnNPCStalkedEnd(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "Event_OnNPCStalkedEnd");

	Params::RBStalkerObjectiveCoordinator_Event_OnNPCStalkedEnd Parms{};

	Parms.NPC = NPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStalkerObjectiveCoordinator.OnBotSpawned
// (Final, Native, Protected)
// Parameters:
// class ARBAISpawner*                     Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBBot*                           bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::OnBotSpawned(class ARBAISpawner* Spawner, class ARBBot* bot, class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnBotSpawned");

	Params::RBStalkerObjectiveCoordinator_OnBotSpawned Parms{};

	Parms.Spawner = Spawner;
	Parms.bot = bot;
	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnProximityProgressCompleted
// (Final, Native, Protected)
// Parameters:
// class URBProximityDetectableComponent*  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::OnProximityProgressCompleted(class URBProximityDetectableComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnProximityProgressCompleted");

	Params::RBStalkerObjectiveCoordinator_OnProximityProgressCompleted Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnRep_CurrentTargetInfos
// (Final, Native, Protected)

void ARBStalkerObjectiveCoordinator::OnRep_CurrentTargetInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnRep_CurrentTargetInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityDetectorIcons
// (Final, Native, Private)

void ARBStalkerObjectiveCoordinator::OnRep_ShowProximityDetectorIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnRep_ShowProximityDetectorIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityTriggerIcons
// (Final, Native, Private)

void ARBStalkerObjectiveCoordinator::OnRep_ShowProximityTriggerIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnRep_ShowProximityTriggerIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnStartSpectatingPlayer
// (Final, Native, Protected)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::OnStartSpectatingPlayer(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnStartSpectatingPlayer");

	Params::RBStalkerObjectiveCoordinator_OnStartSpectatingPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnStopSpectatorMode
// (Final, Native, Protected)

void ARBStalkerObjectiveCoordinator::OnStopSpectatorMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnStopSpectatorMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.OnTargetDie
// (Final, Native, Protected)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::OnTargetDie(class ARBNPC* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "OnTargetDie");

	Params::RBStalkerObjectiveCoordinator_OnTargetDie Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::SetShowProximityDetectorIconsVisible_Server(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "SetShowProximityDetectorIconsVisible_Server");

	Params::RBStalkerObjectiveCoordinator_SetShowProximityDetectorIconsVisible_Server Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStalkerObjectiveCoordinator::SetShowProximityTriggerIconsVisible_Server(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "SetShowProximityTriggerIconsVisible_Server");

	Params::RBStalkerObjectiveCoordinator_SetShowProximityTriggerIconsVisible_Server Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStalkerObjectiveCoordinator.IsLocalPlayerStalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStalkerObjectiveCoordinator::IsLocalPlayerStalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "IsLocalPlayerStalking");

	Params::RBStalkerObjectiveCoordinator_IsLocalPlayerStalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStalkerObjectiveCoordinator.IsNPCLocallyStalked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStalkerObjectiveCoordinator::IsNPCLocallyStalked(class ARBNPC* NPC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "IsNPCLocallyStalked");

	Params::RBStalkerObjectiveCoordinator_IsNPCLocallyStalked Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStalkerObjectiveCoordinator.IsNPCStalked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARBNPC*                           NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBStalkerObjectiveCoordinator::IsNPCStalked(class ARBNPC* NPC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStalkerObjectiveCoordinator", "IsNPCStalked");

	Params::RBStalkerObjectiveCoordinator_IsNPCStalked Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBStroopGameButton.Event_ButtonActivatedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGameButton::Event_ButtonActivatedChanged(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "Event_ButtonActivatedChanged");

	Params::RBStroopGameButton_Event_ButtonActivatedChanged Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStroopGameButton.Event_ButtonChosenChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bChosen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGameButton::Event_ButtonChosenChanged(bool bChosen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "Event_ButtonChosenChanged");

	Params::RBStroopGameButton_Event_ButtonChosenChanged Parms{};

	Parms.bChosen = bChosen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStroopGameButton.FlipButtonTo
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SideIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGameButton::FlipButtonTo(int32 SideIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "FlipButtonTo");

	Params::RBStroopGameButton_FlipButtonTo Parms{};

	Parms.SideIndex = SideIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStroopGameButton.OnButtonDataChanged
// (Event, Public, BlueprintEvent)

void ARBStroopGameButton::OnButtonDataChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnButtonDataChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBStroopGameButton.OnButtonFocused
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFocused                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGameButton::OnButtonFocused(bool bFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnButtonFocused");

	Params::RBStroopGameButton_OnButtonFocused Parms{};

	Parms.bFocused = bFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStroopGameButton.OnButtonSideChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NewSideIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBStroopGameButton::OnButtonSideChanged(int32 NewSideIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnButtonSideChanged");

	Params::RBStroopGameButton_OnButtonSideChanged Parms{};

	Parms.NewSideIndex = NewSideIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBStroopGameButton.OnRep_bActivated
// (Final, Native, Public)

void ARBStroopGameButton::OnRep_bActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnRep_bActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGameButton.OnRep_bOptionChosen
// (Final, Native, Public)

void ARBStroopGameButton::OnRep_bOptionChosen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnRep_bOptionChosen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGameButton.OnRep_ButtonData
// (Final, Native, Public)

void ARBStroopGameButton::OnRep_ButtonData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnRep_ButtonData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBStroopGameButton.OnRep_ButtonSideIndex
// (Final, Native, Public)

void ARBStroopGameButton::OnRep_ButtonSideIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBStroopGameButton", "OnRep_ButtonSideIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.OnCurrentFlipSwitchStateCallback
// (Final, Native, Private)
// Parameters:
// EScheduledPropertyValueChangedType      ChangedType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSwitchMatchFlipSwitchComponent::OnCurrentFlipSwitchStateCallback(EScheduledPropertyValueChangedType ChangedType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "OnCurrentFlipSwitchStateCallback");

	Params::RBSwitchMatchFlipSwitchComponent_OnCurrentFlipSwitchStateCallback Parms{};

	Parms.ChangedType = ChangedType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.OnFlipSwitchStageChanged
// (Event, Protected, BlueprintEvent)

void URBSwitchMatchFlipSwitchComponent::OnFlipSwitchStageChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "OnFlipSwitchStageChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.OnLocallyFocusStateChange
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ARBPlayer*                        Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBSwitchMatchFlipSwitchComponent::OnLocallyFocusStateChange(class ARBPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "OnLocallyFocusStateChange");

	Params::RBSwitchMatchFlipSwitchComponent_OnLocallyFocusStateChange Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.OnRep_CurrentFlipSwitchState
// (Final, Native, Private)

void URBSwitchMatchFlipSwitchComponent::OnRep_CurrentFlipSwitchState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "OnRep_CurrentFlipSwitchState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.GetFlipSwitchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFlipSwitchState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFlipSwitchState URBSwitchMatchFlipSwitchComponent::GetFlipSwitchState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "GetFlipSwitchState");

	Params::RBSwitchMatchFlipSwitchComponent_GetFlipSwitchState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBSwitchMatchFlipSwitchComponent.IsLocallyFocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBSwitchMatchFlipSwitchComponent::IsLocallyFocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBSwitchMatchFlipSwitchComponent", "IsLocallyFocused");

	Params::RBSwitchMatchFlipSwitchComponent_IsLocallyFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTaskConditionContext_PlayerEvent.OnPlayerEvent
// (Final, Native, Private)
// Parameters:
// EPlayerEvent                            EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTaskConditionContext_PlayerEvent::OnPlayerEvent(EPlayerEvent EventType, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTaskConditionContext_PlayerEvent", "OnPlayerEvent");

	Params::RBTaskConditionContext_PlayerEvent_OnPlayerEvent Parms{};

	Parms.EventType = EventType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTasksConfig.GetTaskData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRBTaskDataRow             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRBTaskDataRow URBTasksConfig::GetTaskData(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTasksConfig", "GetTaskData");

	Params::RBTasksConfig_GetTaskData Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTextChatWidget.Event_HideMessage
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   MessageId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTextChatWidget::Event_HideMessage(int32 MessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTextChatWidget", "Event_HideMessage");

	Params::RBTextChatWidget_Event_HideMessage Parms{};

	Parms.MessageId = MessageId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTextChatWidget.Event_ShowMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRBTextChatMessage               Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBTextChatWidget::Event_ShowMessage(const struct FRBTextChatMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTextChatWidget", "Event_ShowMessage");

	Params::RBTextChatWidget_Event_ShowMessage Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTextChatWidget.OnLoadingScreenStateUpdated
// (Final, Native, Protected)
// Parameters:
// bool                                    bShowing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTextChatWidget::OnLoadingScreenStateUpdated(bool bShowing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTextChatWidget", "OnLoadingScreenStateUpdated");

	Params::RBTextChatWidget_OnLoadingScreenStateUpdated Parms{};

	Parms.bShowing = bShowing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTextChatWidget.OnTextChatManagerRegistered
// (Final, Native, Protected)

void URBTextChatWidget::OnTextChatManagerRegistered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTextChatWidget", "OnTextChatManagerRegistered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTimerInterface.SetTimer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MinuteTen                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinuteSingle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondsTen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondsSingle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRBTimerInterface::SetTimer(int32 MinuteTen, int32 MinuteSingle, int32 SecondsTen, int32 SecondsSingle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTimerInterface", "SetTimer");

	Params::RBTimerInterface_SetTimer Parms{};

	Parms.MinuteTen = MinuteTen;
	Parms.MinuteSingle = MinuteSingle;
	Parms.SecondsTen = SecondsTen;
	Parms.SecondsSingle = SecondsSingle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTorturePanelComponent.Multicast_OnPanelSucceeded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARBPawn*                          Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TortureCompleted                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTorturePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn, bool TortureCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTorturePanelComponent", "Multicast_OnPanelSucceeded");

	Params::RBTorturePanelComponent_Multicast_OnPanelSucceeded Parms{};

	Parms.Pawn = Pawn;
	Parms.TortureCompleted = TortureCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTorturePanelComponent.Multicast_OnTryFailed
// (Net, Native, Event, NetMulticast, Public)

void URBTorturePanelComponent::Multicast_OnTryFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTorturePanelComponent", "Multicast_OnTryFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTorturePanelComponent.Multicast_OnTrySucceeded
// (Net, Native, Event, NetMulticast, Public)

void URBTorturePanelComponent::Multicast_OnTrySucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTorturePanelComponent", "Multicast_OnTrySucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTorturePanelComponent.IsTortureRoomCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTorturePanelComponent::IsTortureRoomCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTorturePanelComponent", "IsTortureRoomCompleted");

	Params::RBTorturePanelComponent_IsTortureRoomCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTrapTriggerable.BP_LinkTriggerTrap
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARBWireTriggerTrap*               TriggerTrap                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBTrapTriggerable::BP_LinkTriggerTrap(class ARBWireTriggerTrap* TriggerTrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapTriggerable", "BP_LinkTriggerTrap");

	Params::RBTrapTriggerable_BP_LinkTriggerTrap Parms{};

	Parms.TriggerTrap = TriggerTrap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBTrapTriggerable.IsCurrentlyTriggering
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARBTrapTriggerable::IsCurrentlyTriggering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTrapTriggerable", "IsCurrentlyTriggering");

	Params::RBTrapTriggerable_IsCurrentlyTriggering Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OPP.RBTriggerableInterface.Trigger
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBTriggerableInterface::Trigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableInterface", "Trigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableInterface.Untrigger
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRBTriggerableInterface::Untrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableInterface", "Untrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBTriggerableInterface.IsTriggered
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IRBTriggerableInterface::IsTriggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTriggerableInterface", "IsTriggered");

	Params::RBTriggerableInterface_IsTriggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBTutorialZoneComponent.OnObjectiveCoordinatorStateChanged
// (Final, Native, Private)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBTutorialZoneComponent::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, const EObjectiveCoordinatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTutorialZoneComponent", "OnObjectiveCoordinatorStateChanged");

	Params::RBTutorialZoneComponent_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUnlockableLargePickup.BP_SetIsLocked
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUnlockableLargePickup::BP_SetIsLocked(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUnlockableLargePickup", "BP_SetIsLocked");

	Params::RBUnlockableLargePickup_BP_SetIsLocked Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUnlockableLargePickup.Event_OnIsLockedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBUnlockableLargePickup::Event_OnIsLockedChanged(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUnlockableLargePickup", "Event_OnIsLockedChanged");

	Params::RBUnlockableLargePickup_Event_OnIsLockedChanged Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OPP.RBUnlockableLargePickup.OnRep_Islocked
// (Final, Native, Protected)

void ARBUnlockableLargePickup::OnRep_Islocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUnlockableLargePickup", "OnRep_Islocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUpgradeMenuTab.Event_OnUpgradeAcquired
// (Event, Public, BlueprintEvent)

void URBUpgradeMenuTab::Event_OnUpgradeAcquired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUpgradeMenuTab", "Event_OnUpgradeAcquired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBUpgradeMenuTab.OnItemMouseDown
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMenuUpgradeItemInfo             ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBUpgradeMenuTab::OnItemMouseDown(const struct FMenuUpgradeItemInfo& ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUpgradeMenuTab", "OnItemMouseDown");

	Params::RBUpgradeMenuTab_OnItemMouseDown Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUpgradeMenuTab.OnItemMouseUp
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMenuUpgradeItemInfo             ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URBUpgradeMenuTab::OnItemMouseUp(const struct FMenuUpgradeItemInfo& ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUpgradeMenuTab", "OnItemMouseUp");

	Params::RBUpgradeMenuTab_OnItemMouseUp Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBUpgradeMenuTab.TryAcquireUpgrade
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBUpgradeMenuTab::TryAcquireUpgrade(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBUpgradeMenuTab", "TryAcquireUpgrade");

	Params::RBUpgradeMenuTab_TryAcquireUpgrade Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterVolume.OnWaterVolumeBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARBWaterVolume::OnWaterVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterVolume", "OnWaterVolumeBeginOverlap");

	Params::RBWaterVolume_OnWaterVolumeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWaterVolume.OnWaterVolumeEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWaterVolume::OnWaterVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWaterVolume", "OnWaterVolumeEndOverlap");

	Params::RBWaterVolume_OnWaterVolumeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWindowShutter.BP_ForceBlockableState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EBlockableState                         InBlockableState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARBWindowShutter::BP_ForceBlockableState(EBlockableState InBlockableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWindowShutter", "BP_ForceBlockableState");

	Params::RBWindowShutter_BP_ForceBlockableState Parms{};

	Parms.InBlockableState = InBlockableState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWindowShutter.Event_OnBlockableStateChanged
// (Event, Public, BlueprintEvent)

void ARBWindowShutter::Event_OnBlockableStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWindowShutter", "Event_OnBlockableStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OPP.RBWindowShutter.OnRep_BlockableState
// (Final, Native, Protected)

void ARBWindowShutter::OnRep_BlockableState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWindowShutter", "OnRep_BlockableState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWindowShutter.GetBlockableState
// (Native, Public, Const)
// Parameters:
// EBlockableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBlockableState ARBWindowShutter::GetBlockableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWindowShutter", "GetBlockableState");

	Params::RBWindowShutter_GetBlockableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBWorldSettings.ClearAllFootStepData
// (Final, Native, Public)

void ARBWorldSettings::ClearAllFootStepData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorldSettings", "ClearAllFootStepData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBWorldSettings.ClearCurrentFootStepData
// (Final, Native, Public)

void ARBWorldSettings::ClearCurrentFootStepData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBWorldSettings", "ClearCurrentFootStepData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OPP.RBZoneDefenceWatcherComponent.GetZoneProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URBZoneDefenceWatcherComponent::GetZoneProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceWatcherComponent", "GetZoneProgress");

	Params::RBZoneDefenceWatcherComponent_GetZoneProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceWatcherComponent.IsZoneActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBZoneDefenceWatcherComponent::IsZoneActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceWatcherComponent", "IsZoneActive");

	Params::RBZoneDefenceWatcherComponent_IsZoneActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceWatcherComponent.IsZoneCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBZoneDefenceWatcherComponent::IsZoneCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceWatcherComponent", "IsZoneCompleted");

	Params::RBZoneDefenceWatcherComponent_IsZoneCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OPP.RBZoneDefenceWatcherComponent.OnObjectiveCoordinatorStateChanged
// (Final, Native, Public)
// Parameters:
// class ARBBaseObjectiveCoordinator*      Coordinator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveCoordinatorState              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URBZoneDefenceWatcherComponent::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* Coordinator, EObjectiveCoordinatorState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBZoneDefenceWatcherComponent", "OnObjectiveCoordinatorStateChanged");

	Params::RBZoneDefenceWatcherComponent_OnObjectiveCoordinatorStateChanged Parms{};

	Parms.Coordinator = Coordinator;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

